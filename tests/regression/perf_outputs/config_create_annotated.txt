--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate cachegrind.out.config_create
Command:          target/debug/config_create
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir__________________ 

282,156,931 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir________________________  file:function

< 113,200,122 (40.1%, 40.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c:
   38,297,760 (13.6%)           base64_ascii_to_bin
   27,474,480  (9.7%)           constant_time_in_range_8
   21,230,280  (7.5%)           constant_time_lt_args_8
   14,949,848  (5.3%)           aws_lc_0_19_0_EVP_DecodeUpdate
   11,238,410  (4.0%)           base64_decode_quad

<  63,695,512 (22.6%, 62.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h:
   17,483,760  (6.2%)           constant_time_msb_w
   17,483,760  (6.2%)           constant_time_is_zero_w
   14,986,080  (5.3%)           constant_time_eq_8
   13,737,240  (4.9%)           constant_time_eq_w

<  17,876,168  (6.3%, 69.0%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c:
    5,466,108  (1.9%)           cbs_get
    3,704,868  (1.3%)           aws_lc_0_19_0_CBS_get_u8
    2,199,934  (0.8%)           cbs_get_any_asn1_element
    1,316,592  (0.5%)           aws_lc_0_19_0_CBS_len
    1,062,264  (0.4%)           parse_asn1_tag
      864,690  (0.3%)           aws_lc_0_19_0_CBS_init
      765,468  (0.3%)           aws_lc_0_19_0_CBS_get_any_ber_asn1_element
      758,760  (0.3%)           aws_lc_0_19_0_CBS_get_bytes
      506,760  (0.2%)           aws_lc_0_19_0_CBS_skip
      399,990  (0.1%)           aws_lc_0_19_0_CBS_is_valid_asn1_oid

<  12,069,300  (4.3%, 73.3%)  ./malloc/./malloc/malloc.c:
    4,972,200  (1.8%)           _int_malloc
    2,800,695  (1.0%)           _int_free
    2,599,976  (0.9%)           malloc
    1,220,944  (0.4%)           free

<   8,584,516  (3.0%, 76.3%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c:
    3,012,280  (1.1%)           asn1_item_ex_i2d_opt
    1,964,344  (0.7%)           asn1_template_ex_i2d
    1,817,756  (0.6%)           asn1_ex_i2c
    1,391,696  (0.5%)           asn1_i2d_ex_primitive

<   8,237,886  (2.9%, 79.3%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c:
    2,878,256  (1.0%)           asn1_item_ex_d2i
    1,426,362  (0.5%)           asn1_check_tlen
    1,313,156  (0.5%)           asn1_template_noexp_d2i
    1,130,344  (0.4%)           asn1_d2i_ex_primitive
      764,102  (0.3%)           asn1_template_ex_d2i
      628,278  (0.2%)           asn1_ex_c2i

<   7,548,198  (2.7%, 81.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c:
    1,848,704  (0.7%)           aws_lc_0_19_0_OPENSSL_malloc
    1,765,844  (0.6%)           aws_lc_0_19_0_OPENSSL_free
      775,752  (0.3%)           aws_lc_0_19_0_OPENSSL_isspace
      735,680  (0.3%)           aws_lc_0_19_0_OPENSSL_zalloc
      642,570  (0.2%)           aws_lc_0_19_0_OPENSSL_cleanse
      478,304  (0.2%)           __asan_poison_memory_region
      358,832  (0.1%)           __asan_unpoison_memory_region
      343,692  (0.1%)           aws_lc_0_19_0_OPENSSL_tolower

<   4,891,944  (1.7%, 83.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c:
    1,032,000  (0.4%)           cbb_add_u
      840,000  (0.3%)           cbb_buffer_reserve
      624,000  (0.2%)           aws_lc_0_19_0_CBB_add_space
      613,440  (0.2%)           aws_lc_0_19_0_CBB_flush
      594,720  (0.2%)           cbb_get_base
      576,000  (0.2%)           cbb_buffer_add
      360,000  (0.1%)           aws_lc_0_19_0_CBB_add_u8

<   4,040,217  (1.4%, 85.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c:
    1,969,324  (0.7%)           aws_lc_0_19_0_ASN1_get_object
      809,180  (0.3%)           aws_lc_0_19_0_ASN1_object_size
      514,984  (0.2%)           aws_lc_0_19_0_ASN1_put_object

<   3,601,332  (1.3%, 86.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c:
    2,436,152  (0.9%)           aws_lc_0_19_0_X509_NAME_cmp
    1,165,180  (0.4%)           aws_lc_0_19_0_X509_subject_name_cmp

<   3,508,052  (1.2%, 87.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c:
    1,217,501  (0.4%)           aws_lc_0_19_0_asn1_get_field_ptr
      735,888  (0.3%)           aws_lc_0_19_0_asn1_do_adb
      635,415  (0.2%)           asn1_get_enc_ptr

<   2,989,280  (1.1%, 88.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c:
    1,919,120  (0.7%)           x509_object_cmp
    1,028,100  (0.4%)           x509_object_cmp_sk

<   2,929,300  (1.0%, 89.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c:
    1,417,274  (0.5%)           asn1_item_ex_combine_new
      626,482  (0.2%)           ASN1_template_new
      504,764  (0.2%)           ASN1_primitive_new

<   2,700,456  (1.0%, 90.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c:
    1,166,880  (0.4%)           aws_lc_0_19_0_cbs_get_latin1
      493,680  (0.2%)           aws_lc_0_19_0_cbb_add_utf8
      382,024  (0.1%)           is_valid_code_point
      332,464  (0.1%)           aws_lc_0_19_0_cbb_get_utf8_len
      325,408  (0.1%)           aws_lc_0_19_0_cbs_get_utf8

<   2,176,944  (0.8%, 91.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_mbstr.c:
    2,128,920  (0.8%)           aws_lc_0_19_0_ASN1_mbstring_ncopy

<   2,157,587  (0.8%, 92.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/stack/stack.c:
      560,972  (0.2%)           aws_lc_0_19_0_OPENSSL_sk_insert
      332,519  (0.1%)           aws_lc_0_19_0_OPENSSL_sk_value
      313,110  (0.1%)           aws_lc_0_19_0_OPENSSL_sk_num

<   2,114,230  (0.7%, 93.0%)  ./stdlib/./stdlib/qsort.c:
    2,094,102  (0.7%)           msort_with_tmp.part.0

<   2,097,286  (0.7%, 93.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c:
    1,229,678  (0.4%)           aws_lc_0_19_0_asn1_item_combine_free
      400,991  (0.1%)           aws_lc_0_19_0_ASN1_primitive_free
      390,192  (0.1%)           aws_lc_0_19_0_ASN1_template_free

<   1,726,048  (0.6%, 94.3%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x_name.c:
      931,332  (0.3%)           asn1_string_canon

<   1,709,419  (0.6%, 94.9%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms

<   1,417,168  (0.5%, 95.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h:
    1,304,944  (0.5%)           OPENSSL_memset

<   1,242,455  (0.4%, 95.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h:
      376,224  (0.1%)           CRYPTO_bswap4

<   1,224,312  (0.4%, 96.3%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:
    1,223,770  (0.4%)           __memcpy_avx_unaligned_erms

<     752,162  (0.3%, 96.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_object.c:
      301,730  (0.1%)           aws_lc_0_19_0_ASN1_OBJECT_free

<     675,726  (0.2%, 96.8%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/pem/pem_lib.c:
      658,206  (0.2%)           aws_lc_0_19_0_PEM_read_bio

<     524,302  (0.2%, 97.0%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/buf/buf.c:
      290,076  (0.1%)           aws_lc_0_19_0_BUF_MEM_grow

<     496,698  (0.2%, 97.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c:
      460,350  (0.2%)           aws_lc_0_19_0_OBJ_dup

<     458,522  (0.2%, 97.3%)  ./libio/./libio/iogetline.c:
      436,856  (0.2%)           _IO_getline_info

<     404,422  (0.1%, 97.5%)  ./libio/./libio/iofgets.c:fgets

<     358,392  (0.1%, 97.6%)  ???:
      357,974  (0.1%)           ???

<     332,454  (0.1%, 97.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bio/bio.c:
      332,198  (0.1%)           aws_lc_0_19_0_BIO_gets

<     306,352  (0.1%, 97.8%)  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir_______________________  function:file

> 38,297,760 (13.6%, 13.6%)  base64_ascii_to_bin:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

> 27,474,480  (9.7%, 23.3%)  constant_time_in_range_8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

> 21,230,280  (7.5%, 30.8%)  constant_time_lt_args_8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

> 17,496,794  (6.2%, 37.0%)  constant_time_is_zero_w:
  17,483,760  (6.2%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h

> 17,496,773  (6.2%, 43.2%)  constant_time_msb_w:
  17,483,760  (6.2%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h

> 14,986,080  (5.3%, 48.5%)  constant_time_eq_8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h

> 14,949,848  (5.3%, 53.8%)  aws_lc_0_19_0_EVP_DecodeUpdate:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

> 13,747,448  (4.9%, 58.7%)  constant_time_eq_w:
  13,737,240  (4.9%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h

> 11,238,410  (4.0%, 62.7%)  base64_decode_quad:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

>  5,466,108  (1.9%, 64.6%)  cbs_get:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>  4,972,200  (1.8%, 66.4%)  _int_malloc:./malloc/./malloc/malloc.c

>  3,704,868  (1.3%, 67.7%)  aws_lc_0_19_0_CBS_get_u8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>  3,012,280  (1.1%, 68.8%)  asn1_item_ex_i2d_opt:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>  2,878,256  (1.0%, 69.8%)  asn1_item_ex_d2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>  2,800,695  (1.0%, 70.8%)  _int_free:./malloc/./malloc/malloc.c

>  2,666,759  (0.9%, 71.7%)  malloc:
   2,599,976  (0.9%)           ./malloc/./malloc/malloc.c

>  2,436,152  (0.9%, 72.6%)  aws_lc_0_19_0_X509_NAME_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c

>  2,199,934  (0.8%, 73.4%)  cbs_get_any_asn1_element:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>  2,178,444  (0.8%, 74.2%)  msort_with_tmp.part.0:
   2,094,102  (0.7%)           ./stdlib/./stdlib/qsort.c

>  2,128,920  (0.8%, 74.9%)  aws_lc_0_19_0_ASN1_mbstring_ncopy:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_mbstr.c

>  1,969,324  (0.7%, 75.6%)  aws_lc_0_19_0_ASN1_get_object:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c

>  1,964,344  (0.7%, 76.3%)  asn1_template_ex_i2d:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>  1,919,120  (0.7%, 77.0%)  x509_object_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c

>  1,848,704  (0.7%, 77.6%)  aws_lc_0_19_0_OPENSSL_malloc:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>  1,817,756  (0.6%, 78.3%)  asn1_ex_i2c:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>  1,765,844  (0.6%, 78.9%)  aws_lc_0_19_0_OPENSSL_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>  1,709,419  (0.6%, 79.5%)  __memset_avx2_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

>  1,593,232  (0.6%, 80.1%)  OPENSSL_memset:
   1,304,944  (0.5%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h

>  1,426,362  (0.5%, 80.6%)  asn1_check_tlen:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>  1,417,274  (0.5%, 81.1%)  asn1_item_ex_combine_new:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c

>  1,391,696  (0.5%, 81.6%)  asn1_i2d_ex_primitive:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>  1,349,602  (0.5%, 82.1%)  free:
   1,220,944  (0.4%)           ./malloc/./malloc/malloc.c

>  1,316,592  (0.5%, 82.5%)  aws_lc_0_19_0_CBS_len:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>  1,313,156  (0.5%, 83.0%)  asn1_template_noexp_d2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>  1,229,678  (0.4%, 83.4%)  aws_lc_0_19_0_asn1_item_combine_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c

>  1,223,770  (0.4%, 83.9%)  __memcpy_avx_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

>  1,217,501  (0.4%, 84.3%)  aws_lc_0_19_0_asn1_get_field_ptr:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c

>  1,166,880  (0.4%, 84.7%)  aws_lc_0_19_0_cbs_get_latin1:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c

>  1,165,180  (0.4%, 85.1%)  aws_lc_0_19_0_X509_subject_name_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c

>  1,130,344  (0.4%, 85.5%)  asn1_d2i_ex_primitive:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>  1,062,264  (0.4%, 85.9%)  parse_asn1_tag:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>  1,032,000  (0.4%, 86.3%)  cbb_add_u:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>  1,028,100  (0.4%, 86.6%)  x509_object_cmp_sk:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c

>    931,332  (0.3%, 87.0%)  asn1_string_canon:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x_name.c

>    864,690  (0.3%, 87.3%)  aws_lc_0_19_0_CBS_init:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    840,000  (0.3%, 87.6%)  cbb_buffer_reserve:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    809,180  (0.3%, 87.8%)  aws_lc_0_19_0_ASN1_object_size:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c

>    775,752  (0.3%, 88.1%)  aws_lc_0_19_0_OPENSSL_isspace:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    765,468  (0.3%, 88.4%)  aws_lc_0_19_0_CBS_get_any_ber_asn1_element:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    764,102  (0.3%, 88.7%)  asn1_template_ex_d2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>    758,760  (0.3%, 88.9%)  aws_lc_0_19_0_CBS_get_bytes:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    735,888  (0.3%, 89.2%)  aws_lc_0_19_0_asn1_do_adb:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c

>    735,680  (0.3%, 89.5%)  aws_lc_0_19_0_OPENSSL_zalloc:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    658,206  (0.2%, 89.7%)  aws_lc_0_19_0_PEM_read_bio:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/pem/pem_lib.c

>    642,570  (0.2%, 89.9%)  aws_lc_0_19_0_OPENSSL_cleanse:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    635,415  (0.2%, 90.1%)  asn1_get_enc_ptr:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c

>    628,278  (0.2%, 90.4%)  asn1_ex_c2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>    626,482  (0.2%, 90.6%)  ASN1_template_new:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c

>    624,000  (0.2%, 90.8%)  aws_lc_0_19_0_CBB_add_space:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    613,440  (0.2%, 91.0%)  aws_lc_0_19_0_CBB_flush:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    594,720  (0.2%, 91.2%)  cbb_get_base:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    576,000  (0.2%, 91.4%)  cbb_buffer_add:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    560,972  (0.2%, 91.6%)  aws_lc_0_19_0_OPENSSL_sk_insert:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/stack/stack.c

>    514,984  (0.2%, 91.8%)  aws_lc_0_19_0_ASN1_put_object:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c

>    506,760  (0.2%, 92.0%)  aws_lc_0_19_0_CBS_skip:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    504,764  (0.2%, 92.2%)  ASN1_primitive_new:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c

>    493,680  (0.2%, 92.4%)  aws_lc_0_19_0_cbb_add_utf8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c

>    483,862  (0.2%, 92.5%)  fgets:
     404,422  (0.1%)           ./libio/./libio/iofgets.c

>    478,304  (0.2%, 92.7%)  __asan_poison_memory_region:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    473,342  (0.2%, 92.9%)  _IO_getline_info:
     436,856  (0.2%)           ./libio/./libio/iogetline.c

>    460,350  (0.2%, 93.0%)  aws_lc_0_19_0_OBJ_dup:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c

>    407,078  (0.1%, 93.2%)  ???:
     357,974  (0.1%)           ???

>    400,991  (0.1%, 93.3%)  aws_lc_0_19_0_ASN1_primitive_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c

>    399,990  (0.1%, 93.5%)  aws_lc_0_19_0_CBS_is_valid_asn1_oid:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    390,192  (0.1%, 93.6%)  aws_lc_0_19_0_ASN1_template_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c

>    385,568  (0.1%, 93.7%)  CRYPTO_bswap4:
     376,224  (0.1%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    382,024  (0.1%, 93.9%)  is_valid_code_point:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c

>    360,000  (0.1%, 94.0%)  aws_lc_0_19_0_CBB_add_u8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    358,832  (0.1%, 94.1%)  __asan_unpoison_memory_region:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    343,692  (0.1%, 94.2%)  aws_lc_0_19_0_OPENSSL_tolower:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    332,519  (0.1%, 94.4%)  aws_lc_0_19_0_OPENSSL_sk_value:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/stack/stack.c

>    332,464  (0.1%, 94.5%)  aws_lc_0_19_0_cbb_get_utf8_len:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c

>    332,198  (0.1%, 94.6%)  aws_lc_0_19_0_BIO_gets:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bio/bio.c

>    325,408  (0.1%, 94.7%)  aws_lc_0_19_0_cbs_get_utf8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c

>    313,110  (0.1%, 94.8%)  aws_lc_0_19_0_OPENSSL_sk_num:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/stack/stack.c

>    306,352  (0.1%, 94.9%)  __memcmp_avx2_movbe:./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S

>    301,730  (0.1%, 95.0%)  aws_lc_0_19_0_ASN1_OBJECT_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_object.c

>    290,076  (0.1%, 95.1%)  aws_lc_0_19_0_BUF_MEM_grow:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/buf/buf.c

--------------------------------------------------------------------------------
-- Annotated source file: ./libio/./libio/iofgets.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./libio/./libio/iofgets.c

--------------------------------------------------------------------------------
-- Annotated source file: ./libio/./libio/iogetline.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./libio/./libio/iogetline.c

--------------------------------------------------------------------------------
-- Annotated source file: ./malloc/./malloc/malloc.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./malloc/./malloc/malloc.c

--------------------------------------------------------------------------------
-- Annotated source file: ./stdlib/./stdlib/qsort.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdlib/./stdlib/qsort.c

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_mbstr.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 69 ----------------------------------------
      .         // These functions take a string in UTF8, ASCII or multibyte form and a mask
      .         // of permissible ASN1 string types. It then works out the minimal type
      .         // (using the order Printable < IA5 < T61 < BMP < Universal < UTF8) and
      .         // creates a string of the correct type with the supplied data. Yes this is
      .         // horrible: it has to be :-( The 'ncopy' form checks minimum and maximum
      .         // size limits too.
      .         
      .         int ASN1_mbstring_copy(ASN1_STRING **out, const unsigned char *in,
 18,792 (0.0%)                         ossl_ssize_t len, int inform, unsigned long mask) {
 25,056 (0.0%)    return ASN1_mbstring_ncopy(out, in, len, inform, mask, /*minsize=*/0,
      .                                      /*maxsize=*/0);
  4,176 (0.0%)  }
      .         
      .         OPENSSL_DECLARE_ERROR_REASON(ASN1, INVALID_BMPSTRING)
      .         OPENSSL_DECLARE_ERROR_REASON(ASN1, INVALID_UNIVERSALSTRING)
      .         OPENSSL_DECLARE_ERROR_REASON(ASN1, INVALID_UTF8STRING)
      .         
      .         int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in,
      .                                 ossl_ssize_t len, int inform, unsigned long mask,
 27,144 (0.0%)                          ossl_ssize_t minsize, ossl_ssize_t maxsize) {
  4,176 (0.0%)    if (len == -1) {
      .             len = strlen((const char *)in);
      .           }
  4,176 (0.0%)    if (!mask) {
      .             mask = DIRSTRING_TYPE;
      .           }
      .         
      .           int (*decode_func)(CBS *, uint32_t *);
      .           int error;
 24,000 (0.0%)    switch (inform) {
      .             case MBSTRING_BMP:
      .               decode_func = cbs_get_ucs2_be;
      .               error = ASN1_R_INVALID_BMPSTRING;
      .               break;
      .         
      .             case MBSTRING_UNIV:
      .               decode_func = cbs_get_utf32_be;
      .               error = ASN1_R_INVALID_UNIVERSALSTRING;
      .               break;
      .         
      .             case MBSTRING_UTF8:
  1,056 (0.0%)        decode_func = cbs_get_utf8;
    528 (0.0%)        error = ASN1_R_INVALID_UTF8STRING;
    528 (0.0%)        break;
      .         
      .             case MBSTRING_ASC:
  3,120 (0.0%)        decode_func = cbs_get_latin1;
  1,560 (0.0%)        error = ERR_R_INTERNAL_ERROR;  // Latin-1 inputs are never invalid.
  1,560 (0.0%)        break;
      .         
      .             default:
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNKNOWN_FORMAT);
      .               return -1;
      .           }
      .         
      .           // Check |minsize| and |maxsize| and work out the minimal type, if any.
      .           CBS cbs;
 12,528 (0.0%)    CBS_init(&cbs, in, len);
  4,176 (0.0%)    size_t utf8_len = 0, nchar = 0;
178,728 (0.1%)    while (CBS_len(&cbs) != 0) {
      .             uint32_t c;
265,920 (0.1%)      if (!decode_func(&cbs, &c)) {
      .               OPENSSL_PUT_ERROR(ASN1, error);
      .               return -1;
      .             }
 74,832 (0.0%)      if (nchar == 0 && (inform == MBSTRING_BMP || inform == MBSTRING_UNIV) &&
      .                 c == 0xfeff) {
      .               // Reject byte-order mark. We could drop it but that would mean
      .               // adding ambiguity around whether a BOM was included or not when
      .               // matching strings.
      .               //
      .               // For a little-endian UCS-2 string, the BOM will appear as 0xfffe
      .               // and will be rejected as noncharacter, below.
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_CHARACTERS);
      .               return -1;
      .             }
      .         
      .             // Update which output formats are still possible.
132,960 (0.0%)      if ((mask & B_ASN1_PRINTABLESTRING) && !asn1_is_printable(c)) {
      .               mask &= ~B_ASN1_PRINTABLESTRING;
      .             }
132,960 (0.0%)      if ((mask & B_ASN1_IA5STRING) && (c > 127)) {
      .               mask &= ~B_ASN1_IA5STRING;
      .             }
132,960 (0.0%)      if ((mask & B_ASN1_T61STRING) && (c > 0xff)) {
      .               mask &= ~B_ASN1_T61STRING;
      .             }
132,960 (0.0%)      if ((mask & B_ASN1_BMPSTRING) && (c > 0xffff)) {
      .               mask &= ~B_ASN1_BMPSTRING;
      .             }
 66,480 (0.0%)      if (!mask) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_CHARACTERS);
      .               return -1;
      .             }
      .         
 33,240 (0.0%)      nchar++;
132,960 (0.0%)      utf8_len += cbb_get_utf8_len(c);
 66,480 (0.0%)      if (maxsize > 0 && nchar > (size_t)maxsize) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_STRING_TOO_LONG);
      .         #if defined(OPENSSL_WINDOWS)
      .               ERR_add_error_dataf("maxsize=%lu", (unsigned long)maxsize);
      .         #else
      .               ERR_add_error_dataf("maxsize=%zu", (size_t)maxsize);
      .         #endif
      .               return -1;
      .             }
      .           }
      .         
  4,176 (0.0%)    if (minsize > 0 && nchar < (size_t)minsize) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_STRING_TOO_SHORT);
      .         #if defined(OPENSSL_WINDOWS)
      .             ERR_add_error_dataf("minsize=%lu", (unsigned long)minsize);
      .         #else
      .             ERR_add_error_dataf("minsize=%zu", (size_t)minsize);
      .         #endif
      .             return -1;
      .           }
      .         
      .           // Now work out output format and string type
      .           int str_type;
  4,176 (0.0%)    int (*encode_func)(CBB *, uint32_t) = cbb_add_latin1;
  4,176 (0.0%)    size_t size_estimate = nchar;
  2,088 (0.0%)    int outform = MBSTRING_ASC;
  8,352 (0.0%)    if (mask & B_ASN1_PRINTABLESTRING) {
      .             str_type = V_ASN1_PRINTABLESTRING;
  8,352 (0.0%)    } else if (mask & B_ASN1_IA5STRING) {
      .             str_type = V_ASN1_IA5STRING;
  8,352 (0.0%)    } else if (mask & B_ASN1_T61STRING) {
      .             str_type = V_ASN1_T61STRING;
  8,352 (0.0%)    } else if (mask & B_ASN1_BMPSTRING) {
      .             str_type = V_ASN1_BMPSTRING;
      .             outform = MBSTRING_BMP;
      .             encode_func = cbb_add_ucs2_be;
      .             size_estimate = 2 * nchar;
  8,352 (0.0%)    } else if (mask & B_ASN1_UNIVERSALSTRING) {
      .             str_type = V_ASN1_UNIVERSALSTRING;
      .             encode_func = cbb_add_utf32_be;
      .             size_estimate = 4 * nchar;
      .             outform = MBSTRING_UNIV;
  8,352 (0.0%)    } else if (mask & B_ASN1_UTF8STRING) {
  2,088 (0.0%)      str_type = V_ASN1_UTF8STRING;
  2,088 (0.0%)      outform = MBSTRING_UTF8;
  4,176 (0.0%)      encode_func = cbb_add_utf8;
  6,264 (0.0%)      size_estimate = utf8_len;
      .           } else {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_CHARACTERS);
      .             return -1;
      .           }
      .         
  4,176 (0.0%)    if (!out) {
      .             return str_type;
      .           }
      .         
  2,088 (0.0%)    int free_dest = 0;
      .           ASN1_STRING *dest;
  8,352 (0.0%)    if (*out) {
  8,352 (0.0%)      dest = *out;
      .           } else {
      .             free_dest = 1;
      .             dest = ASN1_STRING_type_new(str_type);
      .             if (!dest) {
      .               return -1;
      .             }
      .           }
      .         
      .           CBB cbb;
  6,264 (0.0%)    CBB_zero(&cbb);
      .           // If both the same type just copy across
  6,264 (0.0%)    if (inform == outform) {
  4,224 (0.0%)      if (!ASN1_STRING_set(dest, in, len)) {
      .               goto err;
      .             }
  1,584 (0.0%)      dest->type = str_type;
  1,584 (0.0%)      *out = dest;
  1,056 (0.0%)      return str_type;
      .           }
 12,480 (0.0%)    if (!CBB_init(&cbb, size_estimate + 1)) {
      .             goto err;
      .           }
  9,360 (0.0%)    CBS_init(&cbs, in, len);
121,560 (0.0%)    while (CBS_len(&cbs) != 0) {
      .             uint32_t c;
359,040 (0.1%)      if (!decode_func(&cbs, &c) || !encode_func(&cbb, c)) {
      .               OPENSSL_PUT_ERROR(ASN1, ERR_R_INTERNAL_ERROR);
      .               goto err;
      .             }
      .           }
  1,560 (0.0%)    uint8_t *data = NULL;
      .           size_t data_len;
  3,120 (0.0%)    if (// OpenSSL historically NUL-terminated this value with a single byte,
      .               // even for |MBSTRING_BMP| and |MBSTRING_UNIV|.
 21,840 (0.0%)        !CBB_add_u8(&cbb, 0) || !CBB_finish(&cbb, &data, &data_len) ||
  7,800 (0.0%)        data_len < 1 || data_len > INT_MAX) {
      .             OPENSSL_PUT_ERROR(ASN1, ERR_R_INTERNAL_ERROR);
      .             OPENSSL_free(data);
      .             goto err;
      .           }
  4,680 (0.0%)    dest->type = str_type;
 10,920 (0.0%)    ASN1_STRING_set0(dest, data, (int)data_len - 1);
  4,680 (0.0%)    *out = dest;
  3,120 (0.0%)    return str_type;
      .         
      .         err:
      .           if (free_dest) {
      .             ASN1_STRING_free(dest);
      .           }
      .           CBB_cleanup(&cbb);
      .           return -1;
 10,440 (0.0%)  }
      .         
      .         int asn1_is_printable(uint32_t value) {
      .           if (value > 0x7f) {
      .             return 0;
      .           }
      .           return OPENSSL_isalnum(value) || //
      .                  value == ' ' || value == '\'' || value == '(' || value == ')' ||
      .                  value == '+' || value == ',' || value == '-' || value == '.' ||
-- line 285 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_object.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 149 ----------------------------------------
     .             // |c2i_ASN1_OBJECT| should have consumed the entire input.
     .             assert(CBS_data(&cbs) == contents);
     .             *inp = CBS_data(&cbs);
     .           }
     .           return ret;
     .         }
     .         
     .         ASN1_OBJECT *c2i_ASN1_OBJECT(ASN1_OBJECT **out, const unsigned char **inp,
40,500 (0.0%)                               long len) {
 8,100 (0.0%)    if (len < 0) {
     .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_OBJECT_ENCODING);
     .             return NULL;
     .           }
     .         
     .           CBS cbs;
28,350 (0.0%)    CBS_init(&cbs, *inp, (size_t)len);
20,250 (0.0%)    if (!CBS_is_valid_asn1_oid(&cbs)) {
     .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_OBJECT_ENCODING);
     .             return NULL;
     .           }
     .         
36,450 (0.0%)    ASN1_OBJECT *ret = ASN1_OBJECT_create(NID_undef, *inp, (size_t)len,
     .                                                 /*sn=*/NULL, /*ln=*/NULL);
 8,100 (0.0%)    if (ret == NULL) {
     .             return NULL;
     .           }
     .         
 8,100 (0.0%)    if (out != NULL) {
16,200 (0.0%)      ASN1_OBJECT_free(*out);
12,150 (0.0%)      *out = ret;
     .           }
24,300 (0.0%)    *inp += len;  // All bytes were consumed.
 4,050 (0.0%)    return ret;
20,250 (0.0%)  }
     .         
24,552 (0.0%)  ASN1_OBJECT *ASN1_OBJECT_new(void) {
     .           ASN1_OBJECT *ret;
     .         
18,414 (0.0%)    ret = (ASN1_OBJECT *)OPENSSL_zalloc(sizeof(ASN1_OBJECT));
12,276 (0.0%)    if (ret == NULL) {
     .             return NULL;
     .           }
12,276 (0.0%)    ret->flags = ASN1_OBJECT_FLAG_DYNAMIC;
 6,138 (0.0%)    return ret;
12,276 (0.0%)  }
     .         
40,815 (0.0%)  void ASN1_OBJECT_free(ASN1_OBJECT *a) {
16,326 (0.0%)    if (a == NULL) {
    80 (0.0%)      return;
     .           }
40,415 (0.0%)    if (a->flags & ASN1_OBJECT_FLAG_DYNAMIC_STRINGS) {
16,452 (0.0%)      OPENSSL_free((void *)a->sn);
16,452 (0.0%)      OPENSSL_free((void *)a->ln);
24,678 (0.0%)      a->sn = a->ln = NULL;
     .           }
40,415 (0.0%)    if (a->flags & ASN1_OBJECT_FLAG_DYNAMIC_DATA) {
16,452 (0.0%)      OPENSSL_free((void *)a->data);
 8,226 (0.0%)      a->data = NULL;
 8,226 (0.0%)      a->length = 0;
     .           }
40,415 (0.0%)    if (a->flags & ASN1_OBJECT_FLAG_DYNAMIC) {
16,452 (0.0%)      OPENSSL_free(a);
     .           }
16,326 (0.0%)  }
     .         
     .         ASN1_OBJECT *ASN1_OBJECT_create(int nid, const unsigned char *data, size_t len,
48,600 (0.0%)                                  const char *sn, const char *ln) {
12,150 (0.0%)    if (len > INT_MAX) {
     .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_STRING_TOO_LONG);
     .             return NULL;
     .           }
     .         
     .           ASN1_OBJECT o;
 8,100 (0.0%)    o.sn = sn;
 8,100 (0.0%)    o.ln = ln;
 8,100 (0.0%)    o.data = data;
 8,100 (0.0%)    o.nid = nid;
 8,100 (0.0%)    o.length = (int)len;
 4,050 (0.0%)    o.flags = ASN1_OBJECT_FLAG_DYNAMIC | ASN1_OBJECT_FLAG_DYNAMIC_STRINGS |
     .                     ASN1_OBJECT_FLAG_DYNAMIC_DATA;
12,150 (0.0%)    return OBJ_dup(&o);
20,250 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 109 ----------------------------------------
      .         //
      .         // In particular, this limit is small enough that the bit count of a BIT STRING
      .         // comfortably fits in an |int|, with room for arithmetic.
      .         #define ASN1_STRING_MAX (64 * 1024 * 1024)
      .         
      .         static void asn1_put_length(unsigned char **pp, int length);
      .         
      .         int ASN1_get_object(const unsigned char **inp, long *out_len, int *out_tag,
278,352 (0.1%)                      int *out_class, long in_len) {
 46,392 (0.0%)    if (in_len < 0) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_HEADER_TOO_LONG);
      .             return 0x80;
      .           }
      .         
      .           // TODO(https://crbug.com/boringssl/354): This should use |CBS_get_asn1| to
      .           // reject non-minimal lengths, which are only allowed in BER. However,
      .           // Android sometimes needs allow a non-minimal length in certificate
      .           // signature fields (see b/18228011). Make this only apply to that field,
      .           // while requiring DER elsewhere. Better yet, it should be limited to an
      .           // preprocessing step in that part of Android.
      .           CBS_ASN1_TAG tag;
      .           size_t header_len;
      .           int indefinite;
      .           CBS cbs, body;
162,372 (0.1%)    CBS_init(&cbs, *inp, (size_t)in_len);
255,156 (0.1%)    if (!CBS_get_any_ber_asn1_element(&cbs, &body, &tag, &header_len,
 69,588 (0.0%)                                      /*out_ber_found=*/NULL, &indefinite) ||
208,764 (0.1%)        indefinite || !CBS_skip(&body, header_len) ||
      .               // Bound the length to comfortably fit in an int. Lengths in this
      .               // module often switch between int and long without overflow checks.
 69,588 (0.0%)        CBS_len(&body) > INT_MAX / 2) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_HEADER_TOO_LONG);
      .             return 0x80;
      .           }
      .         
      .           // Convert between tag representations.
 92,784 (0.0%)    int tag_class = (tag & CBS_ASN1_CLASS_MASK) >> CBS_ASN1_TAG_SHIFT;
 92,784 (0.0%)    int constructed = (tag & CBS_ASN1_CONSTRUCTED) >> CBS_ASN1_TAG_SHIFT;
 69,588 (0.0%)    int tag_number = tag & CBS_ASN1_TAG_NUMBER_MASK;
      .         
      .           // To avoid ambiguity with V_ASN1_NEG, impose a limit on universal tags.
 90,448 (0.0%)    if (tag_class == V_ASN1_UNIVERSAL && tag_number > V_ASN1_MAX_UNIVERSAL) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_HEADER_TOO_LONG);
      .             return 0x80;
      .           }
      .         
115,980 (0.0%)    *inp = CBS_data(&body);
139,176 (0.0%)    *out_len = CBS_len(&body);
 69,588 (0.0%)    *out_tag = tag_number;
 69,588 (0.0%)    *out_class = tag_class;
 23,196 (0.0%)    return constructed;
115,980 (0.0%)  }
      .         
      .         // class 0 is constructed constructed == 2 for indefinite length constructed
      .         void ASN1_put_object(unsigned char **pp, int constructed, int length, int tag,
117,744 (0.0%)                       int xclass) {
 29,436 (0.0%)    unsigned char *p = *pp;
      .           int i, ttag;
      .         
 44,008 (0.0%)    i = (constructed) ? V_ASN1_CONSTRUCTED : 0;
 29,436 (0.0%)    i |= (xclass & V_ASN1_PRIVATE);
 19,624 (0.0%)    if (tag < 31) {
117,744 (0.0%)      *(p++) = i | (tag & V_ASN1_PRIMITIVE_TAG);
      .           } else {
      .             *(p++) = i | V_ASN1_PRIMITIVE_TAG;
      .             for (i = 0, ttag = tag; ttag > 0; i++) {
      .               ttag >>= 7;
      .             }
      .             ttag = i;
      .             while (i-- > 0) {
      .               p[i] = tag & 0x7f;
      .               if (i != (ttag - 1)) {
      .                 p[i] |= 0x80;
      .               }
      .               tag >>= 7;
      .             }
      .             p += ttag;
      .           }
 19,624 (0.0%)    if (constructed == 2) {
      .             *(p++) = 0x80;
      .           } else {
 49,060 (0.0%)      asn1_put_length(&p, length);
      .           }
 29,436 (0.0%)    *pp = p;
 58,872 (0.0%)  }
      .         
      .         int ASN1_put_eoc(unsigned char **pp) {
      .           // This function is no longer used in the library, but some external code
      .           // uses it.
      .           unsigned char *p = *pp;
      .           *p++ = 0;
      .           *p++ = 0;
      .           *pp = p;
      .           return 2;
      .         }
      .         
 49,060 (0.0%)  static void asn1_put_length(unsigned char **pp, int length) {
 29,436 (0.0%)    unsigned char *p = *pp;
      .           int i, l;
 19,624 (0.0%)    if (length <= 127) {
 56,328 (0.0%)      *(p++) = (unsigned char)length;
      .           } else {
    848 (0.0%)      l = length;
  4,240 (0.0%)      for (i = 0; l > 0; i++) {
    848 (0.0%)        l >>= 8;
      .             }
  3,392 (0.0%)      *(p++) = i | 0x80;
    848 (0.0%)      l = i;
  6,784 (0.0%)      while (i-- > 0) {
  5,088 (0.0%)        p[i] = length & 0xff;
    848 (0.0%)        length >>= 8;
      .             }
  1,272 (0.0%)      p += l;
      .           }
 29,436 (0.0%)    *pp = p;
 29,436 (0.0%)  }
      .         
190,896 (0.1%)  int ASN1_object_size(int constructed, int length, int tag) {
 31,816 (0.0%)    int ret = 1;
 63,632 (0.0%)    if (length < 0) {
      .             return -1;
      .           }
 63,632 (0.0%)    if (tag >= 31) {
      .             while (tag > 0) {
      .               tag >>= 7;
      .               ret++;
      .             }
      .           }
 63,632 (0.0%)    if (constructed == 2) {
      .             ret += 3;
      .           } else {
 31,816 (0.0%)      ret++;
 63,632 (0.0%)      if (length > 127) {
  2,120 (0.0%)        int tmplen = length;
  7,420 (0.0%)        while (tmplen > 0) {
  2,120 (0.0%)          tmplen >>= 8;
  2,120 (0.0%)          ret++;
      .               }
      .             }
      .           }
127,264 (0.0%)    if (ret >= INT_MAX - length) {
      .             return -1;
      .           }
 95,448 (0.0%)    return ret + length;
 63,632 (0.0%)  }
      .         
      .         int ASN1_STRING_copy(ASN1_STRING *dst, const ASN1_STRING *str) {
      .           if (str == NULL) {
      .             return 0;
      .           }
      .           if (!ASN1_STRING_set(dst, str->data, str->length)) {
      .             return 0;
      .           }
-- line 261 ----------------------------------------
-- line 275 ----------------------------------------
      .           }
      .           if (!ASN1_STRING_copy(ret, str)) {
      .             ASN1_STRING_free(ret);
      .             return NULL;
      .           }
      .           return ret;
      .         }
      .         
 33,530 (0.0%)  int ASN1_STRING_set(ASN1_STRING *str, const void *_data, ossl_ssize_t len_s) {
  9,580 (0.0%)    const char *data = _data;
      .           size_t len;
  9,580 (0.0%)    if (len_s < 0) {
      .             if (data == NULL) {
      .               return 0;
      .             }
      .             len = strlen(data);
      .           } else {
  9,580 (0.0%)      len = (size_t)len_s;
      .           }
      .         
      .           OPENSSL_STATIC_ASSERT(ASN1_STRING_MAX < INT_MAX, len_will_not_overflow_int);
  9,580 (0.0%)    if (len > ASN1_STRING_MAX) {
      .             OPENSSL_PUT_ERROR(ASN1, ERR_R_OVERFLOW);
      .             return 0;
      .           }
      .         
 23,950 (0.0%)    if (str->length <= (int)len || str->data == NULL) {
 14,370 (0.0%)      unsigned char *c = str->data;
  9,580 (0.0%)      if (c == NULL) {
 33,530 (0.0%)        str->data = OPENSSL_malloc(len + 1);
      .             } else {
      .               str->data = OPENSSL_realloc(c, len + 1);
      .             }
      .         
 19,160 (0.0%)      if (str->data == NULL) {
      .               str->data = c;
      .               return 0;
      .             }
      .           }
 19,160 (0.0%)    str->length = (int)len;
  9,580 (0.0%)    if (data != NULL) {
 33,530 (0.0%)      OPENSSL_memcpy(str->data, data, len);
      .             // Historically, OpenSSL would NUL-terminate most (but not all)
      .             // |ASN1_STRING|s, in case anyone accidentally passed |str->data| into a
      .             // function expecting a C string. We retain this behavior for compatibility,
      .             // but code must not rely on this. See CVE-2021-3712.
 23,950 (0.0%)      str->data[len] = '\0';
      .           }
  4,790 (0.0%)    return 1;
  9,580 (0.0%)  }
      .         
 10,920 (0.0%)  void ASN1_STRING_set0(ASN1_STRING *str, void *data, int len) {
  6,240 (0.0%)    OPENSSL_free(str->data);
  4,680 (0.0%)    str->data = data;
  4,680 (0.0%)    str->length = len;
  4,680 (0.0%)  }
      .         
      .         ASN1_STRING *ASN1_STRING_new(void) {
      .           return (ASN1_STRING_type_new(V_ASN1_OCTET_STRING));
      .         }
      .         
 34,670 (0.0%)  ASN1_STRING *ASN1_STRING_type_new(int type) {
      .           ASN1_STRING *ret;
      .         
 20,802 (0.0%)    ret = (ASN1_STRING *)OPENSSL_zalloc(sizeof(ASN1_STRING));
 13,868 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
 20,802 (0.0%)    ret->type = type;
  6,934 (0.0%)    return ret;
 13,868 (0.0%)  }
      .         
 31,245 (0.0%)  void ASN1_STRING_free(ASN1_STRING *str) {
 12,498 (0.0%)    if (str == NULL) {
  1,738 (0.0%)      return;
      .           }
 18,044 (0.0%)    OPENSSL_free(str->data);
 18,044 (0.0%)    OPENSSL_free(str);
 12,498 (0.0%)  }
      .         
      .         void ASN1_STRING_clear_free(ASN1_STRING *str) {
      .           ASN1_STRING_free(str);
      .         }
      .         
      .         int ASN1_STRING_cmp(const ASN1_STRING *a, const ASN1_STRING *b) {
      .           // Capture padding bits and implicit truncation in BIT STRINGs.
      .           int a_length = a->length, b_length = b->length;
-- line 361 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 121 ----------------------------------------
      .             B_ASN1_GRAPHICSTRING,
      .             B_ASN1_ISO64STRING,
      .             B_ASN1_GENERALSTRING,
      .             B_ASN1_UNIVERSALSTRING,
      .             B_ASN1_UNKNOWN,  // CHARACTER STRING
      .             B_ASN1_BMPSTRING,
      .         };
      .         
 19,040 (0.0%)  unsigned long ASN1_tag2bit(int tag) {
 19,040 (0.0%)    if (tag < 0 || tag > 30) {
      .             return 0;
      .           }
 23,800 (0.0%)    return tag2bit[tag];
  9,520 (0.0%)  }
      .         
      .         // Macro to initialize and invalidate the cache
      .         
      .         // Decode an ASN1 item, this currently behaves just like a standard 'd2i'
      .         // function. 'in' points to a buffer to read the data from, in future we
      .         // will have more advanced versions that can input data a piece at a time and
      .         // this will simply be a special case.
      .         
      .         ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
  3,212 (0.0%)                            const ASN1_ITEM *it) {
    292 (0.0%)    ASN1_VALUE *ptmpval = NULL;
    584 (0.0%)    if (!pval) {
    584 (0.0%)      pval = &ptmpval;
      .           }
      .         
  3,796 (0.0%)    if (asn1_item_ex_d2i(pval, in, len, it, -1, 0, 0, 0) > 0) {
    876 (0.0%)      return *pval;
      .           }
      .           return NULL;
  1,460 (0.0%)  }
      .         
      .         // Decode an item, taking care of IMPLICIT tagging, if any. If 'opt' set and
      .         // tag mismatch return -1 to handle OPTIONAL
      .         
      .         static int asn1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in,
      .                                     long len, const ASN1_ITEM *it, int tag, int aclass,
292,740 (0.1%)                              char opt, int depth) {
 19,516 (0.0%)    const ASN1_TEMPLATE *tt, *errtt = NULL;
      .           const ASN1_EXTERN_FUNCS *ef;
 19,516 (0.0%)    const unsigned char *p = NULL, *q;
      .           unsigned char oclass;
      .           char cst, isopt;
      .           int i;
      .           int otag;
 19,516 (0.0%)    int ret = 0;
      .           ASN1_VALUE **pchptr;
 58,548 (0.0%)    int combine = aclass & ASN1_TFLG_COMBINE;
 19,516 (0.0%)    aclass &= ~ASN1_TFLG_COMBINE;
 78,064 (0.0%)    if (pval == NULL || it == NULL) {
      .             return 0;
      .           }
      .         
      .           // Bound |len| to comfortably fit in an int. Lengths in this module often
      .           // switch between int and long without overflow checks.
 58,548 (0.0%)    if (len > INT_MAX / 2) {
      .             len = INT_MAX / 2;
      .           }
      .         
 58,548 (0.0%)    if (++depth > ASN1_MAX_CONSTRUCTED_NEST) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_TOO_DEEP);
      .             goto err;
      .           }
      .         
253,708 (0.1%)    switch (it->itype) {
      .             case ASN1_ITYPE_PRIMITIVE:
 44,488 (0.0%)        if (it->templates) {
      .                 // tagging or OPTIONAL is currently illegal on an item template
      .                 // because the flags can't get passed down. In practice this
      .                 // isn't a problem: we include the relevant flags from the item
      .                 // template in the template itself.
 10,688 (0.0%)          if ((tag != -1) || opt) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
      .                   goto err;
      .                 }
 32,064 (0.0%)          return asn1_template_ex_d2i(pval, in, len, it->templates, opt, depth);
      .               }
109,850 (0.0%)        return asn1_d2i_ex_primitive(pval, in, len, it, tag, aclass, opt);
      .               break;
      .         
      .             case ASN1_ITYPE_MSTRING:
      .               // It never makes sense for multi-strings to have implicit tagging, so
      .               // if tag != -1, then this looks like an error in the template.
  5,344 (0.0%)        if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 goto err;
      .               }
      .         
  8,016 (0.0%)        p = *in;
      .               // Just read in tag and class
 42,752 (0.0%)        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, &p, len, -1, 0, 1);
  5,344 (0.0%)        if (!ret) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
      .         
      .               // Must be UNIVERSAL class
  8,016 (0.0%)        if (oclass != V_ASN1_UNIVERSAL) {
      .                 // If OPTIONAL, assume this is OK
      .                 if (opt) {
      .                   return -1;
      .                 }
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_MSTRING_NOT_UNIVERSAL);
      .                 goto err;
      .               }
      .               // Check tag matches bit map
 26,720 (0.0%)        if (!(ASN1_tag2bit(otag) & it->utype)) {
      .                 // If OPTIONAL, assume this is OK
      .                 if (opt) {
      .                   return -1;
      .                 }
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_MSTRING_WRONG_TAG);
      .                 goto err;
      .               }
 34,736 (0.0%)        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0);
      .         
      .             case ASN1_ITYPE_EXTERN:
      .               // Use new style d2i
  1,752 (0.0%)        ef = it->funcs;
  8,760 (0.0%)        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, NULL);
      .         
      .             case ASN1_ITYPE_CHOICE: {
      .               // It never makes sense for CHOICE types to have implicit tagging, so if
      .               // tag != -1, then this looks like an error in the template.
      .               if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 goto err;
      .               }
-- line 251 ----------------------------------------
-- line 305 ----------------------------------------
      .               if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL)) {
      .                 goto auxerr;
      .               }
      .               *in = p;
      .               return 1;
      .             }
      .         
      .             case ASN1_ITYPE_SEQUENCE: {
 15,414 (0.0%)        p = *in;
      .         
      .               // If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL
 10,276 (0.0%)        if (tag == -1) {
  5,138 (0.0%)          tag = V_ASN1_SEQUENCE;
  5,138 (0.0%)          aclass = V_ASN1_UNIVERSAL;
      .               }
      .               // Get SEQUENCE length and update len, p
102,760 (0.0%)        ret = asn1_check_tlen(&len, NULL, NULL, &cst, &p, len, tag, aclass, opt);
 10,276 (0.0%)        if (!ret) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
 10,276 (0.0%)        } else if (ret == -1) {
      .                 return -1;
      .               }
 15,414 (0.0%)        if (!cst) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
      .                 goto err;
      .               }
      .         
 44,254 (0.0%)        if (!*pval && !ASN1_item_ex_new(pval, it)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
      .         
 15,414 (0.0%)        const ASN1_AUX *aux = it->funcs;
 22,304 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
 15,532 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL)) {
      .                 goto auxerr;
      .               }
      .         
      .               // Free up and zero any ADB found
167,798 (0.1%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
 69,550 (0.0%)          if (tt->flags & ASN1_TFLG_ADB_MASK) {
      .                   const ASN1_TEMPLATE *seqtt;
      .                   ASN1_VALUE **pseqval;
      .                   seqtt = asn1_do_adb(pval, tt, 0);
      .                   if (seqtt == NULL) {
      .                     continue;
      .                   }
      .                   pseqval = asn1_get_field_ptr(pval, seqtt);
      .                   ASN1_template_free(pseqval, seqtt);
      .                 }
      .               }
      .         
      .               // Get each field entry
171,496 (0.1%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
      .                 const ASN1_TEMPLATE *seqtt;
      .                 ASN1_VALUE **pseqval;
 97,370 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
 27,820 (0.0%)          if (seqtt == NULL) {
      .                   goto err;
      .                 }
 83,460 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
      .                 // Have we ran out of data?
 41,730 (0.0%)          if (!len) {
    160 (0.0%)            break;
      .                 }
 27,500 (0.0%)          q = p;
      .                 // This determines the OPTIONAL flag value. The field cannot be
      .                 // omitted if it is the last of a SEQUENCE and there is still
      .                 // data to be read. This isn't strictly necessary but it
      .                 // increases efficiency in some cases.
 96,250 (0.0%)          if (i == (it->tcount - 1)) {
  9,956 (0.0%)            isopt = 0;
      .                 } else {
 52,632 (0.0%)            isopt = (seqtt->flags & ASN1_TFLG_OPTIONAL) != 0;
      .                 }
      .                 // attempt to read in field, allowing each to be OPTIONAL
      .         
151,250 (0.1%)          ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, depth);
 27,500 (0.0%)          if (!ret) {
      .                   errtt = seqtt;
      .                   goto err;
 27,500 (0.0%)          } else if (ret == -1) {
      .                   // OPTIONAL component absent. Free and zero the field.
  5,170 (0.0%)            ASN1_template_free(pseqval, seqtt);
  1,034 (0.0%)            continue;
      .                 }
      .                 // Update length
 63,580 (0.0%)          len -= p - q;
      .               }
      .         
      .               // Check all data read
 15,414 (0.0%)        if (len) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
      .                 goto err;
      .               }
      .         
      .               // If we get here we've got no more data in the SEQUENCE, however we
      .               // may not have read all fields so check all remaining are OPTIONAL
      .               // and clear any that are.
 32,108 (0.0%)        for (; i < it->tcount; tt++, i++) {
      .                 const ASN1_TEMPLATE *seqtt;
  1,120 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
    320 (0.0%)          if (seqtt == NULL) {
      .                   goto err;
      .                 }
    800 (0.0%)          if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
      .                   ASN1_VALUE **pseqval;
    960 (0.0%)            pseqval = asn1_get_field_ptr(pval, seqtt);
    960 (0.0%)            ASN1_template_free(pseqval, seqtt);
      .                 } else {
      .                   errtt = seqtt;
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_FIELD_MISSING);
      .                   goto err;
      .                 }
      .               }
      .               // Save encoding
 77,070 (0.0%)        if (!asn1_enc_save(pval, *in, p - *in, it)) {
      .                 goto auxerr;
      .               }
 15,532 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL)) {
      .                 goto auxerr;
      .               }
 15,414 (0.0%)        *in = p;
 10,276 (0.0%)        return 1;
      .             }
      .         
      .             default:
      .               return 0;
      .           }
      .         auxerr:
      .           OPENSSL_PUT_ERROR(ASN1, ASN1_R_AUX_ERROR);
      .         err:
-- line 437 ----------------------------------------
-- line 439 ----------------------------------------
      .             ASN1_item_ex_free(pval, it);
      .           }
      .           if (errtt) {
      .             ERR_add_error_data(4, "Field=", errtt->field_name, ", Type=", it->sname);
      .           } else {
      .             ERR_add_error_data(2, "Type=", it->sname);
      .           }
      .           return 0;
 97,580 (0.0%)  }
      .         
      .         int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
      .                              const ASN1_ITEM *it, int tag, int aclass, char opt,
  7,008 (0.0%)                       ASN1_TLC *ctx) {
  7,008 (0.0%)    return asn1_item_ex_d2i(pval, in, len, it, tag, aclass, opt, 0);
  1,168 (0.0%)  }
      .         
      .         // Templates are handled with two separate functions. One handles any
      .         // EXPLICIT tag and the other handles the rest.
      .         
      .         static int asn1_template_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                         long inlen, const ASN1_TEMPLATE *tt, char opt,
229,908 (0.1%)                                  int depth) {
      .           int aclass;
      .           int ret;
      .           long len;
      .           const unsigned char *p, *q;
 32,844 (0.0%)    if (!val) {
      .             return 0;
      .           }
 49,266 (0.0%)    uint32_t flags = tt->flags;
 49,266 (0.0%)    aclass = flags & ASN1_TFLG_TAG_CLASS;
      .         
 49,266 (0.0%)    p = *in;
      .         
      .           // Check if EXPLICIT tag expected
 65,688 (0.0%)    if (flags & ASN1_TFLG_EXPTAG) {
      .             char cst;
      .             // Need to work out amount of data available to the inner content and
      .             // where it starts: so read in EXPLICIT header to get the info.
 12,264 (0.0%)      ret = asn1_check_tlen(&len, NULL, NULL, &cst, &p, inlen, tt->tag, aclass,
      .                                   opt);
  1,168 (0.0%)      q = p;
  1,168 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
  1,168 (0.0%)      } else if (ret == -1) {
      .               return -1;
      .             }
  1,752 (0.0%)      if (!cst) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);
      .               return 0;
      .             }
      .             // We've found the field so it can't be OPTIONAL now
  5,840 (0.0%)      ret = asn1_template_noexp_d2i(val, &p, len, tt, 0, depth);
  1,168 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
      .             }
      .             // We read the field in OK so update length
  2,920 (0.0%)      len -= p - q;
      .             // Check for trailing data.
  1,752 (0.0%)      if (len) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_EXPLICIT_LENGTH_MISMATCH);
      .               goto err;
      .             }
      .           } else {
174,218 (0.1%)      return asn1_template_noexp_d2i(val, in, inlen, tt, opt, depth);
      .           }
      .         
  1,752 (0.0%)    *in = p;
    584 (0.0%)    return 1;
      .         
      .         err:
      .           ASN1_template_free(val, tt);
      .           return 0;
 82,110 (0.0%)  }
      .         
      .         static int asn1_template_noexp_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                            long len, const ASN1_TEMPLATE *tt, char opt,
229,908 (0.1%)                                     int depth) {
      .           int aclass;
      .           int ret;
      .           const unsigned char *p;
 32,844 (0.0%)    if (!val) {
      .             return 0;
      .           }
 49,266 (0.0%)    uint32_t flags = tt->flags;
 49,266 (0.0%)    aclass = flags & ASN1_TFLG_TAG_CLASS;
      .         
 49,266 (0.0%)    p = *in;
      .         
 65,688 (0.0%)    if (flags & ASN1_TFLG_SK_MASK) {
      .             // SET OF, SEQUENCE OF
      .             int sktag, skaclass;
      .             // First work out expected inner tag value
 11,856 (0.0%)      if (flags & ASN1_TFLG_IMPTAG) {
      .               sktag = tt->tag;
      .               skaclass = aclass;
      .             } else {
  2,964 (0.0%)        skaclass = V_ASN1_UNIVERSAL;
 11,856 (0.0%)        if (flags & ASN1_TFLG_SET_OF) {
  4,176 (0.0%)          sktag = V_ASN1_SET;
      .               } else {
    876 (0.0%)          sktag = V_ASN1_SEQUENCE;
      .               }
      .             }
      .             // Get the tag
      .             ret =
 56,316 (0.0%)          asn1_check_tlen(&len, NULL, NULL, NULL, &p, len, sktag, skaclass, opt);
  5,928 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
  5,928 (0.0%)      } else if (ret == -1) {
      .               return -1;
      .             }
 11,856 (0.0%)      if (!*val) {
 11,856 (0.0%)        *val = (ASN1_VALUE *)sk_ASN1_VALUE_new_null();
      .             } else {
      .               // We've got a valid STACK: free up any items present
      .               STACK_OF(ASN1_VALUE) *sktmp = (STACK_OF(ASN1_VALUE) *)*val;
      .               ASN1_VALUE *vtmp;
      .               while (sk_ASN1_VALUE_num(sktmp) > 0) {
      .                 vtmp = sk_ASN1_VALUE_pop(sktmp);
      .                 ASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item));
      .               }
      .             }
      .         
 11,856 (0.0%)      if (!*val) {
      .               goto err;
      .             }
      .         
      .             // Read as many items as we can
 30,366 (0.0%)      while (len > 0) {
      .               ASN1_VALUE *skfield;
 10,364 (0.0%)        const unsigned char *q = p;
  5,182 (0.0%)        skfield = NULL;
 77,730 (0.0%)        if (!asn1_item_ex_d2i(&skfield, &p, len, ASN1_ITEM_ptr(tt->item), -1, 0,
      .                                     0, depth)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
 25,910 (0.0%)        len -= p - q;
 41,456 (0.0%)        if (!sk_ASN1_VALUE_push((STACK_OF(ASN1_VALUE) *)*val, skfield)) {
      .                 ASN1_item_ex_free(&skfield, ASN1_ITEM_ptr(tt->item));
      .                 goto err;
      .               }
      .             }
 53,832 (0.0%)    } else if (flags & ASN1_TFLG_IMPTAG) {
      .             // IMPLICIT tagging
  9,928 (0.0%)      ret = asn1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), tt->tag,
      .                                    aclass, opt, depth);
  1,168 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               goto err;
  1,168 (0.0%)      } else if (ret == -1) {
  1,168 (0.0%)        return -1;
      .             }
      .           } else {
      .             // Nothing special
205,984 (0.1%)      ret = asn1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), -1,
 25,748 (0.0%)                             tt->flags & ASN1_TFLG_COMBINE, opt, depth);
 25,748 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               goto err;
 25,748 (0.0%)      } else if (ret == -1) {
    900 (0.0%)        return -1;
      .             }
      .           }
      .         
 46,164 (0.0%)    *in = p;
 30,776 (0.0%)    return 1;
      .         
      .         err:
      .           ASN1_template_free(val, tt);
      .           return 0;
 82,110 (0.0%)  }
      .         
      .         static int asn1_d2i_ex_primitive(ASN1_VALUE **pval, const unsigned char **in,
      .                                          long inlen, const ASN1_ITEM *it, int tag,
166,830 (0.1%)                                   int aclass, char opt) {
 11,122 (0.0%)    int ret = 0, utype;
      .           long plen;
      .           char cst;
      .           const unsigned char *p;
 11,122 (0.0%)    const unsigned char *cont = NULL;
      .           long len;
 22,244 (0.0%)    if (!pval) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_NULL);
      .             return 0;  // Should never happen
      .           }
      .         
 44,488 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
  5,344 (0.0%)      utype = tag;
  5,344 (0.0%)      tag = -1;
      .           } else {
 25,350 (0.0%)      utype = it->utype;
      .           }
      .         
 33,366 (0.0%)    if (utype == V_ASN1_ANY) {
      .             // If type is ANY need to figure out type from tag
      .             unsigned char oclass;
  1,432 (0.0%)      if (tag >= 0) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_TAGGED_ANY);
      .               return 0;
      .             }
  1,432 (0.0%)      if (opt) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OPTIONAL_ANY);
      .               return 0;
      .             }
  2,148 (0.0%)      p = *in;
 11,456 (0.0%)      ret = asn1_check_tlen(NULL, &utype, &oclass, NULL, &p, inlen, -1, 0, 0);
  1,432 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
      .             }
  2,148 (0.0%)      if (oclass != V_ASN1_UNIVERSAL) {
      .               utype = V_ASN1_OTHER;
      .             }
      .           }
 22,244 (0.0%)    if (tag == -1) {
 21,076 (0.0%)      tag = utype;
 10,538 (0.0%)      aclass = V_ASN1_UNIVERSAL;
      .           }
 33,366 (0.0%)    p = *in;
      .           // Check header
222,440 (0.1%)    ret = asn1_check_tlen(&plen, NULL, NULL, &cst, &p, inlen, tag, aclass, opt);
 22,244 (0.0%)    if (!ret) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .             return 0;
 22,244 (0.0%)    } else if (ret == -1) {
  2,068 (0.0%)      return -1;
      .           }
 10,088 (0.0%)    ret = 0;
      .           // SEQUENCE, SET and "OTHER" are left in encoded form
 80,704 (0.0%)    if ((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||
 10,088 (0.0%)        (utype == V_ASN1_OTHER)) {
      .             // SEQUENCE and SET must be constructed
      .             if (utype != V_ASN1_OTHER && !cst) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_TYPE_NOT_CONSTRUCTED);
      .               return 0;
      .             }
      .         
      .             cont = *in;
      .             len = p - cont + plen;
      .             p += plen;
 30,264 (0.0%)    } else if (cst) {
      .             // This parser historically supported BER constructed strings. We no
      .             // longer do and will gradually tighten this parser into a DER
      .             // parser. BER types should use |CBS_asn1_ber_to_der|.
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_TYPE_NOT_PRIMITIVE);
      .             return 0;
      .           } else {
 20,176 (0.0%)      cont = p;
 20,176 (0.0%)      len = plen;
 40,352 (0.0%)      p += plen;
      .           }
      .         
      .           // We now have content length and type: translate into a structure
100,880 (0.0%)    if (!asn1_ex_c2i(pval, cont, len, utype, it)) {
      .             goto err;
      .           }
      .         
 30,264 (0.0%)    *in = p;
 20,176 (0.0%)    ret = 1;
      .         err:
 10,088 (0.0%)    return ret;
 55,610 (0.0%)  }
      .         
      .         // Translate ASN1 content octets into a structure
      .         
      .         static int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, long len,
121,056 (0.0%)                         int utype, const ASN1_ITEM *it) {
 10,088 (0.0%)    ASN1_VALUE **opval = NULL;
      .           ASN1_STRING *stmp;
 10,088 (0.0%)    ASN1_TYPE *typ = NULL;
 10,088 (0.0%)    int ret = 0;
      .           ASN1_INTEGER **tint;
      .         
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of callbacks.
 40,352 (0.0%)    assert(it->funcs == NULL);
      .         
      .           // If ANY type clear type and set pointer to internal value
 40,352 (0.0%)    if (it->utype == V_ASN1_ANY) {
  2,864 (0.0%)      if (!*pval) {
  1,432 (0.0%)        typ = ASN1_TYPE_new();
  1,432 (0.0%)        if (typ == NULL) {
      .                 goto err;
      .               }
  2,864 (0.0%)        *pval = (ASN1_VALUE *)typ;
      .             } else {
      .               typ = (ASN1_TYPE *)*pval;
      .             }
      .         
  2,864 (0.0%)      if (utype != typ->type) {
  4,296 (0.0%)        ASN1_TYPE_set(typ, utype, NULL);
      .             }
  1,432 (0.0%)      opval = pval;
  2,148 (0.0%)      pval = &typ->value.asn1_value;
      .           }
 79,504 (0.0%)    switch (utype) {
      .             case V_ASN1_OBJECT:
 32,400 (0.0%)        if (!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, &cont, len)) {
      .                 goto err;
      .               }
  8,100 (0.0%)        break;
      .         
      .             case V_ASN1_NULL:
  1,272 (0.0%)        if (len) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NULL_IS_WRONG_LENGTH);
      .                 goto err;
      .               }
  1,272 (0.0%)        *pval = (ASN1_VALUE *)1;
    636 (0.0%)        break;
      .         
      .             case V_ASN1_BOOLEAN:
  1,112 (0.0%)        if (len != 1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BOOLEAN_IS_WRONG_LENGTH);
      .                 goto err;
      .               } else {
      .                 ASN1_BOOLEAN *tbool;
  1,112 (0.0%)          tbool = (ASN1_BOOLEAN *)pval;
  2,780 (0.0%)          *tbool = *cont;
      .               }
    556 (0.0%)        break;
      .         
      .             case V_ASN1_BIT_STRING:
  4,672 (0.0%)        if (!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, &cont, len)) {
      .                 goto err;
      .               }
  1,168 (0.0%)        break;
      .         
      .             case V_ASN1_INTEGER:
      .             case V_ASN1_ENUMERATED:
  1,168 (0.0%)        tint = (ASN1_INTEGER **)pval;
  4,672 (0.0%)        if (!c2i_ASN1_INTEGER(tint, &cont, len)) {
      .                 goto err;
      .               }
      .               // Fixup type to match the expected form
  5,256 (0.0%)        (*tint)->type = utype | ((*tint)->type & V_ASN1_NEG);
    584 (0.0%)        break;
      .         
      .             case V_ASN1_OCTET_STRING:
      .             case V_ASN1_NUMERICSTRING:
      .             case V_ASN1_PRINTABLESTRING:
      .             case V_ASN1_T61STRING:
      .             case V_ASN1_VIDEOTEXSTRING:
      .             case V_ASN1_IA5STRING:
      .             case V_ASN1_UTCTIME:
-- line 787 ----------------------------------------
-- line 791 ----------------------------------------
      .             case V_ASN1_GENERALSTRING:
      .             case V_ASN1_UNIVERSALSTRING:
      .             case V_ASN1_BMPSTRING:
      .             case V_ASN1_UTF8STRING:
      .             case V_ASN1_OTHER:
      .             case V_ASN1_SET:
      .             case V_ASN1_SEQUENCE:
      .             default:
  7,356 (0.0%)        if (utype == V_ASN1_BMPSTRING && (len & 1)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
      .                 goto err;
      .               }
  7,356 (0.0%)        if (utype == V_ASN1_UNIVERSALSTRING && (len & 3)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
      .                 goto err;
      .               }
  7,356 (0.0%)        if (utype == V_ASN1_UTCTIME) {
      .                 CBS cbs;
  3,480 (0.0%)          CBS_init(&cbs, cont, (size_t)len);
  4,060 (0.0%)          if (!CBS_parse_utc_time(&cbs, NULL, /*allow_timezone_offset=*/1)) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_TIME_FORMAT);
      .                   goto err;
      .                 }
      .               }
  7,356 (0.0%)        if (utype == V_ASN1_GENERALIZEDTIME) {
      .                 CBS cbs;
     24 (0.0%)          CBS_init(&cbs, cont, (size_t)len);
     28 (0.0%)          if (!CBS_parse_generalized_time(&cbs, NULL,
      .                                                 /*allow_timezone_offset=*/0)) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_TIME_FORMAT);
      .                   goto err;
      .                 }
      .               }
      .               // All based on ASN1_STRING and handled the same
 14,712 (0.0%)        if (!*pval) {
      .                 stmp = ASN1_STRING_type_new(utype);
      .                 if (!stmp) {
      .                   goto err;
      .                 }
      .                 *pval = (ASN1_VALUE *)stmp;
      .               } else {
 11,034 (0.0%)          stmp = (ASN1_STRING *)*pval;
 11,034 (0.0%)          stmp->type = utype;
      .               }
 29,424 (0.0%)        if (!ASN1_STRING_set(stmp, cont, len)) {
      .                 ASN1_STRING_free(stmp);
      .                 *pval = NULL;
      .                 goto err;
      .               }
  3,678 (0.0%)        break;
      .           }
      .           // If ASN1_ANY and NULL type fix up value
 21,608 (0.0%)    if (typ && (utype == V_ASN1_NULL)) {
  1,272 (0.0%)      typ->value.ptr = NULL;
      .           }
      .         
 20,176 (0.0%)    ret = 1;
      .         err:
 20,176 (0.0%)    if (!ret) {
      .             ASN1_TYPE_free(typ);
      .             if (opval) {
      .               *opval = NULL;
      .             }
      .           }
 10,088 (0.0%)    return ret;
 50,440 (0.0%)  }
      .         
      .         // Check an ASN1 tag and length: a bit like ASN1_get_object but it
      .         // checks the expected tag.
      .         
      .         static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,
      .                                    char *cst, const unsigned char **in, long len,
347,940 (0.1%)                             int exptag, int expclass, char opt) {
      .           int i;
      .           int ptag, pclass;
      .           long plen;
      .           const unsigned char *p;
 69,588 (0.0%)    p = *in;
      .         
208,764 (0.1%)    i = ASN1_get_object(&p, &plen, &ptag, &pclass, len);
 92,784 (0.0%)    if (i & 0x80) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_OBJECT_HEADER);
      .             return 0;
      .           }
 46,392 (0.0%)    if (exptag >= 0) {
115,746 (0.0%)      if ((exptag != ptag) || (expclass != pclass)) {
      .               // If type is OPTIONAL, not an error: indicate missing type.
  2,068 (0.0%)        if (opt) {
  2,068 (0.0%)          return -1;
      .               }
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TAG);
      .               return 0;
      .             }
      .           }
      .         
 44,324 (0.0%)    if (cst) {
 79,050 (0.0%)      *cst = i & V_ASN1_CONSTRUCTED;
      .           }
      .         
 44,324 (0.0%)    if (olen) {
 56,322 (0.0%)      *olen = plen;
      .           }
      .         
 44,324 (0.0%)    if (oclass) {
 13,552 (0.0%)      *oclass = pclass;
      .           }
      .         
 44,324 (0.0%)    if (otag) {
 10,164 (0.0%)      *otag = ptag;
      .           }
      .         
 66,486 (0.0%)    *in = p;
 22,162 (0.0%)    return 1;
115,980 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 78 ----------------------------------------
      .         static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
      .                                     int skcontlen, const ASN1_ITEM *item, int do_sort);
      .         static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
      .                                         const ASN1_TEMPLATE *tt, int tag, int aclass,
      .                                         int optional);
      .         
      .         // Top level i2d equivalents
      .         
  2,920 (0.0%)  int ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it) {
  1,752 (0.0%)    if (out && !*out) {
      .             unsigned char *p, *buf;
  2,336 (0.0%)      int len = ASN1_item_ex_i2d(&val, NULL, it, /*tag=*/-1, /*aclass=*/0);
    584 (0.0%)      if (len <= 0) {
      .               return len;
      .             }
  1,460 (0.0%)      buf = OPENSSL_malloc(len);
    584 (0.0%)      if (!buf) {
      .               return -1;
      .             }
    584 (0.0%)      p = buf;
  2,336 (0.0%)      int len2 = ASN1_item_ex_i2d(&val, &p, it, /*tag=*/-1, /*aclass=*/0);
    584 (0.0%)      if (len2 <= 0) {
      .               OPENSSL_free(buf);
      .               return len2;
      .             }
    876 (0.0%)      assert(len == len2);
    876 (0.0%)      *out = buf;
    584 (0.0%)      return len;
      .           }
      .         
      .           return ASN1_item_ex_i2d(&val, out, it, /*tag=*/-1, /*aclass=*/0);
  1,460 (0.0%)  }
      .         
      .         // Encode an item, taking care of IMPLICIT tagging (if any). This function
      .         // performs the normal item handling: it can be used in external types.
      .         
      .         int ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
 99,216 (0.0%)                       const ASN1_ITEM *it, int tag, int aclass) {
110,240 (0.0%)    int ret = asn1_item_ex_i2d_opt(pval, out, it, tag, aclass, /*optional=*/0);
 22,048 (0.0%)    assert(ret != 0);
 11,024 (0.0%)    return ret;
 22,048 (0.0%)  }
      .         
      .         // asn1_item_ex_i2d_opt behaves like |ASN1_item_ex_i2d| but, if |optional| is
      .         // non-zero and |*pval| is omitted, it returns zero and writes no bytes.
      .         int asn1_item_ex_i2d_opt(ASN1_VALUE **pval, unsigned char **out,
      .                                  const ASN1_ITEM *it, int tag, int aclass,
413,608 (0.1%)                           int optional) {
 31,816 (0.0%)    const ASN1_TEMPLATE *tt = NULL;
      .           int i, seqcontlen, seqlen;
      .         
      .           // Historically, |aclass| was repurposed to pass additional flags into the
      .           // encoding process.
127,264 (0.0%)    assert((aclass & ASN1_TFLG_TAG_CLASS) == aclass);
      .           // If not overridding the tag, |aclass| is ignored and should be zero.
127,264 (0.0%)    assert(tag != -1 || aclass == 0);
      .         
      .           // All fields are pointers, except for boolean |ASN1_ITYPE_PRIMITIVE|s.
      .           // Optional primitives are handled later.
191,568 (0.1%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) {
      .             if (optional) {
      .               return 0;
      .             }
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
      .             return -1;
      .           }
      .         
413,608 (0.1%)    switch (it->itype) {
      .             case ASN1_ITYPE_PRIMITIVE:
 62,960 (0.0%)        if (it->templates) {
      .                 // This is an |ASN1_ITEM_TEMPLATE|.
 25,056 (0.0%)          if (it->templates->flags & ASN1_TFLG_OPTIONAL) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                   return -1;
      .                 }
 50,112 (0.0%)          return asn1_template_ex_i2d(pval, out, it->templates, tag, aclass,
      .                                             optional);
      .               }
127,204 (0.0%)        return asn1_i2d_ex_primitive(pval, out, it, tag, aclass, optional);
      .         
      .             case ASN1_ITYPE_MSTRING:
      .               // It never makes sense for multi-strings to have implicit tagging, so
      .               // if tag != -1, then this looks like an error in the template.
 16,704 (0.0%)        if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 return -1;
      .               }
 83,520 (0.0%)        return asn1_i2d_ex_primitive(pval, out, it, -1, 0, optional);
      .         
      .             case ASN1_ITYPE_CHOICE: {
      .               // It never makes sense for CHOICE types to have implicit tagging, so if
      .               // tag != -1, then this looks like an error in the template.
      .               if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 return -1;
      .               }
-- line 173 ----------------------------------------
-- line 195 ----------------------------------------
      .                 // must be pointers.
      .                 OPENSSL_PUT_ERROR(ASN1, ERR_R_INTERNAL_ERROR);
      .                 return -1;
      .               }
      .               return ret;
      .             }
      .         
      .             case ASN1_ITYPE_SEQUENCE: {
 54,068 (0.0%)        i = asn1_enc_restore(&seqcontlen, out, pval, it);
      .               // An error occurred
 15,448 (0.0%)        if (i < 0) {
      .                 return -1;
      .               }
      .               // We have a valid cached encoding...
 15,448 (0.0%)        if (i > 0) {
      .                 return seqcontlen;
      .               }
      .               // Otherwise carry on
  7,724 (0.0%)        seqcontlen = 0;
      .               // If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL
 15,448 (0.0%)        if (tag == -1) {
  7,724 (0.0%)          tag = V_ASN1_SEQUENCE;
  7,724 (0.0%)          aclass = V_ASN1_UNIVERSAL;
      .               }
      .               // First work out sequence content length
208,548 (0.1%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
      .                 const ASN1_TEMPLATE *seqtt;
      .                 ASN1_VALUE **pseqval;
      .                 int tmplen;
108,136 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
 30,896 (0.0%)          if (!seqtt) {
      .                   return -1;
      .                 }
 92,688 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
      .                 tmplen =
139,032 (0.0%)              asn1_template_ex_i2d(pseqval, NULL, seqtt, -1, 0, /*optional=*/0);
108,136 (0.0%)          if (tmplen == -1 || (tmplen > INT_MAX - seqcontlen)) {
      .                   return -1;
      .                 }
 61,792 (0.0%)          seqcontlen += tmplen;
      .               }
      .         
 46,344 (0.0%)        seqlen = ASN1_object_size(/*constructed=*/1, seqcontlen, tag);
 20,792 (0.0%)        if (!out || seqlen == -1) {
 10,104 (0.0%)          return seqlen;
      .               }
      .               // Output SEQUENCE header
 21,376 (0.0%)        ASN1_put_object(out, /*constructed=*/1, seqcontlen, tag, aclass);
 72,144 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
      .                 const ASN1_TEMPLATE *seqtt;
      .                 ASN1_VALUE **pseqval;
 37,408 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
 10,688 (0.0%)          if (!seqtt) {
      .                   return -1;
      .                 }
 32,064 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
 53,440 (0.0%)          if (asn1_template_ex_i2d(pseqval, out, seqtt, -1, 0, /*optional=*/0) <
      .                     0) {
      .                   return -1;
      .                 }
      .               }
  5,344 (0.0%)        return seqlen;
      .             }
      .         
      .             default:
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .               return -1;
      .           }
159,080 (0.1%)  }
      .         
      .         // asn1_template_ex_i2d behaves like |asn1_item_ex_i2d_opt| but uses an
      .         // |ASN1_TEMPLATE| instead of an |ASN1_ITEM|. An |ASN1_TEMPLATE| wraps an
      .         // |ASN1_ITEM| with modifiers such as tagging, SEQUENCE or SET, etc.
      .         static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
      .                                         const ASN1_TEMPLATE *tt, int tag, int iclass,
324,584 (0.1%)                                  int optional) {
      .           int i, ret, ttag, tclass;
      .           size_t j;
 74,904 (0.0%)    uint32_t flags = tt->flags;
      .         
      .           // Historically, |iclass| was repurposed to pass additional flags into the
      .           // encoding process.
 99,872 (0.0%)    assert((iclass & ASN1_TFLG_TAG_CLASS) == iclass);
      .           // If not overridding the tag, |iclass| is ignored and should be zero.
 99,872 (0.0%)    assert(tag != -1 || iclass == 0);
      .         
      .           // Work out tag and class to use: tagging may come either from the
      .           // template or the arguments, not both because this would create
      .           // ambiguity.
 99,872 (0.0%)    if (flags & ASN1_TFLG_TAG_MASK) {
      .             // Error if argument and template tagging
      .             if (tag != -1) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .               return -1;
      .             }
      .             // Get tagging from template
      .             ttag = tt->tag;
      .             tclass = flags & ASN1_TFLG_TAG_CLASS;
 49,936 (0.0%)    } else if (tag != -1) {
      .             // No template tagging, get from arguments
      .             ttag = tag;
      .             tclass = iclass & ASN1_TFLG_TAG_CLASS;
      .           } else {
 24,968 (0.0%)      ttag = -1;
 24,968 (0.0%)      tclass = 0;
      .           }
      .         
      .           // The template may itself by marked as optional, or this may be the template
      .           // of an |ASN1_ITEM_TEMPLATE| type which was contained inside an outer
      .           // optional template. (They cannot both be true because the
      .           // |ASN1_ITEM_TEMPLATE| codepath rejects optional templates.)
 49,936 (0.0%)    assert(!optional || (flags & ASN1_TFLG_OPTIONAL) == 0);
200,912 (0.1%)    optional = optional || (flags & ASN1_TFLG_OPTIONAL) != 0;
      .         
      .           // At this point 'ttag' contains the outer tag to use, and 'tclass' is the
      .           // class.
      .         
 99,872 (0.0%)    if (flags & ASN1_TFLG_SK_MASK) {
      .             // SET OF, SEQUENCE OF
 12,528 (0.0%)      STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;
      .             int isset, sktag, skaclass;
      .             int skcontlen, sklen;
      .             ASN1_VALUE *skitem;
      .         
 16,704 (0.0%)      if (!*pval) {
      .               if (optional) {
      .                 return 0;
      .               }
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
      .               return -1;
      .             }
      .         
 16,704 (0.0%)      if (flags & ASN1_TFLG_SET_OF) {
  4,176 (0.0%)        isset = 1;
      .               // Historically, types with both bits set were mutated when
      .               // serialized to apply the sort. We no longer support this.
 16,704 (0.0%)        assert((flags & ASN1_TFLG_SEQUENCE_OF) == 0);
      .             } else {
      .               isset = 0;
      .             }
      .         
      .             // Work out inner tag value: if EXPLICIT or no tagging use underlying
      .             // type.
  8,352 (0.0%)      if ((ttag != -1) && !(flags & ASN1_TFLG_EXPTAG)) {
      .               sktag = ttag;
      .               skaclass = tclass;
      .             } else {
  4,176 (0.0%)        skaclass = V_ASN1_UNIVERSAL;
  8,352 (0.0%)        if (isset) {
  8,352 (0.0%)          sktag = V_ASN1_SET;
      .               } else {
      .                 sktag = V_ASN1_SEQUENCE;
      .               }
      .             }
      .         
      .             // Determine total length of items
  4,176 (0.0%)      skcontlen = 0;
 54,288 (0.0%)      for (j = 0; j < sk_ASN1_VALUE_num(sk); j++) {
      .               int tmplen;
 25,056 (0.0%)        skitem = sk_ASN1_VALUE_value(sk, j);
 37,584 (0.0%)        tmplen = ASN1_item_ex_i2d(&skitem, NULL, ASN1_ITEM_ptr(tt->item), -1, 0);
 25,056 (0.0%)        if (tmplen == -1 || (skcontlen > INT_MAX - tmplen)) {
      .                 return -1;
      .               }
  8,352 (0.0%)        skcontlen += tmplen;
      .             }
 25,056 (0.0%)      sklen = ASN1_object_size(/*constructed=*/1, skcontlen, sktag);
  8,352 (0.0%)      if (sklen == -1) {
      .               return -1;
      .             }
      .             // If EXPLICIT need length of surrounding tag
 16,704 (0.0%)      if (flags & ASN1_TFLG_EXPTAG) {
      .               ret = ASN1_object_size(/*constructed=*/1, sklen, ttag);
      .             } else {
  8,352 (0.0%)        ret = sklen;
      .             }
      .         
 12,528 (0.0%)      if (!out || ret == -1) {
  4,176 (0.0%)        return ret;
      .             }
      .         
      .             // Now encode this lot...
      .             // EXPLICIT tag
  8,352 (0.0%)      if (flags & ASN1_TFLG_EXPTAG) {
      .               ASN1_put_object(out, /*constructed=*/1, sklen, ttag, tclass);
      .             }
      .             // SET or SEQUENCE and IMPLICIT tag
 16,704 (0.0%)      ASN1_put_object(out, /*constructed=*/1, skcontlen, sktag, skaclass);
      .             // And the stuff itself
 22,968 (0.0%)      if (!asn1_set_seq_out(sk, out, skcontlen, ASN1_ITEM_ptr(tt->item), isset)) {
      .               return -1;
      .             }
  4,176 (0.0%)      return ret;
      .           }
      .         
 83,168 (0.0%)    if (flags & ASN1_TFLG_EXPTAG) {
      .             // EXPLICIT tagging
      .             // Find length of tagged item
      .             i = asn1_item_ex_i2d_opt(pval, NULL, ASN1_ITEM_ptr(tt->item), -1, 0,
      .                                      optional);
      .             if (i <= 0) {
      .               return i;
      .             }
      .             // Find length of EXPLICIT tag
-- line 398 ----------------------------------------
-- line 403 ----------------------------------------
      .               if (ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item), -1, 0) < 0) {
      .                 return -1;
      .               }
      .             }
      .             return ret;
      .           }
      .         
      .           // Either normal or IMPLICIT tagging
228,712 (0.1%)    return asn1_item_ex_i2d_opt(pval, out, ASN1_ITEM_ptr(tt->item), ttag, tclass,
      .                                       optional);
124,840 (0.0%)  }
      .         
      .         // Temporary structure used to hold DER encoding of items for SET OF
      .         
      .         typedef struct {
      .           unsigned char *data;
      .           int length;
      .         } DER_ENC;
      .         
-- line 421 ----------------------------------------
-- line 431 ----------------------------------------
      .         }
      .         
      .         // asn1_set_seq_out writes |sk| to |out| under the i2d output convention,
      .         // excluding the tag and length. It returns one on success and zero on error.
      .         // |skcontlen| must be the total encoded size. If |do_sort| is non-zero, the
      .         // elements are sorted for a SET OF type. Each element of |sk| has type
      .         // |item|.
      .         static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
 27,144 (0.0%)                              int skcontlen, const ASN1_ITEM *item, int do_sort) {
      .           // No need to sort if there are fewer than two items.
 14,616 (0.0%)    if (!do_sort || sk_ASN1_VALUE_num(sk) < 2) {
 27,144 (0.0%)      for (size_t i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
 12,528 (0.0%)        ASN1_VALUE *skitem = sk_ASN1_VALUE_value(sk, i);
 18,792 (0.0%)        if (ASN1_item_ex_i2d(&skitem, out, item, -1, 0) < 0) {
      .                 return 0;
      .               }
      .             }
  4,176 (0.0%)      return 1;
      .           }
      .         
      .           int ret = 0;
      .           unsigned char *const buf = OPENSSL_malloc(skcontlen);
      .           DER_ENC *encoded = OPENSSL_calloc(sk_ASN1_VALUE_num(sk), sizeof(*encoded));
      .           if (encoded == NULL || buf == NULL) {
      .             goto err;
      .           }
-- line 456 ----------------------------------------
-- line 478 ----------------------------------------
      .           *out = p;
      .         
      .           ret = 1;
      .         
      .         err:
      .           OPENSSL_free(encoded);
      .           OPENSSL_free(buf);
      .           return ret;
 12,528 (0.0%)  }
      .         
      .         // asn1_i2d_ex_primitive behaves like |ASN1_item_ex_i2d| but |item| must be a
      .         // a PRIMITIVE or MSTRING type that is not an |ASN1_ITEM_TEMPLATE|.
      .         static int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out,
      .                                          const ASN1_ITEM *it, int tag, int aclass,
258,908 (0.1%)                                   int optional) {
      .           // Get length of content octets and maybe find out the underlying type.
      .           int omit;
 59,748 (0.0%)    int utype = it->utype;
179,244 (0.1%)    int len = asn1_ex_i2c(pval, NULL, &omit, &utype, it);
 39,832 (0.0%)    if (len < 0) {
      .             return -1;
      .           }
 59,748 (0.0%)    if (omit) {
      .             if (optional) {
      .               return 0;
      .             }
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
      .             return -1;
      .           }
      .         
      .           // If SEQUENCE, SET or OTHER then header is included in pseudo content
      .           // octets so don't include tag+length. We need to check here because the
      .           // call to asn1_ex_i2c() could change utype.
 19,916 (0.0%)    int usetag =
219,076 (0.1%)        utype != V_ASN1_SEQUENCE && utype != V_ASN1_SET && utype != V_ASN1_OTHER;
      .         
      .           // If not implicitly tagged get tag from underlying type
 39,832 (0.0%)    if (tag == -1) {
 39,832 (0.0%)      tag = utype;
      .           }
      .         
      .           // Output tag+length followed by content octets
 39,832 (0.0%)    if (out) {
 10,104 (0.0%)      if (usetag) {
 40,416 (0.0%)        ASN1_put_object(out, /*constructed=*/0, len, tag, aclass);
      .             }
 50,520 (0.0%)      int len2 = asn1_ex_i2c(pval, *out, &omit, &utype, it);
 10,104 (0.0%)      if (len2 < 0) {
      .               return -1;
      .             }
 15,156 (0.0%)      assert(len == len2);
 15,156 (0.0%)      assert(!omit);
 35,364 (0.0%)      *out += len;
      .           }
      .         
 39,832 (0.0%)    if (usetag) {
119,496 (0.0%)      return ASN1_object_size(/*constructed=*/0, len, tag);
      .           }
      .           return len;
 99,580 (0.0%)  }
      .         
      .         // asn1_ex_i2c writes the |*pval| to |cout| under the i2d output convention,
      .         // excluding the tag and length. It returns the number of bytes written,
      .         // possibly zero, on success or -1 on error. If |*pval| should be omitted, it
      .         // returns zero and sets |*out_omit| to true.
      .         //
      .         // If |it| is an MSTRING or ANY type, it gets the underlying type from |*pval|,
      .         // which must be an |ASN1_STRING| or |ASN1_TYPE|, respectively. It then updates
-- line 545 ----------------------------------------
-- line 548 ----------------------------------------
      .         // |V_ASN1_OTHER|, it additionally outputs the tag and length, so the caller
      .         // must not do so.
      .         //
      .         // Otherwise, |*putype| must contain |it->utype|.
      .         //
      .         // WARNING: Unlike most functions in this file, |asn1_ex_i2c| can return zero
      .         // without omitting the element. ASN.1 values may have empty contents.
      .         static int asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cout, int *out_omit,
299,616 (0.1%)                         int *putype, const ASN1_ITEM *it) {
 24,968 (0.0%)    ASN1_BOOLEAN *tbool = NULL;
      .           ASN1_STRING *strtmp;
      .           ASN1_OBJECT *otmp;
      .           int utype;
      .           const unsigned char *cont;
      .           unsigned char c;
      .           int len;
      .         
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of callbacks.
 99,872 (0.0%)    assert(it->funcs == NULL);
      .         
 49,936 (0.0%)    *out_omit = 0;
      .         
      .           // Should type be omitted?
157,984 (0.1%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) || (it->utype != V_ASN1_BOOLEAN)) {
 99,872 (0.0%)      if (!*pval) {
      .               *out_omit = 1;
      .               return 0;
      .             }
      .           }
      .         
 99,872 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
      .             // If MSTRING type set the underlying type
 31,320 (0.0%)      strtmp = (ASN1_STRING *)*pval;
 31,320 (0.0%)      utype = strtmp->type;
 20,880 (0.0%)      if (utype < 0 && utype != V_ASN1_OTHER) {
      .               // MSTRINGs can have type -1 when default-constructed.
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TYPE);
      .               return -1;
      .             }
      .             // Negative INTEGER and ENUMERATED values use |ASN1_STRING| type values
      .             // that do not match their corresponding utype values. INTEGERs cannot
      .             // participate in MSTRING types, but ENUMERATEDs can.
      .             //
      .             // TODO(davidben): Is this a bug? Although arguably one of the MSTRING
      .             // types should contain more values, rather than less. See
      .             // https://crbug.com/boringssl/412. But it is not possible to fit all
      .             // possible ANY values into an |ASN1_STRING|, so matching the spec here
      .             // is somewhat hopeless.
 20,880 (0.0%)      if (utype == V_ASN1_NEG_INTEGER) {
      .               utype = V_ASN1_INTEGER;
 20,880 (0.0%)      } else if (utype == V_ASN1_NEG_ENUMERATED) {
      .               utype = V_ASN1_ENUMERATED;
      .             }
 41,760 (0.0%)      *putype = utype;
 58,112 (0.0%)    } else if (it->utype == V_ASN1_ANY) {
      .             // If ANY set type and pointer to value
      .             ASN1_TYPE *typ;
  4,380 (0.0%)      typ = (ASN1_TYPE *)*pval;
  4,380 (0.0%)      utype = typ->type;
  2,920 (0.0%)      if (utype < 0 && utype != V_ASN1_OTHER) {
      .               // |ASN1_TYPE|s can have type -1 when default-constructed.
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TYPE);
      .               return -1;
      .             }
  4,380 (0.0%)      *putype = utype;
  5,840 (0.0%)      pval = &typ->value.asn1_value;
      .           } else {
 39,204 (0.0%)      utype = *putype;
      .           }
      .         
166,160 (0.1%)    switch (utype) {
      .             case V_ASN1_OBJECT:
 36,900 (0.0%)        otmp = (ASN1_OBJECT *)*pval;
 36,900 (0.0%)        cont = otmp->data;
 36,900 (0.0%)        len = otmp->length;
 24,600 (0.0%)        if (len == 0) {
      .                 // Some |ASN1_OBJECT|s do not have OIDs and cannot be serialized.
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OBJECT);
      .                 return -1;
      .               }
 12,300 (0.0%)        break;
      .         
      .             case V_ASN1_NULL:
  1,060 (0.0%)        cont = NULL;
  1,060 (0.0%)        len = 0;
  1,060 (0.0%)        break;
      .         
      .             case V_ASN1_BOOLEAN:
      .               tbool = (ASN1_BOOLEAN *)pval;
      .               if (*tbool == ASN1_BOOLEAN_NONE) {
      .                 *out_omit = 1;
      .                 return 0;
      .               }
      .               if (it->utype != V_ASN1_ANY) {
-- line 642 ----------------------------------------
-- line 648 ----------------------------------------
      .               }
      .               c = *tbool ? 0xff : 0x00;
      .               cont = &c;
      .               len = 1;
      .               break;
      .         
      .             case V_ASN1_BIT_STRING: {
      .               int ret =
 11,972 (0.0%)            i2c_ASN1_BIT_STRING((ASN1_BIT_STRING *)*pval, cout ? &cout : NULL);
      .               // |i2c_ASN1_BIT_STRING| returns zero on error instead of -1.
  4,672 (0.0%)        return ret <= 0 ? -1 : ret;
      .             }
      .         
      .             case V_ASN1_INTEGER:
      .             case V_ASN1_ENUMERATED: {
      .               // |i2c_ASN1_INTEGER| also handles ENUMERATED.
      .               int ret = i2c_ASN1_INTEGER((ASN1_INTEGER *)*pval, cout ? &cout : NULL);
      .               // |i2c_ASN1_INTEGER| returns zero on error instead of -1.
      .               return ret <= 0 ? -1 : ret;
-- line 666 ----------------------------------------
-- line 679 ----------------------------------------
      .             case V_ASN1_GENERALSTRING:
      .             case V_ASN1_UNIVERSALSTRING:
      .             case V_ASN1_BMPSTRING:
      .             case V_ASN1_UTF8STRING:
      .             case V_ASN1_SEQUENCE:
      .             case V_ASN1_SET:
      .             default:
      .               // All based on ASN1_STRING and handled the same
 31,320 (0.0%)        strtmp = (ASN1_STRING *)*pval;
 31,320 (0.0%)        cont = strtmp->data;
 31,320 (0.0%)        len = strtmp->length;
      .         
 10,440 (0.0%)        break;
      .           }
 80,920 (0.0%)    if (cout && len) {
 31,836 (0.0%)      OPENSSL_memcpy(cout, cont, len);
      .           }
 23,800 (0.0%)    return len;
124,840 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 60 ----------------------------------------
      .         
      .         #include <openssl/asn1t.h>
      .         #include <openssl/mem.h>
      .         
      .         #include "internal.h"
      .         
      .         // Free up an ASN1 structure
      .         
 27,552 (0.0%)  void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it) {
 27,552 (0.0%)    asn1_item_combine_free(&val, it, 0);
 13,776 (0.0%)  }
      .         
  3,018 (0.0%)  void ASN1_item_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
  3,018 (0.0%)    asn1_item_combine_free(pval, it, 0);
  1,509 (0.0%)  }
      .         
      .         void asn1_item_combine_free(ASN1_VALUE **pval, const ASN1_ITEM *it,
120,918 (0.0%)                              int combine) {
 17,274 (0.0%)    const ASN1_TEMPLATE *tt = NULL, *seqtt;
      .           const ASN1_EXTERN_FUNCS *ef;
      .           int i;
 69,096 (0.0%)    if (pval == NULL || it == NULL) {
      .             return;
      .           }
106,676 (0.0%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) {
  1,460 (0.0%)      return;
      .           }
      .         
215,072 (0.1%)    switch (it->itype) {
      .             case ASN1_ITYPE_PRIMITIVE:
 31,516 (0.0%)        if (it->templates) {
  1,752 (0.0%)          ASN1_template_free(pval, it->templates);
      .               } else {
 37,935 (0.0%)          ASN1_primitive_free(pval, it);
      .               }
  7,879 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_MSTRING:
 17,120 (0.0%)        ASN1_primitive_free(pval, it);
  3,424 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_CHOICE: {
      .               const ASN1_AUX *aux = it->funcs;
      .               ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
      .               if (asn1_cb) {
      .                 i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
      .                 if (i == 2) {
      .                   return;
-- line 107 ----------------------------------------
-- line 120 ----------------------------------------
      .               if (!combine) {
      .                 OPENSSL_free(*pval);
      .                 *pval = NULL;
      .               }
      .               break;
      .             }
      .         
      .             case ASN1_ITYPE_EXTERN:
    876 (0.0%)        ef = it->funcs;
  1,752 (0.0%)        if (ef && ef->asn1_ex_free) {
  2,044 (0.0%)          ef->asn1_ex_free(pval, it);
      .               }
    876 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_SEQUENCE: {
 34,643 (0.0%)        if (!asn1_refcount_dec_and_test_zero(pval, it)) {
    584 (0.0%)          return;
      .               }
 13,971 (0.0%)        const ASN1_AUX *aux = it->funcs;
 19,504 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
  9,314 (0.0%)        if (asn1_cb) {
  2,336 (0.0%)          i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
    584 (0.0%)          if (i == 2) {
      .                   return;
      .                 }
      .               }
 23,285 (0.0%)        asn1_enc_free(pval, it);
      .               // If we free up as normal we will invalidate any ANY DEFINED BY
      .               // field and we wont be able to determine the type of the field it
      .               // defines. So free up in reverse order.
 37,256 (0.0%)        tt = it->templates + it->tcount - 1;
126,304 (0.0%)        for (i = 0; i < it->tcount; tt--, i++) {
      .                 ASN1_VALUE **pseqval;
 77,917 (0.0%)          seqtt = asn1_do_adb(pval, tt, 0);
 22,262 (0.0%)          if (!seqtt) {
      .                   continue;
      .                 }
 66,786 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
 66,786 (0.0%)          ASN1_template_free(pseqval, seqtt);
      .               }
  9,314 (0.0%)        if (asn1_cb) {
  2,044 (0.0%)          asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);
      .               }
  9,314 (0.0%)        if (!combine) {
 18,628 (0.0%)          OPENSSL_free(*pval);
  9,314 (0.0%)          *pval = NULL;
      .               }
  9,314 (0.0%)        break;
      .             }
      .           }
 34,548 (0.0%)  }
      .         
113,553 (0.0%)  void ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
 63,085 (0.0%)    if (tt->flags & ASN1_TFLG_SK_MASK) {
  1,314 (0.0%)      STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;
  6,084 (0.0%)      for (size_t i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
  3,018 (0.0%)        ASN1_VALUE *vtmp = sk_ASN1_VALUE_value(sk, i);
  3,018 (0.0%)        ASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item));
      .             }
  1,314 (0.0%)      sk_ASN1_VALUE_free(sk);
    876 (0.0%)      *pval = NULL;
      .           } else {
 97,432 (0.0%)      asn1_item_combine_free(pval, ASN1_ITEM_ptr(tt->item),
 24,358 (0.0%)                             tt->flags & ASN1_TFLG_COMBINE);
      .           }
 76,140 (0.0%)  }
      .         
 66,066 (0.0%)  void ASN1_primitive_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of calbacks.
 44,044 (0.0%)    assert(it->funcs == NULL);
      .         
 81,240 (0.0%)    int utype = it->itype == ASN1_ITYPE_MSTRING ? -1 : it->utype;
 95,593 (0.0%)    switch (utype) {
      .             case V_ASN1_OBJECT:
 16,292 (0.0%)        ASN1_OBJECT_free((ASN1_OBJECT *)*pval);
  4,073 (0.0%)        break;
      .         
      .             case V_ASN1_BOOLEAN:
  1,906 (0.0%)        if (it) {
  4,765 (0.0%)          *(ASN1_BOOLEAN *)pval = (ASN1_BOOLEAN)it->size;
      .               } else {
      .                 *(ASN1_BOOLEAN *)pval = ASN1_BOOLEAN_NONE;
      .               }
    953 (0.0%)        return;
      .         
      .             case V_ASN1_NULL:
      .               break;
      .         
      .             case V_ASN1_ANY:
  2,392 (0.0%)        if (*pval != NULL) {
  1,432 (0.0%)          asn1_type_cleanup((ASN1_TYPE *)*pval);
  1,432 (0.0%)          OPENSSL_free(*pval);
      .               }
    956 (0.0%)        break;
      .         
      .             default:
 21,548 (0.0%)        ASN1_STRING_free((ASN1_STRING *)*pval);
 10,774 (0.0%)        *pval = NULL;
  5,387 (0.0%)        break;
      .           }
 20,116 (0.0%)    *pval = NULL;
 22,022 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 70 ----------------------------------------
      .         static int asn1_item_ex_combine_new(ASN1_VALUE **pval, const ASN1_ITEM *it,
      .                                             int combine);
      .         static void asn1_item_clear(ASN1_VALUE **pval, const ASN1_ITEM *it);
      .         static int ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);
      .         static void asn1_template_clear(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);
      .         static int ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it);
      .         static void asn1_primitive_clear(ASN1_VALUE **pval, const ASN1_ITEM *it);
      .         
 22,432 (0.0%)  ASN1_VALUE *ASN1_item_new(const ASN1_ITEM *it) {
  2,804 (0.0%)    ASN1_VALUE *ret = NULL;
 19,628 (0.0%)    if (ASN1_item_ex_new(&ret, it) > 0) {
  5,608 (0.0%)      return ret;
      .           }
      .           return NULL;
 14,020 (0.0%)  }
      .         
      .         // Allocate an ASN1 structure
      .         
 37,140 (0.0%)  int ASN1_item_ex_new(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 37,140 (0.0%)    return asn1_item_ex_combine_new(pval, it, 0);
 12,380 (0.0%)  }
      .         
      .         static int asn1_item_ex_combine_new(ASN1_VALUE **pval, const ASN1_ITEM *it,
148,582 (0.1%)                                      int combine) {
 21,226 (0.0%)    const ASN1_TEMPLATE *tt = NULL;
      .           const ASN1_EXTERN_FUNCS *ef;
      .           ASN1_VALUE **pseqval;
      .           int i;
      .         
275,938 (0.1%)    switch (it->itype) {
      .             case ASN1_ITYPE_EXTERN:
  1,752 (0.0%)        ef = it->funcs;
  3,504 (0.0%)        if (ef && ef->asn1_ex_new) {
  5,256 (0.0%)          if (!ef->asn1_ex_new(pval, it)) {
      .                   goto memerr;
      .                 }
      .               }
  1,168 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_PRIMITIVE:
 34,624 (0.0%)        if (it->templates) {
      .                 if (!ASN1_template_new(pval, it->templates)) {
      .                   goto memerr;
      .                 }
 60,592 (0.0%)        } else if (!ASN1_primitive_new(pval, it)) {
      .                 goto memerr;
      .               }
 17,312 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_MSTRING:
 33,320 (0.0%)        if (!ASN1_primitive_new(pval, it)) {
      .                 goto memerr;
      .               }
  9,520 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_CHOICE: {
      .               const ASN1_AUX *aux = it->funcs;
      .               ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
      .               if (asn1_cb) {
      .                 i = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);
      .                 if (!i) {
      .                   goto auxerr;
-- line 131 ----------------------------------------
-- line 143 ----------------------------------------
      .               asn1_set_choice_selector(pval, -1, it);
      .               if (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL)) {
      .                 goto auxerr2;
      .               }
      .               break;
      .             }
      .         
      .             case ASN1_ITYPE_SEQUENCE: {
 21,678 (0.0%)        const ASN1_AUX *aux = it->funcs;
 30,656 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
 14,452 (0.0%)        if (asn1_cb) {
  4,672 (0.0%)          i = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);
  1,168 (0.0%)          if (!i) {
      .                   goto auxerr;
      .                 }
  1,168 (0.0%)          if (i == 2) {
      .                   return 1;
      .                 }
      .               }
 14,452 (0.0%)        if (!combine) {
 43,356 (0.0%)          *pval = OPENSSL_zalloc(it->size);
 28,904 (0.0%)          if (!*pval) {
      .                   goto memerr;
      .                 }
 36,130 (0.0%)          asn1_refcount_set_one(pval, it);
 36,130 (0.0%)          asn1_enc_init(pval, it);
      .               }
224,174 (0.1%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
108,516 (0.0%)          pseqval = asn1_get_field_ptr(pval, tt);
126,602 (0.0%)          if (!ASN1_template_new(pseqval, tt)) {
      .                   goto memerr2;
      .                 }
      .               }
 19,708 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL)) {
      .                 goto auxerr2;
      .               }
  7,810 (0.0%)        break;
      .             }
      .           }
 42,452 (0.0%)    return 1;
      .         
      .         memerr2:
      .           asn1_item_combine_free(pval, it, combine);
      .         memerr:
      .           return 0;
      .         
      .         auxerr2:
      .           asn1_item_combine_free(pval, it, combine);
      .         auxerr:
      .           OPENSSL_PUT_ERROR(ASN1, ASN1_R_AUX_ERROR);
      .           return 0;
 42,452 (0.0%)  }
      .         
 16,548 (0.0%)  static void asn1_item_clear(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 35,854 (0.0%)    switch (it->itype) {
      .             case ASN1_ITYPE_EXTERN:
      .               *pval = NULL;
      .               break;
      .         
      .             case ASN1_ITYPE_PRIMITIVE:
 11,032 (0.0%)        if (it->templates) {
      .                 asn1_template_clear(pval, it->templates);
      .               } else {
 13,790 (0.0%)          asn1_primitive_clear(pval, it);
      .               }
  2,758 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_MSTRING:
      .               asn1_primitive_clear(pval, it);
      .               break;
      .         
      .             case ASN1_ITYPE_CHOICE:
      .             case ASN1_ITYPE_SEQUENCE:
      .               *pval = NULL;
      .               break;
      .           }
  8,274 (0.0%)  }
      .         
108,516 (0.0%)  static int ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
 54,258 (0.0%)    const ASN1_ITEM *it = ASN1_ITEM_ptr(tt->item);
      .           int ret;
 90,430 (0.0%)    if (tt->flags & ASN1_TFLG_OPTIONAL) {
 15,250 (0.0%)      asn1_template_clear(pval, tt);
  6,100 (0.0%)      return 1;
      .           }
      .           // If ANY DEFINED BY nothing to do
      .         
 75,180 (0.0%)    if (tt->flags & ASN1_TFLG_ADB_MASK) {
      .             *pval = NULL;
      .             return 1;
      .           }
      .           // If SET OF or SEQUENCE OF, its a STACK
 75,180 (0.0%)    if (tt->flags & ASN1_TFLG_SK_MASK) {
      .             STACK_OF(ASN1_VALUE) *skval;
      .             skval = sk_ASN1_VALUE_new_null();
      .             if (!skval) {
      .               ret = 0;
      .               goto done;
      .             }
      .             *pval = (ASN1_VALUE *)skval;
      .             ret = 1;
      .             goto done;
      .           }
      .           // Otherwise pass it back to the item routine
150,360 (0.1%)    ret = asn1_item_ex_combine_new(pval, it, tt->flags & ASN1_TFLG_COMBINE);
      .         done:
 15,036 (0.0%)    return ret;
 36,172 (0.0%)  }
      .         
 18,300 (0.0%)  static void asn1_template_clear(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
      .           // If ADB or STACK just NULL the field
 15,250 (0.0%)    if (tt->flags & (ASN1_TFLG_ADB_MASK | ASN1_TFLG_SK_MASK)) {
    584 (0.0%)      *pval = NULL;
      .           } else {
 16,548 (0.0%)      asn1_item_clear(pval, ASN1_ITEM_ptr(tt->item));
      .           }
  9,442 (0.0%)  }
      .         
      .         // NB: could probably combine most of the real XXX_new() behaviour and junk
      .         // all the old functions.
      .         
 80,496 (0.0%)  static int ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 26,832 (0.0%)    if (!it) {
      .             return 0;
      .           }
      .         
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of calbacks.
 53,664 (0.0%)    assert(it->funcs == NULL);
      .         
      .           int utype;
 53,664 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
  9,520 (0.0%)      utype = -1;
      .           } else {
 25,968 (0.0%)      utype = it->utype;
      .           }
105,622 (0.0%)    switch (utype) {
      .             case V_ASN1_OBJECT:
 18,174 (0.0%)        *pval = (ASN1_VALUE *)OBJ_get_undef();
 12,116 (0.0%)        return 1;
      .         
      .             case V_ASN1_BOOLEAN:
      .               *(ASN1_BOOLEAN *)pval = (ASN1_BOOLEAN)it->size;
      .               return 1;
      .         
      .             case V_ASN1_NULL:
      .               *pval = (ASN1_VALUE *)1;
      .               return 1;
      .         
      .             case V_ASN1_ANY: {
  2,148 (0.0%)        ASN1_TYPE *typ = OPENSSL_zalloc(sizeof(ASN1_TYPE));
  1,432 (0.0%)        if (!typ) {
      .                 return 0;
      .               }
  1,432 (0.0%)        typ->type = -1;
  2,148 (0.0%)        *pval = (ASN1_VALUE *)typ;
    716 (0.0%)        break;
      .             }
      .         
      .             default:
 33,210 (0.0%)        *pval = (ASN1_VALUE *)ASN1_STRING_type_new(utype);
  6,642 (0.0%)        break;
      .           }
 29,432 (0.0%)    if (*pval) {
 14,716 (0.0%)      return 1;
      .           }
      .           return 0;
 26,832 (0.0%)  }
      .         
 16,548 (0.0%)  static void asn1_primitive_clear(ASN1_VALUE **pval, const ASN1_ITEM *it) {
      .           int utype;
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of calbacks.
 16,548 (0.0%)    assert(it == NULL || it->funcs == NULL);
 16,548 (0.0%)    if (!it || (it->itype == ASN1_ITYPE_MSTRING)) {
      .             utype = -1;
      .           } else {
  8,274 (0.0%)      utype = it->utype;
      .           }
  5,516 (0.0%)    if (utype == V_ASN1_BOOLEAN) {
  5,030 (0.0%)      *(ASN1_BOOLEAN *)pval = (ASN1_BOOLEAN)it->size;
      .           } else {
  3,504 (0.0%)      *pval = NULL;
      .           }
  9,280 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 86 ----------------------------------------
      .           int *sel, ret;
      .           sel = offset2ptr(*pval, it->utype);
      .           ret = *sel;
      .           *sel = value;
      .           return ret;
      .         }
      .         
      .         static CRYPTO_refcount_t *asn1_get_references(ASN1_VALUE **pval,
 60,875 (0.0%)                                                const ASN1_ITEM *it) {
 48,700 (0.0%)    if (it->itype != ASN1_ITYPE_SEQUENCE) {
      .             return NULL;
      .           }
 36,525 (0.0%)    const ASN1_AUX *aux = it->funcs;
 32,380 (0.0%)    if (!aux || !(aux->flags & ASN1_AFLG_REFCOUNT)) {
 22,890 (0.0%)      return NULL;
      .           }
  4,380 (0.0%)    return offset2ptr(*pval, aux->ref_offset);
 24,350 (0.0%)  }
      .         
 43,356 (0.0%)  void asn1_refcount_set_one(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 43,356 (0.0%)    CRYPTO_refcount_t *references = asn1_get_references(pval, it);
 14,452 (0.0%)    if (references != NULL) {
    584 (0.0%)      *references = 1;
      .           }
 21,678 (0.0%)  }
      .         
 29,694 (0.0%)  int asn1_refcount_dec_and_test_zero(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 29,694 (0.0%)    CRYPTO_refcount_t *references = asn1_get_references(pval, it);
  9,898 (0.0%)    if (references != NULL) {
  1,752 (0.0%)      return CRYPTO_refcount_dec_and_test_zero(references);
      .           }
  4,511 (0.0%)    return 1;
  9,898 (0.0%)  }
      .         
148,470 (0.1%)  static ASN1_ENCODING *asn1_get_enc_ptr(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 98,980 (0.0%)    assert(it->itype == ASN1_ITYPE_SEQUENCE);
      .           const ASN1_AUX *aux;
148,470 (0.1%)    if (!pval || !*pval) {
      .             return NULL;
      .           }
 74,235 (0.0%)    aux = it->funcs;
 63,360 (0.0%)    if (!aux || !(aux->flags & ASN1_AFLG_ENCODING)) {
 48,030 (0.0%)      return NULL;
      .           }
  4,380 (0.0%)    return offset2ptr(*pval, aux->enc_offset);
 49,490 (0.0%)  }
      .         
 43,356 (0.0%)  void asn1_enc_init(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 43,356 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
 14,452 (0.0%)    if (enc) {
    584 (0.0%)      enc->enc = NULL;
    584 (0.0%)      enc->len = 0;
  1,168 (0.0%)      enc->alias_only = 0;
  1,168 (0.0%)      enc->alias_only_on_next_parse = 0;
      .           }
 21,678 (0.0%)  }
      .         
 27,942 (0.0%)  void asn1_enc_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 27,942 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
  9,314 (0.0%)    if (enc) {
    438 (0.0%)      asn1_encoding_clear(enc);
      .           }
 13,971 (0.0%)  }
      .         
      .         int asn1_enc_save(ASN1_VALUE **pval, const unsigned char *in, int inlen,
 41,104 (0.0%)                    const ASN1_ITEM *it) {
      .           ASN1_ENCODING *enc;
 30,828 (0.0%)    enc = asn1_get_enc_ptr(pval, it);
 10,276 (0.0%)    if (!enc) {
  9,692 (0.0%)      return 1;
      .           }
      .         
  1,460 (0.0%)    if (!enc->alias_only) {
  1,168 (0.0%)      OPENSSL_free(enc->enc);
      .           }
      .         
  3,212 (0.0%)    enc->alias_only = enc->alias_only_on_next_parse;
  1,168 (0.0%)    enc->alias_only_on_next_parse = 0;
      .         
  1,460 (0.0%)    if (enc->alias_only) {
      .             enc->enc = (uint8_t *)in;
      .           } else {
  2,336 (0.0%)      enc->enc = OPENSSL_memdup(in, inlen);
  1,168 (0.0%)      if (!enc->enc) {
      .               return 0;
      .             }
      .           }
      .         
  1,168 (0.0%)    enc->len = inlen;
    292 (0.0%)    return 1;
 10,276 (0.0%)  }
      .         
    730 (0.0%)  void asn1_encoding_clear(ASN1_ENCODING *enc) {
    730 (0.0%)    if (!enc->alias_only) {
    584 (0.0%)      OPENSSL_free(enc->enc);
      .           }
    292 (0.0%)    enc->enc = NULL;
    292 (0.0%)    enc->len = 0;
    584 (0.0%)    enc->alias_only = 0;
    584 (0.0%)    enc->alias_only_on_next_parse = 0;
    438 (0.0%)  }
      .         
      .         int asn1_enc_restore(int *len, unsigned char **out, ASN1_VALUE **pval,
 61,792 (0.0%)                       const ASN1_ITEM *it) {
 46,344 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
 15,448 (0.0%)    if (!enc || enc->len == 0) {
 15,448 (0.0%)      return 0;
      .           }
      .           if (out) {
      .             OPENSSL_memcpy(*out, enc->enc, enc->len);
      .             *out += enc->len;
      .           }
      .           if (len) {
      .             *len = enc->len;
      .           }
      .           return 1;
 15,448 (0.0%)  }
      .         
      .         // Given an ASN1_TEMPLATE get a pointer to a field
320,395 (0.1%)  ASN1_VALUE **asn1_get_field_ptr(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
      .           ASN1_VALUE **pvaltmp;
320,395 (0.1%)    if (tt->flags & ASN1_TFLG_COMBINE) {
      .             return pval;
      .           }
384,474 (0.1%)    pvaltmp = offset2ptr(*pval, tt->offset);
      .           // NOTE for BOOLEAN types the field is just a plain int so we can't return
      .           // int **, so settle for (int *).
 64,079 (0.0%)    return pvaltmp;
128,158 (0.0%)  }
      .         
      .         // Handle ANY DEFINED BY template, find the selector, look up the relevant
      .         // ASN1_TEMPLATE in the table and return it.
      .         const ASN1_TEMPLATE *asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt,
321,951 (0.1%)                                   int nullerr) {
      .           const ASN1_ADB *adb;
      .           const ASN1_ADB_TABLE *atbl;
      .           ASN1_VALUE **sfld;
      .           int i;
229,965 (0.1%)    if (!(tt->flags & ASN1_TFLG_ADB_MASK)) {
 91,986 (0.0%)      return tt;
      .           }
      .         
      .           // Else ANY DEFINED BY ... get the table
      .           adb = ASN1_ADB_ptr(tt->item);
      .         
      .           // Get the selector field
      .           sfld = offset2ptr(*pval, adb->offset);
      .         
-- line 233 ----------------------------------------
-- line 265 ----------------------------------------
      .           return adb->default_tt;
      .         
      .         err:
      .           // FIXME: should log the value or OID of unsupported type
      .           if (nullerr) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);
      .           }
      .           return NULL;
 91,986 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h
--------------------------------------------------------------------------------
Ir______________ 

-- line 318 ----------------------------------------
        .         #if defined(__GNUC__) || defined(__clang__)
        .           __asm__("" : "+r"(a) : /* no inputs */);
        .         #endif
        .           return a;
        .         }
        .         
        .         // constant_time_msb_w returns the given value with the MSB copied to all the
        .         // other bits.
7,493,040 (2.7%)  static inline crypto_word_t constant_time_msb_w(crypto_word_t a) {
4,995,360 (1.8%)    return 0u - (a >> (sizeof(a) * 8 - 1));
4,995,360 (1.8%)  }
        .         
        .         // constant_time_lt_w returns 0xff..f if a < b and 0 otherwise.
        .         static inline crypto_word_t constant_time_lt_w(crypto_word_t a,
        .                                                        crypto_word_t b) {
        .           // Consider the two cases of the problem:
        .           //   msb(a) == msb(b): a < b iff the MSB of a - b is set.
        .           //   msb(a) != msb(b): a < b iff the MSB of b is set.
        .           //
-- line 336 ----------------------------------------
-- line 377 ----------------------------------------
        .         
        .         // constant_time_ge_8 acts like |constant_time_ge_w| but returns an 8-bit
        .         // mask.
        .         static inline uint8_t constant_time_ge_8(crypto_word_t a, crypto_word_t b) {
        .           return (uint8_t)(constant_time_ge_w(a, b));
        .         }
        .         
        .         // constant_time_is_zero returns 0xff..f if a == 0 and 0 otherwise.
4,995,360 (1.8%)  static inline crypto_word_t constant_time_is_zero_w(crypto_word_t a) {
        .           // Here is an SMT-LIB verification of this formula:
        .           //
        .           // (define-fun is_zero ((a (_ BitVec 32))) (_ BitVec 32)
        .           //   (bvand (bvnot a) (bvsub a #x00000001))
        .           // )
        .           //
        .           // (declare-fun a () (_ BitVec 32))
        .           //
        .           // (assert (not (= (= #x00000001 (bvlshr (is_zero a) #x0000001f)) (= a #x00000000))))
        .           // (check-sat)
        .           // (get-model)
9,990,720 (3.5%)    return constant_time_msb_w(~a & (a - 1));
2,497,680 (0.9%)  }
        .         
        .         // constant_time_is_zero_8 acts like |constant_time_is_zero_w| but returns an
        .         // 8-bit mask.
        .         static inline uint8_t constant_time_is_zero_8(crypto_word_t a) {
        .           return (uint8_t)(constant_time_is_zero_w(a));
        .         }
        .         
        .         // constant_time_eq_w returns 0xff..f if a == b and 0 otherwise.
        .         static inline crypto_word_t constant_time_eq_w(crypto_word_t a,
6,244,200 (2.2%)                                                 crypto_word_t b) {
4,995,360 (1.8%)    return constant_time_is_zero_w(a ^ b);
2,497,680 (0.9%)  }
        .         
        .         // constant_time_eq_8 acts like |constant_time_eq_w| but returns an 8-bit
        .         // mask.
6,244,200 (2.2%)  static inline uint8_t constant_time_eq_8(crypto_word_t a, crypto_word_t b) {
6,244,200 (2.2%)    return (uint8_t)(constant_time_eq_w(a, b));
2,497,680 (0.9%)  }
        .         
        .         // constant_time_eq_int acts like |constant_time_eq_w| but works on int
        .         // values.
        .         static inline crypto_word_t constant_time_eq_int(int a, int b) {
        .           return constant_time_eq_w((crypto_word_t)(a), (crypto_word_t)(b));
        .         }
        .         
        .         // constant_time_eq_int_8 acts like |constant_time_eq_int| but returns an 8-bit
-- line 424 ----------------------------------------
-- line 882 ----------------------------------------
        .         static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
        .           if (n == 0) {
        .             return dst;
        .           }
        .         
        .           return memmove(dst, src, n);
        .         }
        .         
    1,752 (0.0%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
      584 (0.0%)    if (n == 0) {
        .             return dst;
        .           }
        .         
    1,752 (0.0%)    return memset(dst, c, n);
      584 (0.0%)  }
        .         
        .         
        .         // Loads and stores.
        .         //
        .         // The following functions load and store sized integers with the specified
        .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
        .         // requirements on the input and output pointers.
        .         
-- line 904 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c
--------------------------------------------------------------------------------
Ir_______________ 

-- line 62 ----------------------------------------
         .         
         .         #include <openssl/type_check.h>
         .         
         .         #include "../internal.h"
         .         
         .         
         .         // constant_time_lt_args_8 behaves like |constant_time_lt_8| but takes |uint8_t|
         .         // arguments for a slightly simpler implementation.
 8,741,880 (3.1%)  static inline uint8_t constant_time_lt_args_8(uint8_t a, uint8_t b) {
 2,497,680 (0.9%)    crypto_word_t aw = a;
 2,497,680 (0.9%)    crypto_word_t bw = b;
         .           // |crypto_word_t| is larger than |uint8_t|, so |aw| and |bw| have the same
         .           // MSB. |aw| < |bw| iff MSB(|aw| - |bw|) is 1.
 4,995,360 (1.8%)    return constant_time_msb_w(aw - bw);
 2,497,680 (0.9%)  }
         .         
         .         // constant_time_in_range_8 returns |CONSTTIME_TRUE_8| if |min| <= |a| <= |max|
         .         // and |CONSTTIME_FALSE_8| otherwise.
         .         static inline uint8_t constant_time_in_range_8(uint8_t a, uint8_t min,
12,488,400 (4.4%)                                                 uint8_t max) {
 2,497,680 (0.9%)    a -= min;
 9,990,720 (3.5%)    return constant_time_lt_args_8(a, max - min + 1);
 2,497,680 (0.9%)  }
         .         
         .         // Encoding.
         .         
         .         static uint8_t conv_bin2ascii(uint8_t a) {
         .           // Since PEM is sometimes used to carry private keys, we encode base64 data
         .           // itself in constant-time.
         .           a &= 0x3f;
         .           uint8_t ret = constant_time_select_8(constant_time_eq_8(a, 62), '+', '/');
-- line 92 ----------------------------------------
-- line 257 ----------------------------------------
         .           if (len % 4 != 0) {
         .             return 0;
         .           }
         .         
         .           *out_len = (len / 4) * 3;
         .           return 1;
         .         }
         .         
     1,460 (0.0%)  void EVP_DecodeInit(EVP_ENCODE_CTX *ctx) {
     1,460 (0.0%)    OPENSSL_memset(ctx, 0, sizeof(EVP_ENCODE_CTX));
       876 (0.0%)  }
         .         
 2,497,680 (0.9%)  static uint8_t base64_ascii_to_bin(uint8_t a) {
         .           // Since PEM is sometimes used to carry private keys, we decode base64 data
         .           // itself in constant-time.
 2,497,680 (0.9%)    const uint8_t is_upper = constant_time_in_range_8(a, 'A', 'Z');
 2,497,680 (0.9%)    const uint8_t is_lower = constant_time_in_range_8(a, 'a', 'z');
 2,497,680 (0.9%)    const uint8_t is_digit = constant_time_in_range_8(a, '0', '9');
 2,081,400 (0.7%)    const uint8_t is_plus = constant_time_eq_8(a, '+');
 2,081,400 (0.7%)    const uint8_t is_slash = constant_time_eq_8(a, '/');
 2,081,400 (0.7%)    const uint8_t is_equals = constant_time_eq_8(a, '=');
         .         
   416,280 (0.1%)    uint8_t ret = 0;
 3,330,240 (1.2%)    ret |= is_upper & (a - 'A');       // [0,26)
 3,330,240 (1.2%)    ret |= is_lower & (a - 'a' + 26);  // [26,52)
 3,330,240 (1.2%)    ret |= is_digit & (a - '0' + 52);  // [52,62)
 2,497,680 (0.9%)    ret |= is_plus & 62;
 2,497,680 (0.9%)    ret |= is_slash & 63;
         .           // Invalid inputs, 'A', and '=' have all been mapped to zero. Map invalid
         .           // inputs to 0xff. Note '=' is padding and handled separately by the caller.
 2,913,960 (1.0%)    const uint8_t is_valid =
         .               is_upper | is_lower | is_digit | is_plus | is_slash | is_equals;
 2,497,680 (0.9%)    ret |= ~is_valid;
   416,280 (0.1%)    return ret;
   832,560 (0.3%)  }
         .         
         .         // base64_decode_quad decodes a single “quad” (i.e. four characters) of base64
         .         // data and writes up to three bytes to |out|. It sets |*out_num_bytes| to the
         .         // number of bytes written, which will be less than three if the quad ended
         .         // with padding.  It returns one on success or zero on error.
         .         static int base64_decode_quad(uint8_t *out, size_t *out_num_bytes,
   728,490 (0.3%)                                const uint8_t *in) {
   624,420 (0.2%)    const uint8_t a = base64_ascii_to_bin(in[0]);
   728,490 (0.3%)    const uint8_t b = base64_ascii_to_bin(in[1]);
   728,490 (0.3%)    const uint8_t c = base64_ascii_to_bin(in[2]);
   728,490 (0.3%)    const uint8_t d = base64_ascii_to_bin(in[3]);
   832,560 (0.3%)    if (a == 0xff || b == 0xff || c == 0xff || d == 0xff) {
         .             return 0;
         .           }
         .         
   936,630 (0.3%)    const uint32_t v = ((uint32_t)a) << 18 | ((uint32_t)b) << 12 |
   312,210 (0.1%)                       ((uint32_t)c) << 6 | (uint32_t)d;
         .         
   728,490 (0.3%)    const unsigned padding_pattern = (in[0] == '=') << 3 |
   728,490 (0.3%)                                     (in[1] == '=') << 2 |
   728,564 (0.3%)                                     (in[2] == '=') << 1 |
   624,420 (0.2%)                                     (in[3] == '=');
         .         
   624,312 (0.2%)    switch (padding_pattern) {
         .             case 0:
         .               // The common case of no padding.
   207,804 (0.1%)        *out_num_bytes = 3;
   519,510 (0.2%)        out[0] = v >> 16;
   623,412 (0.2%)        out[1] = v >> 8;
   415,608 (0.1%)        out[2] = v;
   103,902 (0.0%)        break;
         .         
         .             case 1:  // xxx=
       188 (0.0%)        *out_num_bytes = 2;
       470 (0.0%)        out[0] = v >> 16;
       564 (0.0%)        out[1] = v >> 8;
        94 (0.0%)        break;
         .         
         .             case 3:  // xx==
       148 (0.0%)        *out_num_bytes = 1;
       370 (0.0%)        out[0] = v >> 16;
        74 (0.0%)        break;
         .         
         .             default:
         .               return 0;
         .           }
         .         
   104,070 (0.0%)    return 1;
   208,140 (0.1%)  }
         .         
         .         int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, uint8_t *out, int *out_len,
     3,504 (0.0%)                       const uint8_t *in, size_t in_len) {
       584 (0.0%)    *out_len = 0;
         .         
     1,168 (0.0%)    if (ctx->error_encountered) {
         .             return -1;
         .           }
         .         
       292 (0.0%)    size_t bytes_out = 0, i;
 1,693,124 (0.6%)    for (i = 0; i < in_len; i++) {
 2,114,580 (0.7%)      const char c = in[i];
 2,174,304 (0.8%)      switch (c) {
         .               case ' ':
         .               case '\t':
         .               case '\r':
         .               case '\n':
     6,636 (0.0%)          continue;
         .             }
         .         
 1,665,120 (0.6%)      if (ctx->eof_seen) {
         .               ctx->error_encountered = 1;
         .               return -1;
         .             }
         .         
 3,746,520 (1.3%)      ctx->data[ctx->data_used++] = c;
 1,665,120 (0.6%)      if (ctx->data_used == 4) {
         .               size_t num_bytes_resulting;
   936,630 (0.3%)        if (!base64_decode_quad(out, &num_bytes_resulting, ctx->data)) {
         .                 ctx->error_encountered = 1;
         .                 return -1;
         .               }
         .         
   208,140 (0.1%)        ctx->data_used = 0;
   208,140 (0.1%)        bytes_out += num_bytes_resulting;
   208,140 (0.1%)        out += num_bytes_resulting;
         .         
   312,210 (0.1%)        if (num_bytes_resulting < 3) {
       504 (0.0%)          ctx->eof_seen = 1;
         .               }
         .             }
         .           }
         .         
       876 (0.0%)    if (bytes_out > INT_MAX) {
         .             ctx->error_encountered = 1;
         .             *out_len = 0;
         .             return -1;
         .           }
     1,168 (0.0%)    *out_len = (int)bytes_out;
         .         
     1,168 (0.0%)    if (ctx->eof_seen) {
       336 (0.0%)      return 0;
         .           }
         .         
       124 (0.0%)    return 1;
     1,460 (0.0%)  }
         .         
     1,752 (0.0%)  int EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, uint8_t *out, int *out_len) {
       584 (0.0%)    *out_len = 0;
     2,336 (0.0%)    if (ctx->error_encountered || ctx->data_used != 0) {
         .             return -1;
         .           }
         .         
       292 (0.0%)    return 1;
       584 (0.0%)  }
         .         
         .         int EVP_DecodeBase64(uint8_t *out, size_t *out_len, size_t max_out,
         .                              const uint8_t *in, size_t in_len) {
         .           *out_len = 0;
         .         
         .           if (in_len % 4 != 0) {
         .             return 0;
         .           }
-- line 413 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bio/bio.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 92 ----------------------------------------
     .             }
     .           }
     .           return ret;
     .         }
     .         
     .         static CRYPTO_EX_DATA_CLASS g_ex_data_class =
     .             CRYPTO_EX_DATA_CLASS_INIT_WITH_APP_DATA;
     .         
    10 (0.0%)  BIO *BIO_new(const BIO_METHOD *method) {
     6 (0.0%)    BIO *ret = OPENSSL_zalloc(sizeof(BIO));
     4 (0.0%)    if (ret == NULL) {
     .             return NULL;
     .           }
     .         
     6 (0.0%)    ret->method = method;
     4 (0.0%)    ret->shutdown = 1;
     4 (0.0%)    ret->references = 1;
     4 (0.0%)    ret->callback_ex = NULL;
     8 (0.0%)    CRYPTO_new_ex_data(&ret->ex_data);
     .         
     8 (0.0%)    if (method->create != NULL && !method->create(ret)) {
     .             OPENSSL_free(ret);
     .             return NULL;
     .           }
     .         
     2 (0.0%)    return ret;
     4 (0.0%)  }
     .         
    10 (0.0%)  int BIO_free(BIO *bio) {
     .           BIO *next_bio;
     .         
    14 (0.0%)    for (; bio != NULL; bio = next_bio) {
    12 (0.0%)      if (!CRYPTO_refcount_dec_and_test_zero(&bio->references)) {
     .               return 0;
     .             }
     .         
     8 (0.0%)      next_bio = BIO_pop(bio);
     .         
    18 (0.0%)      if (bio->method != NULL && bio->method->destroy != NULL) {
    12 (0.0%)        bio->method->destroy(bio);
     .             }
     8 (0.0%)      if (HAS_CALLBACK(bio)) {
     .               int ret = (int)bio->callback_ex(bio, BIO_CB_FREE, NULL, 0, 0, 0L, 1L, NULL);
     .               if (ret <= 0) {
     .                 return ret;
     .               }
     .             }
     .         
    14 (0.0%)      CRYPTO_free_ex_data(&g_ex_data_class, bio, &bio->ex_data);
     6 (0.0%)      OPENSSL_free(bio);
     .           }
     2 (0.0%)    return 1;
     4 (0.0%)  }
     .         
     .         int BIO_up_ref(BIO *bio) {
     .           CRYPTO_refcount_inc(&bio->references);
     .           return 1;
     .         }
     .         
     .         void BIO_vfree(BIO *bio) {
     .           BIO_free(bio);
-- line 152 ----------------------------------------
-- line 202 ----------------------------------------
     .             *read_bytes = ret;
     .             return 1;
     .           } else {
     .             *read_bytes = 0;
     .             return 0;
     .           }
     .         }
     .         
50,554 (0.0%)  int BIO_gets(BIO *bio, char *buf, int len) {
79,442 (0.0%)    if (bio == NULL || bio->method == NULL || bio->method->bgets == NULL) {
     .             OPENSSL_PUT_ERROR(BIO, BIO_R_UNSUPPORTED_METHOD);
     .             return -2;
     .           }
28,888 (0.0%)    if (!bio->init) {
     .             OPENSSL_PUT_ERROR(BIO, BIO_R_UNINITIALIZED);
     .             return -2;
     .           }
14,444 (0.0%)    if (len <= 0) {
     .             return 0;
     .           }
72,220 (0.0%)    int ret = bio->method->bgets(bio, buf, len);
14,444 (0.0%)    if (ret > 0) {
50,540 (0.0%)      bio->num_read += ret;
     .           }
 7,222 (0.0%)    return ret;
14,444 (0.0%)  }
     .         
     .         int BIO_write(BIO *bio, const void *in, int inl) {
     .           int ret = 0;
     .           if (bio == NULL || bio->method == NULL || bio->method->bwrite == NULL) {
     .             OPENSSL_PUT_ERROR(BIO, BIO_R_UNSUPPORTED_METHOD);
     .             return -2;
     .           }
     .           if (HAS_CALLBACK(bio)) {
-- line 235 ----------------------------------------
-- line 307 ----------------------------------------
     .           }
     .           return BIO_write(bio, in, (int)len);
     .         }
     .         
     .         int BIO_flush(BIO *bio) {
     .           return (int)BIO_ctrl(bio, BIO_CTRL_FLUSH, 0, NULL);
     .         }
     .         
    16 (0.0%)  long BIO_ctrl(BIO *bio, int cmd, long larg, void *parg) {
     4 (0.0%)    if (bio == NULL) {
     .             return 0;
     .           }
     .         
    18 (0.0%)    if (bio->method == NULL || bio->method->ctrl == NULL) {
     .             OPENSSL_PUT_ERROR(BIO, BIO_R_UNSUPPORTED_METHOD);
     .             return -2;
     .           }
     .         
    18 (0.0%)    return bio->method->ctrl(bio, cmd, larg, parg);
     4 (0.0%)  }
     .         
     .         char *BIO_ptr_ctrl(BIO *b, int cmd, long larg) {
     .           char *p = NULL;
     .         
     .           if (BIO_ctrl(b, cmd, larg, (void *)&p) <= 0) {
     .             return NULL;
     .           }
     .         
-- line 334 ----------------------------------------
-- line 470 ----------------------------------------
     .           while (last_bio->next_bio != NULL) {
     .             last_bio = last_bio->next_bio;
     .           }
     .         
     .           last_bio->next_bio = appended_bio;
     .           return bio;
     .         }
     .         
     8 (0.0%)  BIO *BIO_pop(BIO *bio) {
     .           BIO *ret;
     .         
     4 (0.0%)    if (bio == NULL) {
     .             return NULL;
     .           }
     6 (0.0%)    ret = bio->next_bio;
     4 (0.0%)    bio->next_bio = NULL;
     2 (0.0%)    return ret;
     4 (0.0%)  }
     .         
     .         BIO *BIO_next(BIO *bio) {
     .           if (!bio) {
     .             return NULL;
     .           }
     .           return bio->next_bio;
     .         }
     .         
-- line 495 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/buf/buf.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 59 ----------------------------------------
     .         #include <string.h>
     .         
     .         #include <openssl/mem.h>
     .         #include <openssl/err.h>
     .         
     .         #include "../internal.h"
     .         
     .         
14,350 (0.0%)  BUF_MEM *BUF_MEM_new(void) { return OPENSSL_zalloc(sizeof(BUF_MEM)); }
     .         
 4,410 (0.0%)  void BUF_MEM_free(BUF_MEM *buf) {
 1,764 (0.0%)    if (buf == NULL) {
     .             return;
     .           }
     .         
 3,528 (0.0%)    OPENSSL_free(buf->data);
 3,528 (0.0%)    OPENSSL_free(buf);
 1,764 (0.0%)  }
     .         
50,328 (0.0%)  int BUF_MEM_reserve(BUF_MEM *buf, size_t cap) {
33,552 (0.0%)    if (buf->max >= cap) {
11,476 (0.0%)      return 1;
     .           }
     .         
 7,950 (0.0%)    size_t n = cap + 3;
 7,950 (0.0%)    if (n < cap) {
     .             OPENSSL_PUT_ERROR(BUF, ERR_R_OVERFLOW);
     .             return 0;
     .           }
15,900 (0.0%)    n = n / 3;
 7,950 (0.0%)    size_t alloc_size = n * 4;
10,600 (0.0%)    if (alloc_size / 4 != n) {
     .             OPENSSL_PUT_ERROR(BUF, ERR_R_OVERFLOW);
     .             return 0;
     .           }
     .         
18,550 (0.0%)    char *new_buf = OPENSSL_realloc(buf->data, alloc_size);
 5,300 (0.0%)    if (new_buf == NULL) {
     .             return 0;
     .           }
     .         
 7,950 (0.0%)    buf->data = new_buf;
 7,950 (0.0%)    buf->max = alloc_size;
 2,650 (0.0%)    return 1;
16,776 (0.0%)  }
     .         
50,328 (0.0%)  size_t BUF_MEM_grow(BUF_MEM *buf, size_t len) {
58,716 (0.0%)    if (!BUF_MEM_reserve(buf, len)) {
     .             return 0;
     .           }
33,552 (0.0%)    if (buf->length < len) {
97,152 (0.0%)      OPENSSL_memset(&buf->data[buf->length], 0, len - buf->length);
     .           }
25,164 (0.0%)    buf->length = len;
 8,388 (0.0%)    return len;
16,776 (0.0%)  }
     .         
     .         size_t BUF_MEM_grow_clean(BUF_MEM *buf, size_t len) {
     .           return BUF_MEM_grow(buf, len);
     .         }
     .         
     .         int BUF_MEM_append(BUF_MEM *buf, const void *in, size_t len) {
     .           // Work around a C language bug. See https://crbug.com/1019588.
     .           if (len == 0) {
-- line 122 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 19 ----------------------------------------
      .         #include <string.h>
      .         
      .         #include <openssl/mem.h>
      .         #include <openssl/err.h>
      .         
      .         #include "../internal.h"
      .         
      .         
 18,240 (0.0%)  void CBB_zero(CBB *cbb) {
 18,240 (0.0%)    OPENSSL_memset(cbb, 0, sizeof(CBB));
 10,944 (0.0%)  }
      .         
 10,920 (0.0%)  static void cbb_init(CBB *cbb, uint8_t *buf, size_t cap, int can_resize) {
  3,120 (0.0%)    cbb->is_child = 0;
  3,120 (0.0%)    cbb->child = NULL;
  4,680 (0.0%)    cbb->u.base.buf = buf;
  3,120 (0.0%)    cbb->u.base.len = 0;
  4,680 (0.0%)    cbb->u.base.cap = cap;
 14,040 (0.0%)    cbb->u.base.can_resize = can_resize;
  6,240 (0.0%)    cbb->u.base.error = 0;
  4,680 (0.0%)  }
      .         
  9,360 (0.0%)  int CBB_init(CBB *cbb, size_t initial_capacity) {
  4,680 (0.0%)    CBB_zero(cbb);
      .         
  6,240 (0.0%)    uint8_t *buf = OPENSSL_malloc(initial_capacity);
  6,240 (0.0%)    if (initial_capacity > 0 && buf == NULL) {
      .             return 0;
      .           }
      .         
  9,360 (0.0%)    cbb_init(cbb, buf, initial_capacity, /*can_resize=*/1);
  1,560 (0.0%)    return 1;
  3,120 (0.0%)  }
      .         
      .         int CBB_init_fixed(CBB *cbb, uint8_t *buf, size_t len) {
      .           CBB_zero(cbb);
      .           cbb_init(cbb, buf, len, /*can_resize=*/0);
      .           return 1;
      .         }
      .         
  7,800 (0.0%)  void CBB_cleanup(CBB *cbb) {
      .           // Child |CBB|s are non-owning. They are implicitly discarded and should not
      .           // be used with |CBB_cleanup| or |ScopedCBB|.
  6,240 (0.0%)    assert(!cbb->is_child);
  6,240 (0.0%)    if (cbb->is_child) {
      .             return;
      .           }
      .         
  7,800 (0.0%)    if (cbb->u.base.can_resize) {
  7,800 (0.0%)      OPENSSL_free(cbb->u.base.buf);
      .           }
  3,120 (0.0%)  }
      .         
      .         static int cbb_buffer_reserve(struct cbb_buffer_st *base, uint8_t **out,
168,000 (0.1%)                                size_t len) {
 48,000 (0.0%)    if (base == NULL) {
      .             return 0;
      .           }
      .         
120,000 (0.0%)    size_t newlen = base->len + len;
 96,000 (0.0%)    if (newlen < base->len) {
      .             // Overflow
      .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
      .             goto err;
      .           }
      .         
 96,000 (0.0%)    if (newlen > base->cap) {
      .             if (!base->can_resize) {
      .               OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
      .               goto err;
      .             }
      .         
      .             size_t newcap = base->cap * 2;
      .             if (newcap < base->cap || newcap < newlen) {
      .               newcap = newlen;
-- line 93 ----------------------------------------
-- line 96 ----------------------------------------
      .             if (newbuf == NULL) {
      .               goto err;
      .             }
      .         
      .             base->buf = newbuf;
      .             base->cap = newcap;
      .           }
      .         
 48,000 (0.0%)    if (out) {
168,000 (0.1%)      *out = base->buf + base->len;
      .           }
      .         
 48,000 (0.0%)    return 1;
      .         
      .         err:
      .           base->error = 1;
      .           return 0;
 48,000 (0.0%)  }
      .         
      .         static int cbb_buffer_add(struct cbb_buffer_st *base, uint8_t **out,
168,000 (0.1%)                            size_t len) {
192,000 (0.1%)    if (!cbb_buffer_reserve(base, out, len)) {
      .             return 0;
      .           }
      .           // This will not overflow or |cbb_buffer_reserve| would have failed.
144,000 (0.1%)    base->len += len;
 24,000 (0.0%)    return 1;
 48,000 (0.0%)  }
      .         
 10,920 (0.0%)  int CBB_finish(CBB *cbb, uint8_t **out_data, size_t *out_len) {
  6,240 (0.0%)    if (cbb->is_child) {
      .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
      .             return 0;
      .           }
      .         
  7,800 (0.0%)    if (!CBB_flush(cbb)) {
      .             return 0;
      .           }
      .         
 14,040 (0.0%)    if (cbb->u.base.can_resize && (out_data == NULL || out_len == NULL)) {
      .             // |out_data| and |out_len| can only be NULL if the CBB is fixed.
      .             return 0;
      .           }
      .         
  3,120 (0.0%)    if (out_data != NULL) {
  6,240 (0.0%)      *out_data = cbb->u.base.buf;
      .           }
  3,120 (0.0%)    if (out_len != NULL) {
  6,240 (0.0%)      *out_len = cbb->u.base.len;
      .           }
  3,120 (0.0%)    cbb->u.base.buf = NULL;
  4,680 (0.0%)    CBB_cleanup(cbb);
  1,560 (0.0%)    return 1;
  3,120 (0.0%)  }
      .         
198,240 (0.1%)  static struct cbb_buffer_st *cbb_get_base(CBB *cbb) {
198,240 (0.1%)    if (cbb->is_child) {
      .             return cbb->u.child.base;
      .           }
 99,120 (0.0%)    return &cbb->u.base;
 99,120 (0.0%)  }
      .         
      .         static void cbb_on_error(CBB *cbb) {
      .           // Due to C's lack of destructors and |CBB|'s auto-flushing API, a failing
      .           // |CBB|-taking function may leave a dangling pointer to a child |CBB|. As a
      .           // result, the convention is callers may not write to |CBB|s that have failed.
      .           // But, as a safety measure, we lock the |CBB| into an error state. Once the
      .           // error bit is set, |cbb->child| will not be read.
      .           //
-- line 164 ----------------------------------------
-- line 176 ----------------------------------------
      .           // warning does not know |cbb->child| will not be read once |error| is set
      .           // above.
      .           cbb->child = NULL;
      .         }
      .         
      .         // CBB_flush recurses and then writes out any pending length prefix. The
      .         // current length of the underlying base is taken to be the length of the
      .         // length-prefixed data.
127,800 (0.0%)  int CBB_flush(CBB *cbb) {
      .           // If |base| has hit an error, the buffer is in an undefined state, so
      .           // fail all following calls. In particular, |cbb->child| may point to invalid
      .           // memory.
102,240 (0.0%)    struct cbb_buffer_st *base = cbb_get_base(cbb);
178,920 (0.1%)    if (base == NULL || base->error) {
      .             return 0;
      .           }
      .         
102,240 (0.0%)    if (cbb->child == NULL) {
      .             // Nothing to flush.
 51,120 (0.0%)      return 1;
      .           }
      .         
      .           assert(cbb->child->is_child);
      .           struct cbb_child_st *child = &cbb->child->u.child;
      .           assert(child->base == base);
      .           size_t child_start = child->offset + child->pending_len_len;
      .         
      .           if (!CBB_flush(cbb->child) ||
-- line 203 ----------------------------------------
-- line 264 ----------------------------------------
      .           child->base = NULL;
      .           cbb->child = NULL;
      .         
      .           return 1;
      .         
      .         err:
      .           cbb_on_error(cbb);
      .           return 0;
 51,120 (0.0%)  }
      .         
      .         const uint8_t *CBB_data(const CBB *cbb) {
      .           assert(cbb->child == NULL);
      .           if (cbb->is_child) {
      .             return cbb->u.child.base->buf + cbb->u.child.offset +
      .                    cbb->u.child.pending_len_len;
      .           }
      .           return cbb->u.base.buf;
-- line 280 ----------------------------------------
-- line 397 ----------------------------------------
      .           uint8_t *out;
      .           if (!CBB_add_space(cbb, &out, len)) {
      .             return 0;
      .           }
      .           OPENSSL_memset(out, 0, len);
      .           return 1;
      .         }
      .         
168,000 (0.1%)  int CBB_add_space(CBB *cbb, uint8_t **out_data, size_t len) {
168,000 (0.1%)    if (!CBB_flush(cbb) ||
216,000 (0.1%)        !cbb_buffer_add(cbb_get_base(cbb), out_data, len)) {
      .             return 0;
      .           }
 24,000 (0.0%)    return 1;
 48,000 (0.0%)  }
      .         
      .         int CBB_reserve(CBB *cbb, uint8_t **out_data, size_t len) {
      .           if (!CBB_flush(cbb) ||
      .               !cbb_buffer_reserve(cbb_get_base(cbb), out_data, len)) {
      .             return 0;
      .           }
      .           return 1;
      .         }
-- line 419 ----------------------------------------
-- line 425 ----------------------------------------
      .               newlen < base->len ||
      .               newlen > base->cap) {
      .             return 0;
      .           }
      .           base->len = newlen;
      .           return 1;
      .         }
      .         
240,000 (0.1%)  static int cbb_add_u(CBB *cbb, uint64_t v, size_t len_len) {
      .           uint8_t *buf;
192,000 (0.1%)    if (!CBB_add_space(cbb, &buf, len_len)) {
      .             return 0;
      .           }
      .         
264,000 (0.1%)    for (size_t i = len_len - 1; i < len_len; i--) {
120,000 (0.0%)      buf[i] = v;
 24,000 (0.0%)      v >>= 8;
      .           }
      .         
      .           // |v| must fit in |len_len| bytes.
 48,000 (0.0%)    if (v != 0) {
      .             cbb_on_error(cbb);
      .             return 0;
      .           }
      .         
 24,000 (0.0%)    return 1;
120,000 (0.0%)  }
      .         
168,000 (0.1%)  int CBB_add_u8(CBB *cbb, uint8_t value) {
144,000 (0.1%)    return cbb_add_u(cbb, value, 1);
 48,000 (0.0%)  }
      .         
      .         int CBB_add_u16(CBB *cbb, uint16_t value) {
      .           return cbb_add_u(cbb, value, 2);
      .         }
      .         
      .         int CBB_add_u16le(CBB *cbb, uint16_t value) {
      .           return CBB_add_u16(cbb, CRYPTO_bswap2(value));
      .         }
-- line 463 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 26 ----------------------------------------
        .         
        .         #include <string.h>
        .         
        .         #include "../asn1/internal.h"
        .         #include "../internal.h"
        .         #include "internal.h"
        .         
        .         
  345,876 (0.1%)  void CBS_init(CBS *cbs, const uint8_t *data, size_t len) {
  172,938 (0.1%)    cbs->data = data;
  172,938 (0.1%)    cbs->len = len;
  172,938 (0.1%)  }
        .         
1,144,512 (0.4%)  static int cbs_get(CBS *cbs, const uint8_t **p, size_t n) {
  763,008 (0.3%)    if (cbs->len < n) {
    8,760 (0.0%)      return 0;
        .           }
        .         
  745,488 (0.3%)    *p = cbs->data;
1,118,232 (0.4%)    cbs->data += n;
1,118,232 (0.4%)    cbs->len -= n;
  186,372 (0.1%)    return 1;
  381,504 (0.1%)  }
        .         
  228,042 (0.1%)  int CBS_skip(CBS *cbs, size_t len) {
        .           const uint8_t *dummy;
  152,028 (0.1%)    return cbs_get(cbs, &dummy, len);
  126,690 (0.0%)  }
        .         
  201,280 (0.1%)  const uint8_t *CBS_data(const CBS *cbs) { return cbs->data; }
        .         
1,316,592 (0.5%)  size_t CBS_len(const CBS *cbs) { return cbs->len; }
        .         
        .         int CBS_stow(const CBS *cbs, uint8_t **out_ptr, size_t *out_len) {
        .           OPENSSL_free(*out_ptr);
        .           *out_ptr = NULL;
        .           *out_len = 0;
        .         
        .           if (cbs->len == 0) {
        .             return 1;
-- line 65 ----------------------------------------
-- line 79 ----------------------------------------
        .           *out_ptr = OPENSSL_strndup((const char *)cbs->data, cbs->len);
        .           return (*out_ptr != NULL);
        .         }
        .         
        .         int CBS_contains_zero_byte(const CBS *cbs) {
        .           return OPENSSL_memchr(cbs->data, 0, cbs->len) != NULL;
        .         }
        .         
    1,624 (0.0%)  int CBS_mem_equal(const CBS *cbs, const uint8_t *data, size_t len) {
      928 (0.0%)    if (len != cbs->len) {
      160 (0.0%)      return 0;
        .           }
    1,520 (0.0%)    return CRYPTO_memcmp(cbs->data, data, len) == 0;
      464 (0.0%)  }
        .         
   24,180 (0.0%)  static int cbs_get_u(CBS *cbs, uint64_t *out, size_t len) {
    2,418 (0.0%)    uint64_t result = 0;
        .           const uint8_t *data;
        .         
   19,344 (0.0%)    if (!cbs_get(cbs, &data, len)) {
        .             return 0;
        .           }
   30,282 (0.0%)    for (size_t i = 0; i < len; i++) {
    4,548 (0.0%)      result <<= 8;
   27,288 (0.0%)      result |= data[i];
        .           }
    7,254 (0.0%)    *out = result;
    2,418 (0.0%)    return 1;
   12,090 (0.0%)  }
        .         
1,239,336 (0.4%)  int CBS_get_u8(CBS *cbs, uint8_t *out) {
        .           const uint8_t *v;
1,101,632 (0.4%)    if (!cbs_get(cbs, &v, 1)) {
    8,760 (0.0%)      return 0;
        .           }
  533,296 (0.2%)    *out = *v;
  133,324 (0.0%)    return 1;
  688,520 (0.2%)  }
        .         
        .         int CBS_get_u16(CBS *cbs, uint16_t *out) {
        .           uint64_t v;
        .           if (!cbs_get_u(cbs, &v, 2)) {
        .             return 0;
        .           }
        .           *out = v;
        .           return 1;
-- line 124 ----------------------------------------
-- line 172 ----------------------------------------
        .           if (cbs->len == 0) {
        .             return 0;
        .           }
        .           *out = cbs->data[cbs->len - 1];
        .           cbs->len--;
        .           return 1;
        .         }
        .         
  252,920 (0.1%)  int CBS_get_bytes(CBS *cbs, CBS *out, size_t len) {
        .           const uint8_t *v;
  202,336 (0.1%)    if (!cbs_get(cbs, &v, len)) {
        .             return 0;
        .           }
  151,752 (0.1%)    CBS_init(out, v, len);
   25,292 (0.0%)    return 1;
  126,460 (0.0%)  }
        .         
        .         int CBS_copy_bytes(CBS *cbs, uint8_t *out, size_t len) {
        .           const uint8_t *v;
        .           if (!cbs_get(cbs, &v, len)) {
        .             return 0;
        .           }
        .           OPENSSL_memcpy(out, v, len);
        .           return 1;
-- line 195 ----------------------------------------
-- line 272 ----------------------------------------
        .         
        .             // Values end at an octet with the high bit cleared.
        .           } while (b & 0x80);
        .         
        .           *out = v;
        .           return 1;
        .         }
        .         
  227,628 (0.1%)  static int parse_asn1_tag(CBS *cbs, CBS_ASN1_TAG *out) {
        .           uint8_t tag_byte;
  177,044 (0.1%)    if (!CBS_get_u8(cbs, &tag_byte)) {
        .             return 0;
        .           }
        .         
        .           // ITU-T X.690 section 8.1.2.3 specifies the format for identifiers with a tag
        .           // number no greater than 30.
        .           //
        .           // If the number portion is 31 (0x1f, the largest value that fits in the
        .           // allotted bits), then the tag is more than one byte long and the
        .           // continuation bytes contain the tag number.
  126,460 (0.0%)    CBS_ASN1_TAG tag = ((CBS_ASN1_TAG)tag_byte & 0xe0) << CBS_ASN1_TAG_SHIFT;
  101,168 (0.0%)    CBS_ASN1_TAG tag_number = tag_byte & 0x1f;
   50,584 (0.0%)    if (tag_number == 0x1f) {
        .             uint64_t v;
        .             if (!parse_base128_integer(cbs, &v) ||
        .                 // Check the tag number is within our supported bounds.
        .                 v > CBS_ASN1_TAG_NUMBER_MASK ||
        .                 // Small tag numbers should have used low tag number form, even in BER.
        .                 v < 0x1f) {
        .               return 0;
        .             }
        .             tag_number = (CBS_ASN1_TAG)v;
        .           }
        .         
   50,584 (0.0%)    tag |= tag_number;
        .         
        .           // Tag [UNIVERSAL 0] is reserved for use by the encoding. Reject it here to
        .           // avoid some ambiguity around ANY values and BER indefinite-length EOCs. See
        .           // https://crbug.com/boringssl/455.
  101,168 (0.0%)    if ((tag & ~CBS_ASN1_CONSTRUCTED) == 0) {
        .             return 0;
        .           }
        .         
   75,876 (0.0%)    *out = tag;
   25,292 (0.0%)    return 1;
  126,460 (0.0%)  }
        .         
        .         static int cbs_get_any_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
        .                                             size_t *out_header_len, int *out_ber_found,
  354,088 (0.1%)                                      int *out_indefinite, int ber_ok) {
  126,460 (0.0%)    CBS header = *cbs;
        .           CBS throwaway;
        .         
   50,584 (0.0%)    if (out == NULL) {
        .             out = &throwaway;
        .           }
   50,584 (0.0%)    if (ber_ok) {
   46,392 (0.0%)      *out_ber_found = 0;
   69,588 (0.0%)      *out_indefinite = 0;
        .           } else {
    4,192 (0.0%)      assert(out_ber_found == NULL);
    4,192 (0.0%)      assert(out_indefinite == NULL);
        .           }
        .         
        .           CBS_ASN1_TAG tag;
  177,044 (0.1%)    if (!parse_asn1_tag(&header, &tag)) {
        .             return 0;
        .           }
   50,584 (0.0%)    if (out_tag != NULL) {
   75,876 (0.0%)      *out_tag = tag;
        .           }
        .         
        .           uint8_t length_byte;
  177,044 (0.1%)    if (!CBS_get_u8(&header, &length_byte)) {
        .             return 0;
        .           }
        .         
  252,920 (0.1%)    size_t header_len = CBS_len(cbs) - CBS_len(&header);
        .         
        .           size_t len;
        .           // The format for the length encoding is specified in ITU-T X.690 section
        .           // 8.1.3.
   75,876 (0.0%)    if ((length_byte & 0x80) == 0) {
        .             // Short form length.
  114,370 (0.0%)      len = ((size_t)length_byte) + header_len;
   45,748 (0.0%)      if (out_header_len != NULL) {
   91,496 (0.0%)        *out_header_len = header_len;
        .             }
        .           } else {
        .             // The high bit indicate that this is the long form, while the next 7 bits
        .             // encode the number of subsequent octets used to encode the length (ITU-T
        .             // X.690 clause 8.1.3.5.b).
    9,672 (0.0%)      const size_t num_bytes = length_byte & 0x7f;
        .             uint64_t len64;
        .         
   13,328 (0.0%)      if (ber_ok && (tag & CBS_ASN1_CONSTRUCTED) != 0 && num_bytes == 0) {
        .               // indefinite length
        .               if (out_header_len != NULL) {
        .                 *out_header_len = header_len;
        .               }
        .               *out_ber_found = 1;
        .               *out_indefinite = 1;
        .               return CBS_get_bytes(cbs, out, header_len);
        .             }
        .         
        .             // ITU-T X.690 clause 8.1.3.5.c specifies that the value 0xff shall not be
        .             // used as the first byte of the length. If this parser encounters that
        .             // value, num_bytes will be parsed as 127, which will fail this check.
    9,672 (0.0%)      if (num_bytes == 0 || num_bytes > 4) {
        .               return 0;
        .             }
   19,344 (0.0%)      if (!cbs_get_u(&header, &len64, num_bytes)) {
        .               return 0;
        .             }
        .             // ITU-T X.690 section 10.1 (DER length forms) requires encoding the
        .             // length with the minimum number of octets. BER could, technically, have
        .             // 125 superfluous zero bytes. We do not attempt to handle that and still
        .             // require that the length fit in a |uint32_t| for BER.
    7,254 (0.0%)      if (len64 < 128) {
        .               // Length should have used short-form encoding.
        .               if (ber_ok) {
        .                 *out_ber_found = 1;
        .               } else {
        .                 return 0;
        .               }
        .             }
   21,762 (0.0%)      if ((len64 >> ((num_bytes - 1) * 8)) == 0) {
        .               // Length should have been at least one byte shorter.
        .               if (ber_ok) {
        .                 *out_ber_found = 1;
        .               } else {
        .                 return 0;
        .               }
        .             }
    4,836 (0.0%)      len = len64;
   16,926 (0.0%)      if (len + header_len + num_bytes < len) {
        .               // Overflow.
        .               return 0;
        .             }
    9,672 (0.0%)      len += header_len + num_bytes;
    4,836 (0.0%)      if (out_header_len != NULL) {
   12,090 (0.0%)        *out_header_len = header_len + num_bytes;
        .             }
        .           }
        .         
  151,752 (0.1%)    return CBS_get_bytes(cbs, out, len);
  151,752 (0.1%)  }
        .         
        .         int CBS_get_any_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag) {
        .           size_t header_len;
        .           if (!CBS_get_any_asn1_element(cbs, out, out_tag, &header_len)) {
        .             return 0;
        .           }
        .         
        .           if (!CBS_skip(out, header_len)) {
-- line 426 ----------------------------------------
-- line 427 ----------------------------------------
        .             assert(0);
        .             return 0;
        .           }
        .         
        .           return 1;
        .         }
        .         
        .         int CBS_get_any_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
   16,768 (0.0%)                               size_t *out_header_len) {
   23,056 (0.0%)    return cbs_get_any_asn1_element(cbs, out, out_tag, out_header_len, NULL, NULL,
        .                                           /*ber_ok=*/0);
    4,192 (0.0%)  }
        .         
        .         int CBS_get_any_ber_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
        .                                          size_t *out_header_len, int *out_ber_found,
  301,548 (0.1%)                                   int *out_indefinite) {
        .           int ber_found_temp;
  347,940 (0.1%)    return cbs_get_any_asn1_element(
        .               cbs, out, out_tag, out_header_len,
        .               out_ber_found ? out_ber_found : &ber_found_temp, out_indefinite,
        .               /*ber_ok=*/1);
  115,980 (0.0%)  }
        .         
        .         static int cbs_get_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value,
   23,056 (0.0%)                          int skip_header) {
        .           size_t header_len;
        .           CBS_ASN1_TAG tag;
        .           CBS throwaway;
        .         
    4,192 (0.0%)    if (out == NULL) {
        .             out = &throwaway;
        .           }
        .         
   20,960 (0.0%)    if (!CBS_get_any_asn1_element(cbs, out, &tag, &header_len) ||
    2,096 (0.0%)        tag != tag_value) {
        .             return 0;
        .           }
        .         
   18,864 (0.0%)    if (skip_header && !CBS_skip(out, header_len)) {
        .             assert(0);
        .             return 0;
        .           }
        .         
    2,096 (0.0%)    return 1;
   10,480 (0.0%)  }
        .         
   14,672 (0.0%)  int CBS_get_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value) {
   12,576 (0.0%)    return cbs_get_asn1(cbs, out, tag_value, 1 /* skip header */);
    4,192 (0.0%)  }
        .         
        .         int CBS_get_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value) {
        .           return cbs_get_asn1(cbs, out, tag_value, 0 /* include header */);
        .         }
        .         
        .         int CBS_peek_asn1_tag(const CBS *cbs, CBS_ASN1_TAG tag_value) {
        .           CBS copy = *cbs;
        .           CBS_ASN1_TAG actual_tag;
-- line 483 ----------------------------------------
-- line 670 ----------------------------------------
        .         
        .           // Unused bits are zero, and this function does not distinguish between
        .           // missing and unset bits. Thus it is sufficient to do a byte-level length
        .           // check.
        .           return byte_num < CBS_len(cbs) &&
        .                  (CBS_data(cbs)[byte_num] & (1 << bit_num)) != 0;
        .         }
        .         
    9,072 (0.0%)  int CBS_is_valid_asn1_integer(const CBS *cbs, int *out_is_negative) {
    5,040 (0.0%)    CBS copy = *cbs;
        .           uint8_t first_byte, second_byte;
    7,056 (0.0%)    if (!CBS_get_u8(&copy, &first_byte)) {
        .             return 0;  // INTEGERs may not be empty.
        .           }
    2,016 (0.0%)    if (out_is_negative != NULL) {
    5,040 (0.0%)      *out_is_negative = (first_byte & 0x80) != 0;
        .           }
    7,056 (0.0%)    if (!CBS_get_u8(&copy, &second_byte)) {
      660 (0.0%)      return 1;  // One byte INTEGERs are always minimal.
        .           }
    4,116 (0.0%)    if ((first_byte == 0x00 && (second_byte & 0x80) == 0) ||
      678 (0.0%)        (first_byte == 0xff && (second_byte & 0x80) != 0)) {
        .             return 0;  // The value is minimal iff the first 9 bits are not all equal.
        .           }
      678 (0.0%)    return 1;
    5,040 (0.0%)  }
        .         
        .         int CBS_is_unsigned_asn1_integer(const CBS *cbs) {
        .           int is_negative;
        .           return CBS_is_valid_asn1_integer(cbs, &is_negative) && !is_negative;
        .         }
        .         
        .         static int add_decimal(CBB *out, uint64_t v) {
        .           char buf[DECIMAL_SIZE(uint64_t) + 1];
        .           snprintf(buf, sizeof(buf), "%" PRIu64, v);
        .           return CBB_add_bytes(out, (const uint8_t *)buf, strlen(buf));
        .         }
        .         
   32,400 (0.0%)  int CBS_is_valid_asn1_oid(const CBS *cbs) {
   20,250 (0.0%)    if (CBS_len(cbs) == 0) {
        .             return 0;  // OID encodings cannot be empty.
        .           }
        .         
   20,250 (0.0%)    CBS copy = *cbs;
    4,050 (0.0%)    uint8_t v, prev = 0;
  154,550 (0.1%)    while (CBS_get_u8(&copy, &v)) {
        .             // OID encodings are a sequence of minimally-encoded base-128 integers (see
        .             // |parse_base128_integer|). If |prev|'s MSB was clear, it was the last byte
        .             // of an integer (or |v| is the first byte). |v| is then the first byte of
        .             // the next integer. If first byte of an integer is 0x80, it is not
        .             // minimally-encoded.
   97,140 (0.0%)      if ((prev & 0x80) == 0 && v == 0x80) {
        .               return 0;
        .             }
   34,900 (0.0%)      prev = v;
        .           }
        .         
        .           // The last byte should must end an integer encoding.
   16,200 (0.0%)    return (prev & 0x80) == 0;
   20,250 (0.0%)  }
        .         
        .         char *CBS_asn1_oid_to_text(const CBS *cbs) {
        .           CBB cbb;
        .           if (!CBB_init(&cbb, 32)) {
        .             goto err;
        .           }
        .         
        .           CBS copy = *cbs;
-- line 737 ----------------------------------------
-- line 766 ----------------------------------------
        .         
        .           return (char *)txt;
        .         
        .         err:
        .           CBB_cleanup(&cbb);
        .           return NULL;
        .         }
        .         
   31,572 (0.0%)  static int cbs_get_two_digits(CBS *cbs, int *out) {
        .           uint8_t first_digit, second_digit;
   24,556 (0.0%)    if (!CBS_get_u8(cbs, &first_digit)) {
        .             return 0;
        .           }
   21,048 (0.0%)    if (!OPENSSL_isdigit(first_digit)) {
        .             return 0;
        .           }
   24,556 (0.0%)    if (!CBS_get_u8(cbs, &second_digit)) {
        .             return 0;
        .           }
   21,048 (0.0%)    if (!OPENSSL_isdigit(second_digit)) {
        .             return 0;
        .           }
   49,112 (0.0%)    *out = (first_digit - '0') * 10 + (second_digit - '0');
    3,508 (0.0%)    return 1;
   17,540 (0.0%)  }
        .         
    3,504 (0.0%)  static int is_valid_day(int year, int month, int day) {
    1,168 (0.0%)    if (day < 1) {
        .             return 0;
        .           }
   10,360 (0.0%)    switch (month) {
        .             case 1:
        .             case 3:
        .             case 5:
        .             case 7:
        .             case 8:
        .             case 10:
        .             case 12:
    1,456 (0.0%)        return day <= 31;
        .             case 4:
        .             case 6:
        .             case 9:
        .             case 11:
      656 (0.0%)        return day <= 30;
        .             case 2:
      952 (0.0%)        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
       48 (0.0%)          return day <= 29;
        .               } else {
      176 (0.0%)          return day <= 28;
        .               }
        .             default:
        .               return 0;
        .           }
    1,168 (0.0%)  }
        .         
        .         static int CBS_parse_rfc5280_time_internal(const CBS *cbs, int is_gentime,
        .                                                    int allow_timezone_offset,
    6,424 (0.0%)                                             struct tm *out_tm) {
        .           int year, month, day, hour, min, sec, tmp;
    2,920 (0.0%)    CBS copy = *cbs;
        .           uint8_t tz;
        .         
    1,168 (0.0%)    if (is_gentime) {
       28 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
        .               return 0;
        .             }
       12 (0.0%)      year = tmp * 100;
       28 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
        .               return 0;
        .             }
       12 (0.0%)      year += tmp;
        .           } else {
      580 (0.0%)      year = 1900;
    4,060 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
        .               return 0;
        .             }
    1,160 (0.0%)      year += tmp;
    1,160 (0.0%)      if (year < 1950) {
      576 (0.0%)        year += 100;
        .             }
    1,160 (0.0%)      if (year >= 2050) {
        .               return 0;  // A Generalized time must be used.
        .             }
        .           }
    7,008 (0.0%)    if (!cbs_get_two_digits(&copy, &month) || month < 1 ||
    1,752 (0.0%)        month > 12 ||  // Reject invalid months.
    4,088 (0.0%)        !cbs_get_two_digits(&copy, &day) ||
    4,672 (0.0%)        !is_valid_day(year, month, day) ||  // Reject invalid days.
    4,088 (0.0%)        !cbs_get_two_digits(&copy, &hour) ||
    1,752 (0.0%)        hour > 23 ||  // Reject invalid hours.
    4,088 (0.0%)        !cbs_get_two_digits(&copy, &min) ||
    1,752 (0.0%)        min > 59 ||  // Reject invalid minutes.
    8,760 (0.0%)        !cbs_get_two_digits(&copy, &sec) || sec > 59 || !CBS_get_u8(&copy, &tz)) {
        .             return 0;
        .           }
        .         
      584 (0.0%)    int offset_sign = 0;
    2,336 (0.0%)    switch (tz) {
        .             case 'Z':
      584 (0.0%)        break;  // We correctly have 'Z' on the end as per spec.
        .             case '+':
        .               offset_sign = 1;
        .               break;  // Should not be allowed per RFC 5280.
        .             case '-':
        .               offset_sign = -1;
        .               break;  // Should not be allowed per RFC 5280.
        .             default:
        .               return 0;  // Reject anything else after the time.
-- line 873 ----------------------------------------
-- line 880 ----------------------------------------
        .           // are now difficult to change. These certificates were generated with the
        .           // 'openssl' command that permissively allowed the creation of certificates
        .           // with notBefore and notAfter times specified as strings for direct
        .           // certificate inclusion on the command line. For context see cl/237068815.
        .           //
        .           // TODO(bbe): This has been expunged from public web-pki as the ecosystem has
        .           // managed to encourage CA compliance with standards. We should find a way to
        .           // get rid of this or make it off by default.
      584 (0.0%)    int offset_seconds = 0;
    1,168 (0.0%)    if (offset_sign != 0) {
        .             if (!allow_timezone_offset) {
        .               return 0;
        .             }
        .             int offset_hours, offset_minutes;
        .             if (!cbs_get_two_digits(&copy, &offset_hours) ||
        .                 offset_hours > 23 ||  // Reject invalid hours.
        .                 !cbs_get_two_digits(&copy, &offset_minutes) ||
        .                 offset_minutes > 59) {  // Reject invalid minutes.
        .               return 0;
        .             }
        .             offset_seconds = offset_sign * (offset_hours * 3600 + offset_minutes * 60);
        .           }
        .         
    2,920 (0.0%)    if (CBS_len(&copy) != 0) {
        .             return 0;  // Reject invalid lengths.
        .           }
        .         
    1,168 (0.0%)    if (out_tm != NULL) {
        .             // Fill in the tm fields corresponding to what we validated.
        .             out_tm->tm_year = year - 1900;
        .             out_tm->tm_mon = month - 1;
        .             out_tm->tm_mday = day;
        .             out_tm->tm_hour = hour;
        .             out_tm->tm_min = min;
        .             out_tm->tm_sec = sec;
        .             if (offset_seconds && !OPENSSL_gmtime_adj(out_tm, 0, offset_seconds)) {
        .               return 0;
        .             }
        .           }
      584 (0.0%)    return 1;
    2,920 (0.0%)  }
        .         
        .         int CBS_parse_generalized_time(const CBS *cbs, struct tm *out_tm,
       28 (0.0%)                                 int allow_timezone_offset) {
       24 (0.0%)    return CBS_parse_rfc5280_time_internal(cbs, 1, allow_timezone_offset, out_tm);
        8 (0.0%)  }
        .         
        .         int CBS_parse_utc_time(const CBS *cbs, struct tm *out_tm,
    4,060 (0.0%)                         int allow_timezone_offset) {
    3,480 (0.0%)    return CBS_parse_rfc5280_time_internal(cbs, 0, allow_timezone_offset, out_tm);
    1,160 (0.0%)  }
        .         
        .         int CBS_get_optional_asn1_int64(CBS *cbs, int64_t *out, CBS_ASN1_TAG tag,
        .                                         int64_t default_value) {
        .           CBS child;
        .           int present;
        .           if (!CBS_get_optional_asn1(cbs, &child, &present, tag)) {
        .             return 0;
        .           }
-- line 938 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 12 ----------------------------------------
      .          * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
      .          * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
      .         
      .         #include <openssl/bytestring.h>
      .         
      .         #include "internal.h"
      .         
      .         
 89,888 (0.0%)  static int is_valid_code_point(uint32_t v) {
      .           // References in the following are to Unicode 9.0.0.
 44,944 (0.0%)    if (// The Unicode space runs from zero to 0x10ffff (3.4 D9).
 44,944 (0.0%)        v > 0x10ffff ||
      .               // Values 0x...fffe, 0x...ffff, and 0xfdd0-0xfdef are permanently reserved
      .               // (3.4 D14)
 89,888 (0.0%)        (v & 0xfffe) == 0xfffe ||
 44,944 (0.0%)        (v >= 0xfdd0 && v <= 0xfdef) ||
      .               // Surrogate code points are invalid (3.2 C1).
      .               (v >= 0xd800 && v <= 0xdfff)) {
      .             return 0;
      .           }
 22,472 (0.0%)    return 1;
 44,944 (0.0%)  }
      .         
      .         // BOTTOM_BITS returns a byte with the bottom |n| bits set.
      .         #define BOTTOM_BITS(n) (uint8_t)((1u << (n)) - 1)
      .         
      .         // TOP_BITS returns a byte with the top |n| bits set.
      .         #define TOP_BITS(n) ((uint8_t)~BOTTOM_BITS(8 - (n)))
      .         
 97,200 (0.0%)  int cbs_get_utf8(CBS *cbs, uint32_t *out) {
      .           uint8_t c;
 75,600 (0.0%)    if (!CBS_get_u8(cbs, &c)) {
      .             return 0;
      .           }
 32,400 (0.0%)    if (c <= 0x7f) {
 43,072 (0.0%)      *out = c;
 21,536 (0.0%)      return 1;
      .           }
      .           uint32_t v, lower_bound;
      .           size_t len;
    160 (0.0%)    if ((c & TOP_BITS(3)) == TOP_BITS(2)) {
    128 (0.0%)      v = c & BOTTOM_BITS(5);
     32 (0.0%)      len = 1;
     64 (0.0%)      lower_bound = 0x80;
      .           } else if ((c & TOP_BITS(4)) == TOP_BITS(3)) {
      .             v = c & BOTTOM_BITS(4);
      .             len = 2;
      .             lower_bound = 0x800;
      .           } else if ((c & TOP_BITS(5)) == TOP_BITS(4)) {
      .             v = c & BOTTOM_BITS(3);
      .             len = 3;
      .             lower_bound = 0x10000;
      .           } else {
      .             return 0;
      .           }
    288 (0.0%)    for (size_t i = 0; i < len; i++) {
    288 (0.0%)      if (!CBS_get_u8(cbs, &c) ||
     96 (0.0%)          (c & TOP_BITS(2)) != TOP_BITS(1)) {
      .               return 0;
      .             }
     32 (0.0%)      v <<= 6;
    128 (0.0%)      v |= c & BOTTOM_BITS(6);
      .           }
    256 (0.0%)    if (!is_valid_code_point(v) ||
      .               v < lower_bound) {
      .             return 0;
      .           }
     96 (0.0%)    *out = v;
     32 (0.0%)    return 1;
 54,000 (0.0%)  }
      .         
403,920 (0.1%)  int cbs_get_latin1(CBS *cbs, uint32_t *out) {
      .           uint8_t c;
314,160 (0.1%)    if (!CBS_get_u8(cbs, &c)) {
      .             return 0;
      .           }
179,520 (0.1%)    *out = c;
 44,880 (0.0%)    return 1;
224,400 (0.1%)  }
      .         
      .         int cbs_get_ucs2_be(CBS *cbs, uint32_t *out) {
      .           // Note UCS-2 (used by BMPString) does not support surrogates.
      .           uint16_t c;
      .           if (!CBS_get_u16(cbs, &c) ||
      .               !is_valid_code_point(c)) {
      .             return 0;
      .           }
-- line 98 ----------------------------------------
-- line 99 ----------------------------------------
      .           *out = c;
      .           return 1;
      .         }
      .         
      .         int cbs_get_utf32_be(CBS *cbs, uint32_t *out) {
      .           return CBS_get_u32(cbs, out) && is_valid_code_point(*out);
      .         }
      .         
132,960 (0.0%)  size_t cbb_get_utf8_len(uint32_t u) {
 66,480 (0.0%)    if (u <= 0x7f) {
 66,416 (0.0%)      return 1;
      .           }
     64 (0.0%)    if (u <= 0x7ff) {
     64 (0.0%)      return 2;
      .           }
      .           if (u <= 0xffff) {
      .             return 3;
      .           }
      .           return 4;
 66,480 (0.0%)  }
      .         
134,640 (0.0%)  int cbb_add_utf8(CBB *cbb, uint32_t u) {
112,200 (0.0%)    if (!is_valid_code_point(u)) {
      .             return 0;
      .           }
 44,880 (0.0%)    if (u <= 0x7f) {
157,080 (0.1%)      return CBB_add_u8(cbb, (uint8_t)u);
      .           }
      .           if (u <= 0x7ff) {
      .             return CBB_add_u8(cbb, TOP_BITS(2) | (u >> 6)) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | (u & BOTTOM_BITS(6)));
      .           }
      .           if (u <= 0xffff) {
      .             return CBB_add_u8(cbb, TOP_BITS(3) | (u >> 12)) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | ((u >> 6) & BOTTOM_BITS(6))) &&
-- line 133 ----------------------------------------
-- line 135 ----------------------------------------
      .           }
      .           if (u <= 0x10ffff) {
      .             return CBB_add_u8(cbb, TOP_BITS(4) | (u >> 18)) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | ((u >> 12) & BOTTOM_BITS(6))) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | ((u >> 6) & BOTTOM_BITS(6))) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | (u & BOTTOM_BITS(6)));
      .           }
      .           return 0;
 44,880 (0.0%)  }
      .         
      .         int cbb_add_latin1(CBB *cbb, uint32_t u) {
      .           return u <= 0xff && CBB_add_u8(cbb, (uint8_t)u);
      .         }
      .         
      .         int cbb_add_ucs2_be(CBB *cbb, uint32_t u) {
      .           return u <= 0xffff && is_valid_code_point(u) && CBB_add_u16(cbb, (uint16_t)u);
      .         }
-- line 151 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h
--------------------------------------------------------------------------------
Ir____________ 

-- line 293 ----------------------------------------
      .         
      .         // value_barrier_w returns |a|, but prevents GCC and Clang from reasoning about
      .         // the returned value. This is used to mitigate compilers undoing constant-time
      .         // code, until we can express our requirements directly in the language.
      .         //
      .         // Note the compiler is aware that |value_barrier_w| has no side effects and
      .         // always has the same output for a given input. This allows it to eliminate
      .         // dead code, move computations across loops, and vectorize.
 16,872 (0.0%)  static inline crypto_word_t value_barrier_w(crypto_word_t a) {
      .         #if defined(__GNUC__) || defined(__clang__)
 11,248 (0.0%)    __asm__("" : "+r"(a) : /* no inputs */);
      .         #endif
  5,624 (0.0%)    return a;
 11,248 (0.0%)  }
      .         
      .         // value_barrier_u32 behaves like |value_barrier_w| but takes a |uint32_t|.
      .         static inline uint32_t value_barrier_u32(uint32_t a) {
      .         #if defined(__GNUC__) || defined(__clang__)
      .           __asm__("" : "+r"(a) : /* no inputs */);
      .         #endif
      .           return a;
      .         }
-- line 314 ----------------------------------------
-- line 318 ----------------------------------------
      .         #if defined(__GNUC__) || defined(__clang__)
      .           __asm__("" : "+r"(a) : /* no inputs */);
      .         #endif
      .           return a;
      .         }
      .         
      .         // constant_time_msb_w returns the given value with the MSB copied to all the
      .         // other bits.
  5,577 (0.0%)  static inline crypto_word_t constant_time_msb_w(crypto_word_t a) {
  3,718 (0.0%)    return 0u - (a >> (sizeof(a) * 8 - 1));
  3,718 (0.0%)  }
      .         
      .         // constant_time_lt_w returns 0xff..f if a < b and 0 otherwise.
      .         static inline crypto_word_t constant_time_lt_w(crypto_word_t a,
  4,640 (0.0%)                                                 crypto_word_t b) {
      .           // Consider the two cases of the problem:
      .           //   msb(a) == msb(b): a < b iff the MSB of a - b is set.
      .           //   msb(a) != msb(b): a < b iff the MSB of b is set.
      .           //
      .           // If msb(a) == msb(b) then the following evaluates as:
      .           //   msb(a^((a^b)|((a-b)^a))) ==
      .           //   msb(a^((a-b) ^ a))       ==   (because msb(a^b) == 0)
      .           //   msb(a^a^(a-b))           ==   (rearranging)
-- line 340 ----------------------------------------
-- line 355 ----------------------------------------
      .           // )
      .           //
      .           // (declare-fun a () (_ BitVec 32))
      .           // (declare-fun b () (_ BitVec 32))
      .           //
      .           // (assert (not (= (= #x00000001 (bvlshr (lt a b) #x0000001f)) (bvult a b))))
      .           // (check-sat)
      .           // (get-model)
  9,280 (0.0%)    return constant_time_msb_w(a^((a^b)|((a-b)^a)));
  1,856 (0.0%)  }
      .         
      .         // constant_time_lt_8 acts like |constant_time_lt_w| but returns an 8-bit
      .         // mask.
      .         static inline uint8_t constant_time_lt_8(crypto_word_t a, crypto_word_t b) {
      .           return (uint8_t)(constant_time_lt_w(a, b));
      .         }
      .         
      .         // constant_time_ge_w returns 0xff..f if a >= b and 0 otherwise.
-- line 372 ----------------------------------------
-- line 377 ----------------------------------------
      .         
      .         // constant_time_ge_8 acts like |constant_time_ge_w| but returns an 8-bit
      .         // mask.
      .         static inline uint8_t constant_time_ge_8(crypto_word_t a, crypto_word_t b) {
      .           return (uint8_t)(constant_time_ge_w(a, b));
      .         }
      .         
      .         // constant_time_is_zero returns 0xff..f if a == 0 and 0 otherwise.
  3,724 (0.0%)  static inline crypto_word_t constant_time_is_zero_w(crypto_word_t a) {
      .           // Here is an SMT-LIB verification of this formula:
      .           //
      .           // (define-fun is_zero ((a (_ BitVec 32))) (_ BitVec 32)
      .           //   (bvand (bvnot a) (bvsub a #x00000001))
      .           // )
      .           //
      .           // (declare-fun a () (_ BitVec 32))
      .           //
      .           // (assert (not (= (= #x00000001 (bvlshr (is_zero a) #x0000001f)) (= a #x00000000))))
      .           // (check-sat)
      .           // (get-model)
  7,448 (0.0%)    return constant_time_msb_w(~a & (a - 1));
  1,862 (0.0%)  }
      .         
      .         // constant_time_is_zero_8 acts like |constant_time_is_zero_w| but returns an
      .         // 8-bit mask.
      .         static inline uint8_t constant_time_is_zero_8(crypto_word_t a) {
      .           return (uint8_t)(constant_time_is_zero_w(a));
      .         }
      .         
      .         // constant_time_eq_w returns 0xff..f if a == b and 0 otherwise.
      .         static inline crypto_word_t constant_time_eq_w(crypto_word_t a,
  4,640 (0.0%)                                                 crypto_word_t b) {
  3,712 (0.0%)    return constant_time_is_zero_w(a ^ b);
  1,856 (0.0%)  }
      .         
      .         // constant_time_eq_8 acts like |constant_time_eq_w| but returns an 8-bit
      .         // mask.
      .         static inline uint8_t constant_time_eq_8(crypto_word_t a, crypto_word_t b) {
      .           return (uint8_t)(constant_time_eq_w(a, b));
      .         }
      .         
      .         // constant_time_eq_int acts like |constant_time_eq_w| but works on int
-- line 418 ----------------------------------------
-- line 427 ----------------------------------------
      .           return constant_time_eq_8((crypto_word_t)(a), (crypto_word_t)(b));
      .         }
      .         
      .         // constant_time_select_w returns (mask & a) | (~mask & b). When |mask| is all
      .         // 1s or all 0s (as returned by the methods above), the select methods return
      .         // either |a| (if |mask| is nonzero) or |b| (if |mask| is zero).
      .         static inline crypto_word_t constant_time_select_w(crypto_word_t mask,
      .                                                            crypto_word_t a,
 19,684 (0.0%)                                                     crypto_word_t b) {
      .           // Clang recognizes this pattern as a select. While it usually transforms it
      .           // to a cmov, it sometimes further transforms it into a branch, which we do
      .           // not want.
      .           //
      .           // Adding barriers to both |mask| and |~mask| breaks the relationship between
      .           // the two, which makes the compiler stick with bitmasks.
 30,932 (0.0%)    return (value_barrier_w(mask) & a) | (value_barrier_w(~mask) & b);
  8,436 (0.0%)  }
      .         
      .         // constant_time_select_8 acts like |constant_time_select| but operates on
      .         // 8-bit values.
      .         static inline uint8_t constant_time_select_8(uint8_t mask, uint8_t a,
      .                                                      uint8_t b) {
      .           return (uint8_t)(constant_time_select_w(mask, a, b));
      .         }
      .         
      .         // constant_time_select_int acts like |constant_time_select| but operates on
      .         // ints.
 11,136 (0.0%)  static inline int constant_time_select_int(crypto_word_t mask, int a, int b) {
 14,848 (0.0%)    return (int)(constant_time_select_w(mask, (crypto_word_t)(a),
      .                                               (crypto_word_t)(b)));
  3,712 (0.0%)  }
      .         
      .         #if defined(BORINGSSL_CONSTANT_TIME_VALIDATION)
      .         
      .         // CONSTTIME_SECRET takes a pointer and a number of bytes and marks that region
      .         // of memory as secret. Secret data is tracked as it flows to registers and
      .         // other parts of a memory. If secret data is used as a condition for a branch,
      .         // or as a memory index, it will trigger warnings in valgrind.
      .         #define CONSTTIME_SECRET(ptr, len) VALGRIND_MAKE_MEM_UNDEFINED(ptr, len)
-- line 465 ----------------------------------------
-- line 800 ----------------------------------------
      .         static inline uint64_t CRYPTO_bswap8(uint64_t x) {
      .           return _byteswap_uint64(x);
      .         }
      .         #else
      .         static inline uint16_t CRYPTO_bswap2(uint16_t x) {
      .           return (x >> 8) | (x << 8);
      .         }
      .         
 70,542 (0.0%)  static inline uint32_t CRYPTO_bswap4(uint32_t x) {
 23,514 (0.0%)    x = (x >> 16) | (x << 16);
211,626 (0.1%)    x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);
 23,514 (0.0%)    return x;
 47,028 (0.0%)  }
      .         
 58,760 (0.0%)  static inline uint64_t CRYPTO_bswap8(uint64_t x) {
129,272 (0.0%)    return CRYPTO_bswap4(x >> 32) | (((uint64_t)CRYPTO_bswap4(x)) << 32);
 35,256 (0.0%)  }
      .         #endif
      .         
      .         
      .         // Language bug workarounds.
      .         //
      .         // Most C standard library functions are undefined if passed NULL, even when the
      .         // corresponding length is zero. This gives them (and, in turn, all functions
      .         // which call them) surprising behavior on empty arrays. Some compilers will
-- line 824 ----------------------------------------
-- line 866 ----------------------------------------
      .         static inline int OPENSSL_memcmp(const void *s1, const void *s2, size_t n) {
      .           if (n == 0) {
      .             return 0;
      .           }
      .         
      .           return memcmp(s1, s2, n);
      .         }
      .         
 74,640 (0.0%)  static inline void *OPENSSL_memcpy(void *dst, const void *src, size_t n) {
 24,880 (0.0%)    if (n == 0) {
    848 (0.0%)      return dst;
      .           }
      .         
 72,096 (0.0%)    return memcpy(dst, src, n);
 24,880 (0.0%)  }
      .         
      .         static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
      .           if (n == 0) {
      .             return dst;
      .           }
      .         
      .           return memmove(dst, src, n);
      .         }
      .         
  5,466 (0.0%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
  1,822 (0.0%)    if (n == 0) {
    848 (0.0%)      return dst;
      .           }
      .         
  2,922 (0.0%)    return memset(dst, c, n);
  1,822 (0.0%)  }
      .         
      .         
      .         // Loads and stores.
      .         //
      .         // The following functions load and store sized integers with the specified
      .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
      .         // requirements on the input and output pointers.
      .         
-- line 904 ----------------------------------------
-- line 959 ----------------------------------------
      .           OPENSSL_memcpy(&v, in, sizeof(v));
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           return v;
      .         #else
      .           return CRYPTO_bswap4(v);
      .         #endif
      .         }
      .         
     50 (0.0%)  static inline void CRYPTO_store_u32_be(void *out, uint32_t v) {
      .         
      .         #if !defined(OPENSSL_BIG_ENDIAN)
     40 (0.0%)    v = CRYPTO_bswap4(v);
      .         #endif
     60 (0.0%)    OPENSSL_memcpy(out, &v, sizeof(v));
      .         
     30 (0.0%)  }
      .         
      .         static inline uint64_t CRYPTO_load_u64_le(const void *in) {
      .           uint64_t v;
      .           OPENSSL_memcpy(&v, in, sizeof(v));
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           return CRYPTO_bswap8(v);
      .         #else
      .           return v;
-- line 982 ----------------------------------------
-- line 996 ----------------------------------------
      .           OPENSSL_memcpy(&ret, ptr, sizeof(ret));
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           return ret;
      .         #else
      .           return CRYPTO_bswap8(ret);
      .         #endif
      .         }
      .         
     40 (0.0%)  static inline void CRYPTO_store_u64_be(void *out, uint64_t v) {
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .         #else
     32 (0.0%)    v = CRYPTO_bswap8(v);
      .         #endif
     48 (0.0%)    OPENSSL_memcpy(out, &v, sizeof(v));
      .         
     24 (0.0%)  }
      .         
      .         static inline crypto_word_t CRYPTO_load_word_le(const void *in) {
      .         
      .           crypto_word_t v;
      .           OPENSSL_memcpy(&v, in, sizeof(v));
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           return CRYPTO_bswap_word(v);
      .         #else
-- line 1019 ----------------------------------------
-- line 1026 ----------------------------------------
      .         
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           v = CRYPTO_bswap_word(v);
      .         #endif
      .           OPENSSL_memcpy(out, &v, sizeof(v));
      .         
      .         }
      .         
 82,208 (0.0%)  static inline crypto_word_t CRYPTO_load_word_be(const void *in) {
      .           crypto_word_t v;
 70,464 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           return v;
      .         #else
      .         #if defined(OPENSSL_64_BIT)
      .           assert(sizeof(v) == 8);
 35,232 (0.0%)    return CRYPTO_bswap8(v);
      .         #else
      .           assert(sizeof(v) == 4);
      .           return CRYPTO_bswap4(v);
      .         #endif
      .         #endif
 58,720 (0.0%)  }
      .         
      .         // Bit rotation functions.
      .         //
      .         // Note these functions use |(-shift) & 31|, etc., because shifting by the bit
      .         // width is undefined. Both Clang and GCC recognize this pattern as a rotation,
      .         // but MSVC does not. Instead, we call MSVC's built-in functions.
      .         
      .         static inline uint32_t CRYPTO_rotl_u32(uint32_t value, int shift) {
-- line 1056 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h
--------------------------------------------------------------------------------
Ir____________ 

-- line 866 ----------------------------------------
      .         static inline int OPENSSL_memcmp(const void *s1, const void *s2, size_t n) {
      .           if (n == 0) {
      .             return 0;
      .           }
      .         
      .           return memcmp(s1, s2, n);
      .         }
      .         
 42,084 (0.0%)  static inline void *OPENSSL_memcpy(void *dst, const void *src, size_t n) {
 14,028 (0.0%)    if (n == 0) {
      .             return dst;
      .           }
      .         
 42,084 (0.0%)    return memcpy(dst, src, n);
 14,028 (0.0%)  }
      .         
      .         static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
      .           if (n == 0) {
      .             return dst;
      .           }
      .         
      .           return memmove(dst, src, n);
      .         }
      .         
489,354 (0.2%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
163,118 (0.1%)    if (n == 0) {
      .             return dst;
      .           }
      .         
489,354 (0.2%)    return memset(dst, c, n);
163,118 (0.1%)  }
      .         
      .         
      .         // Loads and stores.
      .         //
      .         // The following functions load and store sized integers with the specified
      .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
      .         // requirements on the input and output pointers.
      .         
-- line 904 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 77 ----------------------------------------
      .         #define OPENSSL_MALLOC_PREFIX 8
      .         OPENSSL_STATIC_ASSERT(OPENSSL_MALLOC_PREFIX >= sizeof(size_t),
      .                               size_t_too_large)
      .         
      .         #if defined(OPENSSL_ASAN)
      .         void __asan_poison_memory_region(const volatile void *addr, size_t size);
      .         void __asan_unpoison_memory_region(const volatile void *addr, size_t size);
      .         #else
478,304 (0.2%)  static void __asan_poison_memory_region(const void *addr, size_t size) {}
358,832 (0.1%)  static void __asan_unpoison_memory_region(const void *addr, size_t size) {}
      .         #endif
      .         
      .         // Windows doesn't really support weak symbols as of May 2019, and Clang on
      .         // Windows will emit strong symbols instead. See
      .         // https://bugs.llvm.org/show_bug.cgi?id=37598
      .         #if defined(__ELF__) && defined(__GNUC__)
      .         #define WEAK_SYMBOL_FUNC(rettype, name, args) \
      .           rettype name args __attribute__((weak));
-- line 94 ----------------------------------------
-- line 157 ----------------------------------------
      .             return 0;
      .           }
      .           malloc_impl = m;
      .           realloc_impl = r;
      .           free_impl = f;
      .           return 1;
      .         }
      .         
288,860 (0.1%)  void *OPENSSL_malloc(size_t size) {
173,316 (0.1%)    if (malloc_impl != NULL) {
      .             assert(OPENSSL_memory_alloc == NULL);
      .             assert(OPENSSL_memory_realloc == NULL);
      .             assert(OPENSSL_memory_free == NULL);
      .             assert(OPENSSL_memory_get_size == NULL);
      .             assert(realloc_impl != NULL);
      .             assert(free_impl != NULL);
      .             return malloc_impl(size, AWSLC_FILE, AWSLC_LINE);
      .           }
173,316 (0.1%)    if (OPENSSL_memory_alloc != NULL) {
      .             assert(OPENSSL_memory_free != NULL);
      .             assert(OPENSSL_memory_get_size != NULL);
      .             void *ptr = OPENSSL_memory_alloc(size);
      .             if (ptr == NULL && size != 0) {
      .               goto err;
      .             }
      .             return ptr;
      .           }
      .         
115,544 (0.0%)    if (size + OPENSSL_MALLOC_PREFIX < size) {
      .             goto err;
      .           }
      .         
288,860 (0.1%)    void *ptr = malloc(size + OPENSSL_MALLOC_PREFIX);
115,544 (0.0%)    if (ptr == NULL) {
      .             goto err;
      .           }
      .         
173,316 (0.1%)    *(size_t *)ptr = size;
      .         
231,088 (0.1%)    __asan_poison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
173,316 (0.1%)    return ((uint8_t *)ptr) + OPENSSL_MALLOC_PREFIX;
      .         
      .          err:
      .           // This only works because ERR does not call OPENSSL_malloc.
      .           OPENSSL_PUT_ERROR(CRYPTO, ERR_R_MALLOC_FAILURE);
      .           return NULL;
115,544 (0.0%)  }
      .         
193,600 (0.1%)  void *OPENSSL_zalloc(size_t size) {
154,880 (0.1%)    void *ret = OPENSSL_malloc(size);
 77,440 (0.0%)    if (ret != NULL) {
193,600 (0.1%)      OPENSSL_memset(ret, 0, size);
      .           }
 38,720 (0.0%)    return ret;
 77,440 (0.0%)  }
      .         
 43,428 (0.0%)  void *OPENSSL_calloc(size_t num, size_t size) {
 65,142 (0.0%)    if (size != 0 && num > SIZE_MAX / size) {
      .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
      .             return NULL;
      .           }
      .         
 28,952 (0.0%)    return OPENSSL_zalloc(num * size);
 14,476 (0.0%)  }
      .         
283,190 (0.1%)  void OPENSSL_free(void *orig_ptr) {
113,276 (0.0%)    if (orig_ptr == NULL) {
 13,800 (0.0%)      return;
      .           }
128,514 (0.0%)    if (free_impl != NULL) {
      .             assert(OPENSSL_memory_alloc == NULL);
      .             assert(OPENSSL_memory_realloc == NULL);
      .             assert(OPENSSL_memory_free == NULL);
      .             assert(OPENSSL_memory_get_size == NULL);
      .             assert(malloc_impl != NULL);
      .             assert(realloc_impl != NULL);
      .             free_impl(orig_ptr, AWSLC_FILE, AWSLC_LINE);
      .             return;
      .           }
      .         
128,514 (0.0%)    if (OPENSSL_memory_free != NULL) {
      .             OPENSSL_memory_free(orig_ptr);
      .             return;
      .           }
      .         
128,514 (0.0%)    void *ptr = ((uint8_t *)orig_ptr) - OPENSSL_MALLOC_PREFIX;
171,352 (0.1%)    __asan_unpoison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
      .         
128,514 (0.0%)    size_t size = *(size_t *)ptr;
257,028 (0.1%)    OPENSSL_cleanse(ptr, size + OPENSSL_MALLOC_PREFIX);
      .         
      .         // ASan knows to intercept malloc and free, but not sdallocx.
      .         #if defined(OPENSSL_ASAN)
      .           (void)sdallocx;
      .           free(ptr);
      .           (void) sdallocx;
      .         #else
128,514 (0.0%)    if (sdallocx) {
      .             sdallocx(ptr, size + OPENSSL_MALLOC_PREFIX, 0 /* flags */);
      .           } else {
171,352 (0.1%)      free(ptr);
      .           }
      .         #endif
113,276 (0.0%)  }
      .         
 20,856 (0.0%)  void *OPENSSL_realloc(void *orig_ptr, size_t new_size) {
  6,952 (0.0%)    if (orig_ptr == NULL) {
  5,840 (0.0%)      return OPENSSL_malloc(new_size);
      .           }
  6,048 (0.0%)    if (realloc_impl != NULL) {
      .             assert(OPENSSL_memory_alloc == NULL);
      .             assert(OPENSSL_memory_realloc == NULL);
      .             assert(OPENSSL_memory_free == NULL);
      .             assert(OPENSSL_memory_get_size == NULL);
      .             assert(malloc_impl != NULL);
      .             assert(free_impl != NULL);
      .             return realloc_impl(orig_ptr, new_size, AWSLC_FILE, AWSLC_LINE);
      .           }
  6,048 (0.0%)    if (OPENSSL_memory_realloc != NULL) {
      .             assert(OPENSSL_memory_alloc != NULL);
      .             assert(OPENSSL_memory_free != NULL);
      .             assert(OPENSSL_memory_get_size != NULL);
      .             return OPENSSL_memory_realloc(orig_ptr, new_size);
      .           }
      .           size_t old_size;
  6,048 (0.0%)    if (OPENSSL_memory_get_size != NULL) {
      .             old_size = OPENSSL_memory_get_size(orig_ptr);
      .           } else {
  6,048 (0.0%)      void *ptr = ((uint8_t *)orig_ptr) - OPENSSL_MALLOC_PREFIX;
  8,064 (0.0%)      __asan_unpoison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
  6,048 (0.0%)      old_size = *(size_t *)ptr;
  8,064 (0.0%)      __asan_poison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
      .           }
      .         
  8,064 (0.0%)    void *ret = OPENSSL_malloc(new_size);
  4,032 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
  4,032 (0.0%)    size_t to_copy = new_size;
  6,048 (0.0%)    if (old_size < to_copy) {
  4,032 (0.0%)      to_copy = old_size;
      .           }
      .         
 12,096 (0.0%)    memcpy(ret, orig_ptr, to_copy);
  6,048 (0.0%)    OPENSSL_free(orig_ptr);
      .         
  2,016 (0.0%)    return ret;
  6,952 (0.0%)  }
      .         
257,028 (0.1%)  void OPENSSL_cleanse(void *ptr, size_t len) {
      .         #if defined(OPENSSL_WINDOWS)
      .           SecureZeroMemory(ptr, len);
      .         #else
214,190 (0.1%)    OPENSSL_memset(ptr, 0, len);
      .         
      .         #if !defined(OPENSSL_NO_ASM)
      .           /* As best as we can tell, this is sufficient to break any optimisations that
      .              might try to eliminate "superfluous" memsets. If there's an easy way to
      .              detect memset_s, it would be better to use that. */
 42,838 (0.0%)    __asm__ __volatile__("" : : "r"(ptr) : "memory");
      .         #endif
      .         #endif  // !OPENSSL_NO_ASM
128,514 (0.0%)  }
      .         
      .         void OPENSSL_clear_free(void *ptr, size_t unused) { OPENSSL_free(ptr); }
      .         
      .         int CRYPTO_secure_malloc_init(size_t size, size_t min_size) { return 0; }
      .         
      .         int CRYPTO_secure_malloc_initialized(void) { return 0; }
      .         
      .         size_t CRYPTO_secure_used(void) { return 0; }
-- line 328 ----------------------------------------
-- line 330 ----------------------------------------
      .         void *OPENSSL_secure_malloc(size_t size) { return OPENSSL_malloc(size); }
      .         
      .         void *OPENSSL_secure_zalloc(size_t size) { return OPENSSL_zalloc(size); }
      .         
      .         void OPENSSL_secure_clear_free(void *ptr, size_t len) {
      .           OPENSSL_clear_free(ptr, len);
      .         }
      .         
  1,392 (0.0%)  int CRYPTO_memcmp(const void *in_a, const void *in_b, size_t len) {
    464 (0.0%)    const uint8_t *a = in_a;
    464 (0.0%)    const uint8_t *b = in_b;
    232 (0.0%)    uint8_t x = 0;
      .         
 19,144 (0.0%)    for (size_t i = 0; i < len; i++) {
 44,960 (0.0%)      x |= a[i] ^ b[i];
      .           }
      .         
    232 (0.0%)    return x;
    464 (0.0%)  }
      .         
      .         uint32_t OPENSSL_hash32(const void *ptr, size_t len) {
      .           // These are the FNV-1a parameters for 32 bits.
      .           static const uint32_t kPrime = 16777619u;
      .           static const uint32_t kOffsetBasis = 2166136261u;
      .         
      .           const uint8_t *in = ptr;
      .           uint32_t h = kOffsetBasis;
-- line 356 ----------------------------------------
-- line 387 ----------------------------------------
      .           OPENSSL_memcpy(ret, s, len);
      .           return ret;
      .         }
      .         
      .         int OPENSSL_isalpha(int c) {
      .           return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
      .         }
      .         
 84,192 (0.0%)  int OPENSSL_isdigit(int c) { return c >= '0' && c <= '9'; }
      .         
      .         int OPENSSL_isxdigit(int c) {
      .           return OPENSSL_isdigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
      .         }
      .         
      .         int OPENSSL_fromxdigit(uint8_t *out, int c) {
      .           if (OPENSSL_isdigit(c)) {
      .             *out = c - '0';
-- line 403 ----------------------------------------
-- line 411 ----------------------------------------
      .             *out = c - 'A' + 10;
      .             return 1;
      .           }
      .           return 0;
      .         }
      .         
      .         int OPENSSL_isalnum(int c) { return OPENSSL_isalpha(c) || OPENSSL_isdigit(c); }
      .         
120,240 (0.0%)  int OPENSSL_tolower(int c) {
116,152 (0.0%)    if (c >= 'A' && c <= 'Z') {
 25,680 (0.0%)      return c + ('a' - 'A');
      .           }
 21,500 (0.0%)    return c;
 60,120 (0.0%)  }
      .         
162,640 (0.1%)  int OPENSSL_isspace(int c) {
531,792 (0.2%)    return c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r' ||
      .                  c == ' ';
 81,320 (0.0%)  }
      .         
      .         int OPENSSL_strcasecmp(const char *a, const char *b) {
      .           for (size_t i = 0;; i++) {
      .             const int aa = OPENSSL_tolower(a[i]);
      .             const int bb = OPENSSL_tolower(b[i]);
      .         
      .             if (aa < bb) {
      .               return -1;
-- line 437 ----------------------------------------
-- line 542 ----------------------------------------
      .             return NULL;
      .           }
      .         
      .           OPENSSL_memcpy(ret, str, size);
      .           ret[size] = '\0';
      .           return ret;
      .         }
      .         
     14 (0.0%)  size_t OPENSSL_strlcpy(char *dst, const char *src, size_t dst_size) {
      2 (0.0%)    size_t l = 0;
      .         
    258 (0.0%)    for (; dst_size > 1 && *src; dst_size--) {
    288 (0.0%)      *dst++ = *src++;
     36 (0.0%)      l++;
      .           }
      .         
      4 (0.0%)    if (dst_size) {
      4 (0.0%)      *dst = 0;
      .           }
      .         
     10 (0.0%)    return l + strlen(src);
      4 (0.0%)  }
      .         
      .         size_t OPENSSL_strlcat(char *dst, const char *src, size_t dst_size) {
      .           size_t l = 0;
      .           for (; dst_size > 0 && *dst; dst_size--, dst++) {
      .             l++;
      .           }
      .           return l + OPENSSL_strlcpy(dst, src, dst_size);
      .         }
      .         
 42,084 (0.0%)  void *OPENSSL_memdup(const void *data, size_t size) {
 14,028 (0.0%)    if (size == 0) {
      .             return NULL;
      .           }
      .         
 28,056 (0.0%)    void *ret = OPENSSL_malloc(size);
 14,028 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
 42,084 (0.0%)    OPENSSL_memcpy(ret, data, size);
  7,014 (0.0%)    return ret;
 14,028 (0.0%)  }
      .         
      .         void *CRYPTO_malloc(size_t size, const char *file, int line) {
      .           return OPENSSL_malloc(size);
      .         }
      .         
      .         void *CRYPTO_realloc(void *ptr, size_t new_size, const char *file, int line) {
      .           return OPENSSL_realloc(ptr, new_size);
      .         }
-- line 593 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 97 ----------------------------------------
     .         
     .           CRYPTO_STATIC_MUTEX_lock_write(&global_next_nid_lock);
     .           ret = global_next_nid++;
     .           CRYPTO_STATIC_MUTEX_unlock_write(&global_next_nid_lock);
     .         
     .           return ret;
     .         }
     .         
30,690 (0.0%)  ASN1_OBJECT *OBJ_dup(const ASN1_OBJECT *o) {
     .           ASN1_OBJECT *r;
 6,138 (0.0%)    unsigned char *data = NULL;
12,276 (0.0%)    char *sn = NULL, *ln = NULL;
     .         
12,276 (0.0%)    if (o == NULL) {
     .             return NULL;
     .           }
     .         
30,690 (0.0%)    if (!(o->flags & ASN1_OBJECT_FLAG_DYNAMIC)) {
     .             // TODO(fork): this is a little dangerous.
     .             return (ASN1_OBJECT *)o;
     .           }
     .         
12,276 (0.0%)    r = ASN1_OBJECT_new();
12,276 (0.0%)    if (r == NULL) {
     .             OPENSSL_PUT_ERROR(OBJ, ERR_R_ASN1_LIB);
     .             return NULL;
     .           }
36,828 (0.0%)    r->ln = r->sn = NULL;
     .         
     .           // once data is attached to an object, it remains const
61,380 (0.0%)    r->data = OPENSSL_memdup(o->data, o->length);
49,104 (0.0%)    if (o->length != 0 && r->data == NULL) {
     .             goto err;
     .           }
     .         
24,552 (0.0%)    r->length = o->length;
24,552 (0.0%)    r->nid = o->nid;
     .         
24,552 (0.0%)    if (o->ln != NULL) {
     .             ln = OPENSSL_strdup(o->ln);
     .             if (ln == NULL) {
     .               goto err;
     .             }
     .           }
     .         
24,552 (0.0%)    if (o->sn != NULL) {
     .             sn = OPENSSL_strdup(o->sn);
     .             if (sn == NULL) {
     .               goto err;
     .             }
     .           }
     .         
18,414 (0.0%)    r->sn = sn;
18,414 (0.0%)    r->ln = ln;
     .         
12,276 (0.0%)    r->flags =
24,552 (0.0%)        o->flags | (ASN1_OBJECT_FLAG_DYNAMIC | ASN1_OBJECT_FLAG_DYNAMIC_STRINGS |
     .                           ASN1_OBJECT_FLAG_DYNAMIC_DATA);
12,276 (0.0%)    return r;
     .         
     .         err:
     .           OPENSSL_free(ln);
     .           OPENSSL_free(sn);
     .           OPENSSL_free(data);
     .           OPENSSL_free(r);
     .           return NULL;
12,276 (0.0%)  }
     .         
     .         int OBJ_cmp(const ASN1_OBJECT *a, const ASN1_OBJECT *b) {
     .           if (a->length < b->length) {
     .             return -1;
     .           } else if (a->length > b->length) {
     .             return 1;
     .           }
     .           return OPENSSL_memcmp(a->data, b->data, a->length);
-- line 171 ----------------------------------------
-- line 334 ----------------------------------------
     .               !CBB_add_bytes(&oid, obj->data, obj->length) ||
     .               !CBB_flush(out)) {
     .             return 0;
     .           }
     .         
     .           return 1;
     .         }
     .         
18,174 (0.0%)  const ASN1_OBJECT *OBJ_get_undef(void) {
     .           static const ASN1_OBJECT kUndef = {
     .               /*sn=*/SN_undef,
     .               /*ln=*/LN_undef,
     .               /*nid=*/NID_undef,
     .               /*length=*/0,
     .               /*data=*/NULL,
     .               /*flags=*/0,
     .           };
 6,058 (0.0%)    return &kUndef;
12,116 (0.0%)  }
     .         
     .         ASN1_OBJECT *OBJ_nid2obj(int nid) {
     .           if (nid == NID_undef) {
     .             return (ASN1_OBJECT *)OBJ_get_undef();
     .           }
     .         
     .           if (nid > 0 && nid < NUM_NID) {
     .             const ASN1_OBJECT *obj = get_builtin_object(nid);
-- line 360 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/pem/pem_lib.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 369 ----------------------------------------
      .           OPENSSL_cleanse(iv, sizeof(iv));
      .           OPENSSL_cleanse((char *)&ctx, sizeof(ctx));
      .           OPENSSL_cleanse(buf, PEM_BUFSIZE);
      .           OPENSSL_free(data);
      .           return ret;
      .         }
      .         
      .         int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,
  4,088 (0.0%)                    pem_password_cb *callback, void *u) {
    292 (0.0%)    int i = 0, j, o, klen;
      .           long len;
      .           EVP_CIPHER_CTX ctx;
      .           unsigned char key[EVP_MAX_KEY_LENGTH];
      .           char buf[PEM_BUFSIZE];
      .         
    876 (0.0%)    len = *plen;
      .         
  1,168 (0.0%)    if (cipher->cipher == NULL) {
    584 (0.0%)      return 1;
      .           }
      .         
      .           klen = 0;
      .           if (!callback) {
      .             callback = PEM_def_callback;
      .           }
      .           klen = callback(buf, PEM_BUFSIZE, 0, u);
      .           if (klen <= 0) {
-- line 395 ----------------------------------------
-- line 416 ----------------------------------------
      .           OPENSSL_cleanse((char *)key, sizeof(key));
      .           if (!o) {
      .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_DECRYPT);
      .             return 0;
      .           }
      .           j += i;
      .           *plen = j;
      .           return 1;
  2,336 (0.0%)  }
      .         
  1,752 (0.0%)  int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher) {
    292 (0.0%)    const EVP_CIPHER *enc = NULL;
      .           char *p, c;
    584 (0.0%)    char **header_pp = &header;
      .         
    584 (0.0%)    cipher->cipher = NULL;
  1,752 (0.0%)    OPENSSL_memset(cipher->iv, 0, sizeof(cipher->iv));
  2,044 (0.0%)    if ((header == NULL) || (*header == '\0') || (*header == '\n')) {
    584 (0.0%)      return 1;
      .           }
      .           if (strncmp(header, "Proc-Type: ", 11) != 0) {
      .             OPENSSL_PUT_ERROR(PEM, PEM_R_NOT_PROC_TYPE);
      .             return 0;
      .           }
      .           header += 11;
      .           if (*header != '4') {
      .             return 0;
-- line 442 ----------------------------------------
-- line 489 ----------------------------------------
      .             OPENSSL_PUT_ERROR(PEM, PEM_R_UNSUPPORTED_ENCRYPTION);
      .             return 0;
      .           }
      .           if (!load_iv(header_pp, &(cipher->iv[0]), EVP_CIPHER_iv_length(enc))) {
      .             return 0;
      .           }
      .         
      .           return 1;
    584 (0.0%)  }
      .         
      .         static int load_iv(char **fromp, unsigned char *to, size_t num) {
      .           uint8_t v;
      .           char *from;
      .         
      .           from = *fromp;
      .           for (size_t i = 0; i < num; i++) {
      .             to[i] = 0;
-- line 505 ----------------------------------------
-- line 599 ----------------------------------------
      .             return 0;
      .           }
      .           int ret = PEM_read_bio(b, name, header, data, len);
      .           BIO_free(b);
      .           return ret;
      .         }
      .         
      .         int PEM_read_bio(BIO *bp, char **name, char **header, unsigned char **data,
  3,528 (0.0%)                   long *len) {
      .           EVP_ENCODE_CTX ctx;
  1,176 (0.0%)    int end = 0, i, k, bl = 0, hl = 0, nohead = 0;
      .           char buf[256];
      .           BUF_MEM *nameB;
      .           BUF_MEM *headerB;
      .           BUF_MEM *dataB, *tmpB;
      .         
    588 (0.0%)    nameB = BUF_MEM_new();
    588 (0.0%)    headerB = BUF_MEM_new();
    588 (0.0%)    dataB = BUF_MEM_new();
  1,764 (0.0%)    if ((nameB == NULL) || (headerB == NULL) || (dataB == NULL)) {
      .             BUF_MEM_free(nameB);
      .             BUF_MEM_free(headerB);
      .             BUF_MEM_free(dataB);
      .             return 0;
      .           }
      .         
    294 (0.0%)    buf[254] = '\0';
      .           for (;;) {
  2,058 (0.0%)      i = BIO_gets(bp, buf, 254);
      .         
    588 (0.0%)      if (i <= 0) {
     14 (0.0%)        OPENSSL_PUT_ERROR(PEM, PEM_R_NO_START_LINE);
      2 (0.0%)        goto err;
      .             }
      .         
  6,132 (0.0%)      while ((i >= 0) && (buf[i] <= ' ')) {
    584 (0.0%)        i--;
      .             }
  1,168 (0.0%)      buf[++i] = '\n';
  1,168 (0.0%)      buf[++i] = '\0';
      .         
  2,336 (0.0%)      if (strncmp(buf, "-----BEGIN ", 11) == 0) {
  1,460 (0.0%)        i = strlen(&(buf[11]));
      .         
  3,504 (0.0%)        if (strncmp(&(buf[11 + i - 6]), "-----\n", 6) != 0) {
      .                 continue;
      .               }
  2,628 (0.0%)        if (!BUF_MEM_grow(nameB, i + 9)) {
      .                 goto err;
      .               }
  2,920 (0.0%)        OPENSSL_memcpy(nameB->data, &(buf[11]), i - 6);
  2,044 (0.0%)        nameB->data[i - 6] = '\0';
    292 (0.0%)        break;
      .             }
      .           }
    292 (0.0%)    hl = 0;
  1,752 (0.0%)    if (!BUF_MEM_grow(headerB, 256)) {
      .             goto err;
      .           }
    876 (0.0%)    headerB->data[0] = '\0';
      .           for (;;) {
 55,132 (0.0%)      i = BIO_gets(bp, buf, 254);
 13,856 (0.0%)      if (i <= 0) {
      .               break;
      .             }
      .         
152,416 (0.1%)      while ((i >= 0) && (buf[i] <= ' ')) {
 13,856 (0.0%)        i--;
      .             }
 27,712 (0.0%)      buf[++i] = '\n';
 27,712 (0.0%)      buf[++i] = '\0';
      .         
 20,784 (0.0%)      if (buf[0] == '\n') {
      .               break;
      .             }
 76,208 (0.0%)      if (!BUF_MEM_grow(headerB, hl + i + 9)) {
      .               goto err;
      .             }
 55,424 (0.0%)      if (strncmp(buf, "-----END ", 9) == 0) {
    292 (0.0%)        nohead = 1;
    292 (0.0%)        break;
      .             }
 72,996 (0.0%)      OPENSSL_memcpy(&(headerB->data[hl]), buf, i);
 53,088 (0.0%)      headerB->data[hl + i] = '\0';
 13,272 (0.0%)      hl += i;
      .           }
      .         
    292 (0.0%)    bl = 0;
  1,752 (0.0%)    if (!BUF_MEM_grow(dataB, 1024)) {
      .             goto err;
      .           }
    876 (0.0%)    dataB->data[0] = '\0';
    584 (0.0%)    if (!nohead) {
      .             for (;;) {
      .               i = BIO_gets(bp, buf, 254);
      .               if (i <= 0) {
      .                 break;
      .               }
      .         
      .               while ((i >= 0) && (buf[i] <= ' ')) {
      .                 i--;
-- line 699 ----------------------------------------
-- line 728 ----------------------------------------
      .                 }
      .                 buf[++i] = '\n';
      .                 buf[++i] = '\0';
      .         
      .                 break;
      .               }
      .             }
      .           } else {
    584 (0.0%)      tmpB = headerB;
    584 (0.0%)      headerB = dataB;
    584 (0.0%)      dataB = tmpB;
    876 (0.0%)      bl = hl;
      .           }
  1,460 (0.0%)    i = strlen(nameB->data);
  2,920 (0.0%)    if ((strncmp(buf, "-----END ", 9) != 0) ||
  3,212 (0.0%)        (strncmp(nameB->data, &(buf[9]), i) != 0) ||
  2,920 (0.0%)        (strncmp(&(buf[9 + i]), "-----\n", 6) != 0)) {
      .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_END_LINE);
      .             goto err;
      .           }
      .         
    876 (0.0%)    EVP_DecodeInit(&ctx);
  2,920 (0.0%)    i = EVP_DecodeUpdate(&ctx, (unsigned char *)dataB->data, &bl,
    584 (0.0%)                         (unsigned char *)dataB->data, bl);
    584 (0.0%)    if (i < 0) {
      .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_BASE64_DECODE);
      .             goto err;
      .           }
  3,212 (0.0%)    i = EVP_DecodeFinal(&ctx, (unsigned char *)&(dataB->data[bl]), &k);
    584 (0.0%)    if (i < 0) {
      .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_BASE64_DECODE);
      .             goto err;
      .           }
  1,168 (0.0%)    bl += k;
      .         
    876 (0.0%)    if (bl == 0) {
      .             goto err;
      .           }
  1,168 (0.0%)    *name = nameB->data;
  1,168 (0.0%)    *header = headerB->data;
  1,168 (0.0%)    *data = (unsigned char *)dataB->data;
  1,168 (0.0%)    *len = bl;
    876 (0.0%)    OPENSSL_free(nameB);
    876 (0.0%)    OPENSSL_free(headerB);
    876 (0.0%)    OPENSSL_free(dataB);
    584 (0.0%)    return 1;
      .         err:
      6 (0.0%)    BUF_MEM_free(nameB);
      6 (0.0%)    BUF_MEM_free(headerB);
      6 (0.0%)    BUF_MEM_free(dataB);
      2 (0.0%)    return 0;
  1,470 (0.0%)  }
      .         
      .         int PEM_def_callback(char *buf, int size, int rwflag, void *userdata) {
      .           if (!buf || !userdata || size < 0) {
      .             return 0;
      .           }
      .           size_t len = strlen((char *)userdata);
      .           if (len >= (size_t)size) {
      .             return 0;
-- line 787 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/stack/stack.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 78 ----------------------------------------
      .           // comp is an optional comparison function.
      .           OPENSSL_sk_cmp_func comp;
      .         };
      .         
      .         // kMinSize is the number of pointers that will be initially allocated in a new
      .         // stack.
      .         static const size_t kMinSize = 4;
      .         
 34,070 (0.0%)  OPENSSL_STACK *OPENSSL_sk_new(OPENSSL_sk_cmp_func comp) {
 20,442 (0.0%)    OPENSSL_STACK *ret = OPENSSL_zalloc(sizeof(OPENSSL_STACK));
 13,628 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
 40,884 (0.0%)    ret->data = OPENSSL_calloc(kMinSize, sizeof(void *));
 27,256 (0.0%)    if (ret->data == NULL) {
      .             goto err;
      .           }
      .         
 20,442 (0.0%)    ret->comp = comp;
 20,442 (0.0%)    ret->num_alloc = kMinSize;
      .         
 13,628 (0.0%)    return ret;
      .         
      .         err:
      .           OPENSSL_free(ret);
      .           return NULL;
 13,628 (0.0%)  }
      .         
 47,670 (0.0%)  OPENSSL_STACK *OPENSSL_sk_new_null(void) { return OPENSSL_sk_new(NULL); }
      .         
125,244 (0.0%)  size_t OPENSSL_sk_num(const OPENSSL_STACK *sk) {
 62,622 (0.0%)    if (sk == NULL) {
    592 (0.0%)      return 0;
      .           }
 62,030 (0.0%)    return sk->num;
 62,622 (0.0%)  }
      .         
      .         void OPENSSL_sk_zero(OPENSSL_STACK *sk) {
      .           if (sk == NULL || sk->num == 0) {
      .             return;
      .           }
      .           OPENSSL_memset(sk->data, 0, sizeof(void*) * sk->num);
      .           sk->num = 0;
      .           sk->sorted = 0;
      .         }
      .         
 87,505 (0.0%)  void *OPENSSL_sk_value(const OPENSSL_STACK *sk, size_t i) {
105,006 (0.0%)    if (!sk || i >= sk->num) {
      .             return NULL;
      .           }
105,006 (0.0%)    return sk->data[i];
 35,002 (0.0%)  }
      .         
 12,528 (0.0%)  void *OPENSSL_sk_set(OPENSSL_STACK *sk, size_t i, void *value) {
 12,528 (0.0%)    if (!sk || i >= sk->num) {
      .             return NULL;
      .           }
 16,704 (0.0%)    return sk->data[i] = value;
  4,176 (0.0%)  }
      .         
 33,320 (0.0%)  void OPENSSL_sk_free(OPENSSL_STACK *sk) {
 13,328 (0.0%)    if (sk == NULL) {
    292 (0.0%)      return;
      .           }
 25,488 (0.0%)    OPENSSL_free(sk->data);
 25,488 (0.0%)    OPENSSL_free(sk);
 13,328 (0.0%)  }
      .         
      .         void OPENSSL_sk_pop_free_ex(OPENSSL_STACK *sk,
      .                                     OPENSSL_sk_call_free_func call_free_func,
 28,980 (0.0%)                              OPENSSL_sk_free_func free_func) {
  8,280 (0.0%)    if (sk == NULL) {
      2 (0.0%)      return;
      .           }
      .         
 63,573 (0.0%)    for (size_t i = 0; i < sk->num; i++) {
 61,992 (0.0%)      if (sk->data[i] != NULL) {
 85,239 (0.0%)        call_free_func(free_func, sk->data[i]);
      .             }
      .           }
 16,552 (0.0%)    OPENSSL_sk_free(sk);
  8,280 (0.0%)  }
      .         
      .         // Historically, |sk_pop_free| called the function as |OPENSSL_sk_free_func|
      .         // directly. This is undefined in C. Some callers called |sk_pop_free| directly,
      .         // so we must maintain a compatibility version for now.
      .         static void call_free_func_legacy(OPENSSL_sk_free_func func, void *ptr) {
      .           func(ptr);
      .         }
      .         
      .         void sk_pop_free(OPENSSL_STACK *sk, OPENSSL_sk_free_func free_func) {
      .           OPENSSL_sk_pop_free_ex(sk, call_free_func_legacy, free_func);
      .         }
      .         
 84,252 (0.0%)  size_t OPENSSL_sk_insert(OPENSSL_STACK *sk, void *p, size_t where) {
 24,072 (0.0%)    if (sk == NULL) {
      .             return 0;
      .           }
      .         
 48,144 (0.0%)    if (sk->num >= INT_MAX) {
      .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
      .             return 0;
      .           }
      .         
 84,252 (0.0%)    if (sk->num_alloc <= sk->num + 1) {
      .             // Attempt to double the size of the array.
  3,304 (0.0%)      size_t new_alloc = sk->num_alloc << 1;
  2,478 (0.0%)      size_t alloc_size = new_alloc * sizeof(void *);
      .             void **data;
      .         
      .             // If the doubling overflowed, try to increment.
  6,608 (0.0%)      if (new_alloc < sk->num_alloc || alloc_size / sizeof(void *) != new_alloc) {
      .               new_alloc = sk->num_alloc + 1;
      .               alloc_size = new_alloc * sizeof(void *);
      .             }
      .         
      .             // If the increment also overflowed, fail.
  6,608 (0.0%)      if (new_alloc < sk->num_alloc || alloc_size / sizeof(void *) != new_alloc) {
      .               return 0;
      .             }
      .         
  5,782 (0.0%)      data = OPENSSL_realloc(sk->data, alloc_size);
  1,652 (0.0%)      if (data == NULL) {
      .               return 0;
      .             }
      .         
  2,478 (0.0%)      sk->data = data;
  2,478 (0.0%)      sk->num_alloc = new_alloc;
      .           }
      .         
 48,144 (0.0%)    if (where >= sk->num) {
108,324 (0.0%)      sk->data[sk->num] = p;
      .           } else {
      .             OPENSSL_memmove(&sk->data[where + 1], &sk->data[where],
      .                             sizeof(void *) * (sk->num - where));
      .             sk->data[where] = p;
      .           }
      .         
 60,180 (0.0%)    sk->num++;
 24,072 (0.0%)    sk->sorted = 0;
      .         
 24,072 (0.0%)    return sk->num;
 24,072 (0.0%)  }
      .         
      .         void *OPENSSL_sk_delete(OPENSSL_STACK *sk, size_t where) {
      .           void *ret;
      .         
      .           if (!sk || where >= sk->num) {
      .             return NULL;
      .           }
      .         
-- line 229 ----------------------------------------
-- line 265 ----------------------------------------
      .               sk->data[new_num] = sk->data[i];
      .               new_num++;
      .             }
      .           }
      .           sk->num = new_num;
      .         }
      .         
      .         int OPENSSL_sk_find(const OPENSSL_STACK *sk, size_t *out_index, const void *p,
  2,336 (0.0%)                      OPENSSL_sk_call_cmp_func call_cmp_func) {
    584 (0.0%)    if (sk == NULL) {
      .             return 0;
      .           }
      .         
  1,168 (0.0%)    if (sk->comp == NULL) {
      .             // Use pointer equality when no comparison function has been set.
      .             for (size_t i = 0; i < sk->num; i++) {
      .               if (sk->data[i] == p) {
      .                 if (out_index) {
      .                   *out_index = i;
      .                 }
      .                 return 1;
      .               }
      .             }
      .             return 0;
      .           }
      .         
    584 (0.0%)    if (p == NULL) {
      .             return 0;
      .           }
      .         
  1,460 (0.0%)    if (!OPENSSL_sk_is_sorted(sk)) {
      .             for (size_t i = 0; i < sk->num; i++) {
      .               if (call_cmp_func(sk->comp, p, sk->data[i]) == 0) {
      .                 if (out_index) {
      .                   *out_index = i;
      .                 }
      .                 return 1;
      .               }
      .             }
      .             return 0;
      .           }
      .         
      .           // The stack is sorted, so binary search to find the element.
      .           //
      .           // |lo| and |hi| maintain a half-open interval of where the answer may be. All
      .           // indices such that |lo <= idx < hi| are candidates.
  1,168 (0.0%)    size_t lo = 0, hi = sk->num;
  6,232 (0.0%)    while (lo < hi) {
      .             // Bias |mid| towards |lo|. See the |r == 0| case below.
 13,504 (0.0%)      size_t mid = lo + (hi - lo - 1) / 2;
 10,128 (0.0%)      assert(lo <= mid && mid < hi);
 23,632 (0.0%)      int r = call_cmp_func(sk->comp, p, sk->data[mid]);
  3,376 (0.0%)      if (r > 0) {
  3,720 (0.0%)        lo = mid + 1;  // |mid| is too low.
  1,516 (0.0%)      } else if (r < 0) {
  2,274 (0.0%)        hi = mid;  // |mid| is too high.
      .             } else {
      .               // |mid| matches. However, this function returns the earliest match, so we
      .               // can only return if the range has size one.
      .               if (hi - lo == 1) {
      .                 if (out_index != NULL) {
      .                   *out_index = mid;
      .                 }
      .                 return 1;
-- line 328 ----------------------------------------
-- line 329 ----------------------------------------
      .               }
      .               // The sample is biased towards |lo|. |mid| can only be |hi - 1| if
      .               // |hi - lo| was one, so this makes forward progress.
      .               assert(mid + 1 < hi);
      .               hi = mid + 1;
      .             }
      .           }
      .         
    876 (0.0%)    assert(lo == hi);
    292 (0.0%)    return 0;  // Not found.
    584 (0.0%)  }
      .         
      .         int OPENSSL_sk_unshift(OPENSSL_STACK *sk, void *data) {
      .             return (int)OPENSSL_sk_insert(sk, data, 0);
      .         }
      .         
      .         void *OPENSSL_sk_shift(OPENSSL_STACK *sk) {
      .           if (sk == NULL) {
      .             return NULL;
      .           }
      .           if (sk->num == 0) {
      .             return NULL;
      .           }
      .           return OPENSSL_sk_delete(sk, 0);
      .         }
      .         
 72,216 (0.0%)  size_t OPENSSL_sk_push(OPENSSL_STACK *sk, void *p) {
 84,252 (0.0%)    return OPENSSL_sk_insert(sk, p, sk->num);
 24,072 (0.0%)  }
      .         
      .         void *OPENSSL_sk_pop(OPENSSL_STACK *sk) {
      .           if (sk == NULL) {
      .             return NULL;
      .           }
      .           if (sk->num == 0) {
      .             return NULL;
      .           }
-- line 365 ----------------------------------------
-- line 403 ----------------------------------------
      .           // |a| and |b| point to |void*| pointers which contain the actual values.
      .           const void *const *a_ptr = a;
      .           const void *const *b_ptr = b;
      .           return ctx->call_cmp_func(ctx->cmp_func, *a_ptr, *b_ptr);
      .         }
      .         #endif
      .         
      .         void OPENSSL_sk_sort(OPENSSL_STACK *sk,
  1,752 (0.0%)                       OPENSSL_sk_call_cmp_func call_cmp_func) {
  2,920 (0.0%)    if (sk == NULL || sk->comp == NULL || sk->sorted) {
      .             return;
      .           }
      .         
  1,168 (0.0%)    if (sk->num >= 2) {
      .         #if defined(_MSC_VER)
      .             // MSVC's |qsort_s| is different from the C11 one.
      .             // https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/qsort-s?view=msvc-170
      .             struct sort_compare_ctx ctx = {call_cmp_func, sk->comp};
      .             qsort_s(sk->data, sk->num, sizeof(void *), sort_compare, &ctx);
      .         #else
      .             // sk->comp is a function that takes pointers to pointers to elements, but
      .             // qsort take a comparison function that just takes pointers to elements.
      .             // However, since we're passing an array of pointers to qsort, we can just
      .             // cast the comparison function and everything works.
      .             //
      .             // TODO(davidben): This is undefined behavior, but the call is in libc so,
      .             // e.g., CFI does not notice. |qsort| is missing a void* parameter in its
      .             // callback, while no one defines |qsort_r| or |qsort_s| consistently. See
      .             // https://stackoverflow.com/a/39561369
    864 (0.0%)      int (*comp_func)(const void *, const void *) =
      .                 (int (*)(const void *, const void *))(sk->comp);
  2,592 (0.0%)      qsort(sk->data, sk->num, sizeof(void *), comp_func);
      .         #endif
      .           }
    876 (0.0%)    sk->sorted = 1;
    584 (0.0%)  }
      .         
  1,168 (0.0%)  int OPENSSL_sk_is_sorted(const OPENSSL_STACK *sk) {
    584 (0.0%)    if (!sk) {
      .             return 1;
      .           }
      .           // Zero- and one-element lists are always sorted.
  1,752 (0.0%)    return sk->sorted || (sk->comp != NULL && sk->num < 2);
    584 (0.0%)  }
      .         
      .         OPENSSL_sk_cmp_func OPENSSL_sk_set_cmp_func(OPENSSL_STACK *sk,
      .                                                     OPENSSL_sk_cmp_func comp) {
      .           OPENSSL_sk_cmp_func old = sk->comp;
      .         
      .           if (sk->comp != comp) {
      .             sk->sorted = 0;
      .           }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 69 ----------------------------------------
      .         #include "../internal.h"
      .         #include "internal.h"
      .         
      .         
      .         int X509_issuer_name_cmp(const X509 *a, const X509 *b) {
      .           return (X509_NAME_cmp(a->cert_info->issuer, b->cert_info->issuer));
      .         }
      .         
411,240 (0.1%)  int X509_subject_name_cmp(const X509 *a, const X509 *b) {
616,860 (0.2%)    return (X509_NAME_cmp(a->cert_info->subject, b->cert_info->subject));
137,080 (0.0%)  }
      .         
      .         int X509_CRL_cmp(const X509_CRL *a, const X509_CRL *b) {
      .           return (X509_NAME_cmp(a->crl->issuer, b->crl->issuer));
      .         }
      .         
      .         int X509_CRL_match(const X509_CRL *a, const X509_CRL *b) {
      .           return OPENSSL_memcmp(a->crl_hash, b->crl_hash, SHA256_DIGEST_LENGTH);
      .         }
-- line 87 ----------------------------------------
-- line 134 ----------------------------------------
      .           // retain the old OpenSSL behavior, which was to ignore the error. See
      .           // https://crbug.com/boringssl/355.
      .           x509v3_cache_extensions((X509 *)a);
      .           x509v3_cache_extensions((X509 *)b);
      .         
      .           return OPENSSL_memcmp(a->cert_hash, b->cert_hash, SHA256_DIGEST_LENGTH);
      .         }
      .         
411,240 (0.1%)  int X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b) {
      .           int ret;
      .         
      .           // Ensure canonical encoding is present and up to date
      .         
548,320 (0.2%)    if (!a->canon_enc || a->modified) {
      .             ret = i2d_X509_NAME((X509_NAME *)a, NULL);
      .             if (ret < 0) {
      .               return -2;
      .             }
      .           }
      .         
548,320 (0.2%)    if (!b->canon_enc || b->modified) {
      .             ret = i2d_X509_NAME((X509_NAME *)b, NULL);
      .             if (ret < 0) {
      .               return -2;
      .             }
      .           }
      .         
411,240 (0.1%)    ret = a->canon_enclen - b->canon_enclen;
      .         
137,080 (0.0%)    if (ret) {
110,632 (0.0%)      return ret;
      .           }
      .         
132,240 (0.0%)    return OPENSSL_memcmp(a->canon_enc, b->canon_enc, a->canon_enclen);
137,080 (0.0%)  }
      .         
      .         uint32_t X509_NAME_hash(X509_NAME *x) {
      .           // Make sure the X509_NAME structure contains a valid cached encoding.
      .           if (i2d_X509_NAME(x, NULL) < 0) {
      .             return 0;
      .           }
      .         
      .           uint8_t md[SHA_DIGEST_LENGTH];
-- line 176 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 74 ----------------------------------------
      .         static int X509_OBJECT_up_ref_count(X509_OBJECT *a);
      .         
      .         static X509_LOOKUP *X509_LOOKUP_new(const X509_LOOKUP_METHOD *method,
      .                                             X509_STORE *store);
      .         static int X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,
      .                                           X509_OBJECT *ret);
      .         
      .         static X509_LOOKUP *X509_LOOKUP_new(const X509_LOOKUP_METHOD *method,
     24 (0.0%)                                      X509_STORE *store) {
     12 (0.0%)    X509_LOOKUP *ret = OPENSSL_zalloc(sizeof(X509_LOOKUP));
      8 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
     12 (0.0%)    ret->method = method;
     12 (0.0%)    ret->store_ctx = store;
     30 (0.0%)    if ((method->new_item != NULL) && !method->new_item(ret)) {
      .             OPENSSL_free(ret);
      .             return NULL;
      .           }
      4 (0.0%)    return ret;
      8 (0.0%)  }
      .         
     10 (0.0%)  void X509_LOOKUP_free(X509_LOOKUP *ctx) {
      4 (0.0%)    if (ctx == NULL) {
      .             return;
      .           }
     18 (0.0%)    if (ctx->method != NULL && ctx->method->free != NULL) {
      6 (0.0%)      (*ctx->method->free)(ctx);
      .           }
      8 (0.0%)    OPENSSL_free(ctx);
      4 (0.0%)  }
      .         
      .         int X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc, long argl,
     36 (0.0%)                       char **ret) {
     16 (0.0%)    if (ctx->method == NULL) {
      .             return -1;
      .           }
     20 (0.0%)    if (ctx->method->ctrl != NULL) {
     48 (0.0%)      return ctx->method->ctrl(ctx, cmd, argc, argl, ret);
      .           } else {
      .             return 1;
      .           }
      8 (0.0%)  }
      .         
      .         static int X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,
      .                                           X509_OBJECT *ret) {
      .           if (ctx->method == NULL || ctx->method->get_by_subject == NULL) {
      .             return 0;
      .           }
      .           // Note |get_by_subject| leaves |ret| in an inconsistent state. It has
      .           // pointers to an |X509| or |X509_CRL|, but has not bumped the refcount yet.
      .           // For now, the caller is expected to fix this, but ideally we'd fix the
      .           // |X509_LOOKUP| convention itself.
      .           return ctx->method->get_by_subject(ctx, type, name, ret) > 0;
      .         }
      .         
411,240 (0.1%)  static int x509_object_cmp(const X509_OBJECT *a, const X509_OBJECT *b) {
411,240 (0.1%)    int ret = a->type - b->type;
137,080 (0.0%)    if (ret) {
      .             return ret;
      .           }
274,160 (0.1%)    switch (a->type) {
      .             case X509_LU_X509:
548,320 (0.2%)        return X509_subject_name_cmp(a->data.x509, b->data.x509);
      .             case X509_LU_CRL:
      .               return X509_CRL_cmp(a->data.crl, b->data.crl);
      .             default:
      .               // abort();
      .               return 0;
      .           }
137,080 (0.0%)  }
      .         
      .         static int x509_object_cmp_sk(const X509_OBJECT *const *a,
411,240 (0.1%)                                const X509_OBJECT *const *b) {
479,780 (0.2%)    return x509_object_cmp(*a, *b);
137,080 (0.0%)  }
      .         
      .         static CRYPTO_EX_DATA_CLASS g_ex_data_class =
      .             CRYPTO_EX_DATA_CLASS_INIT_WITH_APP_DATA;
      .         
      8 (0.0%)  X509_STORE *X509_STORE_new(void) {
      6 (0.0%)    X509_STORE *ret = OPENSSL_zalloc(sizeof(X509_STORE));
      4 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
      4 (0.0%)    ret->references = 1;
      8 (0.0%)    CRYPTO_MUTEX_init(&ret->objs_lock);
      8 (0.0%)    CRYPTO_new_ex_data(&ret->ex_data);
     10 (0.0%)    ret->objs = sk_X509_OBJECT_new(x509_object_cmp_sk);
      6 (0.0%)    ret->get_cert_methods = sk_X509_LOOKUP_new_null();
      6 (0.0%)    ret->param = X509_VERIFY_PARAM_new();
     12 (0.0%)    if (ret->objs == NULL ||
      8 (0.0%)        ret->get_cert_methods == NULL ||
      4 (0.0%)        ret->param == NULL) {
      .             X509_STORE_free(ret);
      .             return NULL;
      .           }
      .         
      2 (0.0%)    return ret;
      4 (0.0%)  }
      .         
      .         int X509_STORE_lock(X509_STORE *v) {
      .             if (v == NULL) {
      .               return 0;
      .             }
      .             CRYPTO_MUTEX_lock_write(&v->objs_lock);
      .             return 1;
      .         }
-- line 183 ----------------------------------------
-- line 190 ----------------------------------------
      .             return 1;
      .         }
      .         
      .         int X509_STORE_up_ref(X509_STORE *store) {
      .           CRYPTO_refcount_inc(&store->references);
      .           return 1;
      .         }
      .         
      5 (0.0%)  void X509_STORE_free(X509_STORE *vfy) {
      2 (0.0%)    if (vfy == NULL) {
      .             return;
      .           }
      .         
      6 (0.0%)    if (!CRYPTO_refcount_dec_and_test_zero(&vfy->references)) {
      .             return;
      .           }
      .         
      4 (0.0%)    CRYPTO_MUTEX_cleanup(&vfy->objs_lock);
      7 (0.0%)    CRYPTO_free_ex_data(&g_ex_data_class, vfy, &vfy->ex_data);
      6 (0.0%)    sk_X509_LOOKUP_pop_free(vfy->get_cert_methods, X509_LOOKUP_free);
      6 (0.0%)    sk_X509_OBJECT_pop_free(vfy->objs, X509_OBJECT_free);
      4 (0.0%)    X509_VERIFY_PARAM_free(vfy->param);
      4 (0.0%)    OPENSSL_free(vfy);
      2 (0.0%)  }
      .         
     24 (0.0%)  X509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, const X509_LOOKUP_METHOD *m) {
     12 (0.0%)    STACK_OF(X509_LOOKUP) *sk = v->get_cert_methods;
     40 (0.0%)    for (size_t i = 0; i < sk_X509_LOOKUP_num(sk); i++) {
     12 (0.0%)      X509_LOOKUP *lu = sk_X509_LOOKUP_value(sk, i);
      8 (0.0%)      if (m == lu->method) {
      .               return lu;
      .             }
      .           }
      .         
     24 (0.0%)    X509_LOOKUP *lu = X509_LOOKUP_new(m, v);
     40 (0.0%)    if (lu == NULL || !sk_X509_LOOKUP_push(v->get_cert_methods, lu)) {
      .             X509_LOOKUP_free(lu);
      .             return NULL;
      .           }
      .         
      4 (0.0%)    return lu;
      8 (0.0%)  }
      .         
      .         int X509_STORE_CTX_get_by_subject(X509_STORE_CTX *vs, int type, X509_NAME *name,
      .                                           X509_OBJECT *ret) {
      .           X509_STORE *ctx = vs->ctx;
      .           X509_OBJECT stmp;
      .           CRYPTO_MUTEX_lock_write(&ctx->objs_lock);
      .           X509_OBJECT *tmp = X509_OBJECT_retrieve_by_subject(ctx->objs, type, name);
      .           CRYPTO_MUTEX_unlock_write(&ctx->objs_lock);
-- line 239 ----------------------------------------
-- line 256 ----------------------------------------
      .           ret->type = tmp->type;
      .           ret->data.ptr = tmp->data.ptr;
      .         
      .           X509_OBJECT_up_ref_count(ret);
      .         
      .           return 1;
      .         }
      .         
  2,044 (0.0%)  static int x509_store_add(X509_STORE *ctx, void *x, int is_crl) {
    584 (0.0%)    if (x == NULL) {
      .             return 0;
      .           }
      .         
    584 (0.0%)    X509_OBJECT *const obj = X509_OBJECT_new();
    584 (0.0%)    if (obj == NULL) {
      .             return 0;
      .           }
      .         
    584 (0.0%)    if (is_crl) {
      .             obj->type = X509_LU_CRL;
      .             obj->data.crl = (X509_CRL *)x;
      .           } else {
    584 (0.0%)      obj->type = X509_LU_X509;
    876 (0.0%)      obj->data.x509 = (X509 *)x;
      .           }
    876 (0.0%)    X509_OBJECT_up_ref_count(obj);
      .         
  1,168 (0.0%)    CRYPTO_MUTEX_lock_write(&ctx->objs_lock);
      .         
    292 (0.0%)    int ret = 1;
    292 (0.0%)    int added = 0;
      .           // Duplicates are silently ignored
  2,336 (0.0%)    if (!X509_OBJECT_retrieve_match(ctx->objs, obj)) {
  3,504 (0.0%)      ret = added = (sk_X509_OBJECT_push(ctx->objs, obj) != 0);
      .           }
      .         
  1,168 (0.0%)    CRYPTO_MUTEX_unlock_write(&ctx->objs_lock);
      .         
    584 (0.0%)    if (!added) {
      .             X509_OBJECT_free(obj);
      .           }
      .         
    292 (0.0%)    return ret;
    584 (0.0%)  }
      .         
  1,752 (0.0%)  int X509_STORE_add_cert(X509_STORE *ctx, X509 *x) {
  1,752 (0.0%)    return x509_store_add(ctx, x, /*is_crl=*/0);
    584 (0.0%)  }
      .         
      .         int X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x) {
      .           return x509_store_add(ctx, x, /*is_crl=*/1);
      .         }
      .         
    876 (0.0%)  X509_OBJECT *X509_OBJECT_new(void) {
    584 (0.0%)    return OPENSSL_zalloc(sizeof(X509_OBJECT));
    584 (0.0%)  }
      .         
    730 (0.0%)  void X509_OBJECT_free(X509_OBJECT *obj) {
    292 (0.0%)    if (obj == NULL) {
      .             return;
      .           }
    438 (0.0%)    X509_OBJECT_free_contents(obj);
    584 (0.0%)    OPENSSL_free(obj);
    292 (0.0%)  }
      .         
  1,460 (0.0%)  static int X509_OBJECT_up_ref_count(X509_OBJECT *a) {
  1,168 (0.0%)    switch (a->type) {
      .             case X509_LU_X509:
  1,168 (0.0%)        X509_up_ref(a->data.x509);
    292 (0.0%)        break;
      .             case X509_LU_CRL:
      .               X509_CRL_up_ref(a->data.crl);
      .               break;
      .           }
    292 (0.0%)    return 1;
    584 (0.0%)  }
      .         
    730 (0.0%)  void X509_OBJECT_free_contents(X509_OBJECT *a) {
    584 (0.0%)    switch (a->type) {
      .             case X509_LU_X509:
    584 (0.0%)        X509_free(a->data.x509);
    146 (0.0%)        break;
      .             case X509_LU_CRL:
      .               X509_CRL_free(a->data.crl);
      .               break;
      .           }
      .         
    730 (0.0%)    OPENSSL_memset(a, 0, sizeof(X509_OBJECT));
    438 (0.0%)  }
      .         
      .         int X509_OBJECT_get_type(const X509_OBJECT *a) { return a->type; }
      .         
      .         X509 *X509_OBJECT_get0_X509(const X509_OBJECT *a) {
      .           if (a == NULL || a->type != X509_LU_X509) {
      .             return NULL;
      .           }
      .           return a->data.x509;
-- line 352 ----------------------------------------
-- line 519 ----------------------------------------
      .               return NULL;
      .             }
      .           }
      .           CRYPTO_MUTEX_unlock_write(&ctx->ctx->objs_lock);
      .           return sk;
      .         }
      .         
      .         static X509_OBJECT *X509_OBJECT_retrieve_match(STACK_OF(X509_OBJECT) *h,
  2,628 (0.0%)                                                 X509_OBJECT *x) {
    876 (0.0%)    sk_X509_OBJECT_sort(h);
      .           size_t idx;
  2,336 (0.0%)    if (!sk_X509_OBJECT_find_awslc(h, &idx, x)) {
    584 (0.0%)      return NULL;
      .           }
      .           if ((x->type != X509_LU_X509) && (x->type != X509_LU_CRL)) {
      .             return sk_X509_OBJECT_value(h, idx);
      .           }
      .           for (size_t i = idx; i < sk_X509_OBJECT_num(h); i++) {
      .             X509_OBJECT *obj = sk_X509_OBJECT_value(h, i);
      .             if (x509_object_cmp(obj, x)) {
      .               return NULL;
-- line 539 ----------------------------------------
-- line 546 ----------------------------------------
      .               if (!X509_CRL_match(obj->data.crl, x->data.crl)) {
      .                 return obj;
      .               }
      .             } else {
      .               return obj;
      .             }
      .           }
      .           return NULL;
  1,460 (0.0%)  }
      .         
      .         // Try to get issuer certificate from store. Due to limitations of the API
      .         // this can only retrieve a single certificate matching a given subject name.
      .         // However it will fill the cache with all matching certificates, so we can
      .         // examine the cache for all matches. Return values are: 1 lookup
      .         // successful.  0 certificate not found. -1 some other error.
      .         int X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x) {
      .           X509_NAME *xn;
-- line 562 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x_name.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 67 ----------------------------------------
      .         #include <openssl/x509.h>
      .         
      .         #include "../asn1/internal.h"
      .         #include "../internal.h"
      .         #include "internal.h"
      .         
      .         
      .         typedef STACK_OF(X509_NAME_ENTRY) STACK_OF_X509_NAME_ENTRY;
142,376 (0.1%)  DEFINE_STACK_OF(STACK_OF_X509_NAME_ENTRY)
      .         
      .         // Maximum length of X509_NAME: much larger than anything we should
      .         // ever see in practice.
      .         
      .         #define X509_NAME_MAX (1024 * 1024)
      .         
      .         static int x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                     long len, const ASN1_ITEM *it, int tag, int aclass,
-- line 83 ----------------------------------------
-- line 94 ----------------------------------------
      .         static int i2d_name_canon(STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname,
      .                                   unsigned char **in);
      .         
      .         ASN1_SEQUENCE(X509_NAME_ENTRY) = {
      .             ASN1_SIMPLE(X509_NAME_ENTRY, object, ASN1_OBJECT),
      .             ASN1_SIMPLE(X509_NAME_ENTRY, value, ASN1_PRINTABLE),
      .         } ASN1_SEQUENCE_END(X509_NAME_ENTRY)
      .         
 54,288 (0.0%)  IMPLEMENT_ASN1_FUNCTIONS_const(X509_NAME_ENTRY)
      .         IMPLEMENT_ASN1_DUP_FUNCTION_const(X509_NAME_ENTRY)
      .         
      .         // For the "Name" type we need a SEQUENCE OF { SET OF X509_NAME_ENTRY } so
      .         // declare two template wrappers for this
      .         
      .         ASN1_ITEM_TEMPLATE(X509_NAME_ENTRIES) = ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SET_OF,
      .                                                                       0, RDNS,
      .                                                                       X509_NAME_ENTRY)
-- line 110 ----------------------------------------
-- line 129 ----------------------------------------
      .         };
      .         
      .         IMPLEMENT_EXTERN_ASN1(X509_NAME, V_ASN1_SEQUENCE, x509_name_ff)
      .         
      .         IMPLEMENT_ASN1_FUNCTIONS(X509_NAME)
      .         
      .         IMPLEMENT_ASN1_DUP_FUNCTION(X509_NAME)
      .         
  7,008 (0.0%)  static int x509_name_ex_new(ASN1_VALUE **val, const ASN1_ITEM *it) {
  1,168 (0.0%)    X509_NAME *ret = NULL;
  3,504 (0.0%)    ret = OPENSSL_malloc(sizeof(X509_NAME));
  2,336 (0.0%)    if (!ret) {
      .             goto memerr;
      .           }
  8,176 (0.0%)    if ((ret->entries = sk_X509_NAME_ENTRY_new_null()) == NULL) {
      .             goto memerr;
      .           }
  8,176 (0.0%)    if ((ret->bytes = BUF_MEM_new()) == NULL) {
      .             goto memerr;
      .           }
  2,336 (0.0%)    ret->canon_enc = NULL;
  2,336 (0.0%)    ret->canon_enclen = 0;
  2,336 (0.0%)    ret->modified = 1;
  3,504 (0.0%)    *val = (ASN1_VALUE *)ret;
  2,336 (0.0%)    return 1;
      .         
      .         memerr:
      .           if (ret) {
      .             if (ret->entries) {
      .               sk_X509_NAME_ENTRY_free(ret->entries);
      .             }
      .             OPENSSL_free(ret);
      .           }
      .           return 0;
  2,336 (0.0%)  }
      .         
  5,256 (0.0%)  static void x509_name_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
      .           X509_NAME *a;
  5,256 (0.0%)    if (!pval || !*pval) {
      .             return;
      .           }
  2,628 (0.0%)    a = (X509_NAME *)*pval;
      .         
  3,504 (0.0%)    BUF_MEM_free(a->bytes);
  5,256 (0.0%)    sk_X509_NAME_ENTRY_pop_free(a->entries, X509_NAME_ENTRY_free);
  3,504 (0.0%)    if (a->canon_enc) {
  1,168 (0.0%)      OPENSSL_free(a->canon_enc);
      .           }
  2,628 (0.0%)    OPENSSL_free(a);
  2,628 (0.0%)    *pval = NULL;
  1,752 (0.0%)  }
      .         
 10,440 (0.0%)  static void local_sk_X509_NAME_ENTRY_free(STACK_OF(X509_NAME_ENTRY) *ne) {
  6,264 (0.0%)    sk_X509_NAME_ENTRY_free(ne);
  6,264 (0.0%)  }
      .         
 10,440 (0.0%)  static void local_sk_X509_NAME_ENTRY_pop_free(STACK_OF(X509_NAME_ENTRY) *ne) {
 10,440 (0.0%)    sk_X509_NAME_ENTRY_pop_free(ne, X509_NAME_ENTRY_free);
  6,264 (0.0%)  }
      .         
      .         static int x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                     long len, const ASN1_ITEM *it, int tag, int aclass,
  9,928 (0.0%)                              char opt, ASN1_TLC *ctx) {
  1,752 (0.0%)    const unsigned char *p = *in, *q;
    584 (0.0%)    STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname = NULL;
    584 (0.0%)    X509_NAME *nm = NULL;
      .           size_t i, j;
      .           int ret;
      .           STACK_OF(X509_NAME_ENTRY) *entries;
      .           X509_NAME_ENTRY *entry;
      .           // Bound the size of an X509_NAME we are willing to parse.
  1,168 (0.0%)    if (len > X509_NAME_MAX) {
      .             len = X509_NAME_MAX;
      .           }
  1,168 (0.0%)    q = p;
      .         
      .           // Get internal representation of Name
    584 (0.0%)    ASN1_VALUE *intname_val = NULL;
  8,760 (0.0%)    ret = ASN1_item_ex_d2i(&intname_val, &p, len,
      .                                  ASN1_ITEM_rptr(X509_NAME_INTERNAL), tag, aclass, opt,
      .                                  ctx);
  1,168 (0.0%)    if (ret <= 0) {
      .             return ret;
      .           }
  1,168 (0.0%)    intname = (STACK_OF(STACK_OF_X509_NAME_ENTRY) *)intname_val;
      .         
  2,336 (0.0%)    if (*val) {
  2,336 (0.0%)      x509_name_ex_free(val, NULL);
      .           }
    584 (0.0%)    ASN1_VALUE *nm_val = NULL;
  3,504 (0.0%)    if (!x509_name_ex_new(&nm_val, NULL)) {
      .             goto err;
      .           }
  1,168 (0.0%)    nm = (X509_NAME *)nm_val;
      .           // We've decoded it: now cache encoding
  5,840 (0.0%)    if (!BUF_MEM_grow(nm->bytes, p - q)) {
      .             goto err;
      .           }
  5,840 (0.0%)    OPENSSL_memcpy(nm->bytes->data, q, p - q);
      .         
      .           // Convert internal representation to X509_NAME structure
 16,616 (0.0%)    for (i = 0; i < sk_STACK_OF_X509_NAME_ENTRY_num(intname); i++) {
 12,528 (0.0%)      entries = sk_STACK_OF_X509_NAME_ENTRY_value(intname, i);
 27,144 (0.0%)      for (j = 0; j < sk_X509_NAME_ENTRY_num(entries); j++) {
 12,528 (0.0%)        entry = sk_X509_NAME_ENTRY_value(entries, j);
  8,352 (0.0%)        entry->set = (int)i;
 16,704 (0.0%)        if (!sk_X509_NAME_ENTRY_push(nm->entries, entry)) {
      .                 goto err;
      .               }
 12,528 (0.0%)        (void)sk_X509_NAME_ENTRY_set(entries, j, NULL);
      .             }
      .           }
  2,336 (0.0%)    ret = x509_name_canon(nm);
  1,168 (0.0%)    if (!ret) {
      .             goto err;
      .           }
  2,920 (0.0%)    sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname, local_sk_X509_NAME_ENTRY_free);
  1,168 (0.0%)    nm->modified = 0;
  1,752 (0.0%)    *val = (ASN1_VALUE *)nm;
  1,752 (0.0%)    *in = p;
  1,168 (0.0%)    return ret;
      .         err:
      .           X509_NAME_free(nm);
      .           sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname,
      .                                                local_sk_X509_NAME_ENTRY_pop_free);
      .           OPENSSL_PUT_ERROR(X509, ERR_R_ASN1_LIB);
      .           return 0;
  2,920 (0.0%)  }
      .         
      .         static int x509_name_ex_i2d(ASN1_VALUE **val, unsigned char **out,
      .                                     const ASN1_ITEM *it, int tag, int aclass) {
      .           X509_NAME *a = (X509_NAME *)*val;
      .           if (a->modified && (!x509_name_encode(a) || !x509_name_canon(a))) {
      .             return -1;
      .           }
      .           int ret = a->bytes->length;
-- line 264 ----------------------------------------
-- line 324 ----------------------------------------
      .         // it all strings are converted to UTF8, leading, trailing and multiple
      .         // spaces collapsed, converted to lower case and the leading SEQUENCE header
      .         // removed. In future we could also normalize the UTF8 too. By doing this
      .         // comparison of Name structures can be rapidly perfomed by just using
      .         // OPENSSL_memcmp() of the canonical encoding. By omitting the leading SEQUENCE
      .         // name constraints of type dirName can also be checked with a simple
      .         // OPENSSL_memcmp().
      .         
  4,672 (0.0%)  static int x509_name_canon(X509_NAME *a) {
      .           unsigned char *p;
    584 (0.0%)    STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname = NULL;
    584 (0.0%)    STACK_OF(X509_NAME_ENTRY) *entries = NULL;
    584 (0.0%)    X509_NAME_ENTRY *entry, *tmpentry = NULL;
  1,168 (0.0%)    int set = -1, ret = 0, len;
      .           size_t i;
      .         
  2,336 (0.0%)    if (a->canon_enc) {
      .             OPENSSL_free(a->canon_enc);
      .             a->canon_enc = NULL;
      .           }
      .           // Special case: empty X509_NAME => null encoding
  3,504 (0.0%)    if (sk_X509_NAME_ENTRY_num(a->entries) == 0) {
      .             a->canon_enclen = 0;
      .             return 1;
      .           }
  1,168 (0.0%)    intname = sk_STACK_OF_X509_NAME_ENTRY_new_null();
  1,168 (0.0%)    if (!intname) {
      .             goto err;
      .           }
 19,288 (0.0%)    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {
 14,616 (0.0%)      entry = sk_X509_NAME_ENTRY_value(a->entries, i);
  8,352 (0.0%)      if (entry->set != set) {
  4,176 (0.0%)        entries = sk_X509_NAME_ENTRY_new_null();
  4,176 (0.0%)        if (!entries) {
      .                 goto err;
      .               }
 14,616 (0.0%)        if (!sk_STACK_OF_X509_NAME_ENTRY_push(intname, entries)) {
      .                 sk_X509_NAME_ENTRY_free(entries);
      .                 goto err;
      .               }
  6,264 (0.0%)        set = entry->set;
      .             }
  4,176 (0.0%)      tmpentry = X509_NAME_ENTRY_new();
  4,176 (0.0%)      if (tmpentry == NULL) {
      .               goto err;
      .             }
 12,528 (0.0%)      tmpentry->object = OBJ_dup(entry->object);
 18,792 (0.0%)      if (!asn1_string_canon(tmpentry->value, entry->value)) {
      .               goto err;
      .             }
 14,616 (0.0%)      if (!sk_X509_NAME_ENTRY_push(entries, tmpentry)) {
      .               goto err;
      .             }
  2,088 (0.0%)      tmpentry = NULL;
      .           }
      .         
      .           // Finally generate encoding
      .         
  2,920 (0.0%)    len = i2d_name_canon(intname, NULL);
  1,168 (0.0%)    if (len < 0) {
      .             goto err;
      .           }
  1,752 (0.0%)    a->canon_enclen = len;
      .         
  3,504 (0.0%)    p = OPENSSL_malloc(a->canon_enclen);
      .         
  1,752 (0.0%)    if (!p) {
      .             goto err;
      .           }
      .         
  1,752 (0.0%)    a->canon_enc = p;
      .         
  2,920 (0.0%)    i2d_name_canon(intname, &p);
      .         
  1,168 (0.0%)    ret = 1;
      .         
      .         err:
      .         
  1,168 (0.0%)    if (tmpentry) {
      .             X509_NAME_ENTRY_free(tmpentry);
      .           }
  1,168 (0.0%)    if (intname) {
  2,920 (0.0%)      sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname,
      .                                                  local_sk_X509_NAME_ENTRY_pop_free);
      .           }
    584 (0.0%)    return ret;
  2,920 (0.0%)  }
      .         
      .         // Bitmap of all the types of string that will be canonicalized.
      .         
      .         #define ASN1_MASK_CANON                                            \
      .           (B_ASN1_UTF8STRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | \
      .            B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING |  \
      .            B_ASN1_VISIBLESTRING)
      .         
 12,528 (0.0%)  static int asn1_string_canon(ASN1_STRING *out, ASN1_STRING *in) {
      .           unsigned char *to, *from;
      .           int len, i;
      .         
      .           // If type not in bitmask just copy string across
 14,616 (0.0%)    if (!(ASN1_tag2bit(in->type) & ASN1_MASK_CANON)) {
      .             if (!ASN1_STRING_copy(out, in)) {
      .               return 0;
      .             }
      .             return 1;
      .           }
      .         
  4,176 (0.0%)    out->type = V_ASN1_UTF8STRING;
 16,704 (0.0%)    out->length = ASN1_STRING_to_UTF8(&out->data, in);
  8,352 (0.0%)    if (out->length == -1) {
      .             return 0;
      .           }
      .         
  6,264 (0.0%)    to = out->data;
  4,176 (0.0%)    from = to;
      .         
  6,264 (0.0%)    len = out->length;
      .         
      .           // Convert string in place to canonical form.
      .         
      .           // Ignore leading spaces
 20,880 (0.0%)    while ((len > 0) && OPENSSL_isspace(*from)) {
      .             from++;
      .             len--;
      .           }
      .         
 10,440 (0.0%)    to = from + len;
      .         
      .           // Ignore trailing spaces
 22,968 (0.0%)    while ((len > 0) && OPENSSL_isspace(to[-1])) {
      .             to--;
      .             len--;
      .           }
      .         
  6,264 (0.0%)    to = out->data;
      .         
  2,088 (0.0%)    i = 0;
108,168 (0.0%)    while (i < len) {
      .             // Collapse multiple spaces
232,904 (0.1%)      if (OPENSSL_isspace(*from)) {
      .               // Copy one space across
 12,848 (0.0%)        *to++ = ' ';
      .               // Ignore subsequent spaces. Note: don't need to check len here
      .               // because we know the last character is a non-space so we can't
      .               // overflow.
      .               do {
  3,212 (0.0%)          from++;
  3,212 (0.0%)          i++;
 25,696 (0.0%)        } while (OPENSSL_isspace(*from));
      .             } else {
330,660 (0.1%)        *to++ = OPENSSL_tolower(*from);
 30,060 (0.0%)        from++;
 30,060 (0.0%)        i++;
      .             }
      .           }
      .         
 12,528 (0.0%)    out->length = to - out->data;
      .         
  2,088 (0.0%)    return 1;
  4,176 (0.0%)  }
      .         
      .         static int i2d_name_canon(STACK_OF(STACK_OF_X509_NAME_ENTRY) *_intname,
 10,512 (0.0%)                            unsigned char **in) {
      .           int len, ltmp;
      .           size_t i;
      .           ASN1_VALUE *v;
  2,336 (0.0%)    STACK_OF(ASN1_VALUE) *intname = (STACK_OF(ASN1_VALUE) *)_intname;
      .         
  1,168 (0.0%)    len = 0;
 33,232 (0.0%)    for (i = 0; i < sk_ASN1_VALUE_num(intname); i++) {
 25,056 (0.0%)      v = sk_ASN1_VALUE_value(intname, i);
 33,408 (0.0%)      ltmp = ASN1_item_ex_i2d(&v, in, ASN1_ITEM_rptr(X509_NAME_ENTRIES),
      .                                     /*tag=*/-1, /*aclass=*/0);
  8,352 (0.0%)      if (ltmp < 0) {
      .               return ltmp;
      .             }
  8,352 (0.0%)      len += ltmp;
      .           }
  1,168 (0.0%)    return len;
  5,840 (0.0%)  }
      .         
      .         int X509_NAME_set(X509_NAME **xn, X509_NAME *name) {
      .           if ((name = X509_NAME_dup(name)) == NULL) {
      .             return 0;
      .           }
      .           X509_NAME_free(*xn);
      .           *xn = name;
      .           return 1;
-- line 511 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir_________________ 

257,401,813 (91.2%)    annotated: files known & above threshold & readable, line numbers known
          0            annotated: files known & above threshold & readable, line numbers unknown
          0          unannotated: files known & above threshold & two or more non-identical
 18,286,557  (6.5%)  unannotated: files known & above threshold & unreadable 
  6,110,169  (2.2%)  unannotated: files known & below threshold
    358,392  (0.1%)  unannotated: files unknown

