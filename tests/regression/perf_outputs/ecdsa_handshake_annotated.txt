--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate cachegrind.out.ecdsa_handshake
Command:          target/debug/ecdsa_handshake
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir_________________ 

10,737,965 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir______________________  file:function

< 1,551,316 (14.4%, 14.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S:
    676,336  (6.3%)           __ecp_nistz256_mul_montq
    475,750  (4.4%)           __ecp_nistz256_sqr_montq
     95,732  (0.9%)           aws_lc_0_19_0_ecp_nistz256_point_double
     53,590  (0.5%)           __ecp_nistz256_sub_fromq
     50,496  (0.5%)           __ecp_nistz256_mul_by_2q
     43,512  (0.4%)           aws_lc_0_19_0_ecp_nistz256_avx2_select_w7
     38,280  (0.4%)           aws_lc_0_19_0_ecp_nistz256_point_add
     25,550  (0.2%)           aws_lc_0_19_0_ecp_nistz256_sqr_mont
     25,248  (0.2%)           __ecp_nistz256_add_toq
     22,360  (0.2%)           ecp_nistz256_avx2_select_w5
     19,224  (0.2%)           aws_lc_0_19_0_ecp_nistz256_point_add_affine
     17,138  (0.2%)           __ecp_nistz256_subq

< 1,120,875 (10.4%, 24.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/third_party/s2n-bignum/x86_att/p384/bignum_montmul_p384_alt.S:???

< 1,041,951  (9.7%, 34.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h:
    479,346  (4.5%)           constant_time_select_w
    366,808  (3.4%)           value_barrier_w
     62,006  (0.6%)           constant_time_is_zero_w
     32,176  (0.3%)           OPENSSL_memcpy
     31,514  (0.3%)           constant_time_msb_w
     22,832  (0.2%)           CRYPTO_bswap4
     19,998  (0.2%)           CRYPTO_store_u32_be

<   918,027  (8.5%, 43.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/third_party/s2n-bignum/x86_att/p384/bignum_montsqr_p384_alt.S:???

<   844,509  (7.9%, 51.0%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont.S:aws_lc_0_19_0_bn_mul_mont

<   585,323  (5.5%, 56.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha256-x86_64.S:
    582,837  (5.4%)           sha256_block_data_order_avx

<   534,934  (5.0%, 61.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/p384.c:
    391,776  (3.6%)           p384_felem_cmovznz
     49,742  (0.5%)           p384_select_point_affine
     21,130  (0.2%)           ec_GFp_nistp384_point_mul_public

<   368,493  (3.4%, 64.9%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c:
    231,149  (2.2%)           s2n_stuffer_validate
     32,580  (0.3%)           s2n_stuffer_skip_write
     30,402  (0.3%)           s2n_stuffer_reserve_space
     24,530  (0.2%)           s2n_stuffer_write_bytes

<   344,547  (3.2%, 68.1%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c:
    330,349  (3.1%)           s2n_blob_validate

<   337,233  (3.1%, 71.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/ec_nistp.c:
    192,456  (1.8%)           cmovznz
     79,200  (0.7%)           aws_lc_0_19_0_ec_nistp_point_double
     65,577  (0.6%)           aws_lc_0_19_0_ec_nistp_point_add

<   196,053  (1.8%, 73.0%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/aes/../cpucap/internal.h:
     66,924  (0.6%)           CRYPTO_is_BMI2_capable
     66,924  (0.6%)           CRYPTO_is_ADX_capable
     61,270  (0.6%)           OPENSSL_ia32cap_get

<   188,494  (1.8%, 74.8%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/../../../third_party/s2n-bignum/include/s2n-bignum_aws-lc.h:
     73,008  (0.7%)           use_s2n_bignum_alt
     59,780  (0.6%)           bignum_montmul_p384_selector
     55,638  (0.5%)           bignum_montsqr_p384_selector

<   174,636  (1.6%, 76.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/third_party/s2n-bignum/x86_att/p384/bignum_add_p384.S:???

<   155,068  (1.4%, 77.9%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c:
    154,854  (1.4%)           s2n_result_is_ok

<   153,059  (1.4%, 79.3%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c:
     97,842  (0.9%)           s2n_tls_hmac_init
     13,440  (0.1%)           s2n_hmac_state_validate

<   132,640  (1.2%, 80.5%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c:
     23,280  (0.2%)           s2n_hash_state_validate
     14,906  (0.1%)           s2n_low_level_hash_update
     12,928  (0.1%)           s2n_hash_update

<   131,008  (1.2%, 81.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/third_party/s2n-bignum/x86_att/p384/bignum_sub_p384.S:???

<   103,123  (1.0%, 82.7%)  ./elf/./elf/dl-lookup.c:
     66,754  (0.6%)           do_lookup_x
     21,732  (0.2%)           _dl_lookup_symbol_x
     14,637  (0.1%)           check_match

<    81,578  (0.8%, 83.5%)  ./malloc/./malloc/malloc.c:
     35,380  (0.3%)           _int_malloc
     17,225  (0.2%)           malloc
     14,736  (0.1%)           _int_free

<    80,529  (0.7%, 84.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c:
     22,450  (0.2%)           cbs_get
     13,896  (0.1%)           aws_lc_0_19_0_CBS_get_u8
     11,121  (0.1%)           cbs_get_any_asn1_element

<    73,122  (0.7%, 84.9%)  ./elf/../sysdeps/x86_64/dl-machine.h:
     73,056  (0.7%)           _dl_relocate_object

<    68,644  (0.6%, 85.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha512-x86_64.S:
     68,491  (0.6%)           sha512_block_data_order_avx

<    62,597  (0.6%, 86.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c:
     21,700  (0.2%)           aws_lc_0_19_0_OBJ_cmp
     18,760  (0.2%)           get_builtin_object
     16,093  (0.1%)           obj_cmp

<    55,661  (0.5%, 86.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c:
     20,134  (0.2%)           asn1_item_ex_i2d_opt
     12,912  (0.1%)           asn1_template_ex_i2d
     11,407  (0.1%)           asn1_ex_i2c

<    55,165  (0.5%, 87.2%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms

<    50,268  (0.5%, 87.6%)  ./elf/./elf/do-rel.h:
     50,212  (0.5%)           _dl_relocate_object

<    50,026  (0.5%, 88.1%)  ./stdio-common/./stdio-common/vfscanf-internal.c:__vfscanf_internal

<    48,660  (0.5%, 88.5%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:
     48,118  (0.4%)           __memcpy_avx_unaligned_erms

<    45,136  (0.4%, 89.0%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/montgomery.c:
     40,440  (0.4%)           aws_lc_0_19_0_bn_mod_mul_montgomery_small

<    44,442  (0.4%, 89.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c:
     15,762  (0.1%)           asn1_item_ex_d2i

<    43,232  (0.4%, 89.8%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/p256-nistz.c:
     11,926  (0.1%)           copy_conditional

<    42,924  (0.4%, 90.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c:
     11,616  (0.1%)           aws_lc_0_19_0_OPENSSL_malloc

<    41,138  (0.4%, 90.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c:aws_lc_0_19_0_bn_is_bit_set_words

<    33,776  (0.3%, 90.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/exponentiation.c:
     33,650  (0.3%)           aws_lc_0_19_0_bn_mod_exp_mont_small

<    32,808  (0.3%, 91.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/wnaf.c:aws_lc_0_19_0_ec_compute_wNAF

<    31,206  (0.3%, 91.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha1-x86_64.S:
     31,030  (0.3%)           sha1_block_data_order_avx2

<    29,940  (0.3%, 91.8%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/sha/sha256.c:
     15,158  (0.1%)           sha256_final_impl

<    27,848  (0.3%, 92.0%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c:
     18,810  (0.2%)           aws_lc_0_19_0_X509_NAME_cmp

<    25,237  (0.2%, 92.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/md4/../digest/md32_common.h:
     17,783  (0.2%)           crypto_md32_update

<    24,124  (0.2%, 92.5%)  ./stdlib/../stdlib/strtol_l.c:____strtoul_l_internal

<    23,694  (0.2%, 92.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/md5-x86_64.S:aws_lc_0_19_0_md5_block_asm_data_order

<    23,008  (0.2%, 92.9%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_network_order.c:
     10,913  (0.1%)           s2n_stuffer_write_network_order

<    22,653  (0.2%, 93.1%)  ./elf/./elf/dl-tunables.c:
     21,511  (0.2%)           __GI___tunables_init

<    22,515  (0.2%, 93.3%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c:
     14,532  (0.1%)           x509_object_cmp

<    22,238  (0.2%, 93.5%)  ./elf/./elf/dl-reloc.c:_dl_relocate_object

<    20,015  (0.2%, 93.7%)  ./string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S:
     19,983  (0.2%)           strcmp

<    18,874  (0.2%, 93.9%)  ./elf/../sysdeps/generic/dl-new-hash.h:_dl_lookup_symbol_x

<    17,600  (0.2%, 94.1%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_ensure.c:s2n_ensure_memmove_trace

<    16,072  (0.1%, 94.2%)  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe

<    16,014  (0.1%, 94.4%)  ./stdlib/../bits/stdlib-bsearch.h:bsearch

<    15,293  (0.1%, 94.5%)  ./stdlib/./stdlib/qsort.c:
     15,209  (0.1%)           msort_with_tmp.part.0

<    12,014  (0.1%, 94.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/third_party/s2n-bignum/x86_att/p384/bignum_nonzero_6.S:???

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir______________________  function:file

> 2,369,611 (22.1%, 22.1%)  ???:
  1,120,875 (10.4%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/third_party/s2n-bignum/x86_att/p384/bignum_montmul_p384_alt.S
    918,027  (8.5%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/third_party/s2n-bignum/x86_att/p384/bignum_montsqr_p384_alt.S
    174,636  (1.6%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/third_party/s2n-bignum/x86_att/p384/bignum_add_p384.S
    131,008  (1.2%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/third_party/s2n-bignum/x86_att/p384/bignum_sub_p384.S
     12,014  (0.1%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/third_party/s2n-bignum/x86_att/p384/bignum_nonzero_6.S

>   844,509  (7.9%, 29.9%)  aws_lc_0_19_0_bn_mul_mont:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont.S

>   676,336  (6.3%, 36.2%)  __ecp_nistz256_mul_montq:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>   582,837  (5.4%, 41.7%)  sha256_block_data_order_avx:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha256-x86_64.S

>   479,346  (4.5%, 46.1%)  constant_time_select_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>   475,750  (4.4%, 50.6%)  __ecp_nistz256_sqr_montq:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>   391,776  (3.6%, 54.2%)  p384_felem_cmovznz:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/p384.c

>   366,808  (3.4%, 57.6%)  value_barrier_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>   330,349  (3.1%, 60.7%)  s2n_blob_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c

>   231,149  (2.2%, 62.8%)  s2n_stuffer_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>   192,456  (1.8%, 64.6%)  cmovznz:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/ec_nistp.c

>   154,854  (1.4%, 66.1%)  s2n_result_is_ok:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c

>   146,233  (1.4%, 67.4%)  _dl_relocate_object:
     73,056  (0.7%)           ./elf/../sysdeps/x86_64/dl-machine.h
     50,212  (0.5%)           ./elf/./elf/do-rel.h
     22,238  (0.2%)           ./elf/./elf/dl-reloc.c

>    97,842  (0.9%, 68.4%)  s2n_tls_hmac_init:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c

>    95,732  (0.9%, 69.2%)  aws_lc_0_19_0_ecp_nistz256_point_double:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    79,200  (0.7%, 70.0%)  aws_lc_0_19_0_ec_nistp_point_double:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/ec_nistp.c

>    73,008  (0.7%, 70.7%)  use_s2n_bignum_alt:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/../../../third_party/s2n-bignum/include/s2n-bignum_aws-lc.h

>    68,644  (0.6%, 71.3%)  do_lookup_x:
     66,754  (0.6%)           ./elf/./elf/dl-lookup.c

>    68,491  (0.6%, 71.9%)  sha512_block_data_order_avx:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha512-x86_64.S

>    66,924  (0.6%, 72.6%)  CRYPTO_is_BMI2_capable:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/aes/../cpucap/internal.h

>    66,924  (0.6%, 73.2%)  CRYPTO_is_ADX_capable:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/aes/../cpucap/internal.h

>    65,577  (0.6%, 73.8%)  aws_lc_0_19_0_ec_nistp_point_add:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/ec_nistp.c

>    62,006  (0.6%, 74.4%)  constant_time_is_zero_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    61,270  (0.6%, 74.9%)  OPENSSL_ia32cap_get:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/aes/../cpucap/internal.h

>    59,780  (0.6%, 75.5%)  bignum_montmul_p384_selector:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/../../../third_party/s2n-bignum/include/s2n-bignum_aws-lc.h

>    55,638  (0.5%, 76.0%)  bignum_montsqr_p384_selector:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/../../../third_party/s2n-bignum/include/s2n-bignum_aws-lc.h

>    55,165  (0.5%, 76.5%)  __memset_avx2_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

>    53,590  (0.5%, 77.0%)  __ecp_nistz256_sub_fromq:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    51,636  (0.5%, 77.5%)  __vfscanf_internal:
     50,026  (0.5%)           ./stdio-common/./stdio-common/vfscanf-internal.c

>    50,496  (0.5%, 78.0%)  __ecp_nistz256_mul_by_2q:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    49,742  (0.5%, 78.4%)  p384_select_point_affine:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/p384.c

>    48,118  (0.4%, 78.9%)  __memcpy_avx_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

>    43,512  (0.4%, 79.3%)  aws_lc_0_19_0_ecp_nistz256_avx2_select_w7:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    41,138  (0.4%, 79.7%)  aws_lc_0_19_0_bn_is_bit_set_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c

>    40,606  (0.4%, 80.1%)  _dl_lookup_symbol_x:
     21,732  (0.2%)           ./elf/./elf/dl-lookup.c
     18,874  (0.2%)           ./elf/../sysdeps/generic/dl-new-hash.h

>    40,440  (0.4%, 80.4%)  aws_lc_0_19_0_bn_mod_mul_montgomery_small:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/montgomery.c

>    38,280  (0.4%, 80.8%)  aws_lc_0_19_0_ecp_nistz256_point_add:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    35,380  (0.3%, 81.1%)  _int_malloc:./malloc/./malloc/malloc.c

>    34,016  (0.3%, 81.4%)  OPENSSL_memcpy:
     32,176  (0.3%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    33,650  (0.3%, 81.8%)  aws_lc_0_19_0_bn_mod_exp_mont_small:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/exponentiation.c

>    32,808  (0.3%, 82.1%)  aws_lc_0_19_0_ec_compute_wNAF:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/wnaf.c

>    32,580  (0.3%, 82.4%)  s2n_stuffer_skip_write:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    31,514  (0.3%, 82.7%)  constant_time_msb_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    31,030  (0.3%, 82.9%)  sha1_block_data_order_avx2:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha1-x86_64.S

>    30,402  (0.3%, 83.2%)  s2n_stuffer_reserve_space:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    25,550  (0.2%, 83.5%)  aws_lc_0_19_0_ecp_nistz256_sqr_mont:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    25,248  (0.2%, 83.7%)  __ecp_nistz256_add_toq:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    24,530  (0.2%, 83.9%)  s2n_stuffer_write_bytes:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    24,124  (0.2%, 84.2%)  ____strtoul_l_internal:./stdlib/../stdlib/strtol_l.c

>    24,043  (0.2%, 84.4%)  __GI___tunables_init:
     21,511  (0.2%)           ./elf/./elf/dl-tunables.c

>    23,694  (0.2%, 84.6%)  aws_lc_0_19_0_md5_block_asm_data_order:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/md5-x86_64.S

>    23,280  (0.2%, 84.8%)  s2n_hash_state_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>    22,928  (0.2%, 85.0%)  CRYPTO_bswap4:
     22,832  (0.2%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    22,450  (0.2%, 85.2%)  cbs_get:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    22,360  (0.2%, 85.4%)  ecp_nistz256_avx2_select_w5:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    21,700  (0.2%, 85.6%)  aws_lc_0_19_0_OBJ_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c

>    21,130  (0.2%, 85.8%)  ec_GFp_nistp384_point_mul_public:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/p384.c

>    20,134  (0.2%, 86.0%)  asn1_item_ex_i2d_opt:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>    20,027  (0.2%, 86.2%)  strcmp:
     19,983  (0.2%)           ./string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S

>    19,998  (0.2%, 86.4%)  CRYPTO_store_u32_be:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    19,224  (0.2%, 86.6%)  aws_lc_0_19_0_ecp_nistz256_point_add_affine:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    18,810  (0.2%, 86.8%)  aws_lc_0_19_0_X509_NAME_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c

>    18,760  (0.2%, 86.9%)  get_builtin_object:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c

>    17,783  (0.2%, 87.1%)  crypto_md32_update:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/md4/../digest/md32_common.h

>    17,610  (0.2%, 87.3%)  malloc:
     17,225  (0.2%)           ./malloc/./malloc/malloc.c

>    17,600  (0.2%, 87.4%)  s2n_ensure_memmove_trace:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_ensure.c

>    17,138  (0.2%, 87.6%)  __ecp_nistz256_subq:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    16,093  (0.1%, 87.7%)  obj_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c

>    16,072  (0.1%, 87.9%)  __memcmp_avx2_movbe:./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S

>    16,014  (0.1%, 88.0%)  bsearch:./stdlib/../bits/stdlib-bsearch.h

>    15,796  (0.1%, 88.2%)  msort_with_tmp.part.0:
     15,209  (0.1%)           ./stdlib/./stdlib/qsort.c

>    15,762  (0.1%, 88.3%)  asn1_item_ex_d2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>    15,158  (0.1%, 88.5%)  sha256_final_impl:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/sha/sha256.c

>    14,906  (0.1%, 88.6%)  s2n_low_level_hash_update:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>    14,736  (0.1%, 88.7%)  _int_free:./malloc/./malloc/malloc.c

>    14,637  (0.1%, 88.9%)  check_match:./elf/./elf/dl-lookup.c

>    14,532  (0.1%, 89.0%)  x509_object_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c

>    13,896  (0.1%, 89.1%)  aws_lc_0_19_0_CBS_get_u8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    13,440  (0.1%, 89.3%)  s2n_hmac_state_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c

>    12,928  (0.1%, 89.4%)  s2n_hash_update:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>    12,912  (0.1%, 89.5%)  asn1_template_ex_i2d:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>    11,926  (0.1%, 89.6%)  copy_conditional:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/p256-nistz.c

>    11,616  (0.1%, 89.7%)  aws_lc_0_19_0_OPENSSL_malloc:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    11,407  (0.1%, 89.8%)  asn1_ex_i2c:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>    11,121  (0.1%, 89.9%)  cbs_get_any_asn1_element:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    10,913  (0.1%, 90.0%)  s2n_stuffer_write_network_order:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_network_order.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/../sysdeps/generic/dl-new-hash.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/../sysdeps/generic/dl-new-hash.h

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/../sysdeps/x86_64/dl-machine.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/../sysdeps/x86_64/dl-machine.h

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-lookup.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-lookup.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-reloc.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-reloc.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-tunables.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-tunables.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/do-rel.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/do-rel.h

--------------------------------------------------------------------------------
-- Annotated source file: ./malloc/./malloc/malloc.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./malloc/./malloc/malloc.c

--------------------------------------------------------------------------------
-- Annotated source file: ./stdio-common/./stdio-common/vfscanf-internal.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdio-common/./stdio-common/vfscanf-internal.c

--------------------------------------------------------------------------------
-- Annotated source file: ./stdlib/../bits/stdlib-bsearch.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdlib/../bits/stdlib-bsearch.h

--------------------------------------------------------------------------------
-- Annotated source file: ./stdlib/../stdlib/strtol_l.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdlib/../stdlib/strtol_l.c

--------------------------------------------------------------------------------
-- Annotated source file: ./stdlib/./stdlib/qsort.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdlib/./stdlib/qsort.c

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 121 ----------------------------------------
    .             B_ASN1_GRAPHICSTRING,
    .             B_ASN1_ISO64STRING,
    .             B_ASN1_GENERALSTRING,
    .             B_ASN1_UNIVERSALSTRING,
    .             B_ASN1_UNKNOWN,  // CHARACTER STRING
    .             B_ASN1_BMPSTRING,
    .         };
    .         
  104 (0.0%)  unsigned long ASN1_tag2bit(int tag) {
  104 (0.0%)    if (tag < 0 || tag > 30) {
    .             return 0;
    .           }
  130 (0.0%)    return tag2bit[tag];
   52 (0.0%)  }
    .         
    .         // Macro to initialize and invalidate the cache
    .         
    .         // Decode an ASN1 item, this currently behaves just like a standard 'd2i'
    .         // function. 'in' points to a buffer to read the data from, in future we
    .         // will have more advanced versions that can input data a piece at a time and
    .         // this will simply be a special case.
    .         
    .         ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
  110 (0.0%)                            const ASN1_ITEM *it) {
   10 (0.0%)    ASN1_VALUE *ptmpval = NULL;
   20 (0.0%)    if (!pval) {
   20 (0.0%)      pval = &ptmpval;
    .           }
    .         
  130 (0.0%)    if (asn1_item_ex_d2i(pval, in, len, it, -1, 0, 0, 0) > 0) {
   30 (0.0%)      return *pval;
    .           }
    .           return NULL;
   50 (0.0%)  }
    .         
    .         // Decode an item, taking care of IMPLICIT tagging, if any. If 'opt' set and
    .         // tag mismatch return -1 to handle OPTIONAL
    .         
    .         static int asn1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in,
    .                                     long len, const ASN1_ITEM *it, int tag, int aclass,
1,680 (0.0%)                              char opt, int depth) {
  112 (0.0%)    const ASN1_TEMPLATE *tt, *errtt = NULL;
    .           const ASN1_EXTERN_FUNCS *ef;
  112 (0.0%)    const unsigned char *p = NULL, *q;
    .           unsigned char oclass;
    .           char cst, isopt;
    .           int i;
    .           int otag;
  112 (0.0%)    int ret = 0;
    .           ASN1_VALUE **pchptr;
  336 (0.0%)    int combine = aclass & ASN1_TFLG_COMBINE;
  112 (0.0%)    aclass &= ~ASN1_TFLG_COMBINE;
  448 (0.0%)    if (pval == NULL || it == NULL) {
    .             return 0;
    .           }
    .         
    .           // Bound |len| to comfortably fit in an int. Lengths in this module often
    .           // switch between int and long without overflow checks.
  336 (0.0%)    if (len > INT_MAX / 2) {
    .             len = INT_MAX / 2;
    .           }
    .         
  336 (0.0%)    if (++depth > ASN1_MAX_CONSTRUCTED_NEST) {
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_TOO_DEEP);
    .             goto err;
    .           }
    .         
1,456 (0.0%)    switch (it->itype) {
    .             case ASN1_ITYPE_PRIMITIVE:
  252 (0.0%)        if (it->templates) {
    .                 // tagging or OPTIONAL is currently illegal on an item template
    .                 // because the flags can't get passed down. In practice this
    .                 // isn't a problem: we include the relevant flags from the item
    .                 // template in the template itself.
   68 (0.0%)          if ((tag != -1) || opt) {
    .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
    .                   goto err;
    .                 }
  204 (0.0%)          return asn1_template_ex_d2i(pval, in, len, it->templates, opt, depth);
    .               }
  598 (0.0%)        return asn1_d2i_ex_primitive(pval, in, len, it, tag, aclass, opt);
    .               break;
    .         
    .             case ASN1_ITYPE_MSTRING:
    .               // It never makes sense for multi-strings to have implicit tagging, so
    .               // if tag != -1, then this looks like an error in the template.
   28 (0.0%)        if (tag != -1) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
    .                 goto err;
    .               }
    .         
   42 (0.0%)        p = *in;
    .               // Just read in tag and class
  224 (0.0%)        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, &p, len, -1, 0, 1);
   28 (0.0%)        if (!ret) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .                 goto err;
    .               }
    .         
    .               // Must be UNIVERSAL class
   42 (0.0%)        if (oclass != V_ASN1_UNIVERSAL) {
    .                 // If OPTIONAL, assume this is OK
    .                 if (opt) {
    .                   return -1;
    .                 }
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_MSTRING_NOT_UNIVERSAL);
    .                 goto err;
    .               }
    .               // Check tag matches bit map
  140 (0.0%)        if (!(ASN1_tag2bit(otag) & it->utype)) {
    .                 // If OPTIONAL, assume this is OK
    .                 if (opt) {
    .                   return -1;
    .                 }
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_MSTRING_WRONG_TAG);
    .                 goto err;
    .               }
  182 (0.0%)        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0);
    .         
    .             case ASN1_ITYPE_EXTERN:
    .               // Use new style d2i
    6 (0.0%)        ef = it->funcs;
   30 (0.0%)        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, NULL);
    .         
    .             case ASN1_ITYPE_CHOICE: {
    .               // It never makes sense for CHOICE types to have implicit tagging, so if
    .               // tag != -1, then this looks like an error in the template.
    6 (0.0%)        if (tag != -1) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
    .                 goto err;
    .               }
    .         
    9 (0.0%)        const ASN1_AUX *aux = it->funcs;
   12 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
    6 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL)) {
    .                 goto auxerr;
    .               }
    .         
   12 (0.0%)        if (*pval) {
    .                 // Free up and zero CHOICE value if initialised
    .                 i = asn1_get_choice_selector(pval, it);
    .                 if ((i >= 0) && (i < it->tcount)) {
    .                   tt = it->templates + i;
    .                   pchptr = asn1_get_field_ptr(pval, tt);
    .                   ASN1_template_free(pchptr, tt);
    .                   asn1_set_choice_selector(pval, -1, it);
    .                 }
   21 (0.0%)        } else if (!ASN1_item_ex_new(pval, it)) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .                 goto err;
    .               }
    .               // CHOICE type, try each possibility in turn
    9 (0.0%)        p = *in;
   81 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
   54 (0.0%)          pchptr = asn1_get_field_ptr(pval, tt);
    .                 // We mark field as OPTIONAL so its absence can be recognised.
   90 (0.0%)          ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, depth);
    .                 // If field not present, try the next one
   18 (0.0%)          if (ret == -1) {
    6 (0.0%)            continue;
    .                 }
    .                 // If positive return, read OK, break loop
    6 (0.0%)          if (ret > 0) {
    3 (0.0%)            break;
    .                 }
    .                 // Otherwise must be an ASN1 parsing error
    .                 errtt = tt;
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .                 goto err;
    .               }
    .         
    .               // Did we fall off the end without reading anything?
   18 (0.0%)        if (i == it->tcount) {
    .                 // If OPTIONAL, this is OK
    .                 if (opt) {
    .                   // Free and zero it
    .                   ASN1_item_ex_free(pval, it);
    .                   return -1;
    .                 }
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NO_MATCHING_CHOICE_TYPE);
    .                 goto err;
    .               }
    .         
   18 (0.0%)        asn1_set_choice_selector(pval, i, it);
    6 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL)) {
    .                 goto auxerr;
    .               }
    9 (0.0%)        *in = p;
    6 (0.0%)        return 1;
    .             }
    .         
    .             case ASN1_ITYPE_SEQUENCE: {
   90 (0.0%)        p = *in;
    .         
    .               // If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL
   60 (0.0%)        if (tag == -1) {
   27 (0.0%)          tag = V_ASN1_SEQUENCE;
   27 (0.0%)          aclass = V_ASN1_UNIVERSAL;
    .               }
    .               // Get SEQUENCE length and update len, p
  600 (0.0%)        ret = asn1_check_tlen(&len, NULL, NULL, &cst, &p, len, tag, aclass, opt);
   60 (0.0%)        if (!ret) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .                 goto err;
   60 (0.0%)        } else if (ret == -1) {
    6 (0.0%)          return -1;
    .               }
   81 (0.0%)        if (!cst) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
    .                 goto err;
    .               }
    .         
  255 (0.0%)        if (!*pval && !ASN1_item_ex_new(pval, it)) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .                 goto err;
    .               }
    .         
   81 (0.0%)        const ASN1_AUX *aux = it->funcs;
  114 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
   72 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL)) {
    .                 goto auxerr;
    .               }
    .         
    .               // Free up and zero any ADB found
  849 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
  345 (0.0%)          if (tt->flags & ASN1_TFLG_ADB_MASK) {
    .                   const ASN1_TEMPLATE *seqtt;
    .                   ASN1_VALUE **pseqval;
    .                   seqtt = asn1_do_adb(pval, tt, 0);
    .                   if (seqtt == NULL) {
    .                     continue;
    .                   }
    .                   pseqval = asn1_get_field_ptr(pval, seqtt);
    .                   ASN1_template_free(pseqval, seqtt);
    .                 }
    .               }
    .         
    .               // Get each field entry
  806 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
    .                 const ASN1_TEMPLATE *seqtt;
    .                 ASN1_VALUE **pseqval;
  469 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
  134 (0.0%)          if (seqtt == NULL) {
    .                   goto err;
    .                 }
  402 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
    .                 // Have we ran out of data?
  201 (0.0%)          if (!len) {
    6 (0.0%)            break;
    .                 }
  122 (0.0%)          q = p;
    .                 // This determines the OPTIONAL flag value. The field cannot be
    .                 // omitted if it is the last of a SEQUENCE and there is still
    .                 // data to be read. This isn't strictly necessary but it
    .                 // increases efficiency in some cases.
  427 (0.0%)          if (i == (it->tcount - 1)) {
   42 (0.0%)            isopt = 0;
    .                 } else {
  240 (0.0%)            isopt = (seqtt->flags & ASN1_TFLG_OPTIONAL) != 0;
    .                 }
    .                 // attempt to read in field, allowing each to be OPTIONAL
    .         
  671 (0.0%)          ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, depth);
  122 (0.0%)          if (!ret) {
    .                   errtt = seqtt;
    .                   goto err;
  122 (0.0%)          } else if (ret == -1) {
    .                   // OPTIONAL component absent. Free and zero the field.
   25 (0.0%)            ASN1_template_free(pseqval, seqtt);
    5 (0.0%)            continue;
    .                 }
    .                 // Update length
  280 (0.0%)          len -= p - q;
    .               }
    .         
    .               // Check all data read
   81 (0.0%)        if (len) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
    .                 goto err;
    .               }
    .         
    .               // If we get here we've got no more data in the SEQUENCE, however we
    .               // may not have read all fields so check all remaining are OPTIONAL
    .               // and clear any that are.
  226 (0.0%)        for (; i < it->tcount; tt++, i++) {
    .                 const ASN1_TEMPLATE *seqtt;
   56 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
   16 (0.0%)          if (seqtt == NULL) {
    .                   goto err;
    .                 }
   40 (0.0%)          if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
    .                   ASN1_VALUE **pseqval;
   48 (0.0%)            pseqval = asn1_get_field_ptr(pval, seqtt);
   48 (0.0%)            ASN1_template_free(pseqval, seqtt);
    .                 } else {
    .                   errtt = seqtt;
    .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_FIELD_MISSING);
    .                   goto err;
    .                 }
    .               }
    .               // Save encoding
  405 (0.0%)        if (!asn1_enc_save(pval, *in, p - *in, it)) {
    .                 goto auxerr;
    .               }
   72 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL)) {
    .                 goto auxerr;
    .               }
   81 (0.0%)        *in = p;
   54 (0.0%)        return 1;
    .             }
    .         
    .             default:
    .               return 0;
    .           }
    .         auxerr:
    .           OPENSSL_PUT_ERROR(ASN1, ASN1_R_AUX_ERROR);
    .         err:
-- line 437 ----------------------------------------
-- line 439 ----------------------------------------
    .             ASN1_item_ex_free(pval, it);
    .           }
    .           if (errtt) {
    .             ERR_add_error_data(4, "Field=", errtt->field_name, ", Type=", it->sname);
    .           } else {
    .             ERR_add_error_data(2, "Type=", it->sname);
    .           }
    .           return 0;
  560 (0.0%)  }
    .         
    .         int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
    .                              const ASN1_ITEM *it, int tag, int aclass, char opt,
   24 (0.0%)                       ASN1_TLC *ctx) {
   24 (0.0%)    return asn1_item_ex_d2i(pval, in, len, it, tag, aclass, opt, 0);
    4 (0.0%)  }
    .         
    .         // Templates are handled with two separate functions. One handles any
    .         // EXPLICIT tag and the other handles the rest.
    .         
    .         static int asn1_template_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
    .                                         long inlen, const ASN1_TEMPLATE *tt, char opt,
1,218 (0.0%)                                  int depth) {
    .           int aclass;
    .           int ret;
    .           long len;
    .           const unsigned char *p, *q;
  174 (0.0%)    if (!val) {
    .             return 0;
    .           }
  261 (0.0%)    uint32_t flags = tt->flags;
  261 (0.0%)    aclass = flags & ASN1_TFLG_TAG_CLASS;
    .         
  261 (0.0%)    p = *in;
    .         
    .           // Check if EXPLICIT tag expected
  348 (0.0%)    if (flags & ASN1_TFLG_EXPTAG) {
    .             char cst;
    .             // Need to work out amount of data available to the inner content and
    .             // where it starts: so read in EXPLICIT header to get the info.
   42 (0.0%)      ret = asn1_check_tlen(&len, NULL, NULL, &cst, &p, inlen, tt->tag, aclass,
    .                                   opt);
    4 (0.0%)      q = p;
    4 (0.0%)      if (!ret) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .               return 0;
    4 (0.0%)      } else if (ret == -1) {
    .               return -1;
    .             }
    6 (0.0%)      if (!cst) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);
    .               return 0;
    .             }
    .             // We've found the field so it can't be OPTIONAL now
   20 (0.0%)      ret = asn1_template_noexp_d2i(val, &p, len, tt, 0, depth);
    4 (0.0%)      if (!ret) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .               return 0;
    .             }
    .             // We read the field in OK so update length
   10 (0.0%)      len -= p - q;
    .             // Check for trailing data.
    6 (0.0%)      if (len) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_EXPLICIT_LENGTH_MISMATCH);
    .               goto err;
    .             }
    .           } else {
  935 (0.0%)      return asn1_template_noexp_d2i(val, in, inlen, tt, opt, depth);
    .           }
    .         
    6 (0.0%)    *in = p;
    2 (0.0%)    return 1;
    .         
    .         err:
    .           ASN1_template_free(val, tt);
    .           return 0;
  435 (0.0%)  }
    .         
    .         static int asn1_template_noexp_d2i(ASN1_VALUE **val, const unsigned char **in,
    .                                            long len, const ASN1_TEMPLATE *tt, char opt,
1,218 (0.0%)                                     int depth) {
    .           int aclass;
    .           int ret;
    .           const unsigned char *p;
  174 (0.0%)    if (!val) {
    .             return 0;
    .           }
  261 (0.0%)    uint32_t flags = tt->flags;
  261 (0.0%)    aclass = flags & ASN1_TFLG_TAG_CLASS;
    .         
  261 (0.0%)    p = *in;
    .         
  348 (0.0%)    if (flags & ASN1_TFLG_SK_MASK) {
    .             // SET OF, SEQUENCE OF
    .             int sktag, skaclass;
    .             // First work out expected inner tag value
   72 (0.0%)      if (flags & ASN1_TFLG_IMPTAG) {
    .               sktag = tt->tag;
    .               skaclass = aclass;
    .             } else {
   18 (0.0%)        skaclass = V_ASN1_UNIVERSAL;
   72 (0.0%)        if (flags & ASN1_TFLG_SET_OF) {
   24 (0.0%)          sktag = V_ASN1_SET;
    .               } else {
    6 (0.0%)          sktag = V_ASN1_SEQUENCE;
    .               }
    .             }
    .             // Get the tag
    .             ret =
  342 (0.0%)          asn1_check_tlen(&len, NULL, NULL, NULL, &p, len, sktag, skaclass, opt);
   36 (0.0%)      if (!ret) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .               return 0;
   36 (0.0%)      } else if (ret == -1) {
    .               return -1;
    .             }
   72 (0.0%)      if (!*val) {
   72 (0.0%)        *val = (ASN1_VALUE *)sk_ASN1_VALUE_new_null();
    .             } else {
    .               // We've got a valid STACK: free up any items present
    .               STACK_OF(ASN1_VALUE) *sktmp = (STACK_OF(ASN1_VALUE) *)*val;
    .               ASN1_VALUE *vtmp;
    .               while (sk_ASN1_VALUE_num(sktmp) > 0) {
    .                 vtmp = sk_ASN1_VALUE_pop(sktmp);
    .                 ASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item));
    .               }
    .             }
    .         
   72 (0.0%)      if (!*val) {
    .               goto err;
    .             }
    .         
    .             // Read as many items as we can
  183 (0.0%)      while (len > 0) {
    .               ASN1_VALUE *skfield;
   62 (0.0%)        const unsigned char *q = p;
   31 (0.0%)        skfield = NULL;
  465 (0.0%)        if (!asn1_item_ex_d2i(&skfield, &p, len, ASN1_ITEM_ptr(tt->item), -1, 0,
    .                                     0, depth)) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .                 goto err;
    .               }
  155 (0.0%)        len -= p - q;
  248 (0.0%)        if (!sk_ASN1_VALUE_push((STACK_OF(ASN1_VALUE) *)*val, skfield)) {
    .                 ASN1_item_ex_free(&skfield, ASN1_ITEM_ptr(tt->item));
    .                 goto err;
    .               }
    .             }
  276 (0.0%)    } else if (flags & ASN1_TFLG_IMPTAG) {
    .             // IMPLICIT tagging
  221 (0.0%)      ret = asn1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), tt->tag,
    .                                    aclass, opt, depth);
   26 (0.0%)      if (!ret) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .               goto err;
   26 (0.0%)      } else if (ret == -1) {
   16 (0.0%)        return -1;
    .             }
    .           } else {
    .             // Nothing special
  896 (0.0%)      ret = asn1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), -1,
  112 (0.0%)                             tt->flags & ASN1_TFLG_COMBINE, opt, depth);
  112 (0.0%)      if (!ret) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .               goto err;
  112 (0.0%)      } else if (ret == -1) {
    6 (0.0%)        return -1;
    .             }
    .           }
    .         
  228 (0.0%)    *in = p;
  152 (0.0%)    return 1;
    .         
    .         err:
    .           ASN1_template_free(val, tt);
    .           return 0;
  435 (0.0%)  }
    .         
    .         static int asn1_d2i_ex_primitive(ASN1_VALUE **pval, const unsigned char **in,
    .                                          long inlen, const ASN1_ITEM *it, int tag,
  900 (0.0%)                                   int aclass, char opt) {
   60 (0.0%)    int ret = 0, utype;
    .           long plen;
    .           char cst;
    .           const unsigned char *p;
   60 (0.0%)    const unsigned char *cont = NULL;
    .           long len;
  120 (0.0%)    if (!pval) {
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_NULL);
    .             return 0;  // Should never happen
    .           }
    .         
  240 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
   28 (0.0%)      utype = tag;
   28 (0.0%)      tag = -1;
    .           } else {
  138 (0.0%)      utype = it->utype;
    .           }
    .         
  180 (0.0%)    if (utype == V_ASN1_ANY) {
    .             // If type is ANY need to figure out type from tag
    .             unsigned char oclass;
    2 (0.0%)      if (tag >= 0) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_TAGGED_ANY);
    .               return 0;
    .             }
    2 (0.0%)      if (opt) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OPTIONAL_ANY);
    .               return 0;
    .             }
    3 (0.0%)      p = *in;
   16 (0.0%)      ret = asn1_check_tlen(NULL, &utype, &oclass, NULL, &p, inlen, -1, 0, 0);
    2 (0.0%)      if (!ret) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .               return 0;
    .             }
    3 (0.0%)      if (oclass != V_ASN1_UNIVERSAL) {
    .               utype = V_ASN1_OTHER;
    .             }
    .           }
  120 (0.0%)    if (tag == -1) {
  100 (0.0%)      tag = utype;
   50 (0.0%)      aclass = V_ASN1_UNIVERSAL;
    .           }
  180 (0.0%)    p = *in;
    .           // Check header
1,200 (0.0%)    ret = asn1_check_tlen(&plen, NULL, NULL, &cst, &p, inlen, tag, aclass, opt);
  120 (0.0%)    if (!ret) {
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .             return 0;
  120 (0.0%)    } else if (ret == -1) {
   16 (0.0%)      return -1;
    .           }
   52 (0.0%)    ret = 0;
    .           // SEQUENCE, SET and "OTHER" are left in encoded form
  416 (0.0%)    if ((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||
   52 (0.0%)        (utype == V_ASN1_OTHER)) {
    .             // SEQUENCE and SET must be constructed
    .             if (utype != V_ASN1_OTHER && !cst) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_TYPE_NOT_CONSTRUCTED);
    .               return 0;
    .             }
    .         
    .             cont = *in;
    .             len = p - cont + plen;
    .             p += plen;
  156 (0.0%)    } else if (cst) {
    .             // This parser historically supported BER constructed strings. We no
    .             // longer do and will gradually tighten this parser into a DER
    .             // parser. BER types should use |CBS_asn1_ber_to_der|.
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_TYPE_NOT_PRIMITIVE);
    .             return 0;
    .           } else {
  104 (0.0%)      cont = p;
  104 (0.0%)      len = plen;
  208 (0.0%)      p += plen;
    .           }
    .         
    .           // We now have content length and type: translate into a structure
  520 (0.0%)    if (!asn1_ex_c2i(pval, cont, len, utype, it)) {
    .             goto err;
    .           }
    .         
  156 (0.0%)    *in = p;
  104 (0.0%)    ret = 1;
    .         err:
   52 (0.0%)    return ret;
  300 (0.0%)  }
    .         
    .         // Translate ASN1 content octets into a structure
    .         
    .         static int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, long len,
  624 (0.0%)                         int utype, const ASN1_ITEM *it) {
   52 (0.0%)    ASN1_VALUE **opval = NULL;
    .           ASN1_STRING *stmp;
   52 (0.0%)    ASN1_TYPE *typ = NULL;
   52 (0.0%)    int ret = 0;
    .           ASN1_INTEGER **tint;
    .         
    .           // Historically, |it->funcs| for primitive types contained an
    .           // |ASN1_PRIMITIVE_FUNCS| table of callbacks.
  208 (0.0%)    assert(it->funcs == NULL);
    .         
    .           // If ANY type clear type and set pointer to internal value
  208 (0.0%)    if (it->utype == V_ASN1_ANY) {
    4 (0.0%)      if (!*pval) {
    2 (0.0%)        typ = ASN1_TYPE_new();
    2 (0.0%)        if (typ == NULL) {
    .                 goto err;
    .               }
    4 (0.0%)        *pval = (ASN1_VALUE *)typ;
    .             } else {
    .               typ = (ASN1_TYPE *)*pval;
    .             }
    .         
    4 (0.0%)      if (utype != typ->type) {
    6 (0.0%)        ASN1_TYPE_set(typ, utype, NULL);
    .             }
    2 (0.0%)      opval = pval;
    3 (0.0%)      pval = &typ->value.asn1_value;
    .           }
  384 (0.0%)    switch (utype) {
    .             case V_ASN1_OBJECT:
  160 (0.0%)        if (!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, &cont, len)) {
    .                 goto err;
    .               }
   40 (0.0%)        break;
    .         
    .             case V_ASN1_NULL:
    .               if (len) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NULL_IS_WRONG_LENGTH);
    .                 goto err;
    .               }
    .               *pval = (ASN1_VALUE *)1;
    .               break;
    .         
    .             case V_ASN1_BOOLEAN:
    6 (0.0%)        if (len != 1) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BOOLEAN_IS_WRONG_LENGTH);
    .                 goto err;
    .               } else {
    .                 ASN1_BOOLEAN *tbool;
    6 (0.0%)          tbool = (ASN1_BOOLEAN *)pval;
   15 (0.0%)          *tbool = *cont;
    .               }
    3 (0.0%)        break;
    .         
    .             case V_ASN1_BIT_STRING:
   16 (0.0%)        if (!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, &cont, len)) {
    .                 goto err;
    .               }
    4 (0.0%)        break;
    .         
    .             case V_ASN1_INTEGER:
    .             case V_ASN1_ENUMERATED:
    4 (0.0%)        tint = (ASN1_INTEGER **)pval;
   16 (0.0%)        if (!c2i_ASN1_INTEGER(tint, &cont, len)) {
    .                 goto err;
    .               }
    .               // Fixup type to match the expected form
   18 (0.0%)        (*tint)->type = utype | ((*tint)->type & V_ASN1_NEG);
    2 (0.0%)        break;
    .         
    .             case V_ASN1_OCTET_STRING:
    .             case V_ASN1_NUMERICSTRING:
    .             case V_ASN1_PRINTABLESTRING:
    .             case V_ASN1_T61STRING:
    .             case V_ASN1_VIDEOTEXSTRING:
    .             case V_ASN1_IA5STRING:
    .             case V_ASN1_UTCTIME:
-- line 787 ----------------------------------------
-- line 791 ----------------------------------------
    .             case V_ASN1_GENERALSTRING:
    .             case V_ASN1_UNIVERSALSTRING:
    .             case V_ASN1_BMPSTRING:
    .             case V_ASN1_UTF8STRING:
    .             case V_ASN1_OTHER:
    .             case V_ASN1_SET:
    .             case V_ASN1_SEQUENCE:
    .             default:
   50 (0.0%)        if (utype == V_ASN1_BMPSTRING && (len & 1)) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
    .                 goto err;
    .               }
   50 (0.0%)        if (utype == V_ASN1_UNIVERSALSTRING && (len & 3)) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
    .                 goto err;
    .               }
   50 (0.0%)        if (utype == V_ASN1_UTCTIME) {
    .                 CBS cbs;
    6 (0.0%)          CBS_init(&cbs, cont, (size_t)len);
    7 (0.0%)          if (!CBS_parse_utc_time(&cbs, NULL, /*allow_timezone_offset=*/1)) {
    .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_TIME_FORMAT);
    .                   goto err;
    .                 }
    .               }
   50 (0.0%)        if (utype == V_ASN1_GENERALIZEDTIME) {
    .                 CBS cbs;
    6 (0.0%)          CBS_init(&cbs, cont, (size_t)len);
    7 (0.0%)          if (!CBS_parse_generalized_time(&cbs, NULL,
    .                                                 /*allow_timezone_offset=*/0)) {
    .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_TIME_FORMAT);
    .                   goto err;
    .                 }
    .               }
    .               // All based on ASN1_STRING and handled the same
  100 (0.0%)        if (!*pval) {
   28 (0.0%)          stmp = ASN1_STRING_type_new(utype);
   14 (0.0%)          if (!stmp) {
    .                   goto err;
    .                 }
   28 (0.0%)          *pval = (ASN1_VALUE *)stmp;
    .               } else {
   54 (0.0%)          stmp = (ASN1_STRING *)*pval;
   54 (0.0%)          stmp->type = utype;
    .               }
  200 (0.0%)        if (!ASN1_STRING_set(stmp, cont, len)) {
    .                 ASN1_STRING_free(stmp);
    .                 *pval = NULL;
    .                 goto err;
    .               }
   25 (0.0%)        break;
    .           }
    .           // If ASN1_ANY and NULL type fix up value
  106 (0.0%)    if (typ && (utype == V_ASN1_NULL)) {
    .             typ->value.ptr = NULL;
    .           }
    .         
  104 (0.0%)    ret = 1;
    .         err:
  104 (0.0%)    if (!ret) {
    .             ASN1_TYPE_free(typ);
    .             if (opval) {
    .               *opval = NULL;
    .             }
    .           }
   52 (0.0%)    return ret;
  260 (0.0%)  }
    .         
    .         // Check an ASN1 tag and length: a bit like ASN1_get_object but it
    .         // checks the expected tag.
    .         
    .         static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,
    .                                    char *cst, const unsigned char **in, long len,
1,875 (0.0%)                             int exptag, int expclass, char opt) {
    .           int i;
    .           int ptag, pclass;
    .           long plen;
    .           const unsigned char *p;
  375 (0.0%)    p = *in;
    .         
1,125 (0.0%)    i = ASN1_get_object(&p, &plen, &ptag, &pclass, len);
  500 (0.0%)    if (i & 0x80) {
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_OBJECT_HEADER);
    .             return 0;
    .           }
  250 (0.0%)    if (exptag >= 0) {
  627 (0.0%)      if ((exptag != ptag) || (expclass != pclass)) {
    .               // If type is OPTIONAL, not an error: indicate missing type.
   22 (0.0%)        if (opt) {
   22 (0.0%)          return -1;
    .               }
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TAG);
    .               return 0;
    .             }
    .           }
    .         
  228 (0.0%)    if (cst) {
  405 (0.0%)      *cst = i & V_ASN1_CONSTRUCTED;
    .           }
    .         
  228 (0.0%)    if (olen) {
  297 (0.0%)      *olen = plen;
    .           }
    .         
  228 (0.0%)    if (oclass) {
   60 (0.0%)      *oclass = pclass;
    .           }
    .         
  228 (0.0%)    if (otag) {
   45 (0.0%)      *otag = ptag;
    .           }
    .         
  342 (0.0%)    *in = p;
  114 (0.0%)    return 1;
  625 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 78 ----------------------------------------
    .         static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
    .                                     int skcontlen, const ASN1_ITEM *item, int do_sort);
    .         static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
    .                                         const ASN1_TEMPLATE *tt, int tag, int aclass,
    .                                         int optional);
    .         
    .         // Top level i2d equivalents
    .         
   30 (0.0%)  int ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it) {
   18 (0.0%)    if (out && !*out) {
    .             unsigned char *p, *buf;
   24 (0.0%)      int len = ASN1_item_ex_i2d(&val, NULL, it, /*tag=*/-1, /*aclass=*/0);
    6 (0.0%)      if (len <= 0) {
    .               return len;
    .             }
   15 (0.0%)      buf = OPENSSL_malloc(len);
    6 (0.0%)      if (!buf) {
    .               return -1;
    .             }
    6 (0.0%)      p = buf;
   24 (0.0%)      int len2 = ASN1_item_ex_i2d(&val, &p, it, /*tag=*/-1, /*aclass=*/0);
    6 (0.0%)      if (len2 <= 0) {
    .               OPENSSL_free(buf);
    .               return len2;
    .             }
    9 (0.0%)      assert(len == len2);
    9 (0.0%)      *out = buf;
    6 (0.0%)      return len;
    .           }
    .         
    .           return ASN1_item_ex_i2d(&val, out, it, /*tag=*/-1, /*aclass=*/0);
   15 (0.0%)  }
    .         
    .         // Encode an item, taking care of IMPLICIT tagging (if any). This function
    .         // performs the normal item handling: it can be used in external types.
    .         
    .         int ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
  594 (0.0%)                       const ASN1_ITEM *it, int tag, int aclass) {
  660 (0.0%)    int ret = asn1_item_ex_i2d_opt(pval, out, it, tag, aclass, /*optional=*/0);
  132 (0.0%)    assert(ret != 0);
   66 (0.0%)    return ret;
  132 (0.0%)  }
    .         
    .         // asn1_item_ex_i2d_opt behaves like |ASN1_item_ex_i2d| but, if |optional| is
    .         // non-zero and |*pval| is omitted, it returns zero and writes no bytes.
    .         int asn1_item_ex_i2d_opt(ASN1_VALUE **pval, unsigned char **out,
    .                                  const ASN1_ITEM *it, int tag, int aclass,
2,730 (0.0%)                           int optional) {
  210 (0.0%)    const ASN1_TEMPLATE *tt = NULL;
    .           int i, seqcontlen, seqlen;
    .         
    .           // Historically, |aclass| was repurposed to pass additional flags into the
    .           // encoding process.
  840 (0.0%)    assert((aclass & ASN1_TFLG_TAG_CLASS) == aclass);
    .           // If not overridding the tag, |aclass| is ignored and should be zero.
  840 (0.0%)    assert(tag != -1 || aclass == 0);
    .         
    .           // All fields are pointers, except for boolean |ASN1_ITYPE_PRIMITIVE|s.
    .           // Optional primitives are handled later.
1,260 (0.0%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) {
    .             if (optional) {
    .               return 0;
    .             }
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
    .             return -1;
    .           }
    .         
2,730 (0.0%)    switch (it->itype) {
    .             case ASN1_ITYPE_PRIMITIVE:
  420 (0.0%)        if (it->templates) {
    .                 // This is an |ASN1_ITEM_TEMPLATE|.
  144 (0.0%)          if (it->templates->flags & ASN1_TFLG_OPTIONAL) {
    .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
    .                   return -1;
    .                 }
  288 (0.0%)          return asn1_template_ex_i2d(pval, out, it->templates, tag, aclass,
    .                                             optional);
    .               }
  891 (0.0%)        return asn1_i2d_ex_primitive(pval, out, it, tag, aclass, optional);
    .         
    .             case ASN1_ITYPE_MSTRING:
    .               // It never makes sense for multi-strings to have implicit tagging, so
    .               // if tag != -1, then this looks like an error in the template.
   96 (0.0%)        if (tag != -1) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
    .                 return -1;
    .               }
  480 (0.0%)        return asn1_i2d_ex_primitive(pval, out, it, -1, 0, optional);
    .         
    .             case ASN1_ITYPE_CHOICE: {
    .               // It never makes sense for CHOICE types to have implicit tagging, so if
    .               // tag != -1, then this looks like an error in the template.
    .               if (tag != -1) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
    .                 return -1;
    .               }
-- line 173 ----------------------------------------
-- line 195 ----------------------------------------
    .                 // must be pointers.
    .                 OPENSSL_PUT_ERROR(ASN1, ERR_R_INTERNAL_ERROR);
    .                 return -1;
    .               }
    .               return ret;
    .             }
    .         
    .             case ASN1_ITYPE_SEQUENCE: {
  399 (0.0%)        i = asn1_enc_restore(&seqcontlen, out, pval, it);
    .               // An error occurred
  114 (0.0%)        if (i < 0) {
    .                 return -1;
    .               }
    .               // We have a valid cached encoding...
  114 (0.0%)        if (i > 0) {
   12 (0.0%)          return seqcontlen;
    .               }
    .               // Otherwise carry on
   51 (0.0%)        seqcontlen = 0;
    .               // If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL
  102 (0.0%)        if (tag == -1) {
   51 (0.0%)          tag = V_ASN1_SEQUENCE;
   51 (0.0%)          aclass = V_ASN1_UNIVERSAL;
    .               }
    .               // First work out sequence content length
1,409 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
    .                 const ASN1_TEMPLATE *seqtt;
    .                 ASN1_VALUE **pseqval;
    .                 int tmplen;
  742 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
  212 (0.0%)          if (!seqtt) {
    .                   return -1;
    .                 }
  636 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
    .                 tmplen =
  954 (0.0%)              asn1_template_ex_i2d(pseqval, NULL, seqtt, -1, 0, /*optional=*/0);
  742 (0.0%)          if (tmplen == -1 || (tmplen > INT_MAX - seqcontlen)) {
    .                   return -1;
    .                 }
  424 (0.0%)          seqcontlen += tmplen;
    .               }
    .         
  306 (0.0%)        seqlen = ASN1_object_size(/*constructed=*/1, seqcontlen, tag);
  138 (0.0%)        if (!out || seqlen == -1) {
   66 (0.0%)          return seqlen;
    .               }
    .               // Output SEQUENCE header
  144 (0.0%)        ASN1_put_object(out, /*constructed=*/1, seqcontlen, tag, aclass);
  502 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
    .                 const ASN1_TEMPLATE *seqtt;
    .                 ASN1_VALUE **pseqval;
  266 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
   76 (0.0%)          if (!seqtt) {
    .                   return -1;
    .                 }
  228 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
  380 (0.0%)          if (asn1_template_ex_i2d(pseqval, out, seqtt, -1, 0, /*optional=*/0) <
    .                     0) {
    .                   return -1;
    .                 }
    .               }
   36 (0.0%)        return seqlen;
    .             }
    .         
    .             default:
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
    .               return -1;
    .           }
1,050 (0.0%)  }
    .         
    .         // asn1_template_ex_i2d behaves like |asn1_item_ex_i2d_opt| but uses an
    .         // |ASN1_TEMPLATE| instead of an |ASN1_ITEM|. An |ASN1_TEMPLATE| wraps an
    .         // |ASN1_ITEM| with modifiers such as tagging, SEQUENCE or SET, etc.
    .         static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
    .                                         const ASN1_TEMPLATE *tt, int tag, int iclass,
2,184 (0.0%)                                  int optional) {
    .           int i, ret, ttag, tclass;
    .           size_t j;
  504 (0.0%)    uint32_t flags = tt->flags;
    .         
    .           // Historically, |iclass| was repurposed to pass additional flags into the
    .           // encoding process.
  672 (0.0%)    assert((iclass & ASN1_TFLG_TAG_CLASS) == iclass);
    .           // If not overridding the tag, |iclass| is ignored and should be zero.
  672 (0.0%)    assert(tag != -1 || iclass == 0);
    .         
    .           // Work out tag and class to use: tagging may come either from the
    .           // template or the arguments, not both because this would create
    .           // ambiguity.
  672 (0.0%)    if (flags & ASN1_TFLG_TAG_MASK) {
    .             // Error if argument and template tagging
    .             if (tag != -1) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
    .               return -1;
    .             }
    .             // Get tagging from template
    .             ttag = tt->tag;
    .             tclass = flags & ASN1_TFLG_TAG_CLASS;
  336 (0.0%)    } else if (tag != -1) {
    .             // No template tagging, get from arguments
    .             ttag = tag;
    .             tclass = iclass & ASN1_TFLG_TAG_CLASS;
    .           } else {
  168 (0.0%)      ttag = -1;
  168 (0.0%)      tclass = 0;
    .           }
    .         
    .           // The template may itself by marked as optional, or this may be the template
    .           // of an |ASN1_ITEM_TEMPLATE| type which was contained inside an outer
    .           // optional template. (They cannot both be true because the
    .           // |ASN1_ITEM_TEMPLATE| codepath rejects optional templates.)
  336 (0.0%)    assert(!optional || (flags & ASN1_TFLG_OPTIONAL) == 0);
1,356 (0.0%)    optional = optional || (flags & ASN1_TFLG_OPTIONAL) != 0;
    .         
    .           // At this point 'ttag' contains the outer tag to use, and 'tclass' is the
    .           // class.
    .         
  672 (0.0%)    if (flags & ASN1_TFLG_SK_MASK) {
    .             // SET OF, SEQUENCE OF
   72 (0.0%)      STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;
    .             int isset, sktag, skaclass;
    .             int skcontlen, sklen;
    .             ASN1_VALUE *skitem;
    .         
   96 (0.0%)      if (!*pval) {
    .               if (optional) {
    .                 return 0;
    .               }
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
    .               return -1;
    .             }
    .         
   96 (0.0%)      if (flags & ASN1_TFLG_SET_OF) {
   24 (0.0%)        isset = 1;
    .               // Historically, types with both bits set were mutated when
    .               // serialized to apply the sort. We no longer support this.
   96 (0.0%)        assert((flags & ASN1_TFLG_SEQUENCE_OF) == 0);
    .             } else {
    .               isset = 0;
    .             }
    .         
    .             // Work out inner tag value: if EXPLICIT or no tagging use underlying
    .             // type.
   48 (0.0%)      if ((ttag != -1) && !(flags & ASN1_TFLG_EXPTAG)) {
    .               sktag = ttag;
    .               skaclass = tclass;
    .             } else {
   24 (0.0%)        skaclass = V_ASN1_UNIVERSAL;
   48 (0.0%)        if (isset) {
   48 (0.0%)          sktag = V_ASN1_SET;
    .               } else {
    .                 sktag = V_ASN1_SEQUENCE;
    .               }
    .             }
    .         
    .             // Determine total length of items
   24 (0.0%)      skcontlen = 0;
  312 (0.0%)      for (j = 0; j < sk_ASN1_VALUE_num(sk); j++) {
    .               int tmplen;
  144 (0.0%)        skitem = sk_ASN1_VALUE_value(sk, j);
  216 (0.0%)        tmplen = ASN1_item_ex_i2d(&skitem, NULL, ASN1_ITEM_ptr(tt->item), -1, 0);
  144 (0.0%)        if (tmplen == -1 || (skcontlen > INT_MAX - tmplen)) {
    .                 return -1;
    .               }
   48 (0.0%)        skcontlen += tmplen;
    .             }
  144 (0.0%)      sklen = ASN1_object_size(/*constructed=*/1, skcontlen, sktag);
   48 (0.0%)      if (sklen == -1) {
    .               return -1;
    .             }
    .             // If EXPLICIT need length of surrounding tag
   96 (0.0%)      if (flags & ASN1_TFLG_EXPTAG) {
    .               ret = ASN1_object_size(/*constructed=*/1, sklen, ttag);
    .             } else {
   48 (0.0%)        ret = sklen;
    .             }
    .         
   72 (0.0%)      if (!out || ret == -1) {
   24 (0.0%)        return ret;
    .             }
    .         
    .             // Now encode this lot...
    .             // EXPLICIT tag
   48 (0.0%)      if (flags & ASN1_TFLG_EXPTAG) {
    .               ASN1_put_object(out, /*constructed=*/1, sklen, ttag, tclass);
    .             }
    .             // SET or SEQUENCE and IMPLICIT tag
   96 (0.0%)      ASN1_put_object(out, /*constructed=*/1, skcontlen, sktag, skaclass);
    .             // And the stuff itself
  132 (0.0%)      if (!asn1_set_seq_out(sk, out, skcontlen, ASN1_ITEM_ptr(tt->item), isset)) {
    .               return -1;
    .             }
   24 (0.0%)      return ret;
    .           }
    .         
  576 (0.0%)    if (flags & ASN1_TFLG_EXPTAG) {
    .             // EXPLICIT tagging
    .             // Find length of tagged item
    .             i = asn1_item_ex_i2d_opt(pval, NULL, ASN1_ITEM_ptr(tt->item), -1, 0,
    .                                      optional);
    .             if (i <= 0) {
    .               return i;
    .             }
    .             // Find length of EXPLICIT tag
-- line 398 ----------------------------------------
-- line 403 ----------------------------------------
    .               if (ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item), -1, 0) < 0) {
    .                 return -1;
    .               }
    .             }
    .             return ret;
    .           }
    .         
    .           // Either normal or IMPLICIT tagging
1,584 (0.0%)    return asn1_item_ex_i2d_opt(pval, out, ASN1_ITEM_ptr(tt->item), ttag, tclass,
    .                                       optional);
  840 (0.0%)  }
    .         
    .         // Temporary structure used to hold DER encoding of items for SET OF
    .         
    .         typedef struct {
    .           unsigned char *data;
    .           int length;
    .         } DER_ENC;
    .         
-- line 421 ----------------------------------------
-- line 431 ----------------------------------------
    .         }
    .         
    .         // asn1_set_seq_out writes |sk| to |out| under the i2d output convention,
    .         // excluding the tag and length. It returns one on success and zero on error.
    .         // |skcontlen| must be the total encoded size. If |do_sort| is non-zero, the
    .         // elements are sorted for a SET OF type. Each element of |sk| has type
    .         // |item|.
    .         static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
  156 (0.0%)                              int skcontlen, const ASN1_ITEM *item, int do_sort) {
    .           // No need to sort if there are fewer than two items.
   84 (0.0%)    if (!do_sort || sk_ASN1_VALUE_num(sk) < 2) {
  156 (0.0%)      for (size_t i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
   72 (0.0%)        ASN1_VALUE *skitem = sk_ASN1_VALUE_value(sk, i);
  108 (0.0%)        if (ASN1_item_ex_i2d(&skitem, out, item, -1, 0) < 0) {
    .                 return 0;
    .               }
    .             }
   24 (0.0%)      return 1;
    .           }
    .         
    .           int ret = 0;
    .           unsigned char *const buf = OPENSSL_malloc(skcontlen);
    .           DER_ENC *encoded = OPENSSL_calloc(sk_ASN1_VALUE_num(sk), sizeof(*encoded));
    .           if (encoded == NULL || buf == NULL) {
    .             goto err;
    .           }
-- line 456 ----------------------------------------
-- line 478 ----------------------------------------
    .           *out = p;
    .         
    .           ret = 1;
    .         
    .         err:
    .           OPENSSL_free(encoded);
    .           OPENSSL_free(buf);
    .           return ret;
   72 (0.0%)  }
    .         
    .         // asn1_i2d_ex_primitive behaves like |ASN1_item_ex_i2d| but |item| must be a
    .         // a PRIMITIVE or MSTRING type that is not an |ASN1_ITEM_TEMPLATE|.
    .         static int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out,
    .                                          const ASN1_ITEM *it, int tag, int aclass,
1,677 (0.0%)                                   int optional) {
    .           // Get length of content octets and maybe find out the underlying type.
    .           int omit;
  387 (0.0%)    int utype = it->utype;
1,161 (0.0%)    int len = asn1_ex_i2c(pval, NULL, &omit, &utype, it);
  258 (0.0%)    if (len < 0) {
    .             return -1;
    .           }
  387 (0.0%)    if (omit) {
   16 (0.0%)      if (optional) {
   16 (0.0%)        return 0;
    .             }
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
    .             return -1;
    .           }
    .         
    .           // If SEQUENCE, SET or OTHER then header is included in pseudo content
    .           // octets so don't include tag+length. We need to check here because the
    .           // call to asn1_ex_i2c() could change utype.
  121 (0.0%)    int usetag =
1,331 (0.0%)        utype != V_ASN1_SEQUENCE && utype != V_ASN1_SET && utype != V_ASN1_OTHER;
    .         
    .           // If not implicitly tagged get tag from underlying type
  242 (0.0%)    if (tag == -1) {
  242 (0.0%)      tag = utype;
    .           }
    .         
    .           // Output tag+length followed by content octets
  242 (0.0%)    if (out) {
   62 (0.0%)      if (usetag) {
  248 (0.0%)        ASN1_put_object(out, /*constructed=*/0, len, tag, aclass);
    .             }
  310 (0.0%)      int len2 = asn1_ex_i2c(pval, *out, &omit, &utype, it);
   62 (0.0%)      if (len2 < 0) {
    .               return -1;
    .             }
   93 (0.0%)      assert(len == len2);
   93 (0.0%)      assert(!omit);
  217 (0.0%)      *out += len;
    .           }
    .         
  242 (0.0%)    if (usetag) {
  726 (0.0%)      return ASN1_object_size(/*constructed=*/0, len, tag);
    .           }
    .           return len;
  645 (0.0%)  }
    .         
    .         // asn1_ex_i2c writes the |*pval| to |cout| under the i2d output convention,
    .         // excluding the tag and length. It returns the number of bytes written,
    .         // possibly zero, on success or -1 on error. If |*pval| should be omitted, it
    .         // returns zero and sets |*out_omit| to true.
    .         //
    .         // If |it| is an MSTRING or ANY type, it gets the underlying type from |*pval|,
    .         // which must be an |ASN1_STRING| or |ASN1_TYPE|, respectively. It then updates
-- line 545 ----------------------------------------
-- line 548 ----------------------------------------
    .         // |V_ASN1_OTHER|, it additionally outputs the tag and length, so the caller
    .         // must not do so.
    .         //
    .         // Otherwise, |*putype| must contain |it->utype|.
    .         //
    .         // WARNING: Unlike most functions in this file, |asn1_ex_i2c| can return zero
    .         // without omitting the element. ASN.1 values may have empty contents.
    .         static int asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cout, int *out_omit,
1,920 (0.0%)                         int *putype, const ASN1_ITEM *it) {
  160 (0.0%)    ASN1_BOOLEAN *tbool = NULL;
    .           ASN1_STRING *strtmp;
    .           ASN1_OBJECT *otmp;
    .           int utype;
    .           const unsigned char *cont;
    .           unsigned char c;
    .           int len;
    .         
    .           // Historically, |it->funcs| for primitive types contained an
    .           // |ASN1_PRIMITIVE_FUNCS| table of callbacks.
  640 (0.0%)    assert(it->funcs == NULL);
    .         
  320 (0.0%)    *out_omit = 0;
    .         
    .           // Should type be omitted?
1,040 (0.0%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) || (it->utype != V_ASN1_BOOLEAN)) {
  640 (0.0%)      if (!*pval) {
   16 (0.0%)        *out_omit = 1;
   16 (0.0%)        return 0;
    .             }
    .           }
    .         
  608 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
    .             // If MSTRING type set the underlying type
  180 (0.0%)      strtmp = (ASN1_STRING *)*pval;
  180 (0.0%)      utype = strtmp->type;
  120 (0.0%)      if (utype < 0 && utype != V_ASN1_OTHER) {
    .               // MSTRINGs can have type -1 when default-constructed.
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TYPE);
    .               return -1;
    .             }
    .             // Negative INTEGER and ENUMERATED values use |ASN1_STRING| type values
    .             // that do not match their corresponding utype values. INTEGERs cannot
    .             // participate in MSTRING types, but ENUMERATEDs can.
    .             //
    .             // TODO(davidben): Is this a bug? Although arguably one of the MSTRING
    .             // types should contain more values, rather than less. See
    .             // https://crbug.com/boringssl/412. But it is not possible to fit all
    .             // possible ANY values into an |ASN1_STRING|, so matching the spec here
    .             // is somewhat hopeless.
  120 (0.0%)      if (utype == V_ASN1_NEG_INTEGER) {
    .               utype = V_ASN1_INTEGER;
  120 (0.0%)      } else if (utype == V_ASN1_NEG_ENUMERATED) {
    .               utype = V_ASN1_ENUMERATED;
    .             }
  240 (0.0%)      *putype = utype;
  368 (0.0%)    } else if (it->utype == V_ASN1_ANY) {
    .             // If ANY set type and pointer to value
    .             ASN1_TYPE *typ;
   15 (0.0%)      typ = (ASN1_TYPE *)*pval;
   15 (0.0%)      utype = typ->type;
   10 (0.0%)      if (utype < 0 && utype != V_ASN1_OTHER) {
    .               // |ASN1_TYPE|s can have type -1 when default-constructed.
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TYPE);
    .               return -1;
    .             }
   15 (0.0%)      *putype = utype;
   20 (0.0%)      pval = &typ->value.asn1_value;
    .           } else {
  261 (0.0%)      utype = *putype;
    .           }
    .         
1,040 (0.0%)    switch (utype) {
    .             case V_ASN1_OBJECT:
  240 (0.0%)        otmp = (ASN1_OBJECT *)*pval;
  240 (0.0%)        cont = otmp->data;
  240 (0.0%)        len = otmp->length;
  160 (0.0%)        if (len == 0) {
    .                 // Some |ASN1_OBJECT|s do not have OIDs and cannot be serialized.
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OBJECT);
    .                 return -1;
    .               }
   80 (0.0%)        break;
    .         
    .             case V_ASN1_NULL:
    .               cont = NULL;
    .               len = 0;
    .               break;
    .         
    .             case V_ASN1_BOOLEAN:
    .               tbool = (ASN1_BOOLEAN *)pval;
-- line 637 ----------------------------------------
-- line 648 ----------------------------------------
    .               }
    .               c = *tbool ? 0xff : 0x00;
    .               cont = &c;
    .               len = 1;
    .               break;
    .         
    .             case V_ASN1_BIT_STRING: {
    .               int ret =
  123 (0.0%)            i2c_ASN1_BIT_STRING((ASN1_BIT_STRING *)*pval, cout ? &cout : NULL);
    .               // |i2c_ASN1_BIT_STRING| returns zero on error instead of -1.
   48 (0.0%)        return ret <= 0 ? -1 : ret;
    .             }
    .         
    .             case V_ASN1_INTEGER:
    .             case V_ASN1_ENUMERATED: {
    .               // |i2c_ASN1_INTEGER| also handles ENUMERATED.
    .               int ret = i2c_ASN1_INTEGER((ASN1_INTEGER *)*pval, cout ? &cout : NULL);
    .               // |i2c_ASN1_INTEGER| returns zero on error instead of -1.
    .               return ret <= 0 ? -1 : ret;
-- line 666 ----------------------------------------
-- line 679 ----------------------------------------
    .             case V_ASN1_GENERALSTRING:
    .             case V_ASN1_UNIVERSALSTRING:
    .             case V_ASN1_BMPSTRING:
    .             case V_ASN1_UTF8STRING:
    .             case V_ASN1_SEQUENCE:
    .             case V_ASN1_SET:
    .             default:
    .               // All based on ASN1_STRING and handled the same
  180 (0.0%)        strtmp = (ASN1_STRING *)*pval;
  180 (0.0%)        cont = strtmp->data;
  180 (0.0%)        len = strtmp->length;
    .         
   60 (0.0%)        break;
    .           }
  476 (0.0%)    if (cout && len) {
  196 (0.0%)      OPENSSL_memcpy(cout, cont, len);
    .           }
  140 (0.0%)    return len;
  800 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 26 ----------------------------------------
    .         
    .         #include <string.h>
    .         
    .         #include "../asn1/internal.h"
    .         #include "../internal.h"
    .         #include "internal.h"
    .         
    .         
1,812 (0.0%)  void CBS_init(CBS *cbs, const uint8_t *data, size_t len) {
  906 (0.0%)    cbs->data = data;
  906 (0.0%)    cbs->len = len;
  906 (0.0%)  }
    .         
4,710 (0.0%)  static int cbs_get(CBS *cbs, const uint8_t **p, size_t n) {
3,140 (0.0%)    if (cbs->len < n) {
   42 (0.0%)      return 0;
    .           }
    .         
3,056 (0.0%)    *p = cbs->data;
4,584 (0.0%)    cbs->data += n;
4,584 (0.0%)    cbs->len -= n;
  764 (0.0%)    return 1;
1,570 (0.0%)  }
    .         
1,197 (0.0%)  int CBS_skip(CBS *cbs, size_t len) {
    .           const uint8_t *dummy;
  798 (0.0%)    return cbs_get(cbs, &dummy, len);
  665 (0.0%)  }
    .         
1,064 (0.0%)  const uint8_t *CBS_data(const CBS *cbs) { return cbs->data; }
    .         
5,064 (0.0%)  size_t CBS_len(const CBS *cbs) { return cbs->len; }
    .         
    .         int CBS_stow(const CBS *cbs, uint8_t **out_ptr, size_t *out_len) {
    .           OPENSSL_free(*out_ptr);
    .           *out_ptr = NULL;
    .           *out_len = 0;
    .         
    .           if (cbs->len == 0) {
    .             return 1;
-- line 65 ----------------------------------------
-- line 79 ----------------------------------------
    .           *out_ptr = OPENSSL_strndup((const char *)cbs->data, cbs->len);
    .           return (*out_ptr != NULL);
    .         }
    .         
    .         int CBS_contains_zero_byte(const CBS *cbs) {
    .           return OPENSSL_memchr(cbs->data, 0, cbs->len) != NULL;
    .         }
    .         
   21 (0.0%)  int CBS_mem_equal(const CBS *cbs, const uint8_t *data, size_t len) {
   12 (0.0%)    if (len != cbs->len) {
    2 (0.0%)      return 0;
    .           }
   20 (0.0%)    return CRYPTO_memcmp(cbs->data, data, len) == 0;
    6 (0.0%)  }
    .         
   20 (0.0%)  static int cbs_get_u(CBS *cbs, uint64_t *out, size_t len) {
    2 (0.0%)    uint64_t result = 0;
    .           const uint8_t *data;
    .         
   16 (0.0%)    if (!cbs_get(cbs, &data, len)) {
    .             return 0;
    .           }
   26 (0.0%)    for (size_t i = 0; i < len; i++) {
    4 (0.0%)      result <<= 8;
   24 (0.0%)      result |= data[i];
    .           }
    6 (0.0%)    *out = result;
    2 (0.0%)    return 1;
   10 (0.0%)  }
    .         
4,653 (0.0%)  int CBS_get_u8(CBS *cbs, uint8_t *out) {
    .           const uint8_t *v;
4,136 (0.0%)    if (!cbs_get(cbs, &v, 1)) {
   42 (0.0%)      return 0;
    .           }
1,984 (0.0%)    *out = *v;
  496 (0.0%)    return 1;
2,585 (0.0%)  }
    .         
    .         int CBS_get_u16(CBS *cbs, uint16_t *out) {
    .           uint64_t v;
    .           if (!cbs_get_u(cbs, &v, 2)) {
    .             return 0;
    .           }
    .           *out = v;
    .           return 1;
-- line 124 ----------------------------------------
-- line 172 ----------------------------------------
    .           if (cbs->len == 0) {
    .             return 0;
    .           }
    .           *out = cbs->data[cbs->len - 1];
    .           cbs->len--;
    .           return 1;
    .         }
    .         
1,330 (0.0%)  int CBS_get_bytes(CBS *cbs, CBS *out, size_t len) {
    .           const uint8_t *v;
1,064 (0.0%)    if (!cbs_get(cbs, &v, len)) {
    .             return 0;
    .           }
  798 (0.0%)    CBS_init(out, v, len);
  133 (0.0%)    return 1;
  665 (0.0%)  }
    .         
    .         int CBS_copy_bytes(CBS *cbs, uint8_t *out, size_t len) {
    .           const uint8_t *v;
    .           if (!cbs_get(cbs, &v, len)) {
    .             return 0;
    .           }
    .           OPENSSL_memcpy(out, v, len);
    .           return 1;
-- line 195 ----------------------------------------
-- line 272 ----------------------------------------
    .         
    .             // Values end at an octet with the high bit cleared.
    .           } while (b & 0x80);
    .         
    .           *out = v;
    .           return 1;
    .         }
    .         
1,197 (0.0%)  static int parse_asn1_tag(CBS *cbs, CBS_ASN1_TAG *out) {
    .           uint8_t tag_byte;
  931 (0.0%)    if (!CBS_get_u8(cbs, &tag_byte)) {
    .             return 0;
    .           }
    .         
    .           // ITU-T X.690 section 8.1.2.3 specifies the format for identifiers with a tag
    .           // number no greater than 30.
    .           //
    .           // If the number portion is 31 (0x1f, the largest value that fits in the
    .           // allotted bits), then the tag is more than one byte long and the
    .           // continuation bytes contain the tag number.
  665 (0.0%)    CBS_ASN1_TAG tag = ((CBS_ASN1_TAG)tag_byte & 0xe0) << CBS_ASN1_TAG_SHIFT;
  532 (0.0%)    CBS_ASN1_TAG tag_number = tag_byte & 0x1f;
  266 (0.0%)    if (tag_number == 0x1f) {
    .             uint64_t v;
    .             if (!parse_base128_integer(cbs, &v) ||
    .                 // Check the tag number is within our supported bounds.
    .                 v > CBS_ASN1_TAG_NUMBER_MASK ||
    .                 // Small tag numbers should have used low tag number form, even in BER.
    .                 v < 0x1f) {
    .               return 0;
    .             }
    .             tag_number = (CBS_ASN1_TAG)v;
    .           }
    .         
  266 (0.0%)    tag |= tag_number;
    .         
    .           // Tag [UNIVERSAL 0] is reserved for use by the encoding. Reject it here to
    .           // avoid some ambiguity around ANY values and BER indefinite-length EOCs. See
    .           // https://crbug.com/boringssl/455.
  532 (0.0%)    if ((tag & ~CBS_ASN1_CONSTRUCTED) == 0) {
    .             return 0;
    .           }
    .         
  399 (0.0%)    *out = tag;
  133 (0.0%)    return 1;
  665 (0.0%)  }
    .         
    .         static int cbs_get_any_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
    .                                             size_t *out_header_len, int *out_ber_found,
1,862 (0.0%)                                      int *out_indefinite, int ber_ok) {
  665 (0.0%)    CBS header = *cbs;
    .           CBS throwaway;
    .         
  266 (0.0%)    if (out == NULL) {
    .             out = &throwaway;
    .           }
  266 (0.0%)    if (ber_ok) {
  250 (0.0%)      *out_ber_found = 0;
  375 (0.0%)      *out_indefinite = 0;
    .           } else {
   16 (0.0%)      assert(out_ber_found == NULL);
   16 (0.0%)      assert(out_indefinite == NULL);
    .           }
    .         
    .           CBS_ASN1_TAG tag;
  931 (0.0%)    if (!parse_asn1_tag(&header, &tag)) {
    .             return 0;
    .           }
  266 (0.0%)    if (out_tag != NULL) {
  399 (0.0%)      *out_tag = tag;
    .           }
    .         
    .           uint8_t length_byte;
  931 (0.0%)    if (!CBS_get_u8(&header, &length_byte)) {
    .             return 0;
    .           }
    .         
1,330 (0.0%)    size_t header_len = CBS_len(cbs) - CBS_len(&header);
    .         
    .           size_t len;
    .           // The format for the length encoding is specified in ITU-T X.690 section
    .           // 8.1.3.
  399 (0.0%)    if ((length_byte & 0x80) == 0) {
    .             // Short form length.
  655 (0.0%)      len = ((size_t)length_byte) + header_len;
  262 (0.0%)      if (out_header_len != NULL) {
  524 (0.0%)        *out_header_len = header_len;
    .             }
    .           } else {
    .             // The high bit indicate that this is the long form, while the next 7 bits
    .             // encode the number of subsequent octets used to encode the length (ITU-T
    .             // X.690 clause 8.1.3.5.b).
    8 (0.0%)      const size_t num_bytes = length_byte & 0x7f;
    .             uint64_t len64;
    .         
   16 (0.0%)      if (ber_ok && (tag & CBS_ASN1_CONSTRUCTED) != 0 && num_bytes == 0) {
    .               // indefinite length
    .               if (out_header_len != NULL) {
    .                 *out_header_len = header_len;
    .               }
    .               *out_ber_found = 1;
    .               *out_indefinite = 1;
    .               return CBS_get_bytes(cbs, out, header_len);
    .             }
    .         
    .             // ITU-T X.690 clause 8.1.3.5.c specifies that the value 0xff shall not be
    .             // used as the first byte of the length. If this parser encounters that
    .             // value, num_bytes will be parsed as 127, which will fail this check.
    8 (0.0%)      if (num_bytes == 0 || num_bytes > 4) {
    .               return 0;
    .             }
   16 (0.0%)      if (!cbs_get_u(&header, &len64, num_bytes)) {
    .               return 0;
    .             }
    .             // ITU-T X.690 section 10.1 (DER length forms) requires encoding the
    .             // length with the minimum number of octets. BER could, technically, have
    .             // 125 superfluous zero bytes. We do not attempt to handle that and still
    .             // require that the length fit in a |uint32_t| for BER.
    6 (0.0%)      if (len64 < 128) {
    .               // Length should have used short-form encoding.
    .               if (ber_ok) {
    .                 *out_ber_found = 1;
    .               } else {
    .                 return 0;
    .               }
    .             }
   18 (0.0%)      if ((len64 >> ((num_bytes - 1) * 8)) == 0) {
    .               // Length should have been at least one byte shorter.
    .               if (ber_ok) {
    .                 *out_ber_found = 1;
    .               } else {
    .                 return 0;
    .               }
    .             }
    4 (0.0%)      len = len64;
   14 (0.0%)      if (len + header_len + num_bytes < len) {
    .               // Overflow.
    .               return 0;
    .             }
    8 (0.0%)      len += header_len + num_bytes;
    4 (0.0%)      if (out_header_len != NULL) {
   10 (0.0%)        *out_header_len = header_len + num_bytes;
    .             }
    .           }
    .         
  798 (0.0%)    return CBS_get_bytes(cbs, out, len);
  798 (0.0%)  }
    .         
    .         int CBS_get_any_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag) {
    .           size_t header_len;
    .           if (!CBS_get_any_asn1_element(cbs, out, out_tag, &header_len)) {
    .             return 0;
    .           }
    .         
    .           if (!CBS_skip(out, header_len)) {
-- line 426 ----------------------------------------
-- line 427 ----------------------------------------
    .             assert(0);
    .             return 0;
    .           }
    .         
    .           return 1;
    .         }
    .         
    .         int CBS_get_any_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
   64 (0.0%)                               size_t *out_header_len) {
   88 (0.0%)    return cbs_get_any_asn1_element(cbs, out, out_tag, out_header_len, NULL, NULL,
    .                                           /*ber_ok=*/0);
   16 (0.0%)  }
    .         
    .         int CBS_get_any_ber_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
    .                                          size_t *out_header_len, int *out_ber_found,
1,625 (0.0%)                                   int *out_indefinite) {
    .           int ber_found_temp;
1,875 (0.0%)    return cbs_get_any_asn1_element(
    .               cbs, out, out_tag, out_header_len,
    .               out_ber_found ? out_ber_found : &ber_found_temp, out_indefinite,
    .               /*ber_ok=*/1);
  625 (0.0%)  }
    .         
    .         static int cbs_get_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value,
   88 (0.0%)                          int skip_header) {
    .           size_t header_len;
    .           CBS_ASN1_TAG tag;
    .           CBS throwaway;
    .         
   16 (0.0%)    if (out == NULL) {
    .             out = &throwaway;
    .           }
    .         
   80 (0.0%)    if (!CBS_get_any_asn1_element(cbs, out, &tag, &header_len) ||
    8 (0.0%)        tag != tag_value) {
    .             return 0;
    .           }
    .         
   72 (0.0%)    if (skip_header && !CBS_skip(out, header_len)) {
    .             assert(0);
    .             return 0;
    .           }
    .         
    8 (0.0%)    return 1;
   40 (0.0%)  }
    .         
   56 (0.0%)  int CBS_get_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value) {
   48 (0.0%)    return cbs_get_asn1(cbs, out, tag_value, 1 /* skip header */);
   16 (0.0%)  }
    .         
    .         int CBS_get_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value) {
    .           return cbs_get_asn1(cbs, out, tag_value, 0 /* include header */);
    .         }
    .         
    .         int CBS_peek_asn1_tag(const CBS *cbs, CBS_ASN1_TAG tag_value) {
    .           CBS copy = *cbs;
    .           CBS_ASN1_TAG actual_tag;
-- line 483 ----------------------------------------
-- line 670 ----------------------------------------
    .         
    .           // Unused bits are zero, and this function does not distinguish between
    .           // missing and unset bits. Thus it is sufficient to do a byte-level length
    .           // check.
    .           return byte_num < CBS_len(cbs) &&
    .                  (CBS_data(cbs)[byte_num] & (1 << bit_num)) != 0;
    .         }
    .         
   36 (0.0%)  int CBS_is_valid_asn1_integer(const CBS *cbs, int *out_is_negative) {
   20 (0.0%)    CBS copy = *cbs;
    .           uint8_t first_byte, second_byte;
   28 (0.0%)    if (!CBS_get_u8(&copy, &first_byte)) {
    .             return 0;  // INTEGERs may not be empty.
    .           }
    8 (0.0%)    if (out_is_negative != NULL) {
   20 (0.0%)      *out_is_negative = (first_byte & 0x80) != 0;
    .           }
   28 (0.0%)    if (!CBS_get_u8(&copy, &second_byte)) {
    2 (0.0%)      return 1;  // One byte INTEGERs are always minimal.
    .           }
   15 (0.0%)    if ((first_byte == 0x00 && (second_byte & 0x80) == 0) ||
    3 (0.0%)        (first_byte == 0xff && (second_byte & 0x80) != 0)) {
    .             return 0;  // The value is minimal iff the first 9 bits are not all equal.
    .           }
    3 (0.0%)    return 1;
   20 (0.0%)  }
    .         
    .         int CBS_is_unsigned_asn1_integer(const CBS *cbs) {
    .           int is_negative;
    .           return CBS_is_valid_asn1_integer(cbs, &is_negative) && !is_negative;
    .         }
    .         
    .         static int add_decimal(CBB *out, uint64_t v) {
    .           char buf[DECIMAL_SIZE(uint64_t) + 1];
    .           snprintf(buf, sizeof(buf), "%" PRIu64, v);
    .           return CBB_add_bytes(out, (const uint8_t *)buf, strlen(buf));
    .         }
    .         
  160 (0.0%)  int CBS_is_valid_asn1_oid(const CBS *cbs) {
  100 (0.0%)    if (CBS_len(cbs) == 0) {
    .             return 0;  // OID encodings cannot be empty.
    .           }
    .         
  100 (0.0%)    CBS copy = *cbs;
   20 (0.0%)    uint8_t v, prev = 0;
  692 (0.0%)    while (CBS_get_u8(&copy, &v)) {
    .             // OID encodings are a sequence of minimally-encoded base-128 integers (see
    .             // |parse_base128_integer|). If |prev|'s MSB was clear, it was the last byte
    .             // of an integer (or |v| is the first byte). |v| is then the first byte of
    .             // the next integer. If first byte of an integer is 0x80, it is not
    .             // minimally-encoded.
  435 (0.0%)      if ((prev & 0x80) == 0 && v == 0x80) {
    .               return 0;
    .             }
  152 (0.0%)      prev = v;
    .           }
    .         
    .           // The last byte should must end an integer encoding.
   80 (0.0%)    return (prev & 0x80) == 0;
  100 (0.0%)  }
    .         
    .         char *CBS_asn1_oid_to_text(const CBS *cbs) {
    .           CBB cbb;
    .           if (!CBB_init(&cbb, 32)) {
    .             goto err;
    .           }
    .         
    .           CBS copy = *cbs;
-- line 737 ----------------------------------------
-- line 766 ----------------------------------------
    .         
    .           return (char *)txt;
    .         
    .         err:
    .           CBB_cleanup(&cbb);
    .           return NULL;
    .         }
    .         
  351 (0.0%)  static int cbs_get_two_digits(CBS *cbs, int *out) {
    .           uint8_t first_digit, second_digit;
  273 (0.0%)    if (!CBS_get_u8(cbs, &first_digit)) {
    .             return 0;
    .           }
  234 (0.0%)    if (!OPENSSL_isdigit(first_digit)) {
    .             return 0;
    .           }
  273 (0.0%)    if (!CBS_get_u8(cbs, &second_digit)) {
    .             return 0;
    .           }
  234 (0.0%)    if (!OPENSSL_isdigit(second_digit)) {
    .             return 0;
    .           }
  546 (0.0%)    *out = (first_digit - '0') * 10 + (second_digit - '0');
   39 (0.0%)    return 1;
  195 (0.0%)  }
    .         
   36 (0.0%)  static int is_valid_day(int year, int month, int day) {
   12 (0.0%)    if (day < 1) {
    .             return 0;
    .           }
  108 (0.0%)    switch (month) {
    .             case 1:
    .             case 3:
    .             case 5:
    .             case 7:
    .             case 8:
    .             case 10:
    .             case 12:
   12 (0.0%)        return day <= 31;
    .             case 4:
    .             case 6:
    .             case 9:
    .             case 11:
   12 (0.0%)        return day <= 30;
    .             case 2:
    .               if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
    .                 return day <= 29;
    .               } else {
    .                 return day <= 28;
    .               }
    .             default:
    .               return 0;
    .           }
   12 (0.0%)  }
    .         
    .         static int CBS_parse_rfc5280_time_internal(const CBS *cbs, int is_gentime,
    .                                                    int allow_timezone_offset,
   66 (0.0%)                                             struct tm *out_tm) {
    .           int year, month, day, hour, min, sec, tmp;
   30 (0.0%)    CBS copy = *cbs;
    .           uint8_t tz;
    .         
   12 (0.0%)    if (is_gentime) {
   21 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
    .               return 0;
    .             }
    9 (0.0%)      year = tmp * 100;
   21 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
    .               return 0;
    .             }
    9 (0.0%)      year += tmp;
    .           } else {
    3 (0.0%)      year = 1900;
   21 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
    .               return 0;
    .             }
    6 (0.0%)      year += tmp;
    6 (0.0%)      if (year < 1950) {
    3 (0.0%)        year += 100;
    .             }
    6 (0.0%)      if (year >= 2050) {
    .               return 0;  // A Generalized time must be used.
    .             }
    .           }
   72 (0.0%)    if (!cbs_get_two_digits(&copy, &month) || month < 1 ||
   18 (0.0%)        month > 12 ||  // Reject invalid months.
   42 (0.0%)        !cbs_get_two_digits(&copy, &day) ||
   48 (0.0%)        !is_valid_day(year, month, day) ||  // Reject invalid days.
   42 (0.0%)        !cbs_get_two_digits(&copy, &hour) ||
   18 (0.0%)        hour > 23 ||  // Reject invalid hours.
   42 (0.0%)        !cbs_get_two_digits(&copy, &min) ||
   18 (0.0%)        min > 59 ||  // Reject invalid minutes.
   90 (0.0%)        !cbs_get_two_digits(&copy, &sec) || sec > 59 || !CBS_get_u8(&copy, &tz)) {
    .             return 0;
    .           }
    .         
    6 (0.0%)    int offset_sign = 0;
   24 (0.0%)    switch (tz) {
    .             case 'Z':
    6 (0.0%)        break;  // We correctly have 'Z' on the end as per spec.
    .             case '+':
    .               offset_sign = 1;
    .               break;  // Should not be allowed per RFC 5280.
    .             case '-':
    .               offset_sign = -1;
    .               break;  // Should not be allowed per RFC 5280.
    .             default:
    .               return 0;  // Reject anything else after the time.
-- line 873 ----------------------------------------
-- line 880 ----------------------------------------
    .           // are now difficult to change. These certificates were generated with the
    .           // 'openssl' command that permissively allowed the creation of certificates
    .           // with notBefore and notAfter times specified as strings for direct
    .           // certificate inclusion on the command line. For context see cl/237068815.
    .           //
    .           // TODO(bbe): This has been expunged from public web-pki as the ecosystem has
    .           // managed to encourage CA compliance with standards. We should find a way to
    .           // get rid of this or make it off by default.
    6 (0.0%)    int offset_seconds = 0;
   12 (0.0%)    if (offset_sign != 0) {
    .             if (!allow_timezone_offset) {
    .               return 0;
    .             }
    .             int offset_hours, offset_minutes;
    .             if (!cbs_get_two_digits(&copy, &offset_hours) ||
    .                 offset_hours > 23 ||  // Reject invalid hours.
    .                 !cbs_get_two_digits(&copy, &offset_minutes) ||
    .                 offset_minutes > 59) {  // Reject invalid minutes.
    .               return 0;
    .             }
    .             offset_seconds = offset_sign * (offset_hours * 3600 + offset_minutes * 60);
    .           }
    .         
   30 (0.0%)    if (CBS_len(&copy) != 0) {
    .             return 0;  // Reject invalid lengths.
    .           }
    .         
   12 (0.0%)    if (out_tm != NULL) {
    .             // Fill in the tm fields corresponding to what we validated.
   16 (0.0%)      out_tm->tm_year = year - 1900;
   16 (0.0%)      out_tm->tm_mon = month - 1;
   12 (0.0%)      out_tm->tm_mday = day;
   12 (0.0%)      out_tm->tm_hour = hour;
   12 (0.0%)      out_tm->tm_min = min;
   12 (0.0%)      out_tm->tm_sec = sec;
    8 (0.0%)      if (offset_seconds && !OPENSSL_gmtime_adj(out_tm, 0, offset_seconds)) {
    .               return 0;
    .             }
    .           }
    6 (0.0%)    return 1;
   30 (0.0%)  }
    .         
    .         int CBS_parse_generalized_time(const CBS *cbs, struct tm *out_tm,
   21 (0.0%)                                 int allow_timezone_offset) {
   18 (0.0%)    return CBS_parse_rfc5280_time_internal(cbs, 1, allow_timezone_offset, out_tm);
    6 (0.0%)  }
    .         
    .         int CBS_parse_utc_time(const CBS *cbs, struct tm *out_tm,
   21 (0.0%)                         int allow_timezone_offset) {
   18 (0.0%)    return CBS_parse_rfc5280_time_internal(cbs, 0, allow_timezone_offset, out_tm);
    6 (0.0%)  }
    .         
    .         int CBS_get_optional_asn1_int64(CBS *cbs, int64_t *out, CBS_ASN1_TAG tag,
    .                                         int64_t default_value) {
    .           CBS child;
    .           int present;
    .           if (!CBS_get_optional_asn1(cbs, &child, &present, tag)) {
    .             return 0;
    .           }
-- line 938 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h
--------------------------------------------------------------------------------
Ir____________ 

-- line 218 ----------------------------------------
      .         #define OPENSSL_HAS_BUILTIN(x) 0
      .         #endif
      .         
      .         
      .         // Pointer utility functions.
      .         
      .         // buffers_alias returns one if |a| and |b| alias and zero otherwise.
      .         static inline int buffers_alias(const uint8_t *a, size_t a_len,
     90 (0.0%)                                  const uint8_t *b, size_t b_len) {
      .           // Cast |a| and |b| to integers. In C, pointer comparisons between unrelated
      .           // objects are undefined whereas pointer to integer conversions are merely
      .           // implementation-defined. We assume the implementation defined it in a sane
      .           // way.
     30 (0.0%)    uintptr_t a_u = (uintptr_t)a;
     30 (0.0%)    uintptr_t b_u = (uintptr_t)b;
    180 (0.0%)    return a_u + a_len > b_u && b_u + b_len > a_u;
     30 (0.0%)  }
      .         
      .         typedef uint8_t stack_align_type;
      .         OPENSSL_STATIC_ASSERT(sizeof(stack_align_type) == 1,
      .                               stack_align_type_is_not_8_bits_long)
      .         
      .         // align_pointer returns |ptr|, advanced to |alignment|. |alignment| must be a
      .         // power of two, and |ptr| must have at least |alignment - 1| bytes of scratch
      .         // space.
    410 (0.0%)  static inline void *align_pointer(void *ptr, size_t alignment) {
      .           // |alignment| must be a power of two.
    574 (0.0%)    assert(alignment != 0 && (alignment & (alignment - 1)) == 0);
      .           // Instead of aligning |ptr| as a |uintptr_t| and casting back, compute the
      .           // offset and advance in pointer space. C guarantees that casting from pointer
      .           // to |uintptr_t| and back gives the same pointer, but general
      .           // integer-to-pointer conversions are implementation-defined. GCC does define
      .           // it in the useful way, but this makes fewer assumptions.
    574 (0.0%)    uintptr_t offset = (0u - (uintptr_t)ptr) & (alignment - 1);
    164 (0.0%)    ptr = (char *)ptr + offset;
    492 (0.0%)    assert(((uintptr_t)ptr & (alignment - 1)) == 0);
     82 (0.0%)    return ptr;
    164 (0.0%)  }
      .         
      .         
      .         // Constant-time utility functions.
      .         //
      .         // The following methods return a bitmask of all ones (0xff...f) for true and 0
      .         // for false. This is useful for choosing a value based on the result of a
      .         // conditional in constant time. For example,
      .         //
-- line 263 ----------------------------------------
-- line 293 ----------------------------------------
      .         
      .         // value_barrier_w returns |a|, but prevents GCC and Clang from reasoning about
      .         // the returned value. This is used to mitigate compilers undoing constant-time
      .         // code, until we can express our requirements directly in the language.
      .         //
      .         // Note the compiler is aware that |value_barrier_w| has no side effects and
      .         // always has the same output for a given input. This allows it to eliminate
      .         // dead code, move computations across loops, and vectorize.
137,553 (1.3%)  static inline crypto_word_t value_barrier_w(crypto_word_t a) {
      .         #if defined(__GNUC__) || defined(__clang__)
 91,702 (0.9%)    __asm__("" : "+r"(a) : /* no inputs */);
      .         #endif
 45,851 (0.4%)    return a;
 91,702 (0.9%)  }
      .         
      .         // value_barrier_u32 behaves like |value_barrier_w| but takes a |uint32_t|.
     27 (0.0%)  static inline uint32_t value_barrier_u32(uint32_t a) {
      .         #if defined(__GNUC__) || defined(__clang__)
     18 (0.0%)    __asm__("" : "+r"(a) : /* no inputs */);
      .         #endif
      9 (0.0%)    return a;
     18 (0.0%)  }
      .         
      .         // value_barrier_u64 behaves like |value_barrier_w| but takes a |uint64_t|.
      .         static inline uint64_t value_barrier_u64(uint64_t a) {
      .         #if defined(__GNUC__) || defined(__clang__)
      .           __asm__("" : "+r"(a) : /* no inputs */);
      .         #endif
      .           return a;
      .         }
      .         
      .         // constant_time_msb_w returns the given value with the MSB copied to all the
      .         // other bits.
 13,506 (0.1%)  static inline crypto_word_t constant_time_msb_w(crypto_word_t a) {
  9,004 (0.1%)    return 0u - (a >> (sizeof(a) * 8 - 1));
  9,004 (0.1%)  }
      .         
      .         // constant_time_lt_w returns 0xff..f if a < b and 0 otherwise.
      .         static inline crypto_word_t constant_time_lt_w(crypto_word_t a,
    365 (0.0%)                                                 crypto_word_t b) {
      .           // Consider the two cases of the problem:
      .           //   msb(a) == msb(b): a < b iff the MSB of a - b is set.
      .           //   msb(a) != msb(b): a < b iff the MSB of b is set.
      .           //
      .           // If msb(a) == msb(b) then the following evaluates as:
      .           //   msb(a^((a^b)|((a-b)^a))) ==
      .           //   msb(a^((a-b) ^ a))       ==   (because msb(a^b) == 0)
      .           //   msb(a^a^(a-b))           ==   (rearranging)
-- line 340 ----------------------------------------
-- line 355 ----------------------------------------
      .           // )
      .           //
      .           // (declare-fun a () (_ BitVec 32))
      .           // (declare-fun b () (_ BitVec 32))
      .           //
      .           // (assert (not (= (= #x00000001 (bvlshr (lt a b) #x0000001f)) (bvult a b))))
      .           // (check-sat)
      .           // (get-model)
    730 (0.0%)    return constant_time_msb_w(a^((a^b)|((a-b)^a)));
    146 (0.0%)  }
      .         
      .         // constant_time_lt_8 acts like |constant_time_lt_w| but returns an 8-bit
      .         // mask.
      .         static inline uint8_t constant_time_lt_8(crypto_word_t a, crypto_word_t b) {
      .           return (uint8_t)(constant_time_lt_w(a, b));
      .         }
      .         
      .         // constant_time_ge_w returns 0xff..f if a >= b and 0 otherwise.
-- line 372 ----------------------------------------
-- line 377 ----------------------------------------
      .         
      .         // constant_time_ge_8 acts like |constant_time_ge_w| but returns an 8-bit
      .         // mask.
      .         static inline uint8_t constant_time_ge_8(crypto_word_t a, crypto_word_t b) {
      .           return (uint8_t)(constant_time_ge_w(a, b));
      .         }
      .         
      .         // constant_time_is_zero returns 0xff..f if a == 0 and 0 otherwise.
 17,716 (0.2%)  static inline crypto_word_t constant_time_is_zero_w(crypto_word_t a) {
      .           // Here is an SMT-LIB verification of this formula:
      .           //
      .           // (define-fun is_zero ((a (_ BitVec 32))) (_ BitVec 32)
      .           //   (bvand (bvnot a) (bvsub a #x00000001))
      .           // )
      .           //
      .           // (declare-fun a () (_ BitVec 32))
      .           //
      .           // (assert (not (= (= #x00000001 (bvlshr (is_zero a) #x0000001f)) (= a #x00000000))))
      .           // (check-sat)
      .           // (get-model)
 35,432 (0.3%)    return constant_time_msb_w(~a & (a - 1));
  8,858 (0.1%)  }
      .         
      .         // constant_time_is_zero_8 acts like |constant_time_is_zero_w| but returns an
      .         // 8-bit mask.
      .         static inline uint8_t constant_time_is_zero_8(crypto_word_t a) {
      .           return (uint8_t)(constant_time_is_zero_w(a));
      .         }
      .         
      .         // constant_time_eq_w returns 0xff..f if a == b and 0 otherwise.
      .         static inline crypto_word_t constant_time_eq_w(crypto_word_t a,
    350 (0.0%)                                                 crypto_word_t b) {
    280 (0.0%)    return constant_time_is_zero_w(a ^ b);
    140 (0.0%)  }
      .         
      .         // constant_time_eq_8 acts like |constant_time_eq_w| but returns an 8-bit
      .         // mask.
      .         static inline uint8_t constant_time_eq_8(crypto_word_t a, crypto_word_t b) {
      .           return (uint8_t)(constant_time_eq_w(a, b));
      .         }
      .         
      .         // constant_time_eq_int acts like |constant_time_eq_w| but works on int
-- line 418 ----------------------------------------
-- line 427 ----------------------------------------
      .           return constant_time_eq_8((crypto_word_t)(a), (crypto_word_t)(b));
      .         }
      .         
      .         // constant_time_select_w returns (mask & a) | (~mask & b). When |mask| is all
      .         // 1s or all 0s (as returned by the methods above), the select methods return
      .         // either |a| (if |mask| is nonzero) or |b| (if |mask| is zero).
      .         static inline crypto_word_t constant_time_select_w(crypto_word_t mask,
      .                                                            crypto_word_t a,
159,782 (1.5%)                                                     crypto_word_t b) {
      .           // Clang recognizes this pattern as a select. While it usually transforms it
      .           // to a cmov, it sometimes further transforms it into a branch, which we do
      .           // not want.
      .           //
      .           // Adding barriers to both |mask| and |~mask| breaks the relationship between
      .           // the two, which makes the compiler stick with bitmasks.
251,086 (2.3%)    return (value_barrier_w(mask) & a) | (value_barrier_w(~mask) & b);
 68,478 (0.6%)  }
      .         
      .         // constant_time_select_8 acts like |constant_time_select| but operates on
      .         // 8-bit values.
      .         static inline uint8_t constant_time_select_8(uint8_t mask, uint8_t a,
      .                                                      uint8_t b) {
      .           return (uint8_t)(constant_time_select_w(mask, a, b));
      .         }
      .         
      .         // constant_time_select_int acts like |constant_time_select| but operates on
      .         // ints.
    840 (0.0%)  static inline int constant_time_select_int(crypto_word_t mask, int a, int b) {
  1,120 (0.0%)    return (int)(constant_time_select_w(mask, (crypto_word_t)(a),
      .                                               (crypto_word_t)(b)));
    280 (0.0%)  }
      .         
      .         #if defined(BORINGSSL_CONSTANT_TIME_VALIDATION)
      .         
      .         // CONSTTIME_SECRET takes a pointer and a number of bytes and marks that region
      .         // of memory as secret. Secret data is tracked as it flows to registers and
      .         // other parts of a memory. If secret data is used as a condition for a branch,
      .         // or as a memory index, it will trigger warnings in valgrind.
      .         #define CONSTTIME_SECRET(ptr, len) VALGRIND_MAKE_MEM_UNDEFINED(ptr, len)
-- line 465 ----------------------------------------
-- line 471 ----------------------------------------
      .         
      .         #else
      .         
      .         #define CONSTTIME_SECRET(ptr, len)
      .         #define CONSTTIME_DECLASSIFY(ptr, len)
      .         
      .         #endif  // BORINGSSL_CONSTANT_TIME_VALIDATION
      .         
    796 (0.0%)  static inline crypto_word_t constant_time_declassify_w(crypto_word_t v) {
      .           // Return |v| through a value barrier to be safe. Valgrind-based constant-time
      .           // validation is partly to check the compiler has not undone any constant-time
      .           // work. Any place |BORINGSSL_CONSTANT_TIME_VALIDATION| influences
      .           // optimizations, this validation is inaccurate.
      .           //
      .           // However, by sending pointers through valgrind, we likely inhibit escape
      .           // analysis. On local variables, particularly booleans, we likely
      .           // significantly impact optimizations.
      .           //
      .           // Thus, to be safe, stick a value barrier, in hopes of comparably inhibiting
      .           // compiler analysis.
      .           CONSTTIME_DECLASSIFY(&v, sizeof(v));
    597 (0.0%)    return value_barrier_w(v);
    398 (0.0%)  }
      .         
     36 (0.0%)  static inline int constant_time_declassify_int(int v) {
      .           OPENSSL_STATIC_ASSERT(sizeof(uint32_t) == sizeof(int),
      .                         int_is_not_the_same_size_as_uint32_t);
      .           // See comment above.
      .           CONSTTIME_DECLASSIFY(&v, sizeof(v));
     27 (0.0%)    return value_barrier_u32(v);
     18 (0.0%)  }
      .         
      .         
      .         // Thread-safe initialisation.
      .         
      .         #if !defined(OPENSSL_THREADS)
      .         typedef uint32_t CRYPTO_once_t;
      .         #define CRYPTO_ONCE_INIT 0
      .         #elif defined(OPENSSL_WINDOWS_THREADS)
-- line 509 ----------------------------------------
-- line 800 ----------------------------------------
      .         static inline uint64_t CRYPTO_bswap8(uint64_t x) {
      .           return _byteswap_uint64(x);
      .         }
      .         #else
      .         static inline uint16_t CRYPTO_bswap2(uint16_t x) {
      .           return (x >> 8) | (x << 8);
      .         }
      .         
  4,281 (0.0%)  static inline uint32_t CRYPTO_bswap4(uint32_t x) {
  1,427 (0.0%)    x = (x >> 16) | (x << 16);
 12,843 (0.1%)    x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);
  1,427 (0.0%)    return x;
  2,854 (0.0%)  }
      .         
    705 (0.0%)  static inline uint64_t CRYPTO_bswap8(uint64_t x) {
  1,551 (0.0%)    return CRYPTO_bswap4(x >> 32) | (((uint64_t)CRYPTO_bswap4(x)) << 32);
    423 (0.0%)  }
      .         #endif
      .         
      .         
      .         // Language bug workarounds.
      .         //
      .         // Most C standard library functions are undefined if passed NULL, even when the
      .         // corresponding length is zero. This gives them (and, in turn, all functions
      .         // which call them) surprising behavior on empty arrays. Some compilers will
-- line 824 ----------------------------------------
-- line 858 ----------------------------------------
      .             return NULL;
      .           }
      .         
      .           return memchr(s, c, n);
      .         }
      .         
      .         #endif  // __cplusplus
      .         
     12 (0.0%)  static inline int OPENSSL_memcmp(const void *s1, const void *s2, size_t n) {
      4 (0.0%)    if (n == 0) {
      .             return 0;
      .           }
      .         
     12 (0.0%)    return memcmp(s1, s2, n);
      4 (0.0%)  }
      .         
 12,078 (0.1%)  static inline void *OPENSSL_memcpy(void *dst, const void *src, size_t n) {
  4,026 (0.0%)    if (n == 0) {
     16 (0.0%)      return dst;
      .           }
      .         
 12,030 (0.1%)    return memcpy(dst, src, n);
  4,026 (0.0%)  }
      .         
     12 (0.0%)  static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
      4 (0.0%)    if (n == 0) {
      .             return dst;
      .           }
      .         
     12 (0.0%)    return memmove(dst, src, n);
      4 (0.0%)  }
      .         
  3,726 (0.0%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
  1,242 (0.0%)    if (n == 0) {
     54 (0.0%)      return dst;
      .           }
      .         
  3,564 (0.0%)    return memset(dst, c, n);
  1,242 (0.0%)  }
      .         
      .         
      .         // Loads and stores.
      .         //
      .         // The following functions load and store sized integers with the specified
      .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
      .         // requirements on the input and output pointers.
      .         
-- line 904 ----------------------------------------
-- line 949 ----------------------------------------
      .         static inline void CRYPTO_store_u32_le(void *out, uint32_t v) {
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           v = CRYPTO_bswap4(v);
      .         #endif
      .           OPENSSL_memcpy(out, &v, sizeof(v));
      .         
      .         }
      .         
    238 (0.0%)  static inline uint32_t CRYPTO_load_u32_be(const void *in) {
      .           uint32_t v;
    204 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           return v;
      .         #else
    102 (0.0%)    return CRYPTO_bswap4(v);
      .         #endif
    170 (0.0%)  }
      .         
  5,555 (0.1%)  static inline void CRYPTO_store_u32_be(void *out, uint32_t v) {
      .         
      .         #if !defined(OPENSSL_BIG_ENDIAN)
  4,444 (0.0%)    v = CRYPTO_bswap4(v);
      .         #endif
  6,666 (0.1%)    OPENSSL_memcpy(out, &v, sizeof(v));
      .         
  3,333 (0.0%)  }
      .         
      .         static inline uint64_t CRYPTO_load_u64_le(const void *in) {
      .           uint64_t v;
      .           OPENSSL_memcpy(&v, in, sizeof(v));
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           return CRYPTO_bswap8(v);
      .         #else
      .           return v;
-- line 982 ----------------------------------------
-- line 986 ----------------------------------------
      .         static inline void CRYPTO_store_u64_le(void *out, uint64_t v) {
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           v = CRYPTO_bswap8(v);
      .         #endif
      .           OPENSSL_memcpy(out, &v, sizeof(v));
      .         
      .         }
      .         
    147 (0.0%)  static inline uint64_t CRYPTO_load_u64_be(const void *ptr) {
      .           uint64_t ret;
    126 (0.0%)    OPENSSL_memcpy(&ret, ptr, sizeof(ret));
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           return ret;
      .         #else
     63 (0.0%)    return CRYPTO_bswap8(ret);
      .         #endif
    105 (0.0%)  }
      .         
    230 (0.0%)  static inline void CRYPTO_store_u64_be(void *out, uint64_t v) {
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .         #else
    184 (0.0%)    v = CRYPTO_bswap8(v);
      .         #endif
    276 (0.0%)    OPENSSL_memcpy(out, &v, sizeof(v));
      .         
    138 (0.0%)  }
      .         
    560 (0.0%)  static inline crypto_word_t CRYPTO_load_word_le(const void *in) {
      .         
      .           crypto_word_t v;
    480 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           return CRYPTO_bswap_word(v);
      .         #else
     80 (0.0%)    return v;
      .         #endif
    400 (0.0%)  }
      .         
    200 (0.0%)  static inline void CRYPTO_store_word_le(void *out, crypto_word_t v) {
      .         
      .         
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           v = CRYPTO_bswap_word(v);
      .         #endif
    240 (0.0%)    OPENSSL_memcpy(out, &v, sizeof(v));
      .         
    120 (0.0%)  }
      .         
    518 (0.0%)  static inline crypto_word_t CRYPTO_load_word_be(const void *in) {
      .           crypto_word_t v;
    444 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           return v;
      .         #else
      .         #if defined(OPENSSL_64_BIT)
      .           assert(sizeof(v) == 8);
    222 (0.0%)    return CRYPTO_bswap8(v);
      .         #else
      .           assert(sizeof(v) == 4);
      .           return CRYPTO_bswap4(v);
      .         #endif
      .         #endif
    370 (0.0%)  }
      .         
      .         // Bit rotation functions.
      .         //
      .         // Note these functions use |(-shift) & 31|, etc., because shifting by the bit
      .         // width is undefined. Both Clang and GCC recognize this pattern as a rotation,
      .         // but MSVC does not. Instead, we call MSVC's built-in functions.
      .         
      .         static inline uint32_t CRYPTO_rotl_u32(uint32_t value, int shift) {
-- line 1056 ----------------------------------------
-- line 1236 ----------------------------------------
      .         // if unsuccessful.
      .         void boringssl_ensure_ffdh_self_test(void);
      .         
      .         #else
      .         
      .         // Outside of FIPS mode, the lazy tests are no-ops.
      .         
      .         OPENSSL_INLINE void boringssl_ensure_rsa_self_test(void) {}
     20 (0.0%)  OPENSSL_INLINE void boringssl_ensure_ecc_self_test(void) {}
      .         OPENSSL_INLINE void boringssl_ensure_ffdh_self_test(void) {}
      .         
      .         #endif  // FIPS
      .         
      .         // boringssl_self_test_sha256 performs a SHA-256 KAT.
      .         int boringssl_self_test_sha256(void);
      .         
      .         // boringssl_self_test_hmac_sha256 performs an HMAC-SHA-256 KAT.
      .         int boringssl_self_test_hmac_sha256(void);
      .         
      .         #if defined(BORINGSSL_FIPS_COUNTERS)
      .         void boringssl_fips_inc_counter(enum fips_counter_t counter);
      .         #else
     48 (0.0%)  OPENSSL_INLINE void boringssl_fips_inc_counter(enum fips_counter_t counter) {}
      .         #endif
      .         
      .         #if defined(BORINGSSL_FIPS_BREAK_TESTS)
      .         OPENSSL_INLINE int boringssl_fips_break_test(const char *test) {
      .           const char *const value = getenv("BORINGSSL_FIPS_BREAK_TEST");
      .           return value != NULL && strcmp(value, test) == 0;
      .         }
      .         #else
-- line 1266 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/aes/../cpucap/internal.h
--------------------------------------------------------------------------------
Ir___________ 

-- line 38 ----------------------------------------
     .         extern uint32_t OPENSSL_ia32cap_P[4];
     .         
     .         #if defined(BORINGSSL_FIPS) && !defined(BORINGSSL_SHARED_LIBRARY)
     .         // The FIPS module, as a static library, requires an out-of-line version of
     .         // |OPENSSL_ia32cap_get| so accesses can be rewritten by delocate. Mark the
     .         // function const so multiple accesses can be optimized together.
     .         const uint32_t *OPENSSL_ia32cap_get(void) __attribute__((const));
     .         #else
24,508 (0.2%)  OPENSSL_INLINE const uint32_t *OPENSSL_ia32cap_get(void) {
12,254 (0.1%)    return OPENSSL_ia32cap_P;
24,508 (0.2%)  }
     .         #endif
     .         
     .         // See Intel manual, volume 2A, table 3-11.
     .         
    16 (0.0%)  OPENSSL_INLINE int CRYPTO_is_FXSR_capable(void) {
    48 (0.0%)    return (OPENSSL_ia32cap_get()[0] & (1 << 24)) != 0;
    16 (0.0%)  }
     .         
     6 (0.0%)  OPENSSL_INLINE int CRYPTO_is_intel_cpu(void) {
     .           // The reserved bit 30 is used to indicate an Intel CPU.
    18 (0.0%)    return (OPENSSL_ia32cap_get()[0] & (1 << 30)) != 0;
     6 (0.0%)  }
     .         
     .         // See Intel manual, volume 2A, table 3-10.
     .         
    16 (0.0%)  OPENSSL_INLINE int CRYPTO_is_PCLMUL_capable(void) {
    56 (0.0%)    return (OPENSSL_ia32cap_get()[1] & (1 << 1)) != 0;
    16 (0.0%)  }
     .         
     .         OPENSSL_INLINE int CRYPTO_is_SSSE3_capable(void) {
     .           return (OPENSSL_ia32cap_get()[1] & (1 << 9)) != 0;
     .         }
     .         
     .         OPENSSL_INLINE int CRYPTO_is_SSE4_1_capable(void) {
     .           return (OPENSSL_ia32cap_get()[1] & (1 << 19)) != 0;
     .         }
     .         
    16 (0.0%)  OPENSSL_INLINE int CRYPTO_is_MOVBE_capable(void) {
    56 (0.0%)    return (OPENSSL_ia32cap_get()[1] & (1 << 22)) != 0;
    16 (0.0%)  }
     .         
    40 (0.0%)  OPENSSL_INLINE int CRYPTO_is_AESNI_capable(void) {
   140 (0.0%)    return (OPENSSL_ia32cap_get()[1] & (1 << 25)) != 0;
    40 (0.0%)  }
     .         
    16 (0.0%)  OPENSSL_INLINE int CRYPTO_is_AVX_capable(void) {
    56 (0.0%)    return (OPENSSL_ia32cap_get()[1] & (1 << 28)) != 0;
    16 (0.0%)  }
     .         
     6 (0.0%)  OPENSSL_INLINE int CRYPTO_is_RDRAND_capable(void) {
    21 (0.0%)    return (OPENSSL_ia32cap_get()[1] & (1u << 30)) != 0;
     6 (0.0%)  }
     .         
     .         OPENSSL_INLINE int CRYPTO_is_AMD_XOP_support(void) {
     .           return (OPENSSL_ia32cap_get()[1] & (1 << 11)) != 0;
     .         }
     .         
     .         // See Intel manual, volume 2A, table 3-8.
     .         
     .         OPENSSL_INLINE int CRYPTO_is_BMI1_capable(void) {
     .           return (OPENSSL_ia32cap_get()[2] & (1 << 3)) != 0;
     .         }
     .         
     .         OPENSSL_INLINE int CRYPTO_is_AVX2_capable(void) {
     .           return (OPENSSL_ia32cap_get()[2] & (1 << 5)) != 0;
     .         }
     .         
12,168 (0.1%)  OPENSSL_INLINE int CRYPTO_is_BMI2_capable(void) {
42,588 (0.4%)    return (OPENSSL_ia32cap_get()[2] & (1 << 8)) != 0;
12,168 (0.1%)  }
     .         
12,168 (0.1%)  OPENSSL_INLINE int CRYPTO_is_ADX_capable(void) {
42,588 (0.4%)    return (OPENSSL_ia32cap_get()[2] & (1 << 19)) != 0;
12,168 (0.1%)  }
     .         
     .         OPENSSL_INLINE int CRYPTO_is_SHAEXT_capable(void) {
     .           return (OPENSSL_ia32cap_get()[2] & (1 << 29)) != 0;
     .         }
     .         
     .         OPENSSL_INLINE int CRYPTO_is_AVX512_capable(void) {
     .           return (OPENSSL_ia32cap_get()[2] & 0xC0030000) == 0xC0030000;
     .         }
     .         
    56 (0.0%)  OPENSSL_INLINE int CRYPTO_is_VAES_capable(void) {
   196 (0.0%)    return (OPENSSL_ia32cap_get()[3] & (1u << (41 - 32))) != 0;
    56 (0.0%)  }
     .         
     .         OPENSSL_INLINE int CRYPTO_is_VPCLMULQDQ_capable(void) {
     .           return (OPENSSL_ia32cap_get()[3] & (1u << (42 - 32))) != 0;
     .         }
     .         
     .         OPENSSL_INLINE int CRYPTO_is_VBMI2_capable(void) {
     .           return (OPENSSL_ia32cap_get()[3] & (1 << 6)) != 0;
     .         }
-- line 132 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/exponentiation.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 439 ----------------------------------------
    .         //    w >= 6  if        b > 671
    .         //     w = 5  if  671 > b > 239
    .         //     w = 4  if  239 > b >  79
    .         //     w = 3  if   79 > b >  23
    .         //    w <= 2  if   23 > b
    .         //
    .         // (with draws in between).  Very small exponents are often selected
    .         // with low Hamming weight, so we use  w = 1  for b <= 23.
    8 (0.0%)  static int BN_window_bits_for_exponent_size(size_t b) {
    4 (0.0%)    if (b > 671) {
    .             return 6;
    .           }
    4 (0.0%)    if (b > 239) {
    4 (0.0%)      return 5;
    .           }
    .           if (b > 79) {
    .             return 4;
    .           }
    .           if (b > 23) {
    .             return 3;
    .           }
    .           return 1;
    4 (0.0%)  }
    .         
    .         // TABLE_SIZE is the maximum precomputation table size for *variable* sliding
    .         // windows. This must be 2^(max_window - 1), where max_window is the largest
    .         // value returned from |BN_window_bits_for_exponent_size|.
    .         #define TABLE_SIZE 32
    .         
    .         // TABLE_BITS_SMALL is the smallest value returned from
    .         // |BN_window_bits_for_exponent_size| when |b| is at most |BN_BITS2| *
-- line 469 ----------------------------------------
-- line 764 ----------------------------------------
    .         err:
    .           BN_MONT_CTX_free(new_mont);
    .           BN_CTX_end(ctx);
    .           return ret;
    .         }
    .         
    .         void bn_mod_exp_mont_small(BN_ULONG *r, const BN_ULONG *a, size_t num,
    .                                    const BN_ULONG *p, size_t num_p,
   26 (0.0%)                             const BN_MONT_CTX *mont) {
   20 (0.0%)    if (num != (size_t)mont->N.width || num > BN_SMALL_MAX_WORDS ||
    .               num_p > SIZE_MAX / BN_BITS2) {
    .             abort();
    .           }
   12 (0.0%)    assert(BN_is_odd(&mont->N));
    .         
    .           // Count the number of bits in |p|, skipping leading zeros. Note this function
    .           // treats |p| as public.
   20 (0.0%)    while (num_p != 0 && p[num_p - 1] == 0) {
    .             num_p--;
    .           }
    4 (0.0%)    if (num_p == 0) {
    .             bn_from_montgomery_small(r, num, mont->RR.d, num, mont);
    .             return;
    .           }
   28 (0.0%)    size_t bits = BN_num_bits_word(p[num_p - 1]) + (num_p - 1) * BN_BITS2;
    4 (0.0%)    assert(bits != 0);
    .         
    .           // We exponentiate by looking at sliding windows of the exponent and
    .           // precomputing powers of |a|. Windows may be shifted so they always end on a
    .           // set bit, so only precompute odd powers. We compute val[i] = a^(2*i + 1) for
    .           // i = 0 to 2^(window-1), all in Montgomery form.
    8 (0.0%)    unsigned window = BN_window_bits_for_exponent_size(bits);
    4 (0.0%)    if (window > TABLE_BITS_SMALL) {
    .             window = TABLE_BITS_SMALL;  // Tolerate excessively large |p|.
    .           }
    .           BN_ULONG val[TABLE_SIZE_SMALL][BN_SMALL_MAX_WORDS];
   14 (0.0%)    OPENSSL_memcpy(val[0], a, num * sizeof(BN_ULONG));
    4 (0.0%)    if (window > 1) {
    .             BN_ULONG d[BN_SMALL_MAX_WORDS];
   16 (0.0%)      bn_mod_mul_montgomery_small(d, val[0], val[0], num, mont);
  290 (0.0%)      for (unsigned i = 1; i < 1u << (window - 1); i++) {
  690 (0.0%)        bn_mod_mul_montgomery_small(val[i], val[i - 1], d, num, mont);
    .             }
    .           }
    .         
    .           // |p| is non-zero, so at least one window is non-zero. To save some
    .           // multiplications, defer initializing |r| until then.
    2 (0.0%)    int r_is_one = 1;
    6 (0.0%)    size_t wstart = bits - 1;  // The top bit of the window.
  254 (0.0%)    for (;;) {
2,048 (0.0%)      if (!bn_is_bit_set_words(p, num_p, wstart)) {
  228 (0.0%)        if (!r_is_one) {
  912 (0.0%)          bn_mod_mul_montgomery_small(r, r, r, num, mont);
    .               }
  228 (0.0%)        if (wstart == 0) {
    .                 break;
    .               }
  114 (0.0%)        wstart--;
  114 (0.0%)        continue;
    .             }
    .         
    .             // We now have wstart on a set bit. Find the largest window we can use.
  142 (0.0%)      unsigned wvalue = 1;
  142 (0.0%)      unsigned wsize = 0;
4,636 (0.0%)      for (unsigned i = 1; i < window && i <= wstart; i++) {
5,600 (0.1%)        if (bn_is_bit_set_words(p, num_p, wstart - i)) {
1,736 (0.0%)          wvalue <<= (i - wsize);
  434 (0.0%)          wvalue |= 1;
  868 (0.0%)          wsize = i;
    .               }
    .             }
    .         
    .             // Shift |r| to the end of the window.
  284 (0.0%)      if (!r_is_one) {
4,060 (0.0%)        for (unsigned i = 0; i < wsize + 1; i++) {
5,152 (0.0%)          bn_mod_mul_montgomery_small(r, r, r, num, mont);
    .               }
    .             }
    .         
  568 (0.0%)      assert(wvalue & 1);
  994 (0.0%)      assert(wvalue < (1u << window));
  284 (0.0%)      if (r_is_one) {
   32 (0.0%)        OPENSSL_memcpy(r, val[wvalue >> 1], num * sizeof(BN_ULONG));
    .             } else {
2,520 (0.0%)        bn_mod_mul_montgomery_small(r, r, val[wvalue >> 1], num, mont);
    .             }
  142 (0.0%)      r_is_one = 0;
  426 (0.0%)      if (wstart == wsize) {
    2 (0.0%)        break;
    .             }
  560 (0.0%)      wstart -= wsize + 1;
    .           }
    .         
    .           // |p| is non-zero, so |r_is_one| must be cleared at some point.
    4 (0.0%)    assert(!r_is_one);
    8 (0.0%)    OPENSSL_cleanse(val, sizeof(val));
   10 (0.0%)  }
    .         
    .         void bn_mod_inverse0_prime_mont_small(BN_ULONG *r, const BN_ULONG *a,
   22 (0.0%)                                        size_t num, const BN_MONT_CTX *mont) {
   14 (0.0%)    if (num != (size_t)mont->N.width || num > BN_SMALL_MAX_WORDS) {
    .             abort();
    .           }
    .         
    .           // Per Fermat's Little Theorem, a^-1 = a^(p-2) (mod p) for p prime.
    .           BN_ULONG p_minus_two[BN_SMALL_MAX_WORDS];
    6 (0.0%)    const BN_ULONG *p = mont->N.d;
   14 (0.0%)    OPENSSL_memcpy(p_minus_two, p, num * sizeof(BN_ULONG));
    6 (0.0%)    if (p_minus_two[0] >= 2) {
    8 (0.0%)      p_minus_two[0] -= 2;
    .           } else {
    .             p_minus_two[0] -= 2;
    .             for (size_t i = 1; i < num; i++) {
    .               if (p_minus_two[i]-- != 0) {
    .                 break;
    .               }
    .             }
    .           }
    .         
   20 (0.0%)    bn_mod_exp_mont_small(r, a, num, p_minus_two, num, mont);
   12 (0.0%)  }
    .         
    .         static void copy_to_prebuf(const BIGNUM *b, int top, BN_ULONG *table, int idx,
    .                                    int window) {
    .           int ret = bn_copy_words(table + idx * top, top, b);
    .           assert(ret);  // |b| is guaranteed to fit.
    .           (void)ret;
    .         }
    .         
-- line 892 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/montgomery.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 314 ----------------------------------------
     .         }
     .         
     .         int BN_to_montgomery(BIGNUM *ret, const BIGNUM *a, const BN_MONT_CTX *mont,
     .                              BN_CTX *ctx) {
     .           return BN_mod_mul_montgomery(ret, a, &mont->RR, mont, ctx);
     .         }
     .         
     .         static int bn_from_montgomery_in_place(BN_ULONG *r, size_t num_r, BN_ULONG *a,
   108 (0.0%)                                         size_t num_a, const BN_MONT_CTX *mont) {
    36 (0.0%)    const BN_ULONG *n = mont->N.d;
    48 (0.0%)    size_t num_n = mont->N.width;
    84 (0.0%)    if (num_r != num_n || num_a != 2 * num_n) {
     .             OPENSSL_PUT_ERROR(BN, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
     .             return 0;
     .           }
     .         
     .           // Add multiples of |n| to |r| until R = 2^(nl * BN_BITS2) divides it. On
     .           // input, we had |r| < |n| * R, so now |r| < 2 * |n| * R. Note that |r|
     .           // includes |carry| which is stored separately.
    36 (0.0%)    BN_ULONG n0 = mont->n0[0];
    12 (0.0%)    BN_ULONG carry = 0;
   268 (0.0%)    for (size_t i = 0; i < num_n; i++) {
   832 (0.0%)      BN_ULONG v = bn_mul_add_words(a + i, n, num_n, a[i] * n0);
   520 (0.0%)      v += carry + a[i + num_n];
   572 (0.0%)      carry |= (v != a[i + num_n]);
   572 (0.0%)      carry &= (v <= a[i + num_n]);
   416 (0.0%)      a[i + num_n] = v;
     .           }
     .         
     .           // Shift |num_n| words to divide by R. We have |a| < 2 * |n|. Note that |a|
     .           // includes |carry| which is stored separately.
    36 (0.0%)    a += num_n;
     .         
     .           // |a| thus requires at most one additional subtraction |n| to be reduced.
    96 (0.0%)    bn_reduce_once(r, a, carry, n, num_n);
    12 (0.0%)    return 1;
    24 (0.0%)  }
     .         
     .         static int BN_from_montgomery_word(BIGNUM *ret, BIGNUM *r,
     .                                            const BN_MONT_CTX *mont) {
     .           if (r->neg) {
     .             OPENSSL_PUT_ERROR(BN, BN_R_NEGATIVE_NUMBER);
     .             return 0;
     .           }
     .         
-- line 358 ----------------------------------------
-- line 578 ----------------------------------------
     .         }
     .         
     .         int bn_less_than_montgomery_R(const BIGNUM *bn, const BN_MONT_CTX *mont) {
     .           return !BN_is_negative(bn) &&
     .                  bn_fits_in_words(bn, mont->N.width);
     .         }
     .         
     .         void bn_to_montgomery_small(BN_ULONG *r, const BN_ULONG *a, size_t num,
    40 (0.0%)                              const BN_MONT_CTX *mont) {
    45 (0.0%)    bn_mod_mul_montgomery_small(r, a, mont->RR.d, num, mont);
    15 (0.0%)  }
     .         
     .         void bn_from_montgomery_small(BN_ULONG *r, size_t num_r, const BN_ULONG *a,
   144 (0.0%)                                size_t num_a, const BN_MONT_CTX *mont) {
   108 (0.0%)    if (num_r != (size_t)mont->N.width || num_r > BN_SMALL_MAX_WORDS ||
    24 (0.0%)        num_a > 2 * num_r) {
     .             abort();
     .           }
   276 (0.0%)    BN_ULONG tmp[BN_SMALL_MAX_WORDS * 2] = {0};
    84 (0.0%)    OPENSSL_memcpy(tmp, a, num_a * sizeof(BN_ULONG));
   132 (0.0%)    if (!bn_from_montgomery_in_place(r, num_r, tmp, 2 * num_r, mont)) {
     .             abort();
     .           }
    84 (0.0%)    OPENSSL_cleanse(tmp, 2 * num_r * sizeof(BN_ULONG));
    72 (0.0%)  }
     .         
     .         void bn_mod_mul_montgomery_small(BN_ULONG *r, const BN_ULONG *a,
     .                                          const BN_ULONG *b, size_t num,
12,132 (0.1%)                                   const BN_MONT_CTX *mont) {
 7,077 (0.1%)    if (num != (size_t)mont->N.width || num > BN_SMALL_MAX_WORDS) {
     .             abort();
     .           }
     .         
     .         #if defined(OPENSSL_BN_ASM_MONT)
     .           // |bn_mul_mont| requires at least 128 bits of limbs, at least for x86.
 2,022 (0.0%)    if (num >= (128 / BN_BITS2)) {
13,143 (0.1%)      if (!bn_mul_mont(r, a, b, mont->N.d, mont->n0, num)) {
     .               abort();  // The check above ensures this won't happen.
     .             }
 1,011 (0.0%)      return;
     .           }
     .         #endif
     .         
     .           // Compute the product.
     .           BN_ULONG tmp[2 * BN_SMALL_MAX_WORDS];
     .           if (a == b) {
     .             bn_sqr_small(tmp, 2 * num, a, num);
     .           } else {
-- line 625 ----------------------------------------
-- line 626 ----------------------------------------
     .             bn_mul_small(tmp, 2 * num, a, num, b, num);
     .           }
     .         
     .           // Reduce.
     .           if (!bn_from_montgomery_in_place(r, num, tmp, 2 * num, mont)) {
     .             abort();
     .           }
     .           OPENSSL_cleanse(tmp, 2 * num * sizeof(BN_ULONG));
 5,055 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 253 ----------------------------------------
     .             return 0;
     .           }
     .         
     .           a->d[i] &= (~(((BN_ULONG)1) << j));
     .           bn_set_minimal_width(a);
     .           return 1;
     .         }
     .         
 9,516 (0.1%)  int bn_is_bit_set_words(const BN_ULONG *a, size_t num, size_t bit) {
 4,758 (0.0%)    size_t i = bit / BN_BITS2;
 4,758 (0.0%)    size_t j = bit % BN_BITS2;
 4,758 (0.0%)    if (i >= num) {
    28 (0.0%)      return 0;
     .           }
14,148 (0.1%)    return (a[i] >> j) & 1;
 3,172 (0.0%)  }
     .         
     .         int BN_is_bit_set(const BIGNUM *a, int n) {
     .           if (n < 0) {
     .             return 0;
     .           }
     .           return bn_is_bit_set_words(a->d, a->width, n);
     .         }
     .         
-- line 276 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/../../../third_party/s2n-bignum/include/s2n-bignum_aws-lc.h
--------------------------------------------------------------------------------
Ir___________ 

-- line 31 ----------------------------------------
     .         // For each of those, we define a _selector function that selects, in runtime,
     .         // the _alt or non-_alt version to run.
     .         
     .         #if defined(OPENSSL_X86_64)
     .         // On x86_64 platforms s2n-bignum uses bmi2 and adx instruction sets
     .         // for some of the functions. These instructions are not supported by
     .         // every x86 CPU so we have to check if they are available and in case
     .         // they are not we fallback to slightly slower but generic implementation.
12,168 (0.1%)  static inline uint8_t use_s2n_bignum_alt(void) {
48,672 (0.5%)    return (!CRYPTO_is_BMI2_capable() || !CRYPTO_is_ADX_capable());
12,168 (0.1%)  }
     .         #else
     .         // On aarch64 platforms s2n-bignum has two implementations of certain
     .         // functions -- the default one and the alternative (suffixed _alt).
     .         // Depending on the architecture one version is faster than the other.
     .         // Generally, the "_alt" functions are faster on architectures with higher
     .         // multiplier throughput, for example, Graviton 3, Apple's M1 and iPhone chips.
     .         static inline uint8_t use_s2n_bignum_alt(void) {
     .           return CRYPTO_is_ARMv8_wide_multiplier_capable();
-- line 49 ----------------------------------------
-- line 53 ----------------------------------------
     .         // Add modulo p_384, z := (x + y) mod p_384, assuming x and y reduced
     .         // Inputs x[6], y[6]; output z[6]
     .         extern void bignum_add_p384(uint64_t z[static 6], const uint64_t x[static 6], const uint64_t y[static 6]);
     .         
     .         // Convert from almost-Montgomery form, z := (x / 2^384) mod p_384
     .         // Input x[6]; output z[6]
     .         extern void bignum_deamont_p384(uint64_t z[static 6], const uint64_t x[static 6]);
     .         extern void bignum_deamont_p384_alt(uint64_t z[static 6], const uint64_t x[static 6]);
    10 (0.0%)  static inline void bignum_deamont_p384_selector(uint64_t z[static 6], const uint64_t x[static 6]) {
    16 (0.0%)    if (use_s2n_bignum_alt()) { bignum_deamont_p384_alt(z, x); }
     .           else { bignum_deamont_p384(z, x); }
     8 (0.0%)  }
     .         
     .         // Montgomery multiply, z := (x * y / 2^384) mod p_384 
     .         // Inputs x[6], y[6]; output z[6]
     .         extern void bignum_montmul_p384(uint64_t z[static 6], const uint64_t x[static 6], const uint64_t y[static 6]);
     .         extern void bignum_montmul_p384_alt(uint64_t z[static 6], const uint64_t x[static 6], const uint64_t y[static 6]);
20,923 (0.2%)  static inline void bignum_montmul_p384_selector(uint64_t z[static 6], const uint64_t x[static 6], const uint64_t y[static 6]) {
26,901 (0.3%)    if (use_s2n_bignum_alt()) { bignum_montmul_p384_alt(z, x, y); }
     .           else { bignum_montmul_p384(z, x, y); }
11,956 (0.1%)  }
     .         
     .         // Montgomery square, z := (x^2 / 2^384) mod p_384
     .         // Input x[6]; output z[6]
     .         extern void bignum_montsqr_p384(uint64_t z[static 6], const uint64_t x[static 6]);
     .         extern void bignum_montsqr_p384_alt(uint64_t z[static 6], const uint64_t x[static 6]);
18,546 (0.2%)  static inline void bignum_montsqr_p384_selector(uint64_t z[static 6], const uint64_t x[static 6]) {
24,728 (0.2%)    if (use_s2n_bignum_alt()) { bignum_montsqr_p384_alt(z, x); }
     .           else { bignum_montsqr_p384(z, x); }
12,364 (0.1%)  }
     .         
     .         // Negate modulo p_384, z := (-x) mod p_384, assuming x reduced
     .         // Input x[6]; output z[6]
     .         extern void bignum_neg_p384(uint64_t z[static 6], const uint64_t x[static 6]);
     .         
     .         // Subtract modulo p_384, z := (x - y) mod p_384
     .         // Inputs x[6], y[6]; output z[6]
     .         extern void bignum_sub_p384(uint64_t z[static 6], const uint64_t x[static 6], const uint64_t y[static 6]); 
     .         
     .         // Convert to Montgomery form z := (2^384 * x) mod p_384 */
     .         // Input x[6]; output z[6] */
     .         extern void bignum_tomont_p384(uint64_t z[static 6], const uint64_t x[static 6]);
     .         extern void bignum_tomont_p384_alt(uint64_t z[static 6], const uint64_t x[static 6]);
    10 (0.0%)  static inline void bignum_tomont_p384_selector(uint64_t z[static 6], const uint64_t x[static 6]) {
    16 (0.0%)    if (use_s2n_bignum_alt()) { bignum_tomont_p384_alt(z, x); }
     .           else { bignum_tomont_p384(z, x); }
     8 (0.0%)  }
     .         
     .         // Convert 6-digit (384-bit) bignum from little-endian form
     .         // Input x[6]; output z[6]
     .         extern void bignum_fromlebytes_6(uint64_t z[static 6], const uint8_t x[static 48]);
     .         
     .         // Convert 6-digit (384-bit) bignum to little-endian form
     .         // Input x[6]; output z[6]
     .         extern void bignum_tolebytes_6(uint8_t z[static 48], const uint64_t x[static 6]);
-- line 107 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/ec_nistp.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 36 ----------------------------------------
      .         #endif
      .         typedef ec_nistp_felem_limb ec_nistp_felem[NISTP_FELEM_MAX_NUM_OF_LIMBS];
      .         
      .         // Conditional copy in constant-time (out = t == 0 ? z : nz).
      .         static void cmovznz(ec_nistp_felem_limb *out,
      .                             size_t num_limbs,
      .                             ec_nistp_felem_limb t,
      .                             const ec_nistp_felem_limb *z,
 11,880 (0.1%)                      const ec_nistp_felem_limb *nz) {
  4,752 (0.0%)    ec_nistp_felem_limb mask = constant_time_is_zero_w(t);
 34,452 (0.3%)    for (size_t i = 0; i < num_limbs; i++) {
135,432 (1.3%)      out[i] = constant_time_select_w(mask, z[i], nz[i]);
      .           }
  5,940 (0.1%)  }
      .         
      .         // Group operations
      .         // ----------------
      .         //
      .         // Building on top of the field operations we have the operations on the
      .         // elliptic curve group itself. Points on the curve are represented in Jacobian
      .         // coordinates.
      .         //
-- line 57 ----------------------------------------
-- line 71 ----------------------------------------
      .         // Outputs can equal corresponding inputs, i.e., x_out == x_in is allowed;
      .         // while x_out == y_in is not (maybe this works, but it's not tested).
      .         void ec_nistp_point_double(const ec_nistp_felem_meth *ctx,
      .                                    ec_nistp_felem_limb *x_out,
      .                                    ec_nistp_felem_limb *y_out,
      .                                    ec_nistp_felem_limb *z_out,
      .                                    const ec_nistp_felem_limb *x_in,
      .                                    const ec_nistp_felem_limb *y_in,
  5,940 (0.1%)                             const ec_nistp_felem_limb *z_in) {
      .           ec_nistp_felem delta, gamma, beta, ftmp, ftmp2, tmptmp, alpha, fourbeta;
      .           // delta = z^2
  2,772 (0.0%)    ctx->sqr(delta, z_in);
      .           // gamma = y^2
  2,772 (0.0%)    ctx->sqr(gamma, y_in);
      .           // beta = x*gamma
  3,168 (0.0%)    ctx->mul(beta, x_in, gamma);
      .         
      .           // alpha = 3*(x-delta)*(x+delta)
  3,168 (0.0%)    ctx->sub(ftmp, x_in, delta);
  3,168 (0.0%)    ctx->add(ftmp2, x_in, delta);
      .         
  3,168 (0.0%)    ctx->add(tmptmp, ftmp2, ftmp2);
  3,168 (0.0%)    ctx->add(ftmp2, ftmp2, tmptmp);
  3,168 (0.0%)    ctx->mul(alpha, ftmp, ftmp2);
      .         
      .           // x' = alpha^2 - 8*beta
  2,772 (0.0%)    ctx->sqr(x_out, alpha);
  3,168 (0.0%)    ctx->add(fourbeta, beta, beta);
  3,168 (0.0%)    ctx->add(fourbeta, fourbeta, fourbeta);
  3,168 (0.0%)    ctx->add(tmptmp, fourbeta, fourbeta);
  3,168 (0.0%)    ctx->sub(x_out, x_out, tmptmp);
      .         
      .           // z' = (y + z)^2 - gamma - delta
      .           // The following calculation differs from the Coq proof cited above.
      .           // The proof is for:
      .           //   add(delta, gamma, delta);
      .           //   add(ftmp, y_in, z_in);
      .           //   square(z_out, ftmp);
      .           //   sub(z_out, z_out, delta);
      .           // Our operations sequence is a bit more efficient because it saves us
      .           // a certain number of conditional moves.
  3,168 (0.0%)    ctx->add(ftmp, y_in, z_in);
  2,772 (0.0%)    ctx->sqr(z_out, ftmp);
  3,168 (0.0%)    ctx->sub(z_out, z_out, gamma);
  3,168 (0.0%)    ctx->sub(z_out, z_out, delta);
      .         
      .           // y' = alpha*(4*beta - x') - 8*gamma^2
  3,168 (0.0%)    ctx->sub(y_out, fourbeta, x_out);
  3,168 (0.0%)    ctx->add(gamma, gamma, gamma);
  2,772 (0.0%)    ctx->sqr(gamma, gamma);
  3,168 (0.0%)    ctx->mul(y_out, alpha, y_out);
  3,168 (0.0%)    ctx->add(gamma, gamma, gamma);
  3,168 (0.0%)    ctx->sub(y_out, y_out, gamma);
  2,376 (0.0%)  }
      .         
      .         // ec_nistp_point_add calculates (x1, y1, z1) + (x2, y2, z2)
      .         //
      .         // The method is taken from:
      .         //   http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-add-2007-bl
      .         // adapted for mixed addition (z2 = 1, or z2 = 0 for the point at infinity).
      .         //
      .         // Coq transcription and correctness proof:
-- line 132 ----------------------------------------
-- line 142 ----------------------------------------
      .                                 ec_nistp_felem_limb *y3,
      .                                 ec_nistp_felem_limb *z3,
      .                                 const ec_nistp_felem_limb *x1,
      .                                 const ec_nistp_felem_limb *y1,
      .                                 const ec_nistp_felem_limb *z1,
      .                                 const int mixed,
      .                                 const ec_nistp_felem_limb *x2,
      .                                 const ec_nistp_felem_limb *y2,
  4,356 (0.0%)                          const ec_nistp_felem_limb *z2) {
      .           ec_nistp_felem x_out, y_out, z_out;
      .         
  1,188 (0.0%)    ec_nistp_felem_limb z1nz = ctx->nz(z1);
  1,188 (0.0%)    ec_nistp_felem_limb z2nz = ctx->nz(z2);
      .         
      .           // z1z1 = z1**2
      .           ec_nistp_felem z1z1;
  1,386 (0.0%)    ctx->sqr(z1z1, z1);
      .         
      .           ec_nistp_felem u1, s1, two_z1z2;
    396 (0.0%)    if (!mixed) {
      .             // z2z2 = z2**2
      .             ec_nistp_felem z2z2;
    469 (0.0%)      ctx->sqr(z2z2, z2);
      .         
      .             // u1 = x1*z2z2
    536 (0.0%)      ctx->mul(u1, x1, z2z2);
      .         
      .             // two_z1z2 = (z1 + z2)**2 - (z1z1 + z2z2) = 2z1z2
    536 (0.0%)      ctx->add(two_z1z2, z1, z2);
    469 (0.0%)      ctx->sqr(two_z1z2, two_z1z2);
    536 (0.0%)      ctx->sub(two_z1z2, two_z1z2, z1z1);
    536 (0.0%)      ctx->sub(two_z1z2, two_z1z2, z2z2);
      .         
      .             // s1 = y1 * z2**3
    536 (0.0%)      ctx->mul(s1, z2, z2z2);
    603 (0.0%)      ctx->mul(s1, s1, y1);
      .           } else {
      .             // We'll assume z2 = 1 (special case z2 = 0 is handled later).
      .         
      .             // u1 = x1*z2z2
  1,048 (0.0%)      OPENSSL_memcpy(u1, x1, ctx->felem_num_limbs * sizeof(ec_nistp_felem_limb));
      .             // two_z1z2 = 2z1z2
  1,048 (0.0%)      ctx->add(two_z1z2, z1, z1);
      .             // s1 = y1 * z2**3
  1,048 (0.0%)      OPENSSL_memcpy(s1, y1, ctx->felem_num_limbs * sizeof(ec_nistp_felem_limb));
      .           }
      .         
      .           // u2 = x2*z1z1
      .           ec_nistp_felem u2;
  1,584 (0.0%)    ctx->mul(u2, x2, z1z1);
      .         
      .           // h = u2 - u1
      .           ec_nistp_felem h;
  1,584 (0.0%)    ctx->sub(h, u2, u1);
      .         
  1,188 (0.0%)    ec_nistp_felem_limb xneq = ctx->nz(h);
      .         
      .           // z_out = two_z1z2 * h
  1,584 (0.0%)    ctx->mul(z_out, h, two_z1z2);
      .         
      .           // z1z1z1 = z1 * z1z1
      .           ec_nistp_felem z1z1z1;
  1,584 (0.0%)    ctx->mul(z1z1z1, z1, z1z1);
      .         
      .           // s2 = y2 * z1**3
      .           ec_nistp_felem s2;
  1,584 (0.0%)    ctx->mul(s2, y2, z1z1z1);
      .         
      .           // r = (s2 - s1)*2
      .           ec_nistp_felem r;
  1,584 (0.0%)    ctx->sub(r, s2, s1);
  1,584 (0.0%)    ctx->add(r, r, r);
      .         
  1,188 (0.0%)    ec_nistp_felem_limb yneq = ctx->nz(r);
      .         
      .           // This case will never occur in the constant-time |ec_GFp_mont_mul|.
    396 (0.0%)    ec_nistp_felem_limb is_nontrivial_double =
  1,188 (0.0%)                                       constant_time_is_zero_w(xneq | yneq) &
    792 (0.0%)                                      ~constant_time_is_zero_w(z1nz) &
    792 (0.0%)                                      ~constant_time_is_zero_w(z2nz);
    990 (0.0%)    if (constant_time_declassify_w(is_nontrivial_double)) {
      .             ec_nistp_point_double(ctx, x3, y3, z3, x1, y1, z1);
      .             return;
      .           }
      .         
      .           // I = (2h)**2
      .           ec_nistp_felem i;
  1,584 (0.0%)    ctx->add(i, h, h);
  1,386 (0.0%)    ctx->sqr(i, i);
      .         
      .           // J = h * I
      .           ec_nistp_felem j;
  1,584 (0.0%)    ctx->mul(j, h, i);
      .         
      .           // V = U1 * I
      .           ec_nistp_felem v;
  1,584 (0.0%)    ctx->mul(v, u1, i);
      .         
      .           // x_out = r**2 - J - 2V
  1,386 (0.0%)    ctx->sqr(x_out, r);
  1,584 (0.0%)    ctx->sub(x_out, x_out, j);
  1,584 (0.0%)    ctx->sub(x_out, x_out, v);
  1,584 (0.0%)    ctx->sub(x_out, x_out, v);
      .         
      .           // y_out = r(V-x_out) - 2 * s1 * J
  1,584 (0.0%)    ctx->sub(y_out, v, x_out);
  1,584 (0.0%)    ctx->mul(y_out, y_out, r);
      .           ec_nistp_felem s1j;
  1,584 (0.0%)    ctx->mul(s1j, s1, j);
  1,584 (0.0%)    ctx->sub(y_out, y_out, s1j);
  1,584 (0.0%)    ctx->sub(y_out, y_out, s1j);
      .         
  1,782 (0.0%)    cmovznz(x_out, ctx->felem_num_limbs, z1nz, x2, x_out);
  1,782 (0.0%)    cmovznz(y_out, ctx->felem_num_limbs, z1nz, y2, y_out);
  1,782 (0.0%)    cmovznz(z_out, ctx->felem_num_limbs, z1nz, z2, z_out);
  1,782 (0.0%)    cmovznz(x3, ctx->felem_num_limbs, z2nz, x1, x_out);
  1,782 (0.0%)    cmovznz(y3, ctx->felem_num_limbs, z2nz, y1, y_out);
  1,782 (0.0%)    cmovznz(z3, ctx->felem_num_limbs, z2nz, z1, z_out);
  1,188 (0.0%)  }
      .         

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/p256-nistz.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 44 ----------------------------------------
    .             TOBN(0xffffffff, 0xffffffff), TOBN(0x00000000, 0xfffffffe),
    .         };
    .         
    .         // Precomputed tables for the default generator
    .         #include "p256-nistz-table.h"
    .         
    .         // Recode window to a signed digit, see |ec_GFp_nistp_recode_scalar_bits| in
    .         // util.c for details
  416 (0.0%)  static crypto_word_t booth_recode_w5(crypto_word_t in) {
    .           crypto_word_t s, d;
    .         
  416 (0.0%)    s = ~((in >> 5) - 1);
  312 (0.0%)    d = (1 << 6) - in - 1;
  832 (0.0%)    d = (d & s) | (in & ~s);
  728 (0.0%)    d = (d >> 1) + (d & 1);
    .         
  520 (0.0%)    return (d << 1) + (s & 1);
  208 (0.0%)  }
    .         
  296 (0.0%)  static crypto_word_t booth_recode_w7(crypto_word_t in) {
    .           crypto_word_t s, d;
    .         
  296 (0.0%)    s = ~((in >> 7) - 1);
  222 (0.0%)    d = (1 << 8) - in - 1;
  592 (0.0%)    d = (d & s) | (in & ~s);
  518 (0.0%)    d = (d >> 1) + (d & 1);
    .         
  370 (0.0%)    return (d << 1) + (s & 1);
  148 (0.0%)  }
    .         
    .         // copy_conditional copies |src| to |dst| if |move| is one and leaves it as-is
    .         // if |move| is zero.
    .         //
    .         // WARNING: this breaks the usual convention of constant-time functions
    .         // returning masks.
    .         static void copy_conditional(BN_ULONG dst[P256_LIMBS],
1,068 (0.0%)                               const BN_ULONG src[P256_LIMBS], BN_ULONG move) {
  534 (0.0%)    BN_ULONG mask1 = ((BN_ULONG)0) - move;
  534 (0.0%)    BN_ULONG mask2 = ~mask1;
    .         
1,780 (0.0%)    dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);
2,492 (0.0%)    dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);
2,492 (0.0%)    dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);
2,492 (0.0%)    dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);
    .           if (P256_LIMBS == 8) {
    .             dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);
    .             dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);
    .             dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);
    .             dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);
    .           }
  534 (0.0%)  }
    .         
    .         // is_not_zero returns one iff in != 0 and zero otherwise.
    .         //
    .         // WARNING: this breaks the usual convention of constant-time functions
    .         // returning masks.
    .         //
    .         // (define-fun is_not_zero ((in (_ BitVec 64))) (_ BitVec 64)
    .         //   (bvlshr (bvor in (bvsub #x0000000000000000 in)) #x000000000000003f)
-- line 102 ----------------------------------------
-- line 105 ----------------------------------------
    .         // (declare-fun x () (_ BitVec 64))
    .         //
    .         // (assert (and (= x #x0000000000000000) (= (is_not_zero x) #x0000000000000001)))
    .         // (check-sat)
    .         //
    .         // (assert (and (not (= x #x0000000000000000)) (= (is_not_zero x) #x0000000000000000)))
    .         // (check-sat)
    .         //
    8 (0.0%)  static BN_ULONG is_not_zero(BN_ULONG in) {
    6 (0.0%)    in |= (0 - in);
    2 (0.0%)    in >>= BN_BITS2 - 1;
    2 (0.0%)    return in;
    4 (0.0%)  }
    .         
    .         // ecp_nistz256_mod_inverse_sqr_mont sets |r| to (|in| * 2^-256)^-2 * 2^256 mod
    .         // p. That is, |r| is the modular inverse square of |in| for input and output in
    .         // the Montgomery domain.
    .         static void ecp_nistz256_mod_inverse_sqr_mont(BN_ULONG r[P256_LIMBS],
   36 (0.0%)                                                const BN_ULONG in[P256_LIMBS]) {
    .           // This implements the addition chain described in
    .           // https://briansmith.org/ecc-inversion-addition-chains-01#p256_field_inversion
    .           BN_ULONG x2[P256_LIMBS], x3[P256_LIMBS], x6[P256_LIMBS], x12[P256_LIMBS],
    .               x15[P256_LIMBS], x30[P256_LIMBS], x32[P256_LIMBS];
   20 (0.0%)    ecp_nistz256_sqr_mont(x2, in);      // 2^2 - 2^1
   24 (0.0%)    ecp_nistz256_mul_mont(x2, x2, in);  // 2^2 - 2^0
    .         
   20 (0.0%)    ecp_nistz256_sqr_mont(x3, x2);      // 2^3 - 2^1
   24 (0.0%)    ecp_nistz256_mul_mont(x3, x3, in);  // 2^3 - 2^0
    .         
   20 (0.0%)    ecp_nistz256_sqr_mont(x6, x3);
   40 (0.0%)    for (int i = 1; i < 3; i++) {
   40 (0.0%)      ecp_nistz256_sqr_mont(x6, x6);
    .           }                                   // 2^6 - 2^3
   24 (0.0%)    ecp_nistz256_mul_mont(x6, x6, x3);  // 2^6 - 2^0
    .         
   20 (0.0%)    ecp_nistz256_sqr_mont(x12, x6);
   76 (0.0%)    for (int i = 1; i < 6; i++) {
  100 (0.0%)      ecp_nistz256_sqr_mont(x12, x12);
    .           }                                     // 2^12 - 2^6
   24 (0.0%)    ecp_nistz256_mul_mont(x12, x12, x6);  // 2^12 - 2^0
    .         
   20 (0.0%)    ecp_nistz256_sqr_mont(x15, x12);
   40 (0.0%)    for (int i = 1; i < 3; i++) {
   40 (0.0%)      ecp_nistz256_sqr_mont(x15, x15);
    .           }                                     // 2^15 - 2^3
   24 (0.0%)    ecp_nistz256_mul_mont(x15, x15, x3);  // 2^15 - 2^0
    .         
   20 (0.0%)    ecp_nistz256_sqr_mont(x30, x15);
  184 (0.0%)    for (int i = 1; i < 15; i++) {
  280 (0.0%)      ecp_nistz256_sqr_mont(x30, x30);
    .           }                                      // 2^30 - 2^15
   24 (0.0%)    ecp_nistz256_mul_mont(x30, x30, x15);  // 2^30 - 2^0
    .         
   20 (0.0%)    ecp_nistz256_sqr_mont(x32, x30);
   20 (0.0%)    ecp_nistz256_sqr_mont(x32, x32);      // 2^32 - 2^2
   24 (0.0%)    ecp_nistz256_mul_mont(x32, x32, x2);  // 2^32 - 2^0
    .         
    .           BN_ULONG ret[P256_LIMBS];
   20 (0.0%)    ecp_nistz256_sqr_mont(ret, x32);
  388 (0.0%)    for (int i = 1; i < 31 + 1; i++) {
  620 (0.0%)      ecp_nistz256_sqr_mont(ret, ret);
    .           }                                     // 2^64 - 2^32
   24 (0.0%)    ecp_nistz256_mul_mont(ret, ret, in);  // 2^64 - 2^32 + 2^0
    .         
1,552 (0.0%)    for (int i = 0; i < 96 + 32; i++) {
2,560 (0.0%)      ecp_nistz256_sqr_mont(ret, ret);
    .           }                                      // 2^192 - 2^160 + 2^128
   24 (0.0%)    ecp_nistz256_mul_mont(ret, ret, x32);  // 2^192 - 2^160 + 2^128 + 2^32 - 2^0
    .         
  400 (0.0%)    for (int i = 0; i < 32; i++) {
  640 (0.0%)      ecp_nistz256_sqr_mont(ret, ret);
    .           }                                      // 2^224 - 2^192 + 2^160 + 2^64 - 2^32
   24 (0.0%)    ecp_nistz256_mul_mont(ret, ret, x32);  // 2^224 - 2^192 + 2^160 + 2^64 - 2^0
    .         
  376 (0.0%)    for (int i = 0; i < 30; i++) {
  600 (0.0%)      ecp_nistz256_sqr_mont(ret, ret);
    .           }                                      // 2^254 - 2^222 + 2^190 + 2^94 - 2^30
   24 (0.0%)    ecp_nistz256_mul_mont(ret, ret, x30);  // 2^254 - 2^222 + 2^190 + 2^94 - 2^0
    .         
   20 (0.0%)    ecp_nistz256_sqr_mont(ret, ret);
   20 (0.0%)    ecp_nistz256_sqr_mont(r, ret);  // 2^256 - 2^224 + 2^192 + 2^96 - 2^2
   24 (0.0%)  }
    .         
    .         // r = p * p_scalar
    .         static void ecp_nistz256_windowed_mul(const EC_GROUP *group, P256_POINT *r,
    .                                               const EC_JACOBIAN *p,
   22 (0.0%)                                        const EC_SCALAR *p_scalar) {
    4 (0.0%)    assert(p != NULL);
    4 (0.0%)    assert(p_scalar != NULL);
    8 (0.0%)    assert(group->field.N.width == P256_LIMBS);
    .         
    .           static const size_t kWindowSize = 5;
    .           static const crypto_word_t kMask = (1 << (5 /* kWindowSize */ + 1)) - 1;
    .         
    .           // A |P256_POINT| is (3 * 32) = 96 bytes, and the 64-byte alignment should
    .           // add no more than 63 bytes of overhead. Thus, |table| should require
    .           // ~1599 ((96 * 16) + 63) bytes of stack space.
    .           stack_align_type table_buffer[64 + (sizeof(P256_POINT) * 16)];
   10 (0.0%)    P256_POINT *aligned_table = (P256_POINT *) align_pointer(table_buffer, 64);
    .           uint8_t p_str[33];
   12 (0.0%)    OPENSSL_memcpy(p_str, p_scalar->words, 32);
    2 (0.0%)    p_str[32] = 0;
    .         
    .           // table[0] is implicitly (0,0,0) (the point at infinity), therefore it is
    .           // not stored. All other values are actually stored with an offset of -1 in
    .           // table.
    4 (0.0%)    P256_POINT *row = aligned_table;
    8 (0.0%)    assert(group->field.N.width == P256_LIMBS);
   12 (0.0%)    OPENSSL_memcpy(row[1 - 1].X, p->X.words, P256_LIMBS * sizeof(BN_ULONG));
   16 (0.0%)    OPENSSL_memcpy(row[1 - 1].Y, p->Y.words, P256_LIMBS * sizeof(BN_ULONG));
   16 (0.0%)    OPENSSL_memcpy(row[1 - 1].Z, p->Z.words, P256_LIMBS * sizeof(BN_ULONG));
    .         
   12 (0.0%)    ecp_nistz256_point_double(&row[2 - 1], &row[1 - 1]);
   16 (0.0%)    ecp_nistz256_point_add(&row[3 - 1], &row[2 - 1], &row[1 - 1]);
   14 (0.0%)    ecp_nistz256_point_double(&row[4 - 1], &row[2 - 1]);
   14 (0.0%)    ecp_nistz256_point_double(&row[6 - 1], &row[3 - 1]);
   14 (0.0%)    ecp_nistz256_point_double(&row[8 - 1], &row[4 - 1]);
   14 (0.0%)    ecp_nistz256_point_double(&row[12 - 1], &row[6 - 1]);
   16 (0.0%)    ecp_nistz256_point_add(&row[5 - 1], &row[4 - 1], &row[1 - 1]);
   16 (0.0%)    ecp_nistz256_point_add(&row[7 - 1], &row[6 - 1], &row[1 - 1]);
   16 (0.0%)    ecp_nistz256_point_add(&row[9 - 1], &row[8 - 1], &row[1 - 1]);
   16 (0.0%)    ecp_nistz256_point_add(&row[13 - 1], &row[12 - 1], &row[1 - 1]);
   14 (0.0%)    ecp_nistz256_point_double(&row[14 - 1], &row[7 - 1]);
   14 (0.0%)    ecp_nistz256_point_double(&row[10 - 1], &row[5 - 1]);
   16 (0.0%)    ecp_nistz256_point_add(&row[15 - 1], &row[14 - 1], &row[1 - 1]);
   16 (0.0%)    ecp_nistz256_point_add(&row[11 - 1], &row[10 - 1], &row[1 - 1]);
   14 (0.0%)    ecp_nistz256_point_double(&row[16 - 1], &row[8 - 1]);
    .         
    .           BN_ULONG tmp[P256_LIMBS];
    .           stack_align_type buffer_h[32 + sizeof(P256_POINT)];
   10 (0.0%)    P256_POINT *aligned_h = (P256_POINT *) align_pointer(buffer_h, 32);
    2 (0.0%)    size_t index = 255;
   12 (0.0%)    crypto_word_t wvalue = p_str[(index - 1) / 8];
   18 (0.0%)    wvalue = (wvalue >> ((index - 1) % 8)) & kMask;
    .         
   20 (0.0%)    ecp_nistz256_select_w5(r, aligned_table, booth_recode_w5(wvalue) >> 1);
    .         
  210 (0.0%)    while (index >= 5) {
  204 (0.0%)      if (index != 255) {
  400 (0.0%)        size_t off = (index - 1) / 8;
    .         
1,200 (0.0%)        wvalue = (crypto_word_t)p_str[off] | (crypto_word_t)p_str[off + 1] << 8;
  900 (0.0%)        wvalue = (wvalue >> ((index - 1) % 8)) & kMask;
    .         
  400 (0.0%)        wvalue = booth_recode_w5(wvalue);
    .         
  800 (0.0%)        ecp_nistz256_select_w5(aligned_h, aligned_table, wvalue >> 1);
    .         
  600 (0.0%)        ecp_nistz256_neg(tmp, aligned_h->Y);
  900 (0.0%)        copy_conditional(aligned_h->Y, tmp, (wvalue & 1));
    .         
  600 (0.0%)        ecp_nistz256_point_add(r, r, aligned_h);
    .             }
    .         
  204 (0.0%)      index -= kWindowSize;
    .         
  510 (0.0%)      ecp_nistz256_point_double(r, r);
  510 (0.0%)      ecp_nistz256_point_double(r, r);
  510 (0.0%)      ecp_nistz256_point_double(r, r);
  510 (0.0%)      ecp_nistz256_point_double(r, r);
  510 (0.0%)      ecp_nistz256_point_double(r, r);
    .           }
    .         
    .           // Final window
    6 (0.0%)    wvalue = p_str[0];
   10 (0.0%)    wvalue = (wvalue << 1) & kMask;
    .         
    8 (0.0%)    wvalue = booth_recode_w5(wvalue);
    .         
   16 (0.0%)    ecp_nistz256_select_w5(aligned_h, aligned_table, wvalue >> 1);
    .         
   12 (0.0%)    ecp_nistz256_neg(tmp, aligned_h->Y);
   18 (0.0%)    copy_conditional(aligned_h->Y, tmp, wvalue & 1);
    .         
   12 (0.0%)    ecp_nistz256_point_add(r, r, aligned_h);
   12 (0.0%)  }
    .         
   12 (0.0%)  static crypto_word_t calc_first_wvalue(size_t *index, const uint8_t p_str[33]) {
    .           static const size_t kWindowSize = 7;
    .           static const crypto_word_t kMask = (1 << (7 /* kWindowSize */ + 1)) - 1;
    6 (0.0%)    *index = kWindowSize;
    .         
   16 (0.0%)    crypto_word_t wvalue = (p_str[0] << 1) & kMask;
    6 (0.0%)    return booth_recode_w7(wvalue);
    4 (0.0%)  }
    .         
  432 (0.0%)  static crypto_word_t calc_wvalue(size_t *index, const uint8_t p_str[33]) {
    .           static const size_t kWindowSize = 7;
    .           static const crypto_word_t kMask = (1 << (7 /* kWindowSize */ + 1)) - 1;
    .         
  360 (0.0%)    const size_t off = (*index - 1) / 8;
  144 (0.0%)    crypto_word_t wvalue =
  864 (0.0%)        (crypto_word_t)p_str[off] | (crypto_word_t)p_str[off + 1] << 8;
  720 (0.0%)    wvalue = (wvalue >> ((*index - 1) % 8)) & kMask;
  432 (0.0%)    *index += kWindowSize;
    .         
  216 (0.0%)    return booth_recode_w7(wvalue);
  144 (0.0%)  }
    .         
    .         static void ecp_nistz256_point_mul(const EC_GROUP *group, EC_JACOBIAN *r,
    .                                            const EC_JACOBIAN *p,
   22 (0.0%)                                     const EC_SCALAR *scalar) {
    .           stack_align_type buffer_out[32 + sizeof(P256_POINT)];
   10 (0.0%)    P256_POINT *aligned_out = (P256_POINT *) align_pointer(buffer_out, 32);
   12 (0.0%)    ecp_nistz256_windowed_mul(group, aligned_out, p, scalar);
    .         
    8 (0.0%)    assert(group->field.N.width == P256_LIMBS);
   12 (0.0%)    OPENSSL_memcpy(r->X.words, aligned_out->X, P256_LIMBS * sizeof(BN_ULONG));
   16 (0.0%)    OPENSSL_memcpy(r->Y.words, aligned_out->Y, P256_LIMBS * sizeof(BN_ULONG));
   16 (0.0%)    OPENSSL_memcpy(r->Z.words, aligned_out->Z, P256_LIMBS * sizeof(BN_ULONG));
   12 (0.0%)  }
    .         
    .         static void ecp_nistz256_point_mul_base(const EC_GROUP *group, EC_JACOBIAN *r,
   20 (0.0%)                                          const EC_SCALAR *scalar) {
    .         
    .           stack_align_type buffer_t[32 + sizeof(P256_POINT_AFFINE)];
   10 (0.0%)    P256_POINT_AFFINE *aligned_t = (P256_POINT_AFFINE *) align_pointer(buffer_t, 32);
    .           stack_align_type buffer_p[32 + sizeof(P256_POINT)];
   10 (0.0%)    P256_POINT *aligned_p = (P256_POINT *) align_pointer(buffer_p, 32);
    .         
    .           uint8_t p_str[33];
   12 (0.0%)    OPENSSL_memcpy(p_str, scalar->words, 32);
    2 (0.0%)    p_str[32] = 0;
    .         
    .           // First window
    2 (0.0%)    size_t index = 0;
   12 (0.0%)    crypto_word_t wvalue = calc_first_wvalue(&index, p_str);
    .         
   16 (0.0%)    ecp_nistz256_select_w7(aligned_t, ecp_nistz256_precomputed[0], wvalue >> 1);
   14 (0.0%)    ecp_nistz256_neg(aligned_p->Z, aligned_t->Y);
   20 (0.0%)    copy_conditional(aligned_t->Y, aligned_p->Z, wvalue & 1);
    .         
    .           // Convert |t| from affine to Jacobian coordinates. We set Z to zero if |t|
    .           // is infinity and |ONE| otherwise. |t| was computed from the table, so it
    .           // is infinity iff |wvalue >> 1| is zero.
   12 (0.0%)    OPENSSL_memcpy(aligned_p->X, aligned_t->X, sizeof(aligned_p->X));
   16 (0.0%)    OPENSSL_memcpy(aligned_p->Y, aligned_t->Y, sizeof(aligned_p->Y));
   12 (0.0%)    OPENSSL_memset(aligned_p->Z, 0, sizeof(aligned_p->Z));
   22 (0.0%)    copy_conditional(aligned_p->Z, ONE, is_not_zero(wvalue >> 1));
    .         
  224 (0.0%)    for (int i = 1; i < 37; i++) {
  432 (0.0%)      wvalue = calc_wvalue(&index, p_str);
    .         
1,008 (0.0%)      ecp_nistz256_select_w7(aligned_t, ecp_nistz256_precomputed[i], wvalue >> 1);
    .         
    .             stack_align_type buffer_neg_y[32 + (sizeof(BN_ULONG) * P256_LIMBS)];
  360 (0.0%)      BN_ULONG *aligned_neg_y = (BN_ULONG *) align_pointer(buffer_neg_y, 32);
  432 (0.0%)      ecp_nistz256_neg(aligned_neg_y, aligned_t->Y);
  648 (0.0%)      copy_conditional(aligned_t->Y, aligned_neg_y, wvalue & 1);
    .         
    .             // Note |ecp_nistz256_point_add_affine| does not work if |p.p| and |t.a|
    .             // are the same non-infinity point.
  432 (0.0%)      ecp_nistz256_point_add_affine(aligned_p, aligned_p, aligned_t);
    .           }
    .         
    8 (0.0%)    assert(group->field.N.width == P256_LIMBS);
   12 (0.0%)    OPENSSL_memcpy(r->X.words, aligned_p->X, P256_LIMBS * sizeof(BN_ULONG));
   16 (0.0%)    OPENSSL_memcpy(r->Y.words, aligned_p->Y, P256_LIMBS * sizeof(BN_ULONG));
   16 (0.0%)    OPENSSL_memcpy(r->Z.words, aligned_p->Z, P256_LIMBS * sizeof(BN_ULONG));
   12 (0.0%)  }
    .         
    .         static void ecp_nistz256_points_mul_public(const EC_GROUP *group,
    .                                                    EC_JACOBIAN *r,
    .                                                    const EC_SCALAR *g_scalar,
    .                                                    const EC_JACOBIAN *p_,
    .                                                    const EC_SCALAR *p_scalar) {
    .           assert(p_ != NULL && p_scalar != NULL && g_scalar != NULL);
    .         
-- line 372 ----------------------------------------
-- line 431 ----------------------------------------
    .           assert(group->field.N.width == P256_LIMBS);
    .           OPENSSL_memcpy(r->X.words, aligned_p->X, P256_LIMBS * sizeof(BN_ULONG));
    .           OPENSSL_memcpy(r->Y.words, aligned_p->Y, P256_LIMBS * sizeof(BN_ULONG));
    .           OPENSSL_memcpy(r->Z.words, aligned_p->Z, P256_LIMBS * sizeof(BN_ULONG));
    .         }
    .         
    .         static int ecp_nistz256_get_affine(const EC_GROUP *group,
    .                                            const EC_JACOBIAN *point, EC_FELEM *x,
   44 (0.0%)                                     EC_FELEM *y) {
   36 (0.0%)    if (constant_time_declassify_int(
    .                   ec_GFp_simple_is_at_infinity(group, point))) {
    .             OPENSSL_PUT_ERROR(EC, EC_R_POINT_AT_INFINITY);
    .             return 0;
    .           }
    .         
    .           BN_ULONG z_inv2[P256_LIMBS];
   16 (0.0%)    assert(group->field.N.width == P256_LIMBS);
   24 (0.0%)    ecp_nistz256_mod_inverse_sqr_mont(z_inv2, point->Z.words);
    .         
    8 (0.0%)    if (x != NULL) {
   24 (0.0%)      ecp_nistz256_mul_mont(x->words, z_inv2, point->X.words);
    .           }
    .         
    8 (0.0%)    if (y != NULL) {
   10 (0.0%)      ecp_nistz256_sqr_mont(z_inv2, z_inv2);                            // z^-4
   16 (0.0%)      ecp_nistz256_mul_mont(y->words, point->Y.words, point->Z.words);  // y * z
   12 (0.0%)      ecp_nistz256_mul_mont(y->words, y->words, z_inv2);  // y * z^-3
    .           }
    .         
    4 (0.0%)    return 1;
   20 (0.0%)  }
    .         
    .         static void ecp_nistz256_add(const EC_GROUP *group, EC_JACOBIAN *r,
    .                                      const EC_JACOBIAN *a_, const EC_JACOBIAN *b_) {
    .           P256_POINT a, b;
    .           OPENSSL_memcpy(a.X, a_->X.words, P256_LIMBS * sizeof(BN_ULONG));
    .           OPENSSL_memcpy(a.Y, a_->Y.words, P256_LIMBS * sizeof(BN_ULONG));
    .           OPENSSL_memcpy(a.Z, a_->Z.words, P256_LIMBS * sizeof(BN_ULONG));
    .           OPENSSL_memcpy(b.X, b_->X.words, P256_LIMBS * sizeof(BN_ULONG));
-- line 469 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/p384.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 53 ----------------------------------------
      .         #define p384_felem_opp(out, in0)        bignum_neg_p384(out, in0)
      .         #define p384_felem_to_bytes(out, in0)   bignum_tolebytes_6(out, in0)
      .         #define p384_felem_from_bytes(out, in0) bignum_fromlebytes_6(out, in0)
      .         #define p384_felem_to_mont(out, in0)    bignum_tomont_p384_selector(out, in0)
      .         #define p384_felem_from_mont(out, in0)  bignum_deamont_p384_selector(out, in0)
      .         #define p384_felem_mul(out, in0, in1)   bignum_montmul_p384_selector(out, in0, in1)
      .         #define p384_felem_sqr(out, in0)        bignum_montsqr_p384_selector(out, in0)
      .         
  3,960 (0.0%)  static p384_limb_t p384_felem_nz(const p384_limb_t in1[P384_NLIMBS]) {
  2,376 (0.0%)    return bignum_nonzero_6(in1);
  1,584 (0.0%)  }
      .         
      .         #else // EC_NISTP_USE_S2N_BIGNUM
      .         
      .         // Fiat-crypto implementation of field arithmetic
      .         #define p384_felem_add(out, in0, in1)   fiat_p384_add(out, in0, in1)
      .         #define p384_felem_sub(out, in0, in1)   fiat_p384_sub(out, in0, in1)
      .         #define p384_felem_opp(out, in0)        fiat_p384_opp(out, in0)
      .         #define p384_felem_mul(out, in0, in1)   fiat_p384_mul(out, in0, in1)
-- line 71 ----------------------------------------
-- line 80 ----------------------------------------
      .           fiat_p384_nonzero(&ret, in1);
      .           return ret;
      .         }
      .         
      .         #endif // EC_NISTP_USE_S2N_BIGNUM
      .         
      .         
      .         static void p384_felem_copy(p384_limb_t out[P384_NLIMBS],
    225 (0.0%)                             const p384_limb_t in1[P384_NLIMBS]) {
    990 (0.0%)    for (size_t i = 0; i < P384_NLIMBS; i++) {
  2,700 (0.0%)      out[i] = in1[i];
      .           }
    180 (0.0%)  }
      .         
      .         static void p384_felem_cmovznz(p384_limb_t out[P384_NLIMBS],
      .                                        p384_limb_t t,
      .                                        const p384_limb_t z[P384_NLIMBS],
 22,896 (0.2%)                                 const p384_limb_t nz[P384_NLIMBS]) {
 10,176 (0.1%)    p384_limb_t mask = constant_time_is_zero_w(t);
 55,968 (0.5%)    for (size_t i = 0; i < P384_NLIMBS; i++) {
290,016 (2.7%)      out[i] = constant_time_select_w(mask, z[i], nz[i]);
      .           }
 12,720 (0.1%)  }
      .         
     60 (0.0%)  static void p384_from_generic(p384_felem out, const EC_FELEM *in) {
      .         #ifdef OPENSSL_BIG_ENDIAN
      .           uint8_t tmp[P384_EC_FELEM_BYTES];
      .           bn_words_to_little_endian(tmp, P384_EC_FELEM_BYTES, in->words, P384_EC_FELEM_WORDS);
      .           p384_felem_from_bytes(out, tmp);
      .         #else
     50 (0.0%)    p384_felem_from_bytes(out, (const uint8_t *)in->words);
      .         #endif
     30 (0.0%)  }
      .         
     60 (0.0%)  static void p384_to_generic(EC_FELEM *out, const p384_felem in) {
      .           // This works because 384 is a multiple of 64, so there are no excess bytes to
      .           // zero when rounding up to |BN_ULONG|s.
      .           OPENSSL_STATIC_ASSERT(
      .               384 / 8 == sizeof(BN_ULONG) * ((384 + BN_BITS2 - 1) / BN_BITS2),
      .               p384_felem_to_bytes_leaves_bytes_uninitialized);
      .         #ifdef OPENSSL_BIG_ENDIAN
      .           uint8_t tmp[P384_EC_FELEM_BYTES];
      .           p384_felem_to_bytes(tmp, in);
      .           bn_little_endian_to_words(out->words, P384_EC_FELEM_WORDS, tmp, P384_EC_FELEM_BYTES);
      .         #else
     50 (0.0%)    p384_felem_to_bytes((uint8_t *)out->words, in);
      .         #endif
     30 (0.0%)  }
      .         
      6 (0.0%)  static void p384_from_scalar(p384_felem out, const EC_SCALAR *in) {
      .         #ifdef OPENSSL_BIG_ENDIAN
      .           uint8_t tmp[P384_EC_FELEM_BYTES];
      .           bn_words_to_little_endian(tmp, P384_EC_FELEM_BYTES, in->words, P384_EC_FELEM_WORDS);
      .           p384_felem_from_bytes(out, tmp);
      .         #else
      5 (0.0%)    p384_felem_from_bytes(out, (const uint8_t *)in->words);
      .         #endif
      3 (0.0%)  }
      .         
      .         // p384_inv_square calculates |out| = |in|^{-2}
      .         //
      .         // Based on Fermat's Little Theorem:
      .         //   a^p = a (mod p)
      .         //   a^{p-1} = 1 (mod p)
      .         //   a^{p-3} = a^{-2} (mod p)
      .         // p = 2^384 - 2^128 - 2^96 + 2^32 - 1
      .         // Hexadecimal representation of p  3:
      .         // p-3 = ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe
      .         //       ffffffff 00000000 00000000 fffffffc
      .         static void p384_inv_square(p384_felem out,
      9 (0.0%)                              const p384_felem in) {
      .           // This implements the addition chain described in
      .           // https://briansmith.org/ecc-inversion-addition-chains-01#p384_field_inversion
      .           // The side comments show the value of the exponent:
      .           // squaring the element => doubling the exponent
      .           // multiplying by an element => adding to the exponent the power of that element
      .           p384_felem x2, x3, x6, x12, x15, x30, x60, x120;
      5 (0.0%)    p384_felem_sqr(x2, in);   // 2^2 - 2^1
      6 (0.0%)    p384_felem_mul(x2, x2, in);  // 2^2 - 2^0
      .         
      5 (0.0%)    p384_felem_sqr(x3, x2);   // 2^3 - 2^1
      6 (0.0%)    p384_felem_mul(x3, x3, in);  // 2^3 - 2^0
      .         
      5 (0.0%)    p384_felem_sqr(x6, x3);
     10 (0.0%)    for (int i = 1; i < 3; i++) {
     10 (0.0%)      p384_felem_sqr(x6, x6);
      .           }                           // 2^6 - 2^3
      6 (0.0%)    p384_felem_mul(x6, x6, x3);  // 2^6 - 2^0
      .         
      5 (0.0%)    p384_felem_sqr(x12, x6);
     19 (0.0%)    for (int i = 1; i < 6; i++) {
     25 (0.0%)      p384_felem_sqr(x12, x12);
      .           }                             // 2^12 - 2^6
      6 (0.0%)    p384_felem_mul(x12, x12, x6);  // 2^12 - 2^0
      .         
      5 (0.0%)    p384_felem_sqr(x15, x12);
     10 (0.0%)    for (int i = 1; i < 3; i++) {
     10 (0.0%)      p384_felem_sqr(x15, x15);
      .           }                             // 2^15 - 2^3
      6 (0.0%)    p384_felem_mul(x15, x15, x3);  // 2^15 - 2^0
      .         
      5 (0.0%)    p384_felem_sqr(x30, x15);
     46 (0.0%)    for (int i = 1; i < 15; i++) {
     70 (0.0%)      p384_felem_sqr(x30, x30);
      .           }                              // 2^30 - 2^15
      6 (0.0%)    p384_felem_mul(x30, x30, x15);  // 2^30 - 2^0
      .         
      5 (0.0%)    p384_felem_sqr(x60, x30);
     91 (0.0%)    for (int i = 1; i < 30; i++) {
    145 (0.0%)      p384_felem_sqr(x60, x60);
      .           }                              // 2^60 - 2^30
      6 (0.0%)    p384_felem_mul(x60, x60, x30);  // 2^60 - 2^0
      .         
      5 (0.0%)    p384_felem_sqr(x120, x60);
    181 (0.0%)    for (int i = 1; i < 60; i++) {
    295 (0.0%)      p384_felem_sqr(x120, x120);
      .           }                                // 2^120 - 2^60
      6 (0.0%)    p384_felem_mul(x120, x120, x60);  // 2^120 - 2^0
      .         
      .           p384_felem ret;
      5 (0.0%)    p384_felem_sqr(ret, x120);
    361 (0.0%)    for (int i = 1; i < 120; i++) {
    595 (0.0%)      p384_felem_sqr(ret, ret);
      .           }                                // 2^240 - 2^120
      6 (0.0%)    p384_felem_mul(ret, ret, x120);   // 2^240 - 2^0
      .         
     49 (0.0%)    for (int i = 0; i < 15; i++) {
     75 (0.0%)      p384_felem_sqr(ret, ret);
      .           }                                // 2^255 - 2^15
      6 (0.0%)    p384_felem_mul(ret, ret, x15);    // 2^255 - 2^0
      .         
      .           // Why (1 + 30) in the loop?
      .           // This is as expressed in:
      .           //   https://briansmith.org/ecc-inversion-addition-chains-01#p384_field_inversion
      .           // My guess is to say that we're going to shift 31 bits, but this time we
      .           // won't add x31 to make all the new bits 1s, as was done in previous steps,
      .           // but we're going to add x30 so there will be 255 1s, then a 0, then 30 1s
      .           // to form this pattern:
      .           //   ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff
      .           // (the last 2 1s are appended in the following step).
     97 (0.0%)    for (int i = 0; i < (1 + 30); i++) {
    155 (0.0%)      p384_felem_sqr(ret, ret);
      .           }                                // 2^286 - 2^31
      6 (0.0%)    p384_felem_mul(ret, ret, x30);    // 2^286 - 2^30 - 2^0
      .         
      5 (0.0%)    p384_felem_sqr(ret, ret);
      5 (0.0%)    p384_felem_sqr(ret, ret);      // 2^288 - 2^32 - 2^2
      6 (0.0%)    p384_felem_mul(ret, ret, x2);     // 2^288 - 2^32 - 2^0
      .         
      .           // Why not 94 instead of (64 + 30) in the loop?
      .           // Similarly to the comment above, there is a shift of 94 bits
      .           // but what will be added is x30, which will cause 64 of those bits
      .           // to be 64 0s and 30 1s to complete the pattern above with:
      .           //   00000000 00000000 fffffffc
      .           // (the last 2 0s are appended by the last 2 shifts).
    286 (0.0%)    for (int i = 0; i < (64 + 30); i++) {
    470 (0.0%)      p384_felem_sqr(ret, ret);
      .           }                                // 2^382 - 2^126 - 2^94
      6 (0.0%)    p384_felem_mul(ret, ret, x30);    // 2^382 - 2^126 - 2^94 + 2^30 - 2^0
      .         
      5 (0.0%)    p384_felem_sqr(ret, ret);
      5 (0.0%)    p384_felem_sqr(out, ret);      // 2^384 - 2^128 - 2^96 + 2^32 - 2^2 = p - 3
      6 (0.0%)  }
      .         
      .         #if defined(EC_NISTP_USE_S2N_BIGNUM)
 14,256 (0.1%)  DEFINE_METHOD_FUNCTION(ec_nistp_felem_meth, p384_felem_methods) {
      .             out->felem_num_limbs = P384_NLIMBS;
      .             out->add = bignum_add_p384;
      .             out->sub = bignum_sub_p384;
      .             out->mul = bignum_montmul_p384_selector;
      .             out->sqr = bignum_montsqr_p384_selector;
      .             out->nz  = p384_felem_nz;
      .         }
      .         #else
-- line 253 ----------------------------------------
-- line 261 ----------------------------------------
      .         }
      .         #endif
      .         
      .         static void p384_point_double(p384_felem x_out,
      .                                       p384_felem y_out,
      .                                       p384_felem z_out,
      .                                       const p384_felem x_in,
      .                                       const p384_felem y_in,
  3,960 (0.0%)                                const p384_felem z_in) {
  5,544 (0.1%)    ec_nistp_point_double(p384_felem_methods(), x_out, y_out, z_out, x_in, y_in, z_in);
  1,188 (0.0%)  }
      .         
      .         // p384_point_add calculates (x1, y1, z1) + (x2, y2, z2)
      .         //
      .         // The method is taken from:
      .         //   http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-add-2007-bl
      .         // adapted for mixed addition (z2 = 1, or z2 = 0 for the point at infinity).
      .         //
      .         // Coq transcription and correctness proof:
-- line 279 ----------------------------------------
-- line 281 ----------------------------------------
      .         // <https://github.com/davidben/fiat-crypto/blob/c7b95f62b2a54b559522573310e9b487327d219a/src/Curves/Weierstrass/Jacobian.v#L544>
      .         static void p384_point_add(p384_felem x3, p384_felem y3, p384_felem z3,
      .                                    const p384_felem x1,
      .                                    const p384_felem y1,
      .                                    const p384_felem z1,
      .                                    const int mixed,
      .                                    const p384_felem x2,
      .                                    const p384_felem y2,
  1,980 (0.0%)                             const p384_felem z2) {
  3,366 (0.0%)    ec_nistp_point_add(p384_felem_methods(), x3, y3, z3, x1, y1, z1, mixed, x2, y2, z2);
    594 (0.0%)  }
      .         
      .         // OPENSSL EC_METHOD FUNCTIONS
      .         
      .         // Takes the Jacobian coordinates (X, Y, Z) of a point and returns:
      .         //   (X', Y') = (X/Z^2, Y/Z^3).
      .         static int ec_GFp_nistp384_point_get_affine_coordinates(
      .             const EC_GROUP *group, const EC_JACOBIAN *point,
     11 (0.0%)      EC_FELEM *x_out, EC_FELEM *y_out) {
      .         
     10 (0.0%)    if (constant_time_declassify_w(ec_GFp_simple_is_at_infinity(group, point))) {
      .             OPENSSL_PUT_ERROR(EC, EC_R_POINT_AT_INFINITY);
      .             return 0;
      .           }
      .         
      .           p384_felem z1, z2;
      6 (0.0%)    p384_from_generic(z1, &point->Z);
      5 (0.0%)    p384_inv_square(z2, z1);
      .         
      2 (0.0%)    if (x_out != NULL) {
      .             p384_felem x;
      5 (0.0%)      p384_from_generic(x, &point->X);
      6 (0.0%)      p384_felem_mul(x, x, z2);
      5 (0.0%)      p384_to_generic(x_out, x);
      .           }
      .         
      2 (0.0%)    if (y_out != NULL) {
      .             p384_felem y;
      .             p384_from_generic(y, &point->Y);
      .             p384_felem_sqr(z2, z2);  // z^-4
      .             p384_felem_mul(y, y, z1);   // y * z
      .             p384_felem_mul(y, y, z2);   // y * z^-3
      .             p384_to_generic(y_out, y);
      .           }
      .         
      1 (0.0%)    return 1;
      5 (0.0%)  }
      .         
      .         static void ec_GFp_nistp384_add(const EC_GROUP *group, EC_JACOBIAN *r,
      .                                         const EC_JACOBIAN *a, const EC_JACOBIAN *b) {
      .           p384_felem x1, y1, z1, x2, y2, z2;
      .           p384_from_generic(x1, &a->X);
      .           p384_from_generic(y1, &a->Y);
      .           p384_from_generic(z1, &a->Z);
      .           p384_from_generic(x2, &b->X);
-- line 335 ----------------------------------------
-- line 352 ----------------------------------------
      .           p384_to_generic(&r->Y, y);
      .           p384_to_generic(&r->Z, z);
      .         }
      .         
      .         // The calls to from/to_generic are needed for the case
      .         // when BORINGSSL_HAS_UINT128 is undefined, i.e. p384_32.h fiat code is used;
      .         // while OPENSSL_64_BIT is defined, i.e. BN_ULONG is uint64_t
      .         static void ec_GFp_nistp384_mont_felem_to_bytes(
     11 (0.0%)    const EC_GROUP *group, uint8_t *out, size_t *out_len, const EC_FELEM *in) {
      .         
      6 (0.0%)    size_t len = BN_num_bytes(&group->field.N);
      .           EC_FELEM felem_tmp;
      .           p384_felem tmp;
      5 (0.0%)    p384_from_generic(tmp, in);
      5 (0.0%)    p384_felem_from_mont(tmp, tmp);
      5 (0.0%)    p384_to_generic(&felem_tmp, tmp);
      .         
      8 (0.0%)    bn_words_to_big_endian(out, len, felem_tmp.words, group->order.N.width);
      .         
      3 (0.0%)    *out_len = len;
      6 (0.0%)  }
      .         
      .         static int ec_GFp_nistp384_mont_felem_from_bytes(
     22 (0.0%)    const EC_GROUP *group, EC_FELEM *out, const uint8_t *in, size_t len) {
      .         
      .           EC_FELEM felem_tmp;
      .           p384_felem tmp;
      .           // This function calls bn_cmp_words_consttime
     16 (0.0%)    if (!ec_GFp_simple_felem_from_bytes(group, &felem_tmp, in, len)) {
      .             return 0;
      .           }
     10 (0.0%)    p384_from_generic(tmp, &felem_tmp);
     10 (0.0%)    p384_felem_to_mont(tmp, tmp);
     10 (0.0%)    p384_to_generic(out, tmp);
      2 (0.0%)    return 1;
     10 (0.0%)  }
      .         
      .         static int ec_GFp_nistp384_cmp_x_coordinate(const EC_GROUP *group,
      .                                                     const EC_JACOBIAN *p,
     10 (0.0%)                                              const EC_SCALAR *r) {
      7 (0.0%)    if (ec_GFp_simple_is_at_infinity(group, p)) {
      .             return 0;
      .           }
      .         
      .           // We wish to compare X/Z^2 with r. This is equivalent to comparing X with
      .           // r*Z^2. Note that X and Z are represented in Montgomery form, while r is
      .           // not.
      .           p384_felem Z2_mont;
      6 (0.0%)    p384_from_generic(Z2_mont, &p->Z);
      6 (0.0%)    p384_felem_mul(Z2_mont, Z2_mont, Z2_mont);
      .         
      .           p384_felem r_Z2;
      5 (0.0%)    p384_from_scalar(r_Z2, r);  // r < order < p, so this is valid.
      6 (0.0%)    p384_felem_mul(r_Z2, r_Z2, Z2_mont);
      .         
      .           p384_felem X;
      5 (0.0%)    p384_from_generic(X, &p->X);
      5 (0.0%)    p384_felem_from_mont(X, X);
      .         
      8 (0.0%)    if (OPENSSL_memcmp(&r_Z2, &X, sizeof(r_Z2)) == 0) {
      2 (0.0%)      return 1;
      .           }
      .         
      .           // During signing the x coefficient is reduced modulo the group order.
      .           // Therefore there is a small possibility, less than 2^189/2^384 = 1/2^195,
      .           // that group_order < p.x < p.
      .           // In that case, we need not only to compare against |r| but also to
      .           // compare against r+group_order.
      .           assert(group->field.N.width == group->order.N.width);
-- line 420 ----------------------------------------
-- line 426 ----------------------------------------
      .             p384_from_generic(r_Z2, &tmp);
      .             p384_felem_mul(r_Z2, r_Z2, Z2_mont);
      .             if (OPENSSL_memcmp(&r_Z2, &X, sizeof(r_Z2)) == 0) {
      .               return 1;
      .             }
      .           }
      .         
      .           return 0;
      5 (0.0%)  }
      .         
      .         // ----------------------------------------------------------------------------
      .         //                    SCALAR MULTIPLICATION OPERATIONS
      .         // ----------------------------------------------------------------------------
      .         //
      .         // The method for computing scalar products in functions:
      .         //   - |ec_GFp_nistp384_point_mul|,
      .         //   - |ec_GFp_nistp384_point_mul_base|,
-- line 442 ----------------------------------------
-- line 463 ----------------------------------------
      .         //
      .         // OpenSSL has a similar analysis for P-521 implementation:
      .         // https://github.com/openssl/openssl/blob/e9492d1cecf459261f1f5ac0eb03e9c631600537/crypto/ec/ecp_nistp521.c#L1318
      .         //
      .         // For detailed analysis of different window sizes see the bottom of this file.
      .         
      .         
      .         // p384_get_bit returns the |i|-th bit in |in|
  1,900 (0.0%)  static crypto_word_t p384_get_bit(const EC_SCALAR *in, int i) {
  1,520 (0.0%)    if (i < 0 || i >= 384) {
      4 (0.0%)      return 0;
      .           }
      .         #if defined(OPENSSL_64_BIT)
      .           assert(sizeof(BN_ULONG) == 8);
  4,536 (0.0%)    return (in->words[i >> 6] >> (i & 63)) & 1;
      .         #else
      .           assert(sizeof(BN_ULONG) == 4);
      .           return (in->words[i >> 5] >> (i & 31)) & 1;
      .         #endif
    760 (0.0%)  }
      .         
      .         // Constants for scalar encoding in the scalar multiplication functions.
      .         #define P384_MUL_WSIZE        (5) // window size w
      .         // Assert the window size is 5 because the pre-computed table in |p384_table.h|
      .         // is generated for window size 5.
      .         OPENSSL_STATIC_ASSERT(P384_MUL_WSIZE == 5,
      .             p384_scalar_mul_window_size_is_not_equal_to_five)
      .         
-- line 490 ----------------------------------------
-- line 503 ----------------------------------------
      .         #define P384_MUL_PUB_TABLE_SIZE (1 << (P384_MUL_PUB_WSIZE - 1))
      .         
      .         // Compute "regular" wNAF representation of a scalar, see
      .         // Joye, Tunstall, "Exponent Recoding and Regular Exponentiation Algorithms",
      .         // AfricaCrypt 2009, Alg 6.
      .         // It forces an odd scalar and outputs digits in
      .         // {\pm 1, \pm 3, \pm 5, \pm 7, \pm 9, ...}
      .         // i.e. signed odd digits with _no zeroes_ -- that makes it "regular".
      6 (0.0%)  static void p384_felem_mul_scalar_rwnaf(int16_t *out, const EC_SCALAR *in) {
      .           int16_t window, d;
      .         
      5 (0.0%)    window = (in->words[0] & P384_MUL_WSIZE_MASK) | 1;
    232 (0.0%)    for (size_t i = 0; i < P384_MUL_NWINDOWS - 1; i++) {
    304 (0.0%)      d = (window & P384_MUL_WSIZE_MASK) - P384_MUL_TWO_TO_WSIZE;
    456 (0.0%)      out[i] = d;
    456 (0.0%)      window = (window - d) >> P384_MUL_WSIZE;
  1,444 (0.0%)      for (size_t j = 1; j <= P384_MUL_WSIZE; j++) {
  7,600 (0.1%)        window += p384_get_bit(in, (i + 1) * P384_MUL_WSIZE + j) << j;
      .             }
      .           }
      4 (0.0%)    out[P384_MUL_NWINDOWS - 1] = window;
      3 (0.0%)  }
      .         
      .         // p384_select_point selects the |idx|-th projective point from the given
      .         // precomputed table and copies it to |out| in constant time.
      .         static void p384_select_point(p384_felem out[3],
      .                                       size_t idx,
      .                                       p384_felem table[][3],
      .                                       size_t table_size) {
      .           OPENSSL_memset(out, 0, sizeof(p384_felem) * 3);
-- line 532 ----------------------------------------
-- line 538 ----------------------------------------
      .           }
      .         }
      .         
      .         // p384_select_point_affine selects the |idx|-th affine point from
      .         // the given precomputed table and copies it to |out| in constant-time.
      .         static void p384_select_point_affine(p384_felem out[2],
      .                                              size_t idx,
      .                                              const p384_felem table[][2],
    616 (0.0%)                                       size_t table_size) {
    385 (0.0%)    OPENSSL_memset(out, 0, sizeof(p384_felem) * 2);
  5,313 (0.0%)    for (size_t i = 0; i < table_size; i++) {
  3,696 (0.0%)      p384_limb_t mismatch = i ^ idx;
 19,712 (0.2%)      p384_felem_cmovznz(out[0], mismatch, table[i][0], out[0]);
 19,712 (0.2%)      p384_felem_cmovznz(out[1], mismatch, table[i][1], out[1]);
      .           }
    308 (0.0%)  }
      .         
      .         // Multiplication of a point by a scalar, r = [scalar]P.
      .         // The product is computed with the use of a small table generated on-the-fly
      .         // and the scalar recoded in the regular-wNAF representation.
      .         //
      .         // The precomputed (on-the-fly) table |p_pre_comp| holds 16 odd multiples of P:
      .         //     [2i + 1]P for i in [0, 15].
      .         // Computing the negation of a point P = (x, y) is relatively easy:
-- line 561 ----------------------------------------
-- line 723 ----------------------------------------
      .         //   2. Double the accumulator 5 times.
      .         //   3. Repeat steps 1. and 2. for groups (2) and (1),
      .         //      and perform step 1. for group (0).
      .         //   4. If the scalar is even subtract G from the accumulator.
      .         //
      .         // Note: this function is constant-time.
      .         static void ec_GFp_nistp384_point_mul_base(const EC_GROUP *group,
      .                                                    EC_JACOBIAN *r,
     10 (0.0%)                                             const EC_SCALAR *scalar) {
      .         
     46 (0.0%)    p384_felem res[3] = {{0}, {0}, {0}}, tmp[3] = {{0}, {0}, {0}}, ftmp;
     27 (0.0%)    int16_t rnaf[P384_MUL_NWINDOWS] = {0};
      .         
      .           // Recode the scalar.
      5 (0.0%)    p384_felem_mul_scalar_rwnaf(rnaf, scalar);
      .         
      .           // Process the 4 groups of digits starting from group (3) down to group (0).
     16 (0.0%)    for (int i = 3; i >= 0; i--) {
      .             // Double |res| 5 times in each iteration, except in the first one.
     97 (0.0%)      for (int j = 0; i != 3 && j < P384_MUL_WSIZE; j++) {
    240 (0.0%)        p384_point_double(res[0], res[1], res[2], res[0], res[1], res[2]);
      .             }
      .         
      .             // Process the digits in the current group from the most to the least
      .             // significant one (this is a requirement to ensure that the case of point
      .             // doubling can't happen).
      .             // For group (3) we process digits s_75 to s_3, for group (2) s_74 to s_2,
      .             // group (1) s_73 to s_1, and for group (0) s_76 to s_0.
     44 (0.0%)      const size_t start_idx = ((P384_MUL_NWINDOWS - i - 1)/4)*4 + i;
      .         
    251 (0.0%)      for (int j = start_idx; j >= 0; j -= 4) {
      .               // For each digit |d| in the current group read the corresponding point
      .               // from the table and add it to |res|. If |d| is negative, negate
      .               // the point before adding it to |res|.
    308 (0.0%)        int16_t d = rnaf[j];
      .               // is_neg = (d < 0) ? 1 : 0
    231 (0.0%)        int16_t is_neg = (d >> 15) & 1;
      .               // d = abs(d)
    539 (0.0%)        d = (d ^ -is_neg) + is_neg;
      .         
    231 (0.0%)        int16_t idx = d >> 1;
      .         
      .               // Select the point to add, in constant time.
  1,309 (0.0%)        p384_select_point_affine(tmp, idx, p384_g_pre_comp[j / 4],
      .                                        P384_MUL_TABLE_SIZE);
      .         
      .               // Negate y coordinate of the point tmp = (x, y); ftmp = -y.
    462 (0.0%)        p384_felem_opp(ftmp, tmp[1]);
      .               // Conditionally select y or -y depending on the sign of the digit |d|.
    770 (0.0%)        p384_felem_cmovznz(tmp[1], is_neg, tmp[1], ftmp);
      .         
      .               // Add the point to the accumulator |res|.
      .               // Note that the points in the pre-computed table are given with affine
      .               // coordinates. The point addition function computes a sum of two points,
      .               // either both given in projective, or one in projective and the other one
      .               // in affine coordinates. The |mixed| flag indicates the latter option,
      .               // in which case we set the third coordinate of the second point to one.
  1,771 (0.0%)        p384_point_add(res[0], res[1], res[2], res[0], res[1], res[2],
      .                              1 /* mixed */, tmp[0], tmp[1], p384_felem_one);
      .             }
      .           }
      .         
      .           // Conditionally subtract G if the scalar is even, in constant-time.
      .           // First, compute |tmp| = |res| + (-G).
      5 (0.0%)    p384_felem_copy(tmp[0], p384_g_pre_comp[0][0][0]);
      6 (0.0%)    p384_felem_opp(tmp[1], p384_g_pre_comp[0][0][1]);
     23 (0.0%)    p384_point_add(tmp[0], tmp[1], tmp[2], res[0], res[1], res[2],
      .                          1 /* mixed */, tmp[0], tmp[1], p384_felem_one);
      .         
      .           // Select |res| or |tmp| based on the |scalar| parity.
      9 (0.0%)    p384_felem_cmovznz(res[0], scalar->words[0] & 1, tmp[0], res[0]);
     12 (0.0%)    p384_felem_cmovznz(res[1], scalar->words[0] & 1, tmp[1], res[1]);
     12 (0.0%)    p384_felem_cmovznz(res[2], scalar->words[0] & 1, tmp[2], res[2]);
      .         
      .           // Copy the result to the output.
      5 (0.0%)    p384_to_generic(&r->X, res[0]);
      7 (0.0%)    p384_to_generic(&r->Y, res[1]);
      7 (0.0%)    p384_to_generic(&r->Z, res[2]);
      6 (0.0%)  }
      .         
      .         // Computes [g_scalar]G + [p_scalar]P, where G is the base point of the P-384
      .         // curve, and P is the given point |p|.
      .         //
      .         // Both scalar products are computed by the same "textbook" wNAF method,
      .         // with w = 5 for g_scalar and w = 5 for p_scalar.
      .         // For the base point G product we use the first sub-table of the precomputed
      .         // table |p384_g_pre_comp| from |p384_table.h| file, while for P we generate
-- line 809 ----------------------------------------
-- line 832 ----------------------------------------
      .         //          g_scalar, negate it if the digit is negative, and add it to the
      .         //          accumulator.
      .         //
      .         // Note: this function is NOT constant-time.
      .         static void ec_GFp_nistp384_point_mul_public(const EC_GROUP *group,
      .                                                      EC_JACOBIAN *r,
      .                                                      const EC_SCALAR *g_scalar,
      .                                                      const EC_JACOBIAN *p,
     12 (0.0%)                                               const EC_SCALAR *p_scalar) {
      .         
     46 (0.0%)    p384_felem res[3] = {{0}, {0}, {0}}, two_p[3] = {{0}, {0}, {0}}, ftmp;
      .         
      .           // Table of multiples of P:  [2i + 1]P for i in [0, 15].
      .           p384_felem p_pre_comp[P384_MUL_PUB_TABLE_SIZE][3];
      .         
      .           // Set the first point in the table to P.
      5 (0.0%)    p384_from_generic(p_pre_comp[0][0], &p->X);
      7 (0.0%)    p384_from_generic(p_pre_comp[0][1], &p->Y);
      7 (0.0%)    p384_from_generic(p_pre_comp[0][2], &p->Z);
      .         
      .           // Compute two_p = [2]P.
     16 (0.0%)    p384_point_double(two_p[0], two_p[1], two_p[2],
      .                             p_pre_comp[0][0], p_pre_comp[0][1], p_pre_comp[0][2]);
      .         
      .           // Generate the remaining 15 multiples of P.
     49 (0.0%)    for (size_t i = 1; i < P384_MUL_PUB_TABLE_SIZE; i++) {
    570 (0.0%)      p384_point_add(p_pre_comp[i][0], p_pre_comp[i][1], p_pre_comp[i][2],
      .                            two_p[0], two_p[1], two_p[2], 0 /* both Jacobian */,
    120 (0.0%)                     p_pre_comp[i - 1][0],
    135 (0.0%)                     p_pre_comp[i - 1][1],
    135 (0.0%)                     p_pre_comp[i - 1][2]);
      .           }
      .         
      .           // Recode the scalars.
    112 (0.0%)    int8_t p_wnaf[385] = {0}, g_wnaf[385] = {0};
      7 (0.0%)    ec_compute_wNAF(group, p_wnaf, p_scalar, 384, P384_MUL_PUB_WSIZE);
      7 (0.0%)    ec_compute_wNAF(group, g_wnaf, g_scalar, 384, P384_MUL_WSIZE);
      .         
      .           // In the beginning res is set to point-at-infinity, so we set the flag.
      1 (0.0%)    int16_t res_is_inf = 1;
      .           int16_t d, is_neg, idx;
      .         
  1,159 (0.0%)    for (int i = 384; i >= 0; i--) {
      .         
      .             // If |res| is point-at-infinity there is no point in doubling so skip it.
    770 (0.0%)      if (!res_is_inf) {
  6,080 (0.1%)        p384_point_double(res[0], res[1], res[2], res[0], res[1], res[2]);
      .             }
      .         
      .             // Process the p_scalar digit.
  1,925 (0.0%)      d = p_wnaf[i];
    770 (0.0%)      if (d != 0) {
    159 (0.0%)        is_neg = d < 0 ? 1 : 0;
    351 (0.0%)        idx = (is_neg) ? (-d - 1) >> 1 : (d - 1) >> 1;
      .         
    106 (0.0%)        if (res_is_inf) {
      .                 // If |res| is point-at-infinity there is no need to add the new point,
      .                 // we can simply copy it.
     12 (0.0%)          p384_felem_copy(res[0], p_pre_comp[idx][0]);
     14 (0.0%)          p384_felem_copy(res[1], p_pre_comp[idx][1]);
     14 (0.0%)          p384_felem_copy(res[2], p_pre_comp[idx][2]);
      2 (0.0%)          res_is_inf = 0;
      .               } else {
      .                 // Otherwise, add to the accumulator either the point at position idx
      .                 // in the table or its negation.
    104 (0.0%)          if (is_neg) {
    462 (0.0%)            p384_felem_opp(ftmp, p_pre_comp[idx][1]);
      .                 } else {
    247 (0.0%)            p384_felem_copy(ftmp, p_pre_comp[idx][1]);
      .                 }
  1,092 (0.0%)          p384_point_add(res[0], res[1], res[2],
      .                                res[0], res[1], res[2],
      .                                0 /* both Jacobian */,
    884 (0.0%)                         p_pre_comp[idx][0], ftmp, p_pre_comp[idx][2]);
      .               }
      .             }
      .         
      .             // Process the g_scalar digit.
  1,925 (0.0%)      d = g_wnaf[i];
    770 (0.0%)      if (d != 0) {
    159 (0.0%)        is_neg = d < 0 ? 1 : 0;
    349 (0.0%)        idx = (is_neg) ? (-d - 1) >> 1 : (d - 1) >> 1;
      .         
    106 (0.0%)        if (res_is_inf) {
      .                 // If |res| is point-at-infinity there is no need to add the new point,
      .                 // we can simply copy it.
      .                 p384_felem_copy(res[0], p384_g_pre_comp[0][idx][0]);
      .                 p384_felem_copy(res[1], p384_g_pre_comp[0][idx][1]);
      .                 p384_felem_copy(res[2], p384_felem_one);
      .                 res_is_inf = 0;
      .               } else {
      .                 // Otherwise, add to the accumulator either the point at position idx
      .                 // in the table or its negation.
    106 (0.0%)          if (is_neg) {
    434 (0.0%)            p384_felem_opp(ftmp, p384_g_pre_comp[0][idx][1]);
      .                 } else {
    286 (0.0%)            p384_felem_copy(ftmp, p384_g_pre_comp[0][idx][1]);
      .                 }
      .                 // Add the point to the accumulator |res|.
      .                 // Note that the points in the pre-computed table are given with affine
      .                 // coordinates. The point addition function computes a sum of two points,
      .                 // either both given in projective, or one in projective and one in
      .                 // affine coordinates. The |mixed| flag indicates the latter option,
      .                 // in which case we set the third coordinate of the second point to one.
  1,166 (0.0%)          p384_point_add(res[0], res[1], res[2],
      .                                res[0], res[1], res[2],
      .                                1 /* mixed */,
    424 (0.0%)                         p384_g_pre_comp[0][idx][0], ftmp, p384_felem_one);
      .               }
      .             }
      .           }
      .         
      .           // Copy the result to the output.
      5 (0.0%)    p384_to_generic(&r->X, res[0]);
      7 (0.0%)    p384_to_generic(&r->Y, res[1]);
      7 (0.0%)    p384_to_generic(&r->Z, res[2]);
      6 (0.0%)  }
      .         
      .         DEFINE_METHOD_FUNCTION(EC_METHOD, EC_GFp_nistp384_method) {
      .           out->point_get_affine_coordinates =
      .               ec_GFp_nistp384_point_get_affine_coordinates;
      .           out->jacobian_to_affine_batch =
      .               ec_GFp_mont_jacobian_to_affine_batch;     // needed for TrustToken tests
      .           out->add = ec_GFp_nistp384_add;
      .           out->dbl = ec_GFp_nistp384_dbl;
-- line 956 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/wnaf.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 81 ----------------------------------------
    .         
    .         
    .         // This file implements the wNAF-based interleaving multi-exponentiation method
    .         // at:
    .         //   http://link.springer.com/chapter/10.1007%2F3-540-45537-X_13
    .         //   http://www.bmoeller.de/pdf/TI-01-08.multiexp.pdf
    .         
    .         void ec_compute_wNAF(const EC_GROUP *group, int8_t *out,
   18 (0.0%)                       const EC_SCALAR *scalar, size_t bits, int w) {
    .           // 'int8_t' can represent integers with absolute values less than 2^7.
    8 (0.0%)    assert(0 < w && w <= 7);
    4 (0.0%)    assert(bits != 0);
   12 (0.0%)    int bit = 1 << w;         // 2^w, at most 128
    6 (0.0%)    int next_bit = bit << 1;  // 2^(w+1), at most 256
    6 (0.0%)    int mask = next_bit - 1;  // at most 255
    .         
   12 (0.0%)    int window_val = scalar->words[0] & mask;
3,862 (0.0%)    for (size_t j = 0; j < bits + 1; j++) {
3,850 (0.0%)      assert(0 <= window_val && window_val <= next_bit);
  770 (0.0%)      int digit = 0;
3,080 (0.0%)      if (window_val & 1) {
  530 (0.0%)        assert(0 < window_val && window_val < next_bit);
  424 (0.0%)        if (window_val & bit) {
  192 (0.0%)          digit = window_val - next_bit;
    .                 // We know -next_bit < digit < 0 and window_val - digit = next_bit.
    .         
    .                 // modified wNAF
  448 (0.0%)          if (j + w + 1 >= bits) {
    .                   // special case for generating modified wNAFs:
    .                   // no new bits will be added into window_val,
    .                   // so using a positive digit here will decrease
    .                   // the total length of the representation
    .         
    .                   digit = window_val & (mask >> 1);
    .                   // We know 0 < digit < bit and window_val - digit = bit.
    .                 }
    .               } else {
   84 (0.0%)          digit = window_val;
    .                 // We know 0 < digit < bit and window_val - digit = 0.
    .               }
    .         
  212 (0.0%)        window_val -= digit;
    .         
    .               // Now window_val is 0 or 2^(w+1) in standard wNAF generation.
    .               // For modified window NAFs, it may also be 2^w.
    .               //
    .               // See the comments above for the derivation of each of these bounds.
  404 (0.0%)        assert(window_val == 0 || window_val == next_bit || window_val == bit);
  742 (0.0%)        assert(-bit < digit && digit < bit);
    .         
    .               // window_val was odd, so digit is also odd.
  424 (0.0%)        assert(digit & 1);
    .             }
    .         
3,850 (0.0%)      out[j] = digit;
    .         
    .             // Incorporate the next bit. Previously, |window_val| <= |next_bit|, so if
    .             // we shift and add at most one copy of |bit|, this will continue to hold
    .             // afterwards.
  770 (0.0%)      window_val >>= 1;
7,700 (0.1%)      window_val += bit * bn_is_bit_set_words(scalar->words, group->order.N.width,
3,080 (0.0%)                                              j + w + 1);
2,310 (0.0%)      assert(window_val <= next_bit);
    .           }
    .         
    .           // bits + 1 entries should be sufficient to consume all bits.
    4 (0.0%)    assert(window_val == 0);
    6 (0.0%)  }
    .         
    .         // compute_precomp sets |out[i]| to (2*i+1)*p, for i from 0 to |len|.
    .         static void compute_precomp(const EC_GROUP *group, EC_JACOBIAN *out,
    .                                     const EC_JACOBIAN *p, size_t len) {
    .           ec_GFp_simple_point_copy(&out[0], p);
    .           EC_JACOBIAN two_p;
    .           ec_GFp_mont_dbl(group, &two_p, p);
    .           for (size_t i = 1; i < len; i++) {
-- line 156 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/md4/../digest/md32_common.h
--------------------------------------------------------------------------------
Ir__________ 

-- line 94 ----------------------------------------
    .         // partial block. This function combines the partial block with |in| and
    .         // incorporates any complete blocks into the digest state |h|. It then updates
    .         // |data| and |*num| with the new partial block and updates |*Nh| and |*Nl| with
    .         // the data consumed.
    .         static inline void crypto_md32_update(crypto_md32_block_func block_func,
    .                                               uint32_t *h, uint8_t *data,
    .                                               size_t block_size, unsigned *num,
    .                                               uint32_t *Nh, uint32_t *Nl,
2,439 (0.0%)                                        const uint8_t *in, size_t len) {
  542 (0.0%)    if (len == 0) {
    .             return;
    .           }
    .         
1,626 (0.0%)    uint32_t l = *Nl + (((uint32_t)len) << 3);
1,084 (0.0%)    if (l < *Nl) {
    .             // Handle carries.
    .             (*Nh)++;
    .           }
1,897 (0.0%)    *Nh += (uint32_t)(len >> 29);
  813 (0.0%)    *Nl = l;
    .         
1,084 (0.0%)    size_t n = *num;
  542 (0.0%)    if (n != 0) {
  519 (0.0%)      if (len >= block_size || len + n >= block_size) {
  350 (0.0%)        OPENSSL_memcpy(data + n, in, block_size - n);
  245 (0.0%)        block_func(h, data, 1);
  105 (0.0%)        n = block_size - n;
   70 (0.0%)        in += n;
   70 (0.0%)        len -= n;
   70 (0.0%)        *num = 0;
    .               // Keep |data| zeroed when unused.
  210 (0.0%)        OPENSSL_memset(data, 0, block_size);
    .             } else {
  344 (0.0%)        OPENSSL_memcpy(data + n, in, len);
  258 (0.0%)        *num += (unsigned)len;
   43 (0.0%)        return;
    .             }
    .           }
    .         
  912 (0.0%)    n = len / block_size;
  456 (0.0%)    if (n > 0) {
  805 (0.0%)      block_func(h, in, n);
  345 (0.0%)      n *= block_size;
  230 (0.0%)      in += n;
  230 (0.0%)      len -= n;
    .           }
    .         
  456 (0.0%)    if (len != 0) {
  544 (0.0%)      *num = (unsigned)len;
  952 (0.0%)      OPENSSL_memcpy(data, in, len);
    .           }
  542 (0.0%)  }
    .         
    .         // crypto_md32_final incorporates the partial block and trailing length into the
    .         // digest state |h|. The trailing length is encoded in little-endian if
    .         // |is_big_endian| is zero and big-endian otherwise. |data| must be a buffer of
    .         // length |block_size| with the first |*num| bytes containing a partial block.
    .         // |Nh| and |Nl| contain the total number of bits processed. On return, this
    .         // function clears the partial block in |data| and
    .         // |*num|.
    .         //
    .         // This function does not serialize |h| into a final digest. This is the
    .         // responsibility of the caller.
    .         static inline void crypto_md32_final(crypto_md32_block_func block_func,
    .                                              uint32_t *h, uint8_t *data,
    .                                              size_t block_size, unsigned *num,
    .                                              uint32_t Nh, uint32_t Nl,
  954 (0.0%)                                       int is_big_endian) {
    .           // |data| always has room for at least one byte. A full block would have
    .           // been consumed.
  424 (0.0%)    size_t n = *num;
  318 (0.0%)    assert(n < block_size);
  424 (0.0%)    data[n] = 0x80;
  106 (0.0%)    n++;
    .         
    .           // Fill the block with zeros if there isn't room for a 64-bit length.
  424 (0.0%)    if (n > block_size - 8) {
   18 (0.0%)      OPENSSL_memset(data + n, 0, block_size - n);
    2 (0.0%)      n = 0;
   14 (0.0%)      block_func(h, data, 1);
    .           }
  954 (0.0%)    OPENSSL_memset(data + n, 0, block_size - 8 - n);
    .         
    .           // Append a 64-bit length to the block and process it.
  212 (0.0%)    if (is_big_endian) {
  848 (0.0%)      CRYPTO_store_u32_be(data + block_size - 8, Nh);
  954 (0.0%)      CRYPTO_store_u32_be(data + block_size - 4, Nl);
    .           } else {
    .             CRYPTO_store_u32_le(data + block_size - 8, Nl);
    .             CRYPTO_store_u32_le(data + block_size - 4, Nh);
    .           }
  742 (0.0%)    block_func(h, data, 1);
  212 (0.0%)    *num = 0;
  530 (0.0%)    OPENSSL_memset(data, 0, block_size);
  318 (0.0%)  }
    .         
    .         
    .         #if defined(__cplusplus)
    .         }  // extern C
    .         #endif
    .         
    .         #endif  // OPENSSL_HEADER_DIGEST_MD32_COMMON_H

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/sha/sha256.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 74 ----------------------------------------
    .           sha->h[4] = 0xffc00b31UL;
    .           sha->h[5] = 0x68581511UL;
    .           sha->h[6] = 0x64f98fa7UL;
    .           sha->h[7] = 0xbefa4fa4UL;
    .           sha->md_len = SHA224_DIGEST_LENGTH;
    .           return 1;
    .         }
    .         
  930 (0.0%)  int SHA256_Init(SHA256_CTX *sha) {
  930 (0.0%)    OPENSSL_memset(sha, 0, sizeof(SHA256_CTX));
  372 (0.0%)    sha->h[0] = 0x6a09e667UL;
  372 (0.0%)    sha->h[1] = 0xbb67ae85UL;
  372 (0.0%)    sha->h[2] = 0x3c6ef372UL;
  372 (0.0%)    sha->h[3] = 0xa54ff53aUL;
  372 (0.0%)    sha->h[4] = 0x510e527fUL;
  372 (0.0%)    sha->h[5] = 0x9b05688cUL;
  372 (0.0%)    sha->h[6] = 0x1f83d9abUL;
  372 (0.0%)    sha->h[7] = 0x5be0cd19UL;
  372 (0.0%)    sha->md_len = SHA256_DIGEST_LENGTH;
  186 (0.0%)    return 1;
  372 (0.0%)  }
    .         
    .         uint8_t *SHA224(const uint8_t *data, size_t len,
    .                         uint8_t out[SHA224_DIGEST_LENGTH]) {
    .           // We have to verify that all the SHA services actually succeed before
    .           // updating the indicator state, so we lock the state here.
    .           FIPS_service_indicator_lock_state();
    .           SHA256_CTX ctx;
    .           const int ok = SHA224_Init(&ctx) &&
-- line 102 ----------------------------------------
-- line 131 ----------------------------------------
    .         static void sha256_block_data_order(uint32_t *state, const uint8_t *in,
    .                                             size_t num);
    .         #endif
    .         
    .         void SHA256_Transform(SHA256_CTX *c, const uint8_t data[SHA256_CBLOCK]) {
    .           sha256_block_data_order(c->h, data, 1);
    .         }
    .         
1,701 (0.0%)  int SHA256_Update(SHA256_CTX *c, const void *data, size_t len) {
5,103 (0.0%)    crypto_md32_update(&sha256_block_data_order, c->h, c->data, SHA256_CBLOCK,
    .                              &c->num, &c->Nh, &c->Nl, data, len);
  243 (0.0%)    return 1;
  486 (0.0%)  }
    .         
   49 (0.0%)  int SHA224_Update(SHA256_CTX *ctx, const void *data, size_t len) {
   42 (0.0%)    return SHA256_Update(ctx, data, len);
   14 (0.0%)  }
    .         
  742 (0.0%)  static int sha256_final_impl(uint8_t *out, size_t md_len, SHA256_CTX *c) {
2,014 (0.0%)    crypto_md32_final(&sha256_block_data_order, c->h, c->data, SHA256_CBLOCK,
    .                             &c->num, c->Nh, c->Nl, /*is_big_endian=*/1);
  530 (0.0%)    if (c->md_len != md_len) {
    .             return 0;
    .           }
    .         
  424 (0.0%)    assert(md_len % 4 == 0);
  318 (0.0%)    const size_t out_words = md_len / 4;
3,922 (0.0%)    for (size_t i = 0; i < out_words; i++) {
5,936 (0.1%)      CRYPTO_store_u32_be(out, c->h[i]);
  848 (0.0%)      out += 4;
    .           }
  106 (0.0%)    FIPS_service_indicator_update_state();
  106 (0.0%)    return 1;
  212 (0.0%)  }
    .         
  636 (0.0%)  int SHA256_Final(uint8_t out[SHA256_DIGEST_LENGTH], SHA256_CTX *c) {
  530 (0.0%)    return sha256_final_impl(out, SHA256_DIGEST_LENGTH, c);
  212 (0.0%)  }
    .         
    .         int SHA224_Final(uint8_t out[SHA224_DIGEST_LENGTH], SHA256_CTX *ctx) {
    .           return sha256_final_impl(out, SHA224_DIGEST_LENGTH, ctx);
    .         }
    .         
    .         #ifndef SHA256_ASM
    .         static const uint32_t K256[64] = {
    .             0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL, 0x3956c25bUL,
-- line 176 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 77 ----------------------------------------
    .         #define OPENSSL_MALLOC_PREFIX 8
    .         OPENSSL_STATIC_ASSERT(OPENSSL_MALLOC_PREFIX >= sizeof(size_t),
    .                               size_t_too_large)
    .         
    .         #if defined(OPENSSL_ASAN)
    .         void __asan_poison_memory_region(const volatile void *addr, size_t size);
    .         void __asan_unpoison_memory_region(const volatile void *addr, size_t size);
    .         #else
3,000 (0.0%)  static void __asan_poison_memory_region(const void *addr, size_t size) {}
1,808 (0.0%)  static void __asan_unpoison_memory_region(const void *addr, size_t size) {}
    .         #endif
    .         
    .         // Windows doesn't really support weak symbols as of May 2019, and Clang on
    .         // Windows will emit strong symbols instead. See
    .         // https://bugs.llvm.org/show_bug.cgi?id=37598
    .         #if defined(__ELF__) && defined(__GNUC__)
    .         #define WEAK_SYMBOL_FUNC(rettype, name, args) \
    .           rettype name args __attribute__((weak));
-- line 94 ----------------------------------------
-- line 157 ----------------------------------------
    .             return 0;
    .           }
    .           malloc_impl = m;
    .           realloc_impl = r;
    .           free_impl = f;
    .           return 1;
    .         }
    .         
1,815 (0.0%)  void *OPENSSL_malloc(size_t size) {
1,089 (0.0%)    if (malloc_impl != NULL) {
    .             assert(OPENSSL_memory_alloc == NULL);
    .             assert(OPENSSL_memory_realloc == NULL);
    .             assert(OPENSSL_memory_free == NULL);
    .             assert(OPENSSL_memory_get_size == NULL);
    .             assert(realloc_impl != NULL);
    .             assert(free_impl != NULL);
    .             return malloc_impl(size, AWSLC_FILE, AWSLC_LINE);
    .           }
1,089 (0.0%)    if (OPENSSL_memory_alloc != NULL) {
    .             assert(OPENSSL_memory_free != NULL);
    .             assert(OPENSSL_memory_get_size != NULL);
    .             void *ptr = OPENSSL_memory_alloc(size);
    .             if (ptr == NULL && size != 0) {
    .               goto err;
    .             }
    .             return ptr;
    .           }
    .         
  726 (0.0%)    if (size + OPENSSL_MALLOC_PREFIX < size) {
    .             goto err;
    .           }
    .         
1,815 (0.0%)    void *ptr = malloc(size + OPENSSL_MALLOC_PREFIX);
  726 (0.0%)    if (ptr == NULL) {
    .             goto err;
    .           }
    .         
1,089 (0.0%)    *(size_t *)ptr = size;
    .         
1,452 (0.0%)    __asan_poison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
1,089 (0.0%)    return ((uint8_t *)ptr) + OPENSSL_MALLOC_PREFIX;
    .         
    .          err:
    .           // This only works because ERR does not call OPENSSL_malloc.
    .           OPENSSL_PUT_ERROR(CRYPTO, ERR_R_MALLOC_FAILURE);
    .           return NULL;
  726 (0.0%)  }
    .         
1,235 (0.0%)  void *OPENSSL_zalloc(size_t size) {
  988 (0.0%)    void *ret = OPENSSL_malloc(size);
  494 (0.0%)    if (ret != NULL) {
1,235 (0.0%)      OPENSSL_memset(ret, 0, size);
    .           }
  247 (0.0%)    return ret;
  494 (0.0%)  }
    .         
  270 (0.0%)  void *OPENSSL_calloc(size_t num, size_t size) {
  405 (0.0%)    if (size != 0 && num > SIZE_MAX / size) {
    .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
    .             return NULL;
    .           }
    .         
  180 (0.0%)    return OPENSSL_zalloc(num * size);
   90 (0.0%)  }
    .         
1,330 (0.0%)  void OPENSSL_free(void *orig_ptr) {
  532 (0.0%)    if (orig_ptr == NULL) {
   52 (0.0%)      return;
    .           }
  642 (0.0%)    if (free_impl != NULL) {
    .             assert(OPENSSL_memory_alloc == NULL);
    .             assert(OPENSSL_memory_realloc == NULL);
    .             assert(OPENSSL_memory_free == NULL);
    .             assert(OPENSSL_memory_get_size == NULL);
    .             assert(malloc_impl != NULL);
    .             assert(realloc_impl != NULL);
    .             free_impl(orig_ptr, AWSLC_FILE, AWSLC_LINE);
    .             return;
    .           }
    .         
  642 (0.0%)    if (OPENSSL_memory_free != NULL) {
    .             OPENSSL_memory_free(orig_ptr);
    .             return;
    .           }
    .         
  642 (0.0%)    void *ptr = ((uint8_t *)orig_ptr) - OPENSSL_MALLOC_PREFIX;
  856 (0.0%)    __asan_unpoison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
    .         
  642 (0.0%)    size_t size = *(size_t *)ptr;
1,284 (0.0%)    OPENSSL_cleanse(ptr, size + OPENSSL_MALLOC_PREFIX);
    .         
    .         // ASan knows to intercept malloc and free, but not sdallocx.
    .         #if defined(OPENSSL_ASAN)
    .           (void)sdallocx;
    .           free(ptr);
    .           (void) sdallocx;
    .         #else
  642 (0.0%)    if (sdallocx) {
    .             sdallocx(ptr, size + OPENSSL_MALLOC_PREFIX, 0 /* flags */);
    .           } else {
  856 (0.0%)      free(ptr);
    .           }
    .         #endif
  532 (0.0%)  }
    .         
   84 (0.0%)  void *OPENSSL_realloc(void *orig_ptr, size_t new_size) {
   28 (0.0%)    if (orig_ptr == NULL) {
    8 (0.0%)      return OPENSSL_malloc(new_size);
    .           }
   36 (0.0%)    if (realloc_impl != NULL) {
    .             assert(OPENSSL_memory_alloc == NULL);
    .             assert(OPENSSL_memory_realloc == NULL);
    .             assert(OPENSSL_memory_free == NULL);
    .             assert(OPENSSL_memory_get_size == NULL);
    .             assert(malloc_impl != NULL);
    .             assert(free_impl != NULL);
    .             return realloc_impl(orig_ptr, new_size, AWSLC_FILE, AWSLC_LINE);
    .           }
   36 (0.0%)    if (OPENSSL_memory_realloc != NULL) {
    .             assert(OPENSSL_memory_alloc != NULL);
    .             assert(OPENSSL_memory_free != NULL);
    .             assert(OPENSSL_memory_get_size != NULL);
    .             return OPENSSL_memory_realloc(orig_ptr, new_size);
    .           }
    .           size_t old_size;
   36 (0.0%)    if (OPENSSL_memory_get_size != NULL) {
    .             old_size = OPENSSL_memory_get_size(orig_ptr);
    .           } else {
   36 (0.0%)      void *ptr = ((uint8_t *)orig_ptr) - OPENSSL_MALLOC_PREFIX;
   48 (0.0%)      __asan_unpoison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
   36 (0.0%)      old_size = *(size_t *)ptr;
   48 (0.0%)      __asan_poison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
    .           }
    .         
   48 (0.0%)    void *ret = OPENSSL_malloc(new_size);
   24 (0.0%)    if (ret == NULL) {
    .             return NULL;
    .           }
    .         
   24 (0.0%)    size_t to_copy = new_size;
   36 (0.0%)    if (old_size < to_copy) {
   24 (0.0%)      to_copy = old_size;
    .           }
    .         
   72 (0.0%)    memcpy(ret, orig_ptr, to_copy);
   36 (0.0%)    OPENSSL_free(orig_ptr);
    .         
   12 (0.0%)    return ret;
   28 (0.0%)  }
    .         
1,422 (0.0%)  void OPENSSL_cleanse(void *ptr, size_t len) {
    .         #if defined(OPENSSL_WINDOWS)
    .           SecureZeroMemory(ptr, len);
    .         #else
1,185 (0.0%)    OPENSSL_memset(ptr, 0, len);
    .         
    .         #if !defined(OPENSSL_NO_ASM)
    .           /* As best as we can tell, this is sufficient to break any optimisations that
    .              might try to eliminate "superfluous" memsets. If there's an easy way to
    .              detect memset_s, it would be better to use that. */
  237 (0.0%)    __asm__ __volatile__("" : : "r"(ptr) : "memory");
    .         #endif
    .         #endif  // !OPENSSL_NO_ASM
  711 (0.0%)  }
    .         
    .         void OPENSSL_clear_free(void *ptr, size_t unused) { OPENSSL_free(ptr); }
    .         
    .         int CRYPTO_secure_malloc_init(size_t size, size_t min_size) { return 0; }
    .         
    .         int CRYPTO_secure_malloc_initialized(void) { return 0; }
    .         
    .         size_t CRYPTO_secure_used(void) { return 0; }
-- line 328 ----------------------------------------
-- line 330 ----------------------------------------
    .         void *OPENSSL_secure_malloc(size_t size) { return OPENSSL_malloc(size); }
    .         
    .         void *OPENSSL_secure_zalloc(size_t size) { return OPENSSL_zalloc(size); }
    .         
    .         void OPENSSL_secure_clear_free(void *ptr, size_t len) {
    .           OPENSSL_clear_free(ptr, len);
    .         }
    .         
   72 (0.0%)  int CRYPTO_memcmp(const void *in_a, const void *in_b, size_t len) {
   24 (0.0%)    const uint8_t *a = in_a;
   24 (0.0%)    const uint8_t *b = in_b;
   12 (0.0%)    uint8_t x = 0;
    .         
1,124 (0.0%)    for (size_t i = 0; i < len; i++) {
2,660 (0.0%)      x |= a[i] ^ b[i];
    .           }
    .         
   12 (0.0%)    return x;
   24 (0.0%)  }
    .         
    .         uint32_t OPENSSL_hash32(const void *ptr, size_t len) {
    .           // These are the FNV-1a parameters for 32 bits.
    .           static const uint32_t kPrime = 16777619u;
    .           static const uint32_t kOffsetBasis = 2166136261u;
    .         
    .           const uint8_t *in = ptr;
    .           uint32_t h = kOffsetBasis;
-- line 356 ----------------------------------------
-- line 387 ----------------------------------------
    .           OPENSSL_memcpy(ret, s, len);
    .           return ret;
    .         }
    .         
    .         int OPENSSL_isalpha(int c) {
    .           return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
    .         }
    .         
  936 (0.0%)  int OPENSSL_isdigit(int c) { return c >= '0' && c <= '9'; }
    .         
    .         int OPENSSL_isxdigit(int c) {
    .           return OPENSSL_isdigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
    .         }
    .         
    .         int OPENSSL_fromxdigit(uint8_t *out, int c) {
    .           if (OPENSSL_isdigit(c)) {
    .             *out = c - '0';
-- line 403 ----------------------------------------
-- line 411 ----------------------------------------
    .             *out = c - 'A' + 10;
    .             return 1;
    .           }
    .           return 0;
    .         }
    .         
    .         int OPENSSL_isalnum(int c) { return OPENSSL_isalpha(c) || OPENSSL_isdigit(c); }
    .         
  232 (0.0%)  int OPENSSL_tolower(int c) {
  228 (0.0%)    if (c >= 'A' && c <= 'Z') {
   36 (0.0%)      return c + ('a' - 'A');
    .           }
   46 (0.0%)    return c;
  116 (0.0%)  }
    .         
  328 (0.0%)  int OPENSSL_isspace(int c) {
1,066 (0.0%)    return c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r' ||
    .                  c == ' ';
  164 (0.0%)  }
    .         
    .         int OPENSSL_strcasecmp(const char *a, const char *b) {
    .           for (size_t i = 0;; i++) {
    .             const int aa = OPENSSL_tolower(a[i]);
    .             const int bb = OPENSSL_tolower(b[i]);
    .         
    .             if (aa < bb) {
    .               return -1;
-- line 437 ----------------------------------------
-- line 565 ----------------------------------------
    .         size_t OPENSSL_strlcat(char *dst, const char *src, size_t dst_size) {
    .           size_t l = 0;
    .           for (; dst_size > 0 && *dst; dst_size--, dst++) {
    .             l++;
    .           }
    .           return l + OPENSSL_strlcpy(dst, src, dst_size);
    .         }
    .         
  222 (0.0%)  void *OPENSSL_memdup(const void *data, size_t size) {
   74 (0.0%)    if (size == 0) {
    .             return NULL;
    .           }
    .         
  148 (0.0%)    void *ret = OPENSSL_malloc(size);
   74 (0.0%)    if (ret == NULL) {
    .             return NULL;
    .           }
    .         
  222 (0.0%)    OPENSSL_memcpy(ret, data, size);
   37 (0.0%)    return ret;
   74 (0.0%)  }
    .         
    .         void *CRYPTO_malloc(size_t size, const char *file, int line) {
    .           return OPENSSL_malloc(size);
    .         }
    .         
    .         void *CRYPTO_realloc(void *ptr, size_t new_size, const char *file, int line) {
    .           return OPENSSL_realloc(ptr, new_size);
    .         }
-- line 593 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 97 ----------------------------------------
    .         
    .           CRYPTO_STATIC_MUTEX_lock_write(&global_next_nid_lock);
    .           ret = global_next_nid++;
    .           CRYPTO_STATIC_MUTEX_unlock_write(&global_next_nid_lock);
    .         
    .           return ret;
    .         }
    .         
  160 (0.0%)  ASN1_OBJECT *OBJ_dup(const ASN1_OBJECT *o) {
    .           ASN1_OBJECT *r;
   32 (0.0%)    unsigned char *data = NULL;
   64 (0.0%)    char *sn = NULL, *ln = NULL;
    .         
   64 (0.0%)    if (o == NULL) {
    .             return NULL;
    .           }
    .         
  160 (0.0%)    if (!(o->flags & ASN1_OBJECT_FLAG_DYNAMIC)) {
    .             // TODO(fork): this is a little dangerous.
    .             return (ASN1_OBJECT *)o;
    .           }
    .         
   64 (0.0%)    r = ASN1_OBJECT_new();
   64 (0.0%)    if (r == NULL) {
    .             OPENSSL_PUT_ERROR(OBJ, ERR_R_ASN1_LIB);
    .             return NULL;
    .           }
  192 (0.0%)    r->ln = r->sn = NULL;
    .         
    .           // once data is attached to an object, it remains const
  320 (0.0%)    r->data = OPENSSL_memdup(o->data, o->length);
  256 (0.0%)    if (o->length != 0 && r->data == NULL) {
    .             goto err;
    .           }
    .         
  128 (0.0%)    r->length = o->length;
  128 (0.0%)    r->nid = o->nid;
    .         
  128 (0.0%)    if (o->ln != NULL) {
    .             ln = OPENSSL_strdup(o->ln);
    .             if (ln == NULL) {
    .               goto err;
    .             }
    .           }
    .         
  128 (0.0%)    if (o->sn != NULL) {
    .             sn = OPENSSL_strdup(o->sn);
    .             if (sn == NULL) {
    .               goto err;
    .             }
    .           }
    .         
   96 (0.0%)    r->sn = sn;
   96 (0.0%)    r->ln = ln;
    .         
   64 (0.0%)    r->flags =
  128 (0.0%)        o->flags | (ASN1_OBJECT_FLAG_DYNAMIC | ASN1_OBJECT_FLAG_DYNAMIC_STRINGS |
    .                           ASN1_OBJECT_FLAG_DYNAMIC_DATA);
   64 (0.0%)    return r;
    .         
    .         err:
    .           OPENSSL_free(ln);
    .           OPENSSL_free(sn);
    .           OPENSSL_free(data);
    .           OPENSSL_free(r);
    .           return NULL;
   64 (0.0%)  }
    .         
5,082 (0.0%)  int OBJ_cmp(const ASN1_OBJECT *a, const ASN1_OBJECT *b) {
5,082 (0.0%)    if (a->length < b->length) {
  530 (0.0%)      return -1;
3,492 (0.0%)    } else if (a->length > b->length) {
    .             return 1;
    .           }
5,820 (0.1%)    return OPENSSL_memcmp(a->data, b->data, a->length);
1,694 (0.0%)  }
    .         
    .         const uint8_t *OBJ_get0_data(const ASN1_OBJECT *obj) {
    .           if (obj == NULL) {
    .             return NULL;
    .           }
    .         
    .           return obj->data;
    .         }
-- line 180 ----------------------------------------
-- line 182 ----------------------------------------
    .         size_t OBJ_length(const ASN1_OBJECT *obj) {
    .           if (obj == NULL || obj->length < 0) {
    .             return 0;
    .           }
    .         
    .           return (size_t)obj->length;
    .         }
    .         
4,690 (0.0%)  static const ASN1_OBJECT *get_builtin_object(int nid) {
    .           // |NID_undef| is stored separately, so all the indices are off by one. The
    .           // caller of this function must have a valid built-in, non-undef NID.
3,752 (0.0%)    BSSL_CHECK(nid > 0 && nid < NUM_NID);
8,442 (0.1%)    return &kObjects[nid - 1];
1,876 (0.0%)  }
    .         
    .         // obj_cmp is called to search the kNIDsInOIDOrder array. The |key| argument is
    .         // an |ASN1_OBJECT|* that we're looking for and |element| is a pointer to an
    .         // unsigned int in the array.
5,082 (0.0%)  static int obj_cmp(const void *key, const void *element) {
2,541 (0.0%)    uint16_t nid = *((const uint16_t *)element);
6,776 (0.1%)    return OBJ_cmp(key, get_builtin_object(nid));
1,694 (0.0%)  }
    .         
  455 (0.0%)  int OBJ_obj2nid(const ASN1_OBJECT *obj) {
  182 (0.0%)    if (obj == NULL) {
    .             return NID_undef;
    .           }
    .         
  364 (0.0%)    if (obj->nid != 0) {
    .             return obj->nid;
    .           }
    .         
  273 (0.0%)    CRYPTO_STATIC_MUTEX_lock_read(&global_added_lock);
  273 (0.0%)    if (global_added_by_data != NULL) {
    .             ASN1_OBJECT *match;
    .         
    .             match = lh_ASN1_OBJECT_retrieve(global_added_by_data, obj);
    .             if (match != NULL) {
    .               CRYPTO_STATIC_MUTEX_unlock_read(&global_added_lock);
    .               return match->nid;
    .             }
    .           }
  273 (0.0%)    CRYPTO_STATIC_MUTEX_unlock_read(&global_added_lock);
    .         
    .           const uint16_t *nid_ptr =
  728 (0.0%)        bsearch(obj, kNIDsInOIDOrder, OPENSSL_ARRAY_SIZE(kNIDsInOIDOrder),
    .                       sizeof(kNIDsInOIDOrder[0]), obj_cmp);
  182 (0.0%)    if (nid_ptr == NULL) {
    .             return NID_undef;
    .           }
    .         
  546 (0.0%)    return get_builtin_object(*nid_ptr)->nid;
  182 (0.0%)  }
    .         
    .         int OBJ_cbs2nid(const CBS *cbs) {
    .           if (CBS_len(cbs) > INT_MAX) {
    .             return NID_undef;
    .           }
    .         
    .           ASN1_OBJECT obj;
    .           OPENSSL_memset(&obj, 0, sizeof(obj));
-- line 242 ----------------------------------------
-- line 334 ----------------------------------------
    .               !CBB_add_bytes(&oid, obj->data, obj->length) ||
    .               !CBB_flush(out)) {
    .             return 0;
    .           }
    .         
    .           return 1;
    .         }
    .         
   93 (0.0%)  const ASN1_OBJECT *OBJ_get_undef(void) {
    .           static const ASN1_OBJECT kUndef = {
    .               /*sn=*/SN_undef,
    .               /*ln=*/LN_undef,
    .               /*nid=*/NID_undef,
    .               /*length=*/0,
    .               /*data=*/NULL,
    .               /*flags=*/0,
    .           };
   31 (0.0%)    return &kUndef;
   62 (0.0%)  }
    .         
    .         ASN1_OBJECT *OBJ_nid2obj(int nid) {
    .           if (nid == NID_undef) {
    .             return (ASN1_OBJECT *)OBJ_get_undef();
    .           }
    .         
    .           if (nid > 0 && nid < NUM_NID) {
    .             const ASN1_OBJECT *obj = get_builtin_object(nid);
-- line 360 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 69 ----------------------------------------
    .         #include "../internal.h"
    .         #include "internal.h"
    .         
    .         
    .         int X509_issuer_name_cmp(const X509 *a, const X509 *b) {
    .           return (X509_NAME_cmp(a->cert_info->issuer, b->cert_info->issuer));
    .         }
    .         
3,114 (0.0%)  int X509_subject_name_cmp(const X509 *a, const X509 *b) {
4,671 (0.0%)    return (X509_NAME_cmp(a->cert_info->subject, b->cert_info->subject));
1,038 (0.0%)  }
    .         
    .         int X509_CRL_cmp(const X509_CRL *a, const X509_CRL *b) {
    .           return (X509_NAME_cmp(a->crl->issuer, b->crl->issuer));
    .         }
    .         
    .         int X509_CRL_match(const X509_CRL *a, const X509_CRL *b) {
    .           return OPENSSL_memcmp(a->crl_hash, b->crl_hash, SHA256_DIGEST_LENGTH);
    .         }
    .         
   28 (0.0%)  X509_NAME *X509_get_issuer_name(const X509 *a) {
   21 (0.0%)    return a->cert_info->issuer;
   14 (0.0%)  }
    .         
    .         uint32_t X509_issuer_name_hash(X509 *x) {
    .           return X509_NAME_hash(x->cert_info->issuer);
    .         }
    .         
    .         uint32_t X509_issuer_name_hash_old(X509 *x) {
    .           return (X509_NAME_hash_old(x->cert_info->issuer));
    .         }
    .         
   24 (0.0%)  X509_NAME *X509_get_subject_name(const X509 *a) {
   18 (0.0%)    return a->cert_info->subject;
   12 (0.0%)  }
    .         
    .         ASN1_INTEGER *X509_get_serialNumber(X509 *a) {
    .           return a->cert_info->serialNumber;
    .         }
    .         
    .         const ASN1_INTEGER *X509_get0_serialNumber(const X509 *x509) {
    .           return x509->cert_info->serialNumber;
    .         }
-- line 111 ----------------------------------------
-- line 119 ----------------------------------------
    .         }
    .         
    .         // Compare two certificates: they must be identical for this to work. NB:
    .         // Although "cmp" operations are generally prototyped to take "const"
    .         // arguments (eg. for use in STACKs), the way X509 handling is - these
    .         // operations may involve ensuring the hashes are up-to-date and ensuring
    .         // certain cert information is cached. So this is the point where the
    .         // "depth-first" constification tree has to halt with an evil cast.
    6 (0.0%)  int X509_cmp(const X509 *a, const X509 *b) {
    .           // Fill in the |cert_hash| fields.
    .           //
    .           // TODO(davidben): This may fail, in which case the the hash will be all
    .           // zeros. This produces a consistent comparison (failures are sticky), but
    .           // not a good one. OpenSSL now returns -2, but this is not a consistent
    .           // comparison and may cause misbehaving sorts by transitivity. For now, we
    .           // retain the old OpenSSL behavior, which was to ignore the error. See
    .           // https://crbug.com/boringssl/355.
    3 (0.0%)    x509v3_cache_extensions((X509 *)a);
    3 (0.0%)    x509v3_cache_extensions((X509 *)b);
    .         
    8 (0.0%)    return OPENSSL_memcmp(a->cert_hash, b->cert_hash, SHA256_DIGEST_LENGTH);
    2 (0.0%)  }
    .         
3,150 (0.0%)  int X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b) {
    .           int ret;
    .         
    .           // Ensure canonical encoding is present and up to date
    .         
4,200 (0.0%)    if (!a->canon_enc || a->modified) {
    .             ret = i2d_X509_NAME((X509_NAME *)a, NULL);
    .             if (ret < 0) {
    .               return -2;
    .             }
    .           }
    .         
4,200 (0.0%)    if (!b->canon_enc || b->modified) {
    .             ret = i2d_X509_NAME((X509_NAME *)b, NULL);
    .             if (ret < 0) {
    .               return -2;
    .             }
    .           }
    .         
3,150 (0.0%)    ret = a->canon_enclen - b->canon_enclen;
    .         
1,050 (0.0%)    if (ret) {
  810 (0.0%)      return ret;
    .           }
    .         
1,200 (0.0%)    return OPENSSL_memcmp(a->canon_enc, b->canon_enc, a->canon_enclen);
1,050 (0.0%)  }
    .         
    .         uint32_t X509_NAME_hash(X509_NAME *x) {
    .           // Make sure the X509_NAME structure contains a valid cached encoding.
    .           if (i2d_X509_NAME(x, NULL) < 0) {
    .             return 0;
    .           }
    .         
    .           uint8_t md[SHA_DIGEST_LENGTH];
-- line 176 ----------------------------------------
-- line 220 ----------------------------------------
    .         
    .         EVP_PKEY *X509_get0_pubkey(const X509 *x) {
    .           if (x == NULL) {
    .             return NULL;
    .           }
    .           return X509_PUBKEY_get0(x->cert_info->key);
    .         }
    .         
   15 (0.0%)  EVP_PKEY *X509_get_pubkey(const X509 *x) {
    6 (0.0%)    if (x == NULL) {
    .             return NULL;
    .           }
   15 (0.0%)    return X509_PUBKEY_get(x->cert_info->key);
    6 (0.0%)  }
    .         
    .         ASN1_BIT_STRING *X509_get0_pubkey_bitstr(const X509 *x) {
    .           if (!x) {
    .             return NULL;
    .           }
    .           return x->cert_info->key->public_key;
    .         }
    .         
-- line 241 ----------------------------------------
-- line 263 ----------------------------------------
    .           }
    .         
    .           return 0;
    .         }
    .         
    .         // Not strictly speaking an "up_ref" as a STACK doesn't have a reference
    .         // count but it has the same effect by duping the STACK and upping the ref of
    .         // each X509 structure.
    5 (0.0%)  STACK_OF(X509) *X509_chain_up_ref(STACK_OF(X509) *chain) {
    4 (0.0%)    STACK_OF(X509) *ret = sk_X509_dup(chain);
    2 (0.0%)    if (ret == NULL) {
    .             return NULL;
    .           }
   13 (0.0%)    for (size_t i = 0; i < sk_X509_num(ret); i++) {
    7 (0.0%)      X509_up_ref(sk_X509_value(ret, i));
    .           }
    1 (0.0%)    return ret;
    2 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 123 ----------------------------------------
    .           }
    .           // Note |get_by_subject| leaves |ret| in an inconsistent state. It has
    .           // pointers to an |X509| or |X509_CRL|, but has not bumped the refcount yet.
    .           // For now, the caller is expected to fix this, but ideally we'd fix the
    .           // |X509_LOOKUP| convention itself.
    .           return ctx->method->get_by_subject(ctx, type, name, ret) > 0;
    .         }
    .         
3,114 (0.0%)  static int x509_object_cmp(const X509_OBJECT *a, const X509_OBJECT *b) {
3,114 (0.0%)    int ret = a->type - b->type;
1,038 (0.0%)    if (ret) {
    .             return ret;
    .           }
2,076 (0.0%)    switch (a->type) {
    .             case X509_LU_X509:
4,152 (0.0%)        return X509_subject_name_cmp(a->data.x509, b->data.x509);
    .             case X509_LU_CRL:
    .               return X509_CRL_cmp(a->data.crl, b->data.crl);
    .             default:
    .               // abort();
    .               return 0;
    .           }
1,038 (0.0%)  }
    .         
    .         static int x509_object_cmp_sk(const X509_OBJECT *const *a,
3,114 (0.0%)                                const X509_OBJECT *const *b) {
3,633 (0.0%)    return x509_object_cmp(*a, *b);
1,038 (0.0%)  }
    .         
    .         static CRYPTO_EX_DATA_CLASS g_ex_data_class =
    .             CRYPTO_EX_DATA_CLASS_INIT_WITH_APP_DATA;
    .         
    .         X509_STORE *X509_STORE_new(void) {
    .           X509_STORE *ret = OPENSSL_zalloc(sizeof(X509_STORE));
    .           if (ret == NULL) {
    .             return NULL;
-- line 158 ----------------------------------------
-- line 226 ----------------------------------------
    .             X509_LOOKUP_free(lu);
    .             return NULL;
    .           }
    .         
    .           return lu;
    .         }
    .         
    .         int X509_STORE_CTX_get_by_subject(X509_STORE_CTX *vs, int type, X509_NAME *name,
   11 (0.0%)                                    X509_OBJECT *ret) {
    3 (0.0%)    X509_STORE *ctx = vs->ctx;
    .           X509_OBJECT stmp;
    4 (0.0%)    CRYPTO_MUTEX_lock_write(&ctx->objs_lock);
    8 (0.0%)    X509_OBJECT *tmp = X509_OBJECT_retrieve_by_subject(ctx->objs, type, name);
    4 (0.0%)    CRYPTO_MUTEX_unlock_write(&ctx->objs_lock);
    .         
    4 (0.0%)    if (tmp == NULL || type == X509_LU_CRL) {
    .             for (size_t i = 0; i < sk_X509_LOOKUP_num(ctx->get_cert_methods); i++) {
    .               X509_LOOKUP *lu = sk_X509_LOOKUP_value(ctx->get_cert_methods, i);
    .               if (X509_LOOKUP_by_subject(lu, type, name, &stmp)) {
    .                 tmp = &stmp;
    .                 break;
    .               }
    .             }
    .             if (tmp == NULL) {
    .               return 0;
    .             }
    .           }
    .         
    .           // if (ret->data.ptr != NULL) X509_OBJECT_free_contents(ret);
    .         
    4 (0.0%)    ret->type = tmp->type;
    4 (0.0%)    ret->data.ptr = tmp->data.ptr;
    .         
    3 (0.0%)    X509_OBJECT_up_ref_count(ret);
    .         
    1 (0.0%)    return 1;
    5 (0.0%)  }
    .         
    .         static int x509_store_add(X509_STORE *ctx, void *x, int is_crl) {
    .           if (x == NULL) {
    .             return 0;
    .           }
    .         
    .           X509_OBJECT *const obj = X509_OBJECT_new();
    .           if (obj == NULL) {
-- line 270 ----------------------------------------
-- line 313 ----------------------------------------
    .         void X509_OBJECT_free(X509_OBJECT *obj) {
    .           if (obj == NULL) {
    .             return;
    .           }
    .           X509_OBJECT_free_contents(obj);
    .           OPENSSL_free(obj);
    .         }
    .         
    5 (0.0%)  static int X509_OBJECT_up_ref_count(X509_OBJECT *a) {
    4 (0.0%)    switch (a->type) {
    .             case X509_LU_X509:
    4 (0.0%)        X509_up_ref(a->data.x509);
    1 (0.0%)        break;
    .             case X509_LU_CRL:
    .               X509_CRL_up_ref(a->data.crl);
    .               break;
    .           }
    1 (0.0%)    return 1;
    2 (0.0%)  }
    .         
    .         void X509_OBJECT_free_contents(X509_OBJECT *a) {
    .           switch (a->type) {
    .             case X509_LU_X509:
    .               X509_free(a->data.x509);
    .               break;
    .             case X509_LU_CRL:
    .               X509_CRL_free(a->data.crl);
-- line 339 ----------------------------------------
-- line 377 ----------------------------------------
    .         
    .             X509_OBJECT_free_contents(a);
    .             a->type = X509_LU_CRL;
    .             a->data.crl = obj;
    .             return 1;
    .         }
    .         
    .         static int x509_object_idx_cnt(STACK_OF(X509_OBJECT) *h, int type,
   11 (0.0%)                                 X509_NAME *name, int *pnmatch) {
    .           X509_OBJECT stmp;
    .           X509 x509_s;
    .           X509_CINF cinf_s;
    .           X509_CRL crl_s;
    .           X509_CRL_INFO crl_info_s;
    .         
    2 (0.0%)    stmp.type = type;
    2 (0.0%)    switch (type) {
    .             case X509_LU_X509:
    2 (0.0%)        stmp.data.x509 = &x509_s;
    2 (0.0%)        x509_s.cert_info = &cinf_s;
    2 (0.0%)        cinf_s.subject = name;
    1 (0.0%)        break;
    .             case X509_LU_CRL:
    .               stmp.data.crl = &crl_s;
    .               crl_s.crl = &crl_info_s;
    .               crl_info_s.issuer = name;
    .               break;
    .             default:
    .               // abort();
    .               return -1;
    .           }
    .         
    .           size_t idx;
    3 (0.0%)    sk_X509_OBJECT_sort(h);
    8 (0.0%)    if (!sk_X509_OBJECT_find_awslc(h, &idx, &stmp)) {
    .             return -1;
    .           }
    .         
    2 (0.0%)    if (pnmatch != NULL) {
    .             *pnmatch = 1;
    .             for (size_t tidx = idx + 1; tidx < sk_X509_OBJECT_num(h); tidx++) {
    .               const X509_OBJECT *tobj = sk_X509_OBJECT_value(h, tidx);
    .               if (x509_object_cmp(tobj, &stmp)) {
    .                 break;
    .               }
    .               (*pnmatch)++;
    .             }
    .           }
    .         
    1 (0.0%)    return (int)idx;
    5 (0.0%)  }
    .         
    .         static int X509_OBJECT_idx_by_subject(STACK_OF(X509_OBJECT) *h, int type,
    7 (0.0%)                                        X509_NAME *name) {
    6 (0.0%)    return x509_object_idx_cnt(h, type, name, NULL);
    2 (0.0%)  }
    .         
    .         X509_OBJECT *X509_OBJECT_retrieve_by_subject(STACK_OF(X509_OBJECT) *h,
    7 (0.0%)                                                      int type, X509_NAME *name) {
    .           int idx;
    7 (0.0%)    idx = X509_OBJECT_idx_by_subject(h, type, name);
    2 (0.0%)    if (idx == -1) {
    .             return NULL;
    .           }
    6 (0.0%)    return sk_X509_OBJECT_value(h, idx);
    2 (0.0%)  }
    .         
    .         STACK_OF(X509_OBJECT) *X509_STORE_get0_objects(X509_STORE *st) {
    .           return st->objs;
    .         }
    .         
    .         STACK_OF(X509) *X509_STORE_CTX_get1_certs(X509_STORE_CTX *ctx, X509_NAME *nm) {
    .           int cnt;
    .           STACK_OF(X509) *sk = sk_X509_new_null();
-- line 450 ----------------------------------------
-- line 553 ----------------------------------------
    .           return NULL;
    .         }
    .         
    .         // Try to get issuer certificate from store. Due to limitations of the API
    .         // this can only retrieve a single certificate matching a given subject name.
    .         // However it will fill the cache with all matching certificates, so we can
    .         // examine the cache for all matches. Return values are: 1 lookup
    .         // successful.  0 certificate not found. -1 some other error.
   10 (0.0%)  int X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x) {
    .           X509_NAME *xn;
    .           X509_OBJECT obj, *pobj;
    .           int idx, ret;
    .           size_t i;
    2 (0.0%)    *issuer = NULL;
    4 (0.0%)    xn = X509_get_issuer_name(x);
    8 (0.0%)    if (!X509_STORE_CTX_get_by_subject(ctx, X509_LU_X509, xn, &obj)) {
    .             return 0;
    .           }
    .           // If certificate matches all OK
    8 (0.0%)    if (x509_check_issued_with_callback(ctx, x, obj.data.x509)) {
    8 (0.0%)      if (x509_check_cert_time(ctx, obj.data.x509, /*suppress_error*/1)) {
    3 (0.0%)        *issuer = obj.data.x509;
    2 (0.0%)        return 1;
    .             }
    .           }
    .           X509_OBJECT_free_contents(&obj);
    .         
    .           // Else find index of first cert accepted by
    .           // |x509_check_issued_with_callback|.
    .           ret = 0;
    .           CRYPTO_MUTEX_lock_write(&ctx->ctx->objs_lock);
-- line 583 ----------------------------------------
-- line 607 ----------------------------------------
    .               }
    .             }
    .           }
    .           CRYPTO_MUTEX_unlock_write(&ctx->ctx->objs_lock);
    .           if(*issuer) {
    .             X509_up_ref(*issuer);
    .           }
    .           return ret;
    5 (0.0%)  }
    .         
    .         int X509_STORE_set_flags(X509_STORE *ctx, unsigned long flags) {
    .           return X509_VERIFY_PARAM_set_flags(ctx->param, flags);
    .         }
    .         
    .         int X509_STORE_set_depth(X509_STORE *ctx, int depth) {
    .           X509_VERIFY_PARAM_set_depth(ctx->param, depth);
    .           return 1;
-- line 623 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/md5-x86_64.S
--------------------------------------------------------------------------------
Ir_______ 

-- line 7 ----------------------------------------
 .         .text	
 .         .align	16
 .         
 .         .globl	md5_block_asm_data_order
 .         .hidden md5_block_asm_data_order
 .         .type	md5_block_asm_data_order,@function
 .         md5_block_asm_data_order:
 .         .cfi_startproc	
16 (0.0%)  	pushq	%rbp
 .         .cfi_adjust_cfa_offset	8
 .         .cfi_offset	rbp,-16
16 (0.0%)  	pushq	%rbx
 .         .cfi_adjust_cfa_offset	8
 .         .cfi_offset	rbx,-24
16 (0.0%)  	pushq	%r12
 .         .cfi_adjust_cfa_offset	8
 .         .cfi_offset	r12,-32
16 (0.0%)  	pushq	%r14
 .         .cfi_adjust_cfa_offset	8
 .         .cfi_offset	r14,-40
16 (0.0%)  	pushq	%r15
 .         .cfi_adjust_cfa_offset	8
 .         .cfi_offset	r15,-48
 .         .Lprologue:
 .         
 .         
 .         
 .         
16 (0.0%)  	movq	%rdi,%rbp
16 (0.0%)  	shlq	$6,%rdx
16 (0.0%)  	leaq	(%rsi,%rdx,1),%rdi
16 (0.0%)  	movl	0(%rbp),%eax
16 (0.0%)  	movl	4(%rbp),%ebx
16 (0.0%)  	movl	8(%rbp),%ecx
16 (0.0%)  	movl	12(%rbp),%edx
 .         
 .         
 .         
 .         
 .         
 .         
 .         
16 (0.0%)  	cmpq	%rdi,%rsi
16 (0.0%)  	je	.Lend
 .         
 .         
 .         .Lloop:
38 (0.0%)  	movl	%eax,%r8d
38 (0.0%)  	movl	%ebx,%r9d
38 (0.0%)  	movl	%ecx,%r14d
38 (0.0%)  	movl	%edx,%r15d
38 (0.0%)  	movl	0(%rsi),%r10d
38 (0.0%)  	movl	%edx,%r11d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	leal	-680876936(%rax,%r10,1),%eax
38 (0.0%)  	andl	%ebx,%r11d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	movl	4(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%eax
38 (0.0%)  	roll	$7,%eax
38 (0.0%)  	movl	%ecx,%r11d
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	leal	-389564586(%rdx,%r10,1),%edx
38 (0.0%)  	andl	%eax,%r11d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	movl	8(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%edx
38 (0.0%)  	roll	$12,%edx
38 (0.0%)  	movl	%ebx,%r11d
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	leal	606105819(%rcx,%r10,1),%ecx
38 (0.0%)  	andl	%edx,%r11d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	movl	12(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%ecx
38 (0.0%)  	roll	$17,%ecx
38 (0.0%)  	movl	%eax,%r11d
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	leal	-1044525330(%rbx,%r10,1),%ebx
38 (0.0%)  	andl	%ecx,%r11d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	movl	16(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%ebx
38 (0.0%)  	roll	$22,%ebx
38 (0.0%)  	movl	%edx,%r11d
38 (0.0%)  	addl	%ecx,%ebx
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	leal	-176418897(%rax,%r10,1),%eax
38 (0.0%)  	andl	%ebx,%r11d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	movl	20(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%eax
38 (0.0%)  	roll	$7,%eax
38 (0.0%)  	movl	%ecx,%r11d
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	leal	1200080426(%rdx,%r10,1),%edx
38 (0.0%)  	andl	%eax,%r11d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	movl	24(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%edx
38 (0.0%)  	roll	$12,%edx
38 (0.0%)  	movl	%ebx,%r11d
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	leal	-1473231341(%rcx,%r10,1),%ecx
38 (0.0%)  	andl	%edx,%r11d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	movl	28(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%ecx
38 (0.0%)  	roll	$17,%ecx
38 (0.0%)  	movl	%eax,%r11d
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	leal	-45705983(%rbx,%r10,1),%ebx
38 (0.0%)  	andl	%ecx,%r11d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	movl	32(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%ebx
38 (0.0%)  	roll	$22,%ebx
38 (0.0%)  	movl	%edx,%r11d
38 (0.0%)  	addl	%ecx,%ebx
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	leal	1770035416(%rax,%r10,1),%eax
38 (0.0%)  	andl	%ebx,%r11d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	movl	36(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%eax
38 (0.0%)  	roll	$7,%eax
38 (0.0%)  	movl	%ecx,%r11d
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	leal	-1958414417(%rdx,%r10,1),%edx
38 (0.0%)  	andl	%eax,%r11d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	movl	40(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%edx
38 (0.0%)  	roll	$12,%edx
38 (0.0%)  	movl	%ebx,%r11d
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	leal	-42063(%rcx,%r10,1),%ecx
38 (0.0%)  	andl	%edx,%r11d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	movl	44(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%ecx
38 (0.0%)  	roll	$17,%ecx
38 (0.0%)  	movl	%eax,%r11d
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	leal	-1990404162(%rbx,%r10,1),%ebx
38 (0.0%)  	andl	%ecx,%r11d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	movl	48(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%ebx
38 (0.0%)  	roll	$22,%ebx
38 (0.0%)  	movl	%edx,%r11d
38 (0.0%)  	addl	%ecx,%ebx
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	leal	1804603682(%rax,%r10,1),%eax
38 (0.0%)  	andl	%ebx,%r11d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	movl	52(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%eax
38 (0.0%)  	roll	$7,%eax
38 (0.0%)  	movl	%ecx,%r11d
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	leal	-40341101(%rdx,%r10,1),%edx
38 (0.0%)  	andl	%eax,%r11d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	movl	56(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%edx
38 (0.0%)  	roll	$12,%edx
38 (0.0%)  	movl	%ebx,%r11d
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	leal	-1502002290(%rcx,%r10,1),%ecx
38 (0.0%)  	andl	%edx,%r11d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	movl	60(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%ecx
38 (0.0%)  	roll	$17,%ecx
38 (0.0%)  	movl	%eax,%r11d
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	leal	1236535329(%rbx,%r10,1),%ebx
38 (0.0%)  	andl	%ecx,%r11d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	movl	0(%rsi),%r10d
38 (0.0%)  	addl	%r11d,%ebx
38 (0.0%)  	roll	$22,%ebx
38 (0.0%)  	movl	%edx,%r11d
38 (0.0%)  	addl	%ecx,%ebx
38 (0.0%)  	movl	4(%rsi),%r10d
38 (0.0%)  	movl	%edx,%r11d
38 (0.0%)  	movl	%edx,%r12d
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	-165796510(%rax,%r10,1),%eax
38 (0.0%)  	andl	%ebx,%r12d
38 (0.0%)  	andl	%ecx,%r11d
38 (0.0%)  	movl	24(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%ecx,%r11d
38 (0.0%)  	addl	%r12d,%eax
38 (0.0%)  	movl	%ecx,%r12d
38 (0.0%)  	roll	$5,%eax
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	-1069501632(%rdx,%r10,1),%edx
38 (0.0%)  	andl	%eax,%r12d
38 (0.0%)  	andl	%ebx,%r11d
38 (0.0%)  	movl	44(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%ebx,%r11d
38 (0.0%)  	addl	%r12d,%edx
38 (0.0%)  	movl	%ebx,%r12d
38 (0.0%)  	roll	$9,%edx
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	643717713(%rcx,%r10,1),%ecx
38 (0.0%)  	andl	%edx,%r12d
38 (0.0%)  	andl	%eax,%r11d
38 (0.0%)  	movl	0(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%eax,%r11d
38 (0.0%)  	addl	%r12d,%ecx
38 (0.0%)  	movl	%eax,%r12d
38 (0.0%)  	roll	$14,%ecx
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	-373897302(%rbx,%r10,1),%ebx
38 (0.0%)  	andl	%ecx,%r12d
38 (0.0%)  	andl	%edx,%r11d
38 (0.0%)  	movl	20(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%edx,%r11d
38 (0.0%)  	addl	%r12d,%ebx
38 (0.0%)  	movl	%edx,%r12d
38 (0.0%)  	roll	$20,%ebx
38 (0.0%)  	addl	%ecx,%ebx
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	-701558691(%rax,%r10,1),%eax
38 (0.0%)  	andl	%ebx,%r12d
38 (0.0%)  	andl	%ecx,%r11d
38 (0.0%)  	movl	40(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%ecx,%r11d
38 (0.0%)  	addl	%r12d,%eax
38 (0.0%)  	movl	%ecx,%r12d
38 (0.0%)  	roll	$5,%eax
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	38016083(%rdx,%r10,1),%edx
38 (0.0%)  	andl	%eax,%r12d
38 (0.0%)  	andl	%ebx,%r11d
38 (0.0%)  	movl	60(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%ebx,%r11d
38 (0.0%)  	addl	%r12d,%edx
38 (0.0%)  	movl	%ebx,%r12d
38 (0.0%)  	roll	$9,%edx
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	-660478335(%rcx,%r10,1),%ecx
38 (0.0%)  	andl	%edx,%r12d
38 (0.0%)  	andl	%eax,%r11d
38 (0.0%)  	movl	16(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%eax,%r11d
38 (0.0%)  	addl	%r12d,%ecx
38 (0.0%)  	movl	%eax,%r12d
38 (0.0%)  	roll	$14,%ecx
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	-405537848(%rbx,%r10,1),%ebx
38 (0.0%)  	andl	%ecx,%r12d
38 (0.0%)  	andl	%edx,%r11d
38 (0.0%)  	movl	36(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%edx,%r11d
38 (0.0%)  	addl	%r12d,%ebx
38 (0.0%)  	movl	%edx,%r12d
38 (0.0%)  	roll	$20,%ebx
38 (0.0%)  	addl	%ecx,%ebx
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	568446438(%rax,%r10,1),%eax
38 (0.0%)  	andl	%ebx,%r12d
38 (0.0%)  	andl	%ecx,%r11d
38 (0.0%)  	movl	56(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%ecx,%r11d
38 (0.0%)  	addl	%r12d,%eax
38 (0.0%)  	movl	%ecx,%r12d
38 (0.0%)  	roll	$5,%eax
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	-1019803690(%rdx,%r10,1),%edx
38 (0.0%)  	andl	%eax,%r12d
38 (0.0%)  	andl	%ebx,%r11d
38 (0.0%)  	movl	12(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%ebx,%r11d
38 (0.0%)  	addl	%r12d,%edx
38 (0.0%)  	movl	%ebx,%r12d
38 (0.0%)  	roll	$9,%edx
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	-187363961(%rcx,%r10,1),%ecx
38 (0.0%)  	andl	%edx,%r12d
38 (0.0%)  	andl	%eax,%r11d
38 (0.0%)  	movl	32(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%eax,%r11d
38 (0.0%)  	addl	%r12d,%ecx
38 (0.0%)  	movl	%eax,%r12d
38 (0.0%)  	roll	$14,%ecx
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	1163531501(%rbx,%r10,1),%ebx
38 (0.0%)  	andl	%ecx,%r12d
38 (0.0%)  	andl	%edx,%r11d
38 (0.0%)  	movl	52(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%edx,%r11d
38 (0.0%)  	addl	%r12d,%ebx
38 (0.0%)  	movl	%edx,%r12d
38 (0.0%)  	roll	$20,%ebx
38 (0.0%)  	addl	%ecx,%ebx
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	-1444681467(%rax,%r10,1),%eax
38 (0.0%)  	andl	%ebx,%r12d
38 (0.0%)  	andl	%ecx,%r11d
38 (0.0%)  	movl	8(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%ecx,%r11d
38 (0.0%)  	addl	%r12d,%eax
38 (0.0%)  	movl	%ecx,%r12d
38 (0.0%)  	roll	$5,%eax
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	-51403784(%rdx,%r10,1),%edx
38 (0.0%)  	andl	%eax,%r12d
38 (0.0%)  	andl	%ebx,%r11d
38 (0.0%)  	movl	28(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%ebx,%r11d
38 (0.0%)  	addl	%r12d,%edx
38 (0.0%)  	movl	%ebx,%r12d
38 (0.0%)  	roll	$9,%edx
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	1735328473(%rcx,%r10,1),%ecx
38 (0.0%)  	andl	%edx,%r12d
38 (0.0%)  	andl	%eax,%r11d
38 (0.0%)  	movl	48(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%eax,%r11d
38 (0.0%)  	addl	%r12d,%ecx
38 (0.0%)  	movl	%eax,%r12d
38 (0.0%)  	roll	$14,%ecx
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	notl	%r11d
38 (0.0%)  	leal	-1926607734(%rbx,%r10,1),%ebx
38 (0.0%)  	andl	%ecx,%r12d
38 (0.0%)  	andl	%edx,%r11d
38 (0.0%)  	movl	0(%rsi),%r10d
38 (0.0%)  	orl	%r11d,%r12d
38 (0.0%)  	movl	%edx,%r11d
38 (0.0%)  	addl	%r12d,%ebx
38 (0.0%)  	movl	%edx,%r12d
38 (0.0%)  	roll	$20,%ebx
38 (0.0%)  	addl	%ecx,%ebx
38 (0.0%)  	movl	20(%rsi),%r10d
38 (0.0%)  	movl	%ecx,%r11d
38 (0.0%)  	leal	-378558(%rax,%r10,1),%eax
38 (0.0%)  	movl	32(%rsi),%r10d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	addl	%r11d,%eax
38 (0.0%)  	roll	$4,%eax
38 (0.0%)  	movl	%ebx,%r11d
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	leal	-2022574463(%rdx,%r10,1),%edx
38 (0.0%)  	movl	44(%rsi),%r10d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	addl	%r11d,%edx
38 (0.0%)  	roll	$11,%edx
38 (0.0%)  	movl	%eax,%r11d
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	leal	1839030562(%rcx,%r10,1),%ecx
38 (0.0%)  	movl	56(%rsi),%r10d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	addl	%r11d,%ecx
38 (0.0%)  	roll	$16,%ecx
38 (0.0%)  	movl	%edx,%r11d
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	leal	-35309556(%rbx,%r10,1),%ebx
38 (0.0%)  	movl	4(%rsi),%r10d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	addl	%r11d,%ebx
38 (0.0%)  	roll	$23,%ebx
38 (0.0%)  	movl	%ecx,%r11d
38 (0.0%)  	addl	%ecx,%ebx
38 (0.0%)  	leal	-1530992060(%rax,%r10,1),%eax
38 (0.0%)  	movl	16(%rsi),%r10d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	addl	%r11d,%eax
38 (0.0%)  	roll	$4,%eax
38 (0.0%)  	movl	%ebx,%r11d
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	leal	1272893353(%rdx,%r10,1),%edx
38 (0.0%)  	movl	28(%rsi),%r10d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	addl	%r11d,%edx
38 (0.0%)  	roll	$11,%edx
38 (0.0%)  	movl	%eax,%r11d
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	leal	-155497632(%rcx,%r10,1),%ecx
38 (0.0%)  	movl	40(%rsi),%r10d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	addl	%r11d,%ecx
38 (0.0%)  	roll	$16,%ecx
38 (0.0%)  	movl	%edx,%r11d
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	leal	-1094730640(%rbx,%r10,1),%ebx
38 (0.0%)  	movl	52(%rsi),%r10d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	addl	%r11d,%ebx
38 (0.0%)  	roll	$23,%ebx
38 (0.0%)  	movl	%ecx,%r11d
38 (0.0%)  	addl	%ecx,%ebx
38 (0.0%)  	leal	681279174(%rax,%r10,1),%eax
38 (0.0%)  	movl	0(%rsi),%r10d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	addl	%r11d,%eax
38 (0.0%)  	roll	$4,%eax
38 (0.0%)  	movl	%ebx,%r11d
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	leal	-358537222(%rdx,%r10,1),%edx
38 (0.0%)  	movl	12(%rsi),%r10d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	addl	%r11d,%edx
38 (0.0%)  	roll	$11,%edx
38 (0.0%)  	movl	%eax,%r11d
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	leal	-722521979(%rcx,%r10,1),%ecx
38 (0.0%)  	movl	24(%rsi),%r10d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	addl	%r11d,%ecx
38 (0.0%)  	roll	$16,%ecx
38 (0.0%)  	movl	%edx,%r11d
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	leal	76029189(%rbx,%r10,1),%ebx
38 (0.0%)  	movl	36(%rsi),%r10d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	addl	%r11d,%ebx
38 (0.0%)  	roll	$23,%ebx
38 (0.0%)  	movl	%ecx,%r11d
38 (0.0%)  	addl	%ecx,%ebx
38 (0.0%)  	leal	-640364487(%rax,%r10,1),%eax
38 (0.0%)  	movl	48(%rsi),%r10d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	addl	%r11d,%eax
38 (0.0%)  	roll	$4,%eax
38 (0.0%)  	movl	%ebx,%r11d
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	leal	-421815835(%rdx,%r10,1),%edx
38 (0.0%)  	movl	60(%rsi),%r10d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	addl	%r11d,%edx
38 (0.0%)  	roll	$11,%edx
38 (0.0%)  	movl	%eax,%r11d
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	leal	530742520(%rcx,%r10,1),%ecx
38 (0.0%)  	movl	8(%rsi),%r10d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	addl	%r11d,%ecx
38 (0.0%)  	roll	$16,%ecx
38 (0.0%)  	movl	%edx,%r11d
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	leal	-995338651(%rbx,%r10,1),%ebx
38 (0.0%)  	movl	0(%rsi),%r10d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	addl	%r11d,%ebx
38 (0.0%)  	roll	$23,%ebx
38 (0.0%)  	movl	%ecx,%r11d
38 (0.0%)  	addl	%ecx,%ebx
38 (0.0%)  	movl	0(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	leal	-198630844(%rax,%r10,1),%eax
38 (0.0%)  	orl	%ebx,%r11d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	addl	%r11d,%eax
38 (0.0%)  	movl	28(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$6,%eax
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	leal	1126891415(%rdx,%r10,1),%edx
38 (0.0%)  	orl	%eax,%r11d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	addl	%r11d,%edx
38 (0.0%)  	movl	56(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$10,%edx
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	leal	-1416354905(%rcx,%r10,1),%ecx
38 (0.0%)  	orl	%edx,%r11d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	addl	%r11d,%ecx
38 (0.0%)  	movl	20(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$15,%ecx
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	leal	-57434055(%rbx,%r10,1),%ebx
38 (0.0%)  	orl	%ecx,%r11d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	addl	%r11d,%ebx
38 (0.0%)  	movl	48(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$21,%ebx
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	addl	%ecx,%ebx
38 (0.0%)  	leal	1700485571(%rax,%r10,1),%eax
38 (0.0%)  	orl	%ebx,%r11d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	addl	%r11d,%eax
38 (0.0%)  	movl	12(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$6,%eax
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	leal	-1894986606(%rdx,%r10,1),%edx
38 (0.0%)  	orl	%eax,%r11d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	addl	%r11d,%edx
38 (0.0%)  	movl	40(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$10,%edx
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	leal	-1051523(%rcx,%r10,1),%ecx
38 (0.0%)  	orl	%edx,%r11d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	addl	%r11d,%ecx
38 (0.0%)  	movl	4(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$15,%ecx
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	leal	-2054922799(%rbx,%r10,1),%ebx
38 (0.0%)  	orl	%ecx,%r11d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	addl	%r11d,%ebx
38 (0.0%)  	movl	32(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$21,%ebx
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	addl	%ecx,%ebx
38 (0.0%)  	leal	1873313359(%rax,%r10,1),%eax
38 (0.0%)  	orl	%ebx,%r11d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	addl	%r11d,%eax
38 (0.0%)  	movl	60(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$6,%eax
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	leal	-30611744(%rdx,%r10,1),%edx
38 (0.0%)  	orl	%eax,%r11d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	addl	%r11d,%edx
38 (0.0%)  	movl	24(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$10,%edx
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	leal	-1560198380(%rcx,%r10,1),%ecx
38 (0.0%)  	orl	%edx,%r11d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	addl	%r11d,%ecx
38 (0.0%)  	movl	52(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$15,%ecx
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	leal	1309151649(%rbx,%r10,1),%ebx
38 (0.0%)  	orl	%ecx,%r11d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	addl	%r11d,%ebx
38 (0.0%)  	movl	16(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$21,%ebx
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	addl	%ecx,%ebx
38 (0.0%)  	leal	-145523070(%rax,%r10,1),%eax
38 (0.0%)  	orl	%ebx,%r11d
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	addl	%r11d,%eax
38 (0.0%)  	movl	44(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$6,%eax
38 (0.0%)  	xorl	%ecx,%r11d
38 (0.0%)  	addl	%ebx,%eax
38 (0.0%)  	leal	-1120210379(%rdx,%r10,1),%edx
38 (0.0%)  	orl	%eax,%r11d
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	addl	%r11d,%edx
38 (0.0%)  	movl	8(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$10,%edx
38 (0.0%)  	xorl	%ebx,%r11d
38 (0.0%)  	addl	%eax,%edx
38 (0.0%)  	leal	718787259(%rcx,%r10,1),%ecx
38 (0.0%)  	orl	%edx,%r11d
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	addl	%r11d,%ecx
38 (0.0%)  	movl	36(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$15,%ecx
38 (0.0%)  	xorl	%eax,%r11d
38 (0.0%)  	addl	%edx,%ecx
38 (0.0%)  	leal	-343485551(%rbx,%r10,1),%ebx
38 (0.0%)  	orl	%ecx,%r11d
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	addl	%r11d,%ebx
38 (0.0%)  	movl	0(%rsi),%r10d
38 (0.0%)  	movl	$0xffffffff,%r11d
38 (0.0%)  	roll	$21,%ebx
38 (0.0%)  	xorl	%edx,%r11d
38 (0.0%)  	addl	%ecx,%ebx
 .         
38 (0.0%)  	addl	%r8d,%eax
38 (0.0%)  	addl	%r9d,%ebx
38 (0.0%)  	addl	%r14d,%ecx
38 (0.0%)  	addl	%r15d,%edx
 .         
 .         
38 (0.0%)  	addq	$64,%rsi
38 (0.0%)  	cmpq	%rdi,%rsi
38 (0.0%)  	jb	.Lloop
 .         
 .         
 .         .Lend:
16 (0.0%)  	movl	%eax,0(%rbp)
16 (0.0%)  	movl	%ebx,4(%rbp)
16 (0.0%)  	movl	%ecx,8(%rbp)
16 (0.0%)  	movl	%edx,12(%rbp)
 .         
16 (0.0%)  	movq	(%rsp),%r15
 .         .cfi_restore	r15
16 (0.0%)  	movq	8(%rsp),%r14
 .         .cfi_restore	r14
16 (0.0%)  	movq	16(%rsp),%r12
 .         .cfi_restore	r12
16 (0.0%)  	movq	24(%rsp),%rbx
 .         .cfi_restore	rbx
16 (0.0%)  	movq	32(%rsp),%rbp
 .         .cfi_restore	rbp
32 (0.0%)  	addq	$40,%rsp
 .         .cfi_adjust_cfa_offset	-40
 .         .Lepilogue:
 .         	.byte	0xf3,0xc3
 .         .cfi_endproc	
 .         .size	md5_block_asm_data_order,.-md5_block_asm_data_order
 .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S
--------------------------------------------------------------------------------
Ir__________ 

-- line 33 ----------------------------------------
    .         
    .         
    .         .globl	ecp_nistz256_neg
    .         .hidden ecp_nistz256_neg
    .         .type	ecp_nistz256_neg,@function
    .         .align	32
    .         ecp_nistz256_neg:
    .         .cfi_startproc	
  176 (0.0%)  	pushq	%r12
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r12,-16
  176 (0.0%)  	pushq	%r13
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r13,-24
    .         .Lneg_body:
    .         
  176 (0.0%)  	xorq	%r8,%r8
  176 (0.0%)  	xorq	%r9,%r9
  176 (0.0%)  	xorq	%r10,%r10
  176 (0.0%)  	xorq	%r11,%r11
  176 (0.0%)  	xorq	%r13,%r13
    .         
  176 (0.0%)  	subq	0(%rsi),%r8
  176 (0.0%)  	sbbq	8(%rsi),%r9
  176 (0.0%)  	sbbq	16(%rsi),%r10
  176 (0.0%)  	movq	%r8,%rax
  176 (0.0%)  	sbbq	24(%rsi),%r11
  176 (0.0%)  	leaq	.Lpoly(%rip),%rsi
  176 (0.0%)  	movq	%r9,%rdx
  176 (0.0%)  	sbbq	$0,%r13
    .         
  176 (0.0%)  	addq	0(%rsi),%r8
  176 (0.0%)  	movq	%r10,%rcx
  176 (0.0%)  	adcq	8(%rsi),%r9
  176 (0.0%)  	adcq	16(%rsi),%r10
  176 (0.0%)  	movq	%r11,%r12
  176 (0.0%)  	adcq	24(%rsi),%r11
  176 (0.0%)  	testq	%r13,%r13
    .         
  176 (0.0%)  	cmovzq	%rax,%r8
  176 (0.0%)  	cmovzq	%rdx,%r9
  176 (0.0%)  	movq	%r8,0(%rdi)
  176 (0.0%)  	cmovzq	%rcx,%r10
  176 (0.0%)  	movq	%r9,8(%rdi)
  176 (0.0%)  	cmovzq	%r12,%r11
  176 (0.0%)  	movq	%r10,16(%rdi)
  176 (0.0%)  	movq	%r11,24(%rdi)
    .         
  176 (0.0%)  	movq	0(%rsp),%r13
    .         .cfi_restore	%r13
  176 (0.0%)  	movq	8(%rsp),%r12
    .         .cfi_restore	%r12
  352 (0.0%)  	leaq	16(%rsp),%rsp
    .         .cfi_adjust_cfa_offset	-16
    .         .Lneg_epilogue:
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	ecp_nistz256_neg,.-ecp_nistz256_neg
    .         
    .         
    .         
-- line 93 ----------------------------------------
-- line 1188 ----------------------------------------
    .         
    .         
    .         .globl	ecp_nistz256_mul_mont
    .         .hidden ecp_nistz256_mul_mont
    .         .type	ecp_nistz256_mul_mont,@function
    .         .align	32
    .         ecp_nistz256_mul_mont:
    .         .cfi_startproc	
   52 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
   52 (0.0%)  	movq	8(%rcx),%rcx
   52 (0.0%)  	andl	$0x80100,%ecx
    .         .Lmul_mont:
   52 (0.0%)  	pushq	%rbp
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbp,-16
   52 (0.0%)  	pushq	%rbx
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbx,-24
   52 (0.0%)  	pushq	%r12
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r12,-32
   52 (0.0%)  	pushq	%r13
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r13,-40
   52 (0.0%)  	pushq	%r14
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r14,-48
   52 (0.0%)  	pushq	%r15
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r15,-56
    .         .Lmul_body:
   52 (0.0%)  	cmpl	$0x80100,%ecx
   52 (0.0%)  	je	.Lmul_montx
   52 (0.0%)  	movq	%rdx,%rbx
   52 (0.0%)  	movq	0(%rdx),%rax
   52 (0.0%)  	movq	0(%rsi),%r9
   52 (0.0%)  	movq	8(%rsi),%r10
   52 (0.0%)  	movq	16(%rsi),%r11
   52 (0.0%)  	movq	24(%rsi),%r12
    .         
   52 (0.0%)  	call	__ecp_nistz256_mul_montq
   52 (0.0%)  	jmp	.Lmul_mont_done
    .         
    .         .align	32
    .         .Lmul_montx:
    .         	movq	%rdx,%rbx
    .         	movq	0(%rdx),%rdx
    .         	movq	0(%rsi),%r9
    .         	movq	8(%rsi),%r10
    .         	movq	16(%rsi),%r11
    .         	movq	24(%rsi),%r12
    .         	leaq	-128(%rsi),%rsi
    .         
    .         	call	__ecp_nistz256_mul_montx
    .         .Lmul_mont_done:
   52 (0.0%)  	movq	0(%rsp),%r15
    .         .cfi_restore	%r15
   52 (0.0%)  	movq	8(%rsp),%r14
    .         .cfi_restore	%r14
   52 (0.0%)  	movq	16(%rsp),%r13
    .         .cfi_restore	%r13
   52 (0.0%)  	movq	24(%rsp),%r12
    .         .cfi_restore	%r12
   52 (0.0%)  	movq	32(%rsp),%rbx
    .         .cfi_restore	%rbx
   52 (0.0%)  	movq	40(%rsp),%rbp
    .         .cfi_restore	%rbp
  104 (0.0%)  	leaq	48(%rsp),%rsp
    .         .cfi_adjust_cfa_offset	-48
    .         .Lmul_epilogue:
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	ecp_nistz256_mul_mont,.-ecp_nistz256_mul_mont
    .         
    .         .type	__ecp_nistz256_mul_montq,@function
    .         .align	32
    .         __ecp_nistz256_mul_montq:
    .         .cfi_startproc	
    .         
    .         
4,124 (0.0%)  	movq	%rax,%rbp
4,124 (0.0%)  	mulq	%r9
4,124 (0.0%)  	movq	.Lpoly+8(%rip),%r14
4,124 (0.0%)  	movq	%rax,%r8
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	movq	%rdx,%r9
    .         
4,124 (0.0%)  	mulq	%r10
4,124 (0.0%)  	movq	.Lpoly+24(%rip),%r15
4,124 (0.0%)  	addq	%rax,%r9
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%r10
    .         
4,124 (0.0%)  	mulq	%r11
4,124 (0.0%)  	addq	%rax,%r10
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%r11
    .         
4,124 (0.0%)  	mulq	%r12
4,124 (0.0%)  	addq	%rax,%r11
4,124 (0.0%)  	movq	%r8,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	xorq	%r13,%r13
4,124 (0.0%)  	movq	%rdx,%r12
    .         
    .         
    .         
    .         
    .         
    .         
    .         
    .         
    .         
    .         
4,124 (0.0%)  	movq	%r8,%rbp
4,124 (0.0%)  	shlq	$32,%r8
4,124 (0.0%)  	mulq	%r15
4,124 (0.0%)  	shrq	$32,%rbp
4,124 (0.0%)  	addq	%r8,%r9
4,124 (0.0%)  	adcq	%rbp,%r10
4,124 (0.0%)  	adcq	%rax,%r11
4,124 (0.0%)  	movq	8(%rbx),%rax
4,124 (0.0%)  	adcq	%rdx,%r12
4,124 (0.0%)  	adcq	$0,%r13
4,124 (0.0%)  	xorq	%r8,%r8
    .         
    .         
    .         
4,124 (0.0%)  	movq	%rax,%rbp
4,124 (0.0%)  	mulq	0(%rsi)
4,124 (0.0%)  	addq	%rax,%r9
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	8(%rsi)
4,124 (0.0%)  	addq	%rcx,%r10
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r10
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	16(%rsi)
4,124 (0.0%)  	addq	%rcx,%r11
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r11
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	24(%rsi)
4,124 (0.0%)  	addq	%rcx,%r12
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r12
4,124 (0.0%)  	movq	%r9,%rax
4,124 (0.0%)  	adcq	%rdx,%r13
4,124 (0.0%)  	adcq	$0,%r8
    .         
    .         
    .         
4,124 (0.0%)  	movq	%r9,%rbp
4,124 (0.0%)  	shlq	$32,%r9
4,124 (0.0%)  	mulq	%r15
4,124 (0.0%)  	shrq	$32,%rbp
4,124 (0.0%)  	addq	%r9,%r10
4,124 (0.0%)  	adcq	%rbp,%r11
4,124 (0.0%)  	adcq	%rax,%r12
4,124 (0.0%)  	movq	16(%rbx),%rax
4,124 (0.0%)  	adcq	%rdx,%r13
4,124 (0.0%)  	adcq	$0,%r8
4,124 (0.0%)  	xorq	%r9,%r9
    .         
    .         
    .         
4,124 (0.0%)  	movq	%rax,%rbp
4,124 (0.0%)  	mulq	0(%rsi)
4,124 (0.0%)  	addq	%rax,%r10
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	8(%rsi)
4,124 (0.0%)  	addq	%rcx,%r11
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r11
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	16(%rsi)
4,124 (0.0%)  	addq	%rcx,%r12
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r12
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	24(%rsi)
4,124 (0.0%)  	addq	%rcx,%r13
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r13
4,124 (0.0%)  	movq	%r10,%rax
4,124 (0.0%)  	adcq	%rdx,%r8
4,124 (0.0%)  	adcq	$0,%r9
    .         
    .         
    .         
4,124 (0.0%)  	movq	%r10,%rbp
4,124 (0.0%)  	shlq	$32,%r10
4,124 (0.0%)  	mulq	%r15
4,124 (0.0%)  	shrq	$32,%rbp
4,124 (0.0%)  	addq	%r10,%r11
4,124 (0.0%)  	adcq	%rbp,%r12
4,124 (0.0%)  	adcq	%rax,%r13
4,124 (0.0%)  	movq	24(%rbx),%rax
4,124 (0.0%)  	adcq	%rdx,%r8
4,124 (0.0%)  	adcq	$0,%r9
4,124 (0.0%)  	xorq	%r10,%r10
    .         
    .         
    .         
4,124 (0.0%)  	movq	%rax,%rbp
4,124 (0.0%)  	mulq	0(%rsi)
4,124 (0.0%)  	addq	%rax,%r11
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	8(%rsi)
4,124 (0.0%)  	addq	%rcx,%r12
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r12
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	16(%rsi)
4,124 (0.0%)  	addq	%rcx,%r13
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r13
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	24(%rsi)
4,124 (0.0%)  	addq	%rcx,%r8
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r8
4,124 (0.0%)  	movq	%r11,%rax
4,124 (0.0%)  	adcq	%rdx,%r9
4,124 (0.0%)  	adcq	$0,%r10
    .         
    .         
    .         
4,124 (0.0%)  	movq	%r11,%rbp
4,124 (0.0%)  	shlq	$32,%r11
4,124 (0.0%)  	mulq	%r15
4,124 (0.0%)  	shrq	$32,%rbp
4,124 (0.0%)  	addq	%r11,%r12
4,124 (0.0%)  	adcq	%rbp,%r13
4,124 (0.0%)  	movq	%r12,%rcx
4,124 (0.0%)  	adcq	%rax,%r8
4,124 (0.0%)  	adcq	%rdx,%r9
4,124 (0.0%)  	movq	%r13,%rbp
4,124 (0.0%)  	adcq	$0,%r10
    .         
    .         
    .         
4,124 (0.0%)  	subq	$-1,%r12
4,124 (0.0%)  	movq	%r8,%rbx
4,124 (0.0%)  	sbbq	%r14,%r13
4,124 (0.0%)  	sbbq	$0,%r8
4,124 (0.0%)  	movq	%r9,%rdx
4,124 (0.0%)  	sbbq	%r15,%r9
4,124 (0.0%)  	sbbq	$0,%r10
    .         
4,124 (0.0%)  	cmovcq	%rcx,%r12
4,124 (0.0%)  	cmovcq	%rbp,%r13
4,124 (0.0%)  	movq	%r12,0(%rdi)
4,124 (0.0%)  	cmovcq	%rbx,%r8
4,124 (0.0%)  	movq	%r13,8(%rdi)
4,124 (0.0%)  	cmovcq	%rdx,%r9
4,124 (0.0%)  	movq	%r8,16(%rdi)
8,248 (0.1%)  	movq	%r9,24(%rdi)
    .         
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	__ecp_nistz256_mul_montq,.-__ecp_nistz256_mul_montq
    .         
    .         
    .         
    .         
-- line 1482 ----------------------------------------
-- line 1485 ----------------------------------------
    .         
    .         
    .         .globl	ecp_nistz256_sqr_mont
    .         .hidden ecp_nistz256_sqr_mont
    .         .type	ecp_nistz256_sqr_mont,@function
    .         .align	32
    .         ecp_nistz256_sqr_mont:
    .         .cfi_startproc	
1,022 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
1,022 (0.0%)  	movq	8(%rcx),%rcx
1,022 (0.0%)  	andl	$0x80100,%ecx
1,022 (0.0%)  	pushq	%rbp
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbp,-16
1,022 (0.0%)  	pushq	%rbx
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbx,-24
1,022 (0.0%)  	pushq	%r12
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r12,-32
1,022 (0.0%)  	pushq	%r13
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r13,-40
1,022 (0.0%)  	pushq	%r14
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r14,-48
1,022 (0.0%)  	pushq	%r15
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r15,-56
    .         .Lsqr_body:
1,022 (0.0%)  	cmpl	$0x80100,%ecx
1,022 (0.0%)  	je	.Lsqr_montx
1,022 (0.0%)  	movq	0(%rsi),%rax
1,022 (0.0%)  	movq	8(%rsi),%r14
1,022 (0.0%)  	movq	16(%rsi),%r15
1,022 (0.0%)  	movq	24(%rsi),%r8
    .         
1,022 (0.0%)  	call	__ecp_nistz256_sqr_montq
1,022 (0.0%)  	jmp	.Lsqr_mont_done
    .         
    .         .align	32
    .         .Lsqr_montx:
    .         	movq	0(%rsi),%rdx
    .         	movq	8(%rsi),%r14
    .         	movq	16(%rsi),%r15
    .         	movq	24(%rsi),%r8
    .         	leaq	-128(%rsi),%rsi
    .         
    .         	call	__ecp_nistz256_sqr_montx
    .         .Lsqr_mont_done:
1,022 (0.0%)  	movq	0(%rsp),%r15
    .         .cfi_restore	%r15
1,022 (0.0%)  	movq	8(%rsp),%r14
    .         .cfi_restore	%r14
1,022 (0.0%)  	movq	16(%rsp),%r13
    .         .cfi_restore	%r13
1,022 (0.0%)  	movq	24(%rsp),%r12
    .         .cfi_restore	%r12
1,022 (0.0%)  	movq	32(%rsp),%rbx
    .         .cfi_restore	%rbx
1,022 (0.0%)  	movq	40(%rsp),%rbp
    .         .cfi_restore	%rbp
2,044 (0.0%)  	leaq	48(%rsp),%rsp
    .         .cfi_adjust_cfa_offset	-48
    .         .Lsqr_epilogue:
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	ecp_nistz256_sqr_mont,.-ecp_nistz256_sqr_mont
    .         
    .         .type	__ecp_nistz256_sqr_montq,@function
    .         .align	32
    .         __ecp_nistz256_sqr_montq:
    .         .cfi_startproc	
3,806 (0.0%)  	movq	%rax,%r13
3,806 (0.0%)  	mulq	%r14
3,806 (0.0%)  	movq	%rax,%r9
3,806 (0.0%)  	movq	%r15,%rax
3,806 (0.0%)  	movq	%rdx,%r10
    .         
3,806 (0.0%)  	mulq	%r13
3,806 (0.0%)  	addq	%rax,%r10
3,806 (0.0%)  	movq	%r8,%rax
3,806 (0.0%)  	adcq	$0,%rdx
3,806 (0.0%)  	movq	%rdx,%r11
    .         
3,806 (0.0%)  	mulq	%r13
3,806 (0.0%)  	addq	%rax,%r11
3,806 (0.0%)  	movq	%r15,%rax
3,806 (0.0%)  	adcq	$0,%rdx
3,806 (0.0%)  	movq	%rdx,%r12
    .         
    .         
3,806 (0.0%)  	mulq	%r14
3,806 (0.0%)  	addq	%rax,%r11
3,806 (0.0%)  	movq	%r8,%rax
3,806 (0.0%)  	adcq	$0,%rdx
3,806 (0.0%)  	movq	%rdx,%rbp
    .         
3,806 (0.0%)  	mulq	%r14
3,806 (0.0%)  	addq	%rax,%r12
3,806 (0.0%)  	movq	%r8,%rax
3,806 (0.0%)  	adcq	$0,%rdx
3,806 (0.0%)  	addq	%rbp,%r12
3,806 (0.0%)  	movq	%rdx,%r13
3,806 (0.0%)  	adcq	$0,%r13
    .         
    .         
3,806 (0.0%)  	mulq	%r15
3,806 (0.0%)  	xorq	%r15,%r15
3,806 (0.0%)  	addq	%rax,%r13
3,806 (0.0%)  	movq	0(%rsi),%rax
3,806 (0.0%)  	movq	%rdx,%r14
3,806 (0.0%)  	adcq	$0,%r14
    .         
3,806 (0.0%)  	addq	%r9,%r9
3,806 (0.0%)  	adcq	%r10,%r10
3,806 (0.0%)  	adcq	%r11,%r11
3,806 (0.0%)  	adcq	%r12,%r12
3,806 (0.0%)  	adcq	%r13,%r13
3,806 (0.0%)  	adcq	%r14,%r14
3,806 (0.0%)  	adcq	$0,%r15
    .         
3,806 (0.0%)  	mulq	%rax
3,806 (0.0%)  	movq	%rax,%r8
3,806 (0.0%)  	movq	8(%rsi),%rax
3,806 (0.0%)  	movq	%rdx,%rcx
    .         
3,806 (0.0%)  	mulq	%rax
3,806 (0.0%)  	addq	%rcx,%r9
3,806 (0.0%)  	adcq	%rax,%r10
3,806 (0.0%)  	movq	16(%rsi),%rax
3,806 (0.0%)  	adcq	$0,%rdx
3,806 (0.0%)  	movq	%rdx,%rcx
    .         
3,806 (0.0%)  	mulq	%rax
3,806 (0.0%)  	addq	%rcx,%r11
3,806 (0.0%)  	adcq	%rax,%r12
3,806 (0.0%)  	movq	24(%rsi),%rax
3,806 (0.0%)  	adcq	$0,%rdx
3,806 (0.0%)  	movq	%rdx,%rcx
    .         
3,806 (0.0%)  	mulq	%rax
3,806 (0.0%)  	addq	%rcx,%r13
3,806 (0.0%)  	adcq	%rax,%r14
3,806 (0.0%)  	movq	%r8,%rax
3,806 (0.0%)  	adcq	%rdx,%r15
    .         
3,806 (0.0%)  	movq	.Lpoly+8(%rip),%rsi
3,806 (0.0%)  	movq	.Lpoly+24(%rip),%rbp
    .         
    .         
    .         
    .         
3,806 (0.0%)  	movq	%r8,%rcx
3,806 (0.0%)  	shlq	$32,%r8
3,806 (0.0%)  	mulq	%rbp
3,806 (0.0%)  	shrq	$32,%rcx
3,806 (0.0%)  	addq	%r8,%r9
3,806 (0.0%)  	adcq	%rcx,%r10
3,806 (0.0%)  	adcq	%rax,%r11
3,806 (0.0%)  	movq	%r9,%rax
3,806 (0.0%)  	adcq	$0,%rdx
    .         
    .         
    .         
3,806 (0.0%)  	movq	%r9,%rcx
3,806 (0.0%)  	shlq	$32,%r9
3,806 (0.0%)  	movq	%rdx,%r8
3,806 (0.0%)  	mulq	%rbp
3,806 (0.0%)  	shrq	$32,%rcx
3,806 (0.0%)  	addq	%r9,%r10
3,806 (0.0%)  	adcq	%rcx,%r11
3,806 (0.0%)  	adcq	%rax,%r8
3,806 (0.0%)  	movq	%r10,%rax
3,806 (0.0%)  	adcq	$0,%rdx
    .         
    .         
    .         
3,806 (0.0%)  	movq	%r10,%rcx
3,806 (0.0%)  	shlq	$32,%r10
3,806 (0.0%)  	movq	%rdx,%r9
3,806 (0.0%)  	mulq	%rbp
3,806 (0.0%)  	shrq	$32,%rcx
3,806 (0.0%)  	addq	%r10,%r11
3,806 (0.0%)  	adcq	%rcx,%r8
3,806 (0.0%)  	adcq	%rax,%r9
3,806 (0.0%)  	movq	%r11,%rax
3,806 (0.0%)  	adcq	$0,%rdx
    .         
    .         
    .         
3,806 (0.0%)  	movq	%r11,%rcx
3,806 (0.0%)  	shlq	$32,%r11
3,806 (0.0%)  	movq	%rdx,%r10
3,806 (0.0%)  	mulq	%rbp
3,806 (0.0%)  	shrq	$32,%rcx
3,806 (0.0%)  	addq	%r11,%r8
3,806 (0.0%)  	adcq	%rcx,%r9
3,806 (0.0%)  	adcq	%rax,%r10
3,806 (0.0%)  	adcq	$0,%rdx
3,806 (0.0%)  	xorq	%r11,%r11
    .         
    .         
    .         
3,806 (0.0%)  	addq	%r8,%r12
3,806 (0.0%)  	adcq	%r9,%r13
3,806 (0.0%)  	movq	%r12,%r8
3,806 (0.0%)  	adcq	%r10,%r14
3,806 (0.0%)  	adcq	%rdx,%r15
3,806 (0.0%)  	movq	%r13,%r9
3,806 (0.0%)  	adcq	$0,%r11
    .         
3,806 (0.0%)  	subq	$-1,%r12
3,806 (0.0%)  	movq	%r14,%r10
3,806 (0.0%)  	sbbq	%rsi,%r13
3,806 (0.0%)  	sbbq	$0,%r14
3,806 (0.0%)  	movq	%r15,%rcx
3,806 (0.0%)  	sbbq	%rbp,%r15
3,806 (0.0%)  	sbbq	$0,%r11
    .         
3,806 (0.0%)  	cmovcq	%r8,%r12
3,806 (0.0%)  	cmovcq	%r9,%r13
3,806 (0.0%)  	movq	%r12,0(%rdi)
3,806 (0.0%)  	cmovcq	%r10,%r14
3,806 (0.0%)  	movq	%r13,8(%rdi)
3,806 (0.0%)  	cmovcq	%rcx,%r15
3,806 (0.0%)  	movq	%r14,16(%rdi)
7,612 (0.1%)  	movq	%r15,24(%rdi)
    .         
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	__ecp_nistz256_sqr_montq,.-__ecp_nistz256_sqr_montq
    .         .type	__ecp_nistz256_mul_montx,@function
    .         .align	32
    .         __ecp_nistz256_mul_montx:
    .         .cfi_startproc	
-- line 1720 ----------------------------------------
-- line 2015 ----------------------------------------
    .         
    .         
    .         .globl	ecp_nistz256_select_w5
    .         .hidden ecp_nistz256_select_w5
    .         .type	ecp_nistz256_select_w5,@function
    .         .align	32
    .         ecp_nistz256_select_w5:
    .         .cfi_startproc	
  104 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rax
  104 (0.0%)  	movq	8(%rax),%rax
  104 (0.0%)  	testl	$32,%eax
  104 (0.0%)  	jnz	.Lavx2_select_w5
    .         	movdqa	.LOne(%rip),%xmm0
    .         	movd	%edx,%xmm1
    .         
    .         	pxor	%xmm2,%xmm2
    .         	pxor	%xmm3,%xmm3
    .         	pxor	%xmm4,%xmm4
    .         	pxor	%xmm5,%xmm5
    .         	pxor	%xmm6,%xmm6
-- line 2034 ----------------------------------------
-- line 2082 ----------------------------------------
    .         
    .         
    .         .globl	ecp_nistz256_select_w7
    .         .hidden ecp_nistz256_select_w7
    .         .type	ecp_nistz256_select_w7,@function
    .         .align	32
    .         ecp_nistz256_select_w7:
    .         .cfi_startproc	
   74 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rax
   74 (0.0%)  	movq	8(%rax),%rax
   74 (0.0%)  	testl	$32,%eax
   74 (0.0%)  	jnz	.Lavx2_select_w7
    .         	movdqa	.LOne(%rip),%xmm8
    .         	movd	%edx,%xmm1
    .         
    .         	pxor	%xmm2,%xmm2
    .         	pxor	%xmm3,%xmm3
    .         	pxor	%xmm4,%xmm4
    .         	pxor	%xmm5,%xmm5
    .         
-- line 2101 ----------------------------------------
-- line 2136 ----------------------------------------
    .         .size	ecp_nistz256_select_w7,.-ecp_nistz256_select_w7
    .         
    .         
    .         .type	ecp_nistz256_avx2_select_w5,@function
    .         .align	32
    .         ecp_nistz256_avx2_select_w5:
    .         .cfi_startproc	
    .         .Lavx2_select_w5:
  104 (0.0%)  	vzeroupper
  104 (0.0%)  	vmovdqa	.LTwo(%rip),%ymm0
    .         
  104 (0.0%)  	vpxor	%ymm2,%ymm2,%ymm2
  104 (0.0%)  	vpxor	%ymm3,%ymm3,%ymm3
  104 (0.0%)  	vpxor	%ymm4,%ymm4,%ymm4
    .         
  104 (0.0%)  	vmovdqa	.LOne(%rip),%ymm5
  104 (0.0%)  	vmovdqa	.LTwo(%rip),%ymm10
    .         
  104 (0.0%)  	vmovd	%edx,%xmm1
  104 (0.0%)  	vpermd	%ymm1,%ymm2,%ymm1
    .         
  104 (0.0%)  	movq	$8,%rax
    .         .Lselect_loop_avx2_w5:
    .         
  832 (0.0%)  	vmovdqa	0(%rsi),%ymm6
  832 (0.0%)  	vmovdqa	32(%rsi),%ymm7
  832 (0.0%)  	vmovdqa	64(%rsi),%ymm8
    .         
  832 (0.0%)  	vmovdqa	96(%rsi),%ymm11
  832 (0.0%)  	vmovdqa	128(%rsi),%ymm12
  832 (0.0%)  	vmovdqa	160(%rsi),%ymm13
    .         
  832 (0.0%)  	vpcmpeqd	%ymm1,%ymm5,%ymm9
  832 (0.0%)  	vpcmpeqd	%ymm1,%ymm10,%ymm14
    .         
  832 (0.0%)  	vpaddd	%ymm0,%ymm5,%ymm5
  832 (0.0%)  	vpaddd	%ymm0,%ymm10,%ymm10
  832 (0.0%)  	leaq	192(%rsi),%rsi
    .         
  832 (0.0%)  	vpand	%ymm9,%ymm6,%ymm6
  832 (0.0%)  	vpand	%ymm9,%ymm7,%ymm7
  832 (0.0%)  	vpand	%ymm9,%ymm8,%ymm8
  832 (0.0%)  	vpand	%ymm14,%ymm11,%ymm11
  832 (0.0%)  	vpand	%ymm14,%ymm12,%ymm12
  832 (0.0%)  	vpand	%ymm14,%ymm13,%ymm13
    .         
  832 (0.0%)  	vpxor	%ymm6,%ymm2,%ymm2
  832 (0.0%)  	vpxor	%ymm7,%ymm3,%ymm3
  832 (0.0%)  	vpxor	%ymm8,%ymm4,%ymm4
  832 (0.0%)  	vpxor	%ymm11,%ymm2,%ymm2
  832 (0.0%)  	vpxor	%ymm12,%ymm3,%ymm3
  832 (0.0%)  	vpxor	%ymm13,%ymm4,%ymm4
    .         
  832 (0.0%)  	decq	%rax
  832 (0.0%)  	jnz	.Lselect_loop_avx2_w5
    .         
  104 (0.0%)  	vmovdqu	%ymm2,0(%rdi)
  104 (0.0%)  	vmovdqu	%ymm3,32(%rdi)
  104 (0.0%)  	vmovdqu	%ymm4,64(%rdi)
  208 (0.0%)  	vzeroupper
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .LSEH_end_ecp_nistz256_avx2_select_w5:
    .         .size	ecp_nistz256_avx2_select_w5,.-ecp_nistz256_avx2_select_w5
    .         
    .         
    .         
    .         .globl	ecp_nistz256_avx2_select_w7
    .         .hidden ecp_nistz256_avx2_select_w7
    .         .type	ecp_nistz256_avx2_select_w7,@function
    .         .align	32
    .         ecp_nistz256_avx2_select_w7:
    .         .cfi_startproc	
    .         .Lavx2_select_w7:
   74 (0.0%)  	vzeroupper
   74 (0.0%)  	vmovdqa	.LThree(%rip),%ymm0
    .         
   74 (0.0%)  	vpxor	%ymm2,%ymm2,%ymm2
   74 (0.0%)  	vpxor	%ymm3,%ymm3,%ymm3
    .         
   74 (0.0%)  	vmovdqa	.LOne(%rip),%ymm4
   74 (0.0%)  	vmovdqa	.LTwo(%rip),%ymm8
   74 (0.0%)  	vmovdqa	.LThree(%rip),%ymm12
    .         
   74 (0.0%)  	vmovd	%edx,%xmm1
   74 (0.0%)  	vpermd	%ymm1,%ymm2,%ymm1
    .         
    .         
   74 (0.0%)  	movq	$21,%rax
    .         .Lselect_loop_avx2_w7:
    .         
1,554 (0.0%)  	vmovdqa	0(%rsi),%ymm5
1,554 (0.0%)  	vmovdqa	32(%rsi),%ymm6
    .         
1,554 (0.0%)  	vmovdqa	64(%rsi),%ymm9
1,554 (0.0%)  	vmovdqa	96(%rsi),%ymm10
    .         
1,554 (0.0%)  	vmovdqa	128(%rsi),%ymm13
1,554 (0.0%)  	vmovdqa	160(%rsi),%ymm14
    .         
1,554 (0.0%)  	vpcmpeqd	%ymm1,%ymm4,%ymm7
1,554 (0.0%)  	vpcmpeqd	%ymm1,%ymm8,%ymm11
1,554 (0.0%)  	vpcmpeqd	%ymm1,%ymm12,%ymm15
    .         
1,554 (0.0%)  	vpaddd	%ymm0,%ymm4,%ymm4
1,554 (0.0%)  	vpaddd	%ymm0,%ymm8,%ymm8
1,554 (0.0%)  	vpaddd	%ymm0,%ymm12,%ymm12
1,554 (0.0%)  	leaq	192(%rsi),%rsi
    .         
1,554 (0.0%)  	vpand	%ymm7,%ymm5,%ymm5
1,554 (0.0%)  	vpand	%ymm7,%ymm6,%ymm6
1,554 (0.0%)  	vpand	%ymm11,%ymm9,%ymm9
1,554 (0.0%)  	vpand	%ymm11,%ymm10,%ymm10
1,554 (0.0%)  	vpand	%ymm15,%ymm13,%ymm13
1,554 (0.0%)  	vpand	%ymm15,%ymm14,%ymm14
    .         
1,554 (0.0%)  	vpxor	%ymm5,%ymm2,%ymm2
1,554 (0.0%)  	vpxor	%ymm6,%ymm3,%ymm3
1,554 (0.0%)  	vpxor	%ymm9,%ymm2,%ymm2
1,554 (0.0%)  	vpxor	%ymm10,%ymm3,%ymm3
1,554 (0.0%)  	vpxor	%ymm13,%ymm2,%ymm2
1,554 (0.0%)  	vpxor	%ymm14,%ymm3,%ymm3
    .         
1,554 (0.0%)  	decq	%rax
1,554 (0.0%)  	jnz	.Lselect_loop_avx2_w7
    .         
    .         
   74 (0.0%)  	vmovdqa	0(%rsi),%ymm5
   74 (0.0%)  	vmovdqa	32(%rsi),%ymm6
    .         
   74 (0.0%)  	vpcmpeqd	%ymm1,%ymm4,%ymm7
    .         
   74 (0.0%)  	vpand	%ymm7,%ymm5,%ymm5
   74 (0.0%)  	vpand	%ymm7,%ymm6,%ymm6
    .         
   74 (0.0%)  	vpxor	%ymm5,%ymm2,%ymm2
   74 (0.0%)  	vpxor	%ymm6,%ymm3,%ymm3
    .         
   74 (0.0%)  	vmovdqu	%ymm2,0(%rdi)
   74 (0.0%)  	vmovdqu	%ymm3,32(%rdi)
  148 (0.0%)  	vzeroupper
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .LSEH_end_ecp_nistz256_avx2_select_w7:
    .         .size	ecp_nistz256_avx2_select_w7,.-ecp_nistz256_avx2_select_w7
    .         .type	__ecp_nistz256_add_toq,@function
    .         .align	32
    .         __ecp_nistz256_add_toq:
    .         .cfi_startproc	
1,052 (0.0%)  	xorq	%r11,%r11
1,052 (0.0%)  	addq	0(%rbx),%r12
1,052 (0.0%)  	adcq	8(%rbx),%r13
1,052 (0.0%)  	movq	%r12,%rax
1,052 (0.0%)  	adcq	16(%rbx),%r8
1,052 (0.0%)  	adcq	24(%rbx),%r9
1,052 (0.0%)  	movq	%r13,%rbp
1,052 (0.0%)  	adcq	$0,%r11
    .         
1,052 (0.0%)  	subq	$-1,%r12
1,052 (0.0%)  	movq	%r8,%rcx
1,052 (0.0%)  	sbbq	%r14,%r13
1,052 (0.0%)  	sbbq	$0,%r8
1,052 (0.0%)  	movq	%r9,%r10
1,052 (0.0%)  	sbbq	%r15,%r9
1,052 (0.0%)  	sbbq	$0,%r11
    .         
1,052 (0.0%)  	cmovcq	%rax,%r12
1,052 (0.0%)  	cmovcq	%rbp,%r13
1,052 (0.0%)  	movq	%r12,0(%rdi)
1,052 (0.0%)  	cmovcq	%rcx,%r8
1,052 (0.0%)  	movq	%r13,8(%rdi)
1,052 (0.0%)  	cmovcq	%r10,%r9
1,052 (0.0%)  	movq	%r8,16(%rdi)
2,104 (0.0%)  	movq	%r9,24(%rdi)
    .         
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	__ecp_nistz256_add_toq,.-__ecp_nistz256_add_toq
    .         
    .         .type	__ecp_nistz256_sub_fromq,@function
    .         .align	32
    .         __ecp_nistz256_sub_fromq:
    .         .cfi_startproc	
2,330 (0.0%)  	subq	0(%rbx),%r12
2,330 (0.0%)  	sbbq	8(%rbx),%r13
2,330 (0.0%)  	movq	%r12,%rax
2,330 (0.0%)  	sbbq	16(%rbx),%r8
2,330 (0.0%)  	sbbq	24(%rbx),%r9
2,330 (0.0%)  	movq	%r13,%rbp
2,330 (0.0%)  	sbbq	%r11,%r11
    .         
2,330 (0.0%)  	addq	$-1,%r12
2,330 (0.0%)  	movq	%r8,%rcx
2,330 (0.0%)  	adcq	%r14,%r13
2,330 (0.0%)  	adcq	$0,%r8
2,330 (0.0%)  	movq	%r9,%r10
2,330 (0.0%)  	adcq	%r15,%r9
2,330 (0.0%)  	testq	%r11,%r11
    .         
2,330 (0.0%)  	cmovzq	%rax,%r12
2,330 (0.0%)  	cmovzq	%rbp,%r13
2,330 (0.0%)  	movq	%r12,0(%rdi)
2,330 (0.0%)  	cmovzq	%rcx,%r8
2,330 (0.0%)  	movq	%r13,8(%rdi)
2,330 (0.0%)  	cmovzq	%r10,%r9
2,330 (0.0%)  	movq	%r8,16(%rdi)
4,660 (0.0%)  	movq	%r9,24(%rdi)
    .         
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	__ecp_nistz256_sub_fromq,.-__ecp_nistz256_sub_fromq
    .         
    .         .type	__ecp_nistz256_subq,@function
    .         .align	32
    .         __ecp_nistz256_subq:
    .         .cfi_startproc	
  902 (0.0%)  	subq	%r12,%rax
  902 (0.0%)  	sbbq	%r13,%rbp
  902 (0.0%)  	movq	%rax,%r12
  902 (0.0%)  	sbbq	%r8,%rcx
  902 (0.0%)  	sbbq	%r9,%r10
  902 (0.0%)  	movq	%rbp,%r13
  902 (0.0%)  	sbbq	%r11,%r11
    .         
  902 (0.0%)  	addq	$-1,%rax
  902 (0.0%)  	movq	%rcx,%r8
  902 (0.0%)  	adcq	%r14,%rbp
  902 (0.0%)  	adcq	$0,%rcx
  902 (0.0%)  	movq	%r10,%r9
  902 (0.0%)  	adcq	%r15,%r10
  902 (0.0%)  	testq	%r11,%r11
    .         
  902 (0.0%)  	cmovnzq	%rax,%r12
  902 (0.0%)  	cmovnzq	%rbp,%r13
  902 (0.0%)  	cmovnzq	%rcx,%r8
1,804 (0.0%)  	cmovnzq	%r10,%r9
    .         
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	__ecp_nistz256_subq,.-__ecp_nistz256_subq
    .         
    .         .type	__ecp_nistz256_mul_by_2q,@function
    .         .align	32
    .         __ecp_nistz256_mul_by_2q:
    .         .cfi_startproc	
2,104 (0.0%)  	xorq	%r11,%r11
2,104 (0.0%)  	addq	%r12,%r12
2,104 (0.0%)  	adcq	%r13,%r13
2,104 (0.0%)  	movq	%r12,%rax
2,104 (0.0%)  	adcq	%r8,%r8
2,104 (0.0%)  	adcq	%r9,%r9
2,104 (0.0%)  	movq	%r13,%rbp
2,104 (0.0%)  	adcq	$0,%r11
    .         
2,104 (0.0%)  	subq	$-1,%r12
2,104 (0.0%)  	movq	%r8,%rcx
2,104 (0.0%)  	sbbq	%r14,%r13
2,104 (0.0%)  	sbbq	$0,%r8
2,104 (0.0%)  	movq	%r9,%r10
2,104 (0.0%)  	sbbq	%r15,%r9
2,104 (0.0%)  	sbbq	$0,%r11
    .         
2,104 (0.0%)  	cmovcq	%rax,%r12
2,104 (0.0%)  	cmovcq	%rbp,%r13
2,104 (0.0%)  	movq	%r12,0(%rdi)
2,104 (0.0%)  	cmovcq	%rcx,%r8
2,104 (0.0%)  	movq	%r13,8(%rdi)
2,104 (0.0%)  	cmovcq	%r10,%r9
2,104 (0.0%)  	movq	%r8,16(%rdi)
4,208 (0.0%)  	movq	%r9,24(%rdi)
    .         
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	__ecp_nistz256_mul_by_2q,.-__ecp_nistz256_mul_by_2q
    .         .globl	ecp_nistz256_point_double
    .         .hidden ecp_nistz256_point_double
    .         .type	ecp_nistz256_point_double,@function
    .         .align	32
    .         ecp_nistz256_point_double:
    .         .cfi_startproc	
  526 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
  526 (0.0%)  	movq	8(%rcx),%rcx
  526 (0.0%)  	andl	$0x80100,%ecx
  526 (0.0%)  	cmpl	$0x80100,%ecx
  526 (0.0%)  	je	.Lpoint_doublex
  526 (0.0%)  	pushq	%rbp
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbp,-16
  526 (0.0%)  	pushq	%rbx
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbx,-24
  526 (0.0%)  	pushq	%r12
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r12,-32
  526 (0.0%)  	pushq	%r13
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r13,-40
  526 (0.0%)  	pushq	%r14
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r14,-48
  526 (0.0%)  	pushq	%r15
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r15,-56
  526 (0.0%)  	subq	$160+8,%rsp
    .         .cfi_adjust_cfa_offset	32*5+8
    .         .Lpoint_doubleq_body:
    .         
    .         .Lpoint_double_shortcutq:
  526 (0.0%)  	movdqu	0(%rsi),%xmm0
  526 (0.0%)  	movq	%rsi,%rbx
  526 (0.0%)  	movdqu	16(%rsi),%xmm1
  526 (0.0%)  	movq	32+0(%rsi),%r12
  526 (0.0%)  	movq	32+8(%rsi),%r13
  526 (0.0%)  	movq	32+16(%rsi),%r8
  526 (0.0%)  	movq	32+24(%rsi),%r9
  526 (0.0%)  	movq	.Lpoly+8(%rip),%r14
  526 (0.0%)  	movq	.Lpoly+24(%rip),%r15
  526 (0.0%)  	movdqa	%xmm0,96(%rsp)
  526 (0.0%)  	movdqa	%xmm1,96+16(%rsp)
  526 (0.0%)  	leaq	32(%rdi),%r10
2,104 (0.0%)  	leaq	64(%rdi),%r11
    .         .byte	102,72,15,110,199
    .         .byte	102,73,15,110,202
    .         .byte	102,73,15,110,211
    .         
  526 (0.0%)  	leaq	0(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_mul_by_2q
    .         
  526 (0.0%)  	movq	64+0(%rsi),%rax
  526 (0.0%)  	movq	64+8(%rsi),%r14
  526 (0.0%)  	movq	64+16(%rsi),%r15
  526 (0.0%)  	movq	64+24(%rsi),%r8
  526 (0.0%)  	leaq	64-0(%rsi),%rsi
  526 (0.0%)  	leaq	64(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
  526 (0.0%)  	movq	0+0(%rsp),%rax
  526 (0.0%)  	movq	8+0(%rsp),%r14
  526 (0.0%)  	leaq	0+0(%rsp),%rsi
  526 (0.0%)  	movq	16+0(%rsp),%r15
  526 (0.0%)  	movq	24+0(%rsp),%r8
  526 (0.0%)  	leaq	0(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
  526 (0.0%)  	movq	32(%rbx),%rax
  526 (0.0%)  	movq	64+0(%rbx),%r9
  526 (0.0%)  	movq	64+8(%rbx),%r10
  526 (0.0%)  	movq	64+16(%rbx),%r11
  526 (0.0%)  	movq	64+24(%rbx),%r12
  526 (0.0%)  	leaq	64-0(%rbx),%rsi
1,052 (0.0%)  	leaq	32(%rbx),%rbx
    .         .byte	102,72,15,126,215
  526 (0.0%)  	call	__ecp_nistz256_mul_montq
  526 (0.0%)  	call	__ecp_nistz256_mul_by_2q
    .         
  526 (0.0%)  	movq	96+0(%rsp),%r12
  526 (0.0%)  	movq	96+8(%rsp),%r13
  526 (0.0%)  	leaq	64(%rsp),%rbx
  526 (0.0%)  	movq	96+16(%rsp),%r8
  526 (0.0%)  	movq	96+24(%rsp),%r9
  526 (0.0%)  	leaq	32(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_add_toq
    .         
  526 (0.0%)  	movq	96+0(%rsp),%r12
  526 (0.0%)  	movq	96+8(%rsp),%r13
  526 (0.0%)  	leaq	64(%rsp),%rbx
  526 (0.0%)  	movq	96+16(%rsp),%r8
  526 (0.0%)  	movq	96+24(%rsp),%r9
  526 (0.0%)  	leaq	64(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
  526 (0.0%)  	movq	0+0(%rsp),%rax
  526 (0.0%)  	movq	8+0(%rsp),%r14
  526 (0.0%)  	leaq	0+0(%rsp),%rsi
  526 (0.0%)  	movq	16+0(%rsp),%r15
1,052 (0.0%)  	movq	24+0(%rsp),%r8
    .         .byte	102,72,15,126,207
  526 (0.0%)  	call	__ecp_nistz256_sqr_montq
  526 (0.0%)  	xorq	%r9,%r9
  526 (0.0%)  	movq	%r12,%rax
  526 (0.0%)  	addq	$-1,%r12
  526 (0.0%)  	movq	%r13,%r10
  526 (0.0%)  	adcq	%rsi,%r13
  526 (0.0%)  	movq	%r14,%rcx
  526 (0.0%)  	adcq	$0,%r14
  526 (0.0%)  	movq	%r15,%r8
  526 (0.0%)  	adcq	%rbp,%r15
  526 (0.0%)  	adcq	$0,%r9
  526 (0.0%)  	xorq	%rsi,%rsi
  526 (0.0%)  	testq	$1,%rax
    .         
  526 (0.0%)  	cmovzq	%rax,%r12
  526 (0.0%)  	cmovzq	%r10,%r13
  526 (0.0%)  	cmovzq	%rcx,%r14
  526 (0.0%)  	cmovzq	%r8,%r15
  526 (0.0%)  	cmovzq	%rsi,%r9
    .         
  526 (0.0%)  	movq	%r13,%rax
  526 (0.0%)  	shrq	$1,%r12
  526 (0.0%)  	shlq	$63,%rax
  526 (0.0%)  	movq	%r14,%r10
  526 (0.0%)  	shrq	$1,%r13
  526 (0.0%)  	orq	%rax,%r12
  526 (0.0%)  	shlq	$63,%r10
  526 (0.0%)  	movq	%r15,%rcx
  526 (0.0%)  	shrq	$1,%r14
  526 (0.0%)  	orq	%r10,%r13
  526 (0.0%)  	shlq	$63,%rcx
  526 (0.0%)  	movq	%r12,0(%rdi)
  526 (0.0%)  	shrq	$1,%r15
  526 (0.0%)  	movq	%r13,8(%rdi)
  526 (0.0%)  	shlq	$63,%r9
  526 (0.0%)  	orq	%rcx,%r14
  526 (0.0%)  	orq	%r9,%r15
  526 (0.0%)  	movq	%r14,16(%rdi)
  526 (0.0%)  	movq	%r15,24(%rdi)
  526 (0.0%)  	movq	64(%rsp),%rax
  526 (0.0%)  	leaq	64(%rsp),%rbx
  526 (0.0%)  	movq	0+32(%rsp),%r9
  526 (0.0%)  	movq	8+32(%rsp),%r10
  526 (0.0%)  	leaq	0+32(%rsp),%rsi
  526 (0.0%)  	movq	16+32(%rsp),%r11
  526 (0.0%)  	movq	24+32(%rsp),%r12
  526 (0.0%)  	leaq	32(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  526 (0.0%)  	leaq	128(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_mul_by_2q
    .         
  526 (0.0%)  	leaq	32(%rsp),%rbx
  526 (0.0%)  	leaq	32(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_add_toq
    .         
  526 (0.0%)  	movq	96(%rsp),%rax
  526 (0.0%)  	leaq	96(%rsp),%rbx
  526 (0.0%)  	movq	0+0(%rsp),%r9
  526 (0.0%)  	movq	8+0(%rsp),%r10
  526 (0.0%)  	leaq	0+0(%rsp),%rsi
  526 (0.0%)  	movq	16+0(%rsp),%r11
  526 (0.0%)  	movq	24+0(%rsp),%r12
  526 (0.0%)  	leaq	0(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  526 (0.0%)  	leaq	128(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_mul_by_2q
    .         
  526 (0.0%)  	movq	0+32(%rsp),%rax
  526 (0.0%)  	movq	8+32(%rsp),%r14
  526 (0.0%)  	leaq	0+32(%rsp),%rsi
  526 (0.0%)  	movq	16+32(%rsp),%r15
1,052 (0.0%)  	movq	24+32(%rsp),%r8
    .         .byte	102,72,15,126,199
  526 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
  526 (0.0%)  	leaq	128(%rsp),%rbx
  526 (0.0%)  	movq	%r14,%r8
  526 (0.0%)  	movq	%r15,%r9
  526 (0.0%)  	movq	%rsi,%r14
  526 (0.0%)  	movq	%rbp,%r15
  526 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
  526 (0.0%)  	movq	0+0(%rsp),%rax
  526 (0.0%)  	movq	0+8(%rsp),%rbp
  526 (0.0%)  	movq	0+16(%rsp),%rcx
  526 (0.0%)  	movq	0+24(%rsp),%r10
  526 (0.0%)  	leaq	0(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_subq
    .         
  526 (0.0%)  	movq	32(%rsp),%rax
  526 (0.0%)  	leaq	32(%rsp),%rbx
  526 (0.0%)  	movq	%r12,%r14
  526 (0.0%)  	xorl	%ecx,%ecx
  526 (0.0%)  	movq	%r12,0+0(%rsp)
  526 (0.0%)  	movq	%r13,%r10
  526 (0.0%)  	movq	%r13,0+8(%rsp)
  526 (0.0%)  	cmovzq	%r8,%r11
  526 (0.0%)  	movq	%r8,0+16(%rsp)
  526 (0.0%)  	leaq	0-0(%rsp),%rsi
  526 (0.0%)  	cmovzq	%r9,%r12
  526 (0.0%)  	movq	%r9,0+24(%rsp)
  526 (0.0%)  	movq	%r14,%r9
  526 (0.0%)  	leaq	0(%rsp),%rdi
1,578 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
    .         .byte	102,72,15,126,203
    .         .byte	102,72,15,126,207
  526 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
  526 (0.0%)  	leaq	160+56(%rsp),%rsi
    .         .cfi_def_cfa	%rsi,8
  526 (0.0%)  	movq	-48(%rsi),%r15
    .         .cfi_restore	%r15
  526 (0.0%)  	movq	-40(%rsi),%r14
    .         .cfi_restore	%r14
  526 (0.0%)  	movq	-32(%rsi),%r13
    .         .cfi_restore	%r13
  526 (0.0%)  	movq	-24(%rsi),%r12
    .         .cfi_restore	%r12
  526 (0.0%)  	movq	-16(%rsi),%rbx
    .         .cfi_restore	%rbx
  526 (0.0%)  	movq	-8(%rsi),%rbp
    .         .cfi_restore	%rbp
1,052 (0.0%)  	leaq	(%rsi),%rsp
    .         .cfi_def_cfa_register	%rsp
    .         .Lpoint_doubleq_epilogue:
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	ecp_nistz256_point_double,.-ecp_nistz256_point_double
    .         .globl	ecp_nistz256_point_add
    .         .hidden ecp_nistz256_point_add
    .         .type	ecp_nistz256_point_add,@function
    .         .align	32
    .         ecp_nistz256_point_add:
    .         .cfi_startproc	
  116 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
  116 (0.0%)  	movq	8(%rcx),%rcx
  116 (0.0%)  	andl	$0x80100,%ecx
  116 (0.0%)  	cmpl	$0x80100,%ecx
  116 (0.0%)  	je	.Lpoint_addx
  116 (0.0%)  	pushq	%rbp
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbp,-16
  116 (0.0%)  	pushq	%rbx
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbx,-24
  116 (0.0%)  	pushq	%r12
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r12,-32
  116 (0.0%)  	pushq	%r13
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r13,-40
  116 (0.0%)  	pushq	%r14
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r14,-48
  116 (0.0%)  	pushq	%r15
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r15,-56
  116 (0.0%)  	subq	$576+8,%rsp
    .         .cfi_adjust_cfa_offset	32*18+8
    .         .Lpoint_addq_body:
    .         
  116 (0.0%)  	movdqu	0(%rsi),%xmm0
  116 (0.0%)  	movdqu	16(%rsi),%xmm1
  116 (0.0%)  	movdqu	32(%rsi),%xmm2
  116 (0.0%)  	movdqu	48(%rsi),%xmm3
  116 (0.0%)  	movdqu	64(%rsi),%xmm4
  116 (0.0%)  	movdqu	80(%rsi),%xmm5
  116 (0.0%)  	movq	%rsi,%rbx
  116 (0.0%)  	movq	%rdx,%rsi
  116 (0.0%)  	movdqa	%xmm0,384(%rsp)
  116 (0.0%)  	movdqa	%xmm1,384+16(%rsp)
  116 (0.0%)  	movdqa	%xmm2,416(%rsp)
  116 (0.0%)  	movdqa	%xmm3,416+16(%rsp)
  116 (0.0%)  	movdqa	%xmm4,448(%rsp)
  116 (0.0%)  	movdqa	%xmm5,448+16(%rsp)
  116 (0.0%)  	por	%xmm4,%xmm5
    .         
  116 (0.0%)  	movdqu	0(%rsi),%xmm0
  116 (0.0%)  	pshufd	$0xb1,%xmm5,%xmm3
  116 (0.0%)  	movdqu	16(%rsi),%xmm1
  116 (0.0%)  	movdqu	32(%rsi),%xmm2
  116 (0.0%)  	por	%xmm3,%xmm5
  116 (0.0%)  	movdqu	48(%rsi),%xmm3
  116 (0.0%)  	movq	64+0(%rsi),%rax
  116 (0.0%)  	movq	64+8(%rsi),%r14
  116 (0.0%)  	movq	64+16(%rsi),%r15
  116 (0.0%)  	movq	64+24(%rsi),%r8
  116 (0.0%)  	movdqa	%xmm0,480(%rsp)
  116 (0.0%)  	pshufd	$0x1e,%xmm5,%xmm4
  116 (0.0%)  	movdqa	%xmm1,480+16(%rsp)
  116 (0.0%)  	movdqu	64(%rsi),%xmm0
  116 (0.0%)  	movdqu	80(%rsi),%xmm1
  116 (0.0%)  	movdqa	%xmm2,512(%rsp)
  116 (0.0%)  	movdqa	%xmm3,512+16(%rsp)
  116 (0.0%)  	por	%xmm4,%xmm5
  116 (0.0%)  	pxor	%xmm4,%xmm4
  232 (0.0%)  	por	%xmm0,%xmm1
    .         .byte	102,72,15,110,199
    .         
  116 (0.0%)  	leaq	64-0(%rsi),%rsi
  116 (0.0%)  	movq	%rax,544+0(%rsp)
  116 (0.0%)  	movq	%r14,544+8(%rsp)
  116 (0.0%)  	movq	%r15,544+16(%rsp)
  116 (0.0%)  	movq	%r8,544+24(%rsp)
  116 (0.0%)  	leaq	96(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
  116 (0.0%)  	pcmpeqd	%xmm4,%xmm5
  116 (0.0%)  	pshufd	$0xb1,%xmm1,%xmm4
  116 (0.0%)  	por	%xmm1,%xmm4
  116 (0.0%)  	pshufd	$0,%xmm5,%xmm5
  116 (0.0%)  	pshufd	$0x1e,%xmm4,%xmm3
  116 (0.0%)  	por	%xmm3,%xmm4
  116 (0.0%)  	pxor	%xmm3,%xmm3
  116 (0.0%)  	pcmpeqd	%xmm3,%xmm4
  116 (0.0%)  	pshufd	$0,%xmm4,%xmm4
  116 (0.0%)  	movq	64+0(%rbx),%rax
  116 (0.0%)  	movq	64+8(%rbx),%r14
  116 (0.0%)  	movq	64+16(%rbx),%r15
  232 (0.0%)  	movq	64+24(%rbx),%r8
    .         .byte	102,72,15,110,203
    .         
  116 (0.0%)  	leaq	64-0(%rbx),%rsi
  116 (0.0%)  	leaq	32(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
  116 (0.0%)  	movq	544(%rsp),%rax
  116 (0.0%)  	leaq	544(%rsp),%rbx
  116 (0.0%)  	movq	0+96(%rsp),%r9
  116 (0.0%)  	movq	8+96(%rsp),%r10
  116 (0.0%)  	leaq	0+96(%rsp),%rsi
  116 (0.0%)  	movq	16+96(%rsp),%r11
  116 (0.0%)  	movq	24+96(%rsp),%r12
  116 (0.0%)  	leaq	224(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	448(%rsp),%rax
  116 (0.0%)  	leaq	448(%rsp),%rbx
  116 (0.0%)  	movq	0+32(%rsp),%r9
  116 (0.0%)  	movq	8+32(%rsp),%r10
  116 (0.0%)  	leaq	0+32(%rsp),%rsi
  116 (0.0%)  	movq	16+32(%rsp),%r11
  116 (0.0%)  	movq	24+32(%rsp),%r12
  116 (0.0%)  	leaq	256(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	416(%rsp),%rax
  116 (0.0%)  	leaq	416(%rsp),%rbx
  116 (0.0%)  	movq	0+224(%rsp),%r9
  116 (0.0%)  	movq	8+224(%rsp),%r10
  116 (0.0%)  	leaq	0+224(%rsp),%rsi
  116 (0.0%)  	movq	16+224(%rsp),%r11
  116 (0.0%)  	movq	24+224(%rsp),%r12
  116 (0.0%)  	leaq	224(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	512(%rsp),%rax
  116 (0.0%)  	leaq	512(%rsp),%rbx
  116 (0.0%)  	movq	0+256(%rsp),%r9
  116 (0.0%)  	movq	8+256(%rsp),%r10
  116 (0.0%)  	leaq	0+256(%rsp),%rsi
  116 (0.0%)  	movq	16+256(%rsp),%r11
  116 (0.0%)  	movq	24+256(%rsp),%r12
  116 (0.0%)  	leaq	256(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	leaq	224(%rsp),%rbx
  116 (0.0%)  	leaq	64(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
  116 (0.0%)  	orq	%r13,%r12
  116 (0.0%)  	movdqa	%xmm4,%xmm2
  116 (0.0%)  	orq	%r8,%r12
  116 (0.0%)  	orq	%r9,%r12
  232 (0.0%)  	por	%xmm5,%xmm2
    .         .byte	102,73,15,110,220
    .         
  116 (0.0%)  	movq	384(%rsp),%rax
  116 (0.0%)  	leaq	384(%rsp),%rbx
  116 (0.0%)  	movq	0+96(%rsp),%r9
  116 (0.0%)  	movq	8+96(%rsp),%r10
  116 (0.0%)  	leaq	0+96(%rsp),%rsi
  116 (0.0%)  	movq	16+96(%rsp),%r11
  116 (0.0%)  	movq	24+96(%rsp),%r12
  116 (0.0%)  	leaq	160(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	480(%rsp),%rax
  116 (0.0%)  	leaq	480(%rsp),%rbx
  116 (0.0%)  	movq	0+32(%rsp),%r9
  116 (0.0%)  	movq	8+32(%rsp),%r10
  116 (0.0%)  	leaq	0+32(%rsp),%rsi
  116 (0.0%)  	movq	16+32(%rsp),%r11
  116 (0.0%)  	movq	24+32(%rsp),%r12
  116 (0.0%)  	leaq	192(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	leaq	160(%rsp),%rbx
  116 (0.0%)  	leaq	0(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
  116 (0.0%)  	orq	%r13,%r12
  116 (0.0%)  	orq	%r8,%r12
  348 (0.0%)  	orq	%r9,%r12
    .         
    .         .byte	102,73,15,126,208
    .         .byte	102,73,15,126,217
  232 (0.0%)  	orq	%r8,%r12
    .         .byte	0x3e
    .         	jnz	.Ladd_proceedq
    .         
    .         
    .         
    .         	testq	%r9,%r9
    .         	jz	.Ladd_doubleq
    .         
-- line 2831 ----------------------------------------
-- line 2850 ----------------------------------------
    .         .byte	102,72,15,126,199
    .         	addq	$416,%rsp
    .         .cfi_adjust_cfa_offset	-416
    .         	jmp	.Lpoint_double_shortcutq
    .         .cfi_adjust_cfa_offset	416
    .         
    .         .align	32
    .         .Ladd_proceedq:
  116 (0.0%)  	movq	0+64(%rsp),%rax
  116 (0.0%)  	movq	8+64(%rsp),%r14
  116 (0.0%)  	leaq	0+64(%rsp),%rsi
  116 (0.0%)  	movq	16+64(%rsp),%r15
  116 (0.0%)  	movq	24+64(%rsp),%r8
  116 (0.0%)  	leaq	96(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
  116 (0.0%)  	movq	448(%rsp),%rax
  116 (0.0%)  	leaq	448(%rsp),%rbx
  116 (0.0%)  	movq	0+0(%rsp),%r9
  116 (0.0%)  	movq	8+0(%rsp),%r10
  116 (0.0%)  	leaq	0+0(%rsp),%rsi
  116 (0.0%)  	movq	16+0(%rsp),%r11
  116 (0.0%)  	movq	24+0(%rsp),%r12
  116 (0.0%)  	leaq	352(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	0+0(%rsp),%rax
  116 (0.0%)  	movq	8+0(%rsp),%r14
  116 (0.0%)  	leaq	0+0(%rsp),%rsi
  116 (0.0%)  	movq	16+0(%rsp),%r15
  116 (0.0%)  	movq	24+0(%rsp),%r8
  116 (0.0%)  	leaq	32(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
  116 (0.0%)  	movq	544(%rsp),%rax
  116 (0.0%)  	leaq	544(%rsp),%rbx
  116 (0.0%)  	movq	0+352(%rsp),%r9
  116 (0.0%)  	movq	8+352(%rsp),%r10
  116 (0.0%)  	leaq	0+352(%rsp),%rsi
  116 (0.0%)  	movq	16+352(%rsp),%r11
  116 (0.0%)  	movq	24+352(%rsp),%r12
  116 (0.0%)  	leaq	352(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	0(%rsp),%rax
  116 (0.0%)  	leaq	0(%rsp),%rbx
  116 (0.0%)  	movq	0+32(%rsp),%r9
  116 (0.0%)  	movq	8+32(%rsp),%r10
  116 (0.0%)  	leaq	0+32(%rsp),%rsi
  116 (0.0%)  	movq	16+32(%rsp),%r11
  116 (0.0%)  	movq	24+32(%rsp),%r12
  116 (0.0%)  	leaq	128(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	160(%rsp),%rax
  116 (0.0%)  	leaq	160(%rsp),%rbx
  116 (0.0%)  	movq	0+32(%rsp),%r9
  116 (0.0%)  	movq	8+32(%rsp),%r10
  116 (0.0%)  	leaq	0+32(%rsp),%rsi
  116 (0.0%)  	movq	16+32(%rsp),%r11
  116 (0.0%)  	movq	24+32(%rsp),%r12
  116 (0.0%)  	leaq	192(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
    .         
    .         
    .         
  116 (0.0%)  	xorq	%r11,%r11
  116 (0.0%)  	addq	%r12,%r12
  116 (0.0%)  	leaq	96(%rsp),%rsi
  116 (0.0%)  	adcq	%r13,%r13
  116 (0.0%)  	movq	%r12,%rax
  116 (0.0%)  	adcq	%r8,%r8
  116 (0.0%)  	adcq	%r9,%r9
  116 (0.0%)  	movq	%r13,%rbp
  116 (0.0%)  	adcq	$0,%r11
    .         
  116 (0.0%)  	subq	$-1,%r12
  116 (0.0%)  	movq	%r8,%rcx
  116 (0.0%)  	sbbq	%r14,%r13
  116 (0.0%)  	sbbq	$0,%r8
  116 (0.0%)  	movq	%r9,%r10
  116 (0.0%)  	sbbq	%r15,%r9
  116 (0.0%)  	sbbq	$0,%r11
    .         
  116 (0.0%)  	cmovcq	%rax,%r12
  116 (0.0%)  	movq	0(%rsi),%rax
  116 (0.0%)  	cmovcq	%rbp,%r13
  116 (0.0%)  	movq	8(%rsi),%rbp
  116 (0.0%)  	cmovcq	%rcx,%r8
  116 (0.0%)  	movq	16(%rsi),%rcx
  116 (0.0%)  	cmovcq	%r10,%r9
  116 (0.0%)  	movq	24(%rsi),%r10
    .         
  116 (0.0%)  	call	__ecp_nistz256_subq
    .         
  116 (0.0%)  	leaq	128(%rsp),%rbx
  116 (0.0%)  	leaq	288(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
  116 (0.0%)  	movq	192+0(%rsp),%rax
  116 (0.0%)  	movq	192+8(%rsp),%rbp
  116 (0.0%)  	movq	192+16(%rsp),%rcx
  116 (0.0%)  	movq	192+24(%rsp),%r10
  116 (0.0%)  	leaq	320(%rsp),%rdi
    .         
  116 (0.0%)  	call	__ecp_nistz256_subq
    .         
  116 (0.0%)  	movq	%r12,0(%rdi)
  116 (0.0%)  	movq	%r13,8(%rdi)
  116 (0.0%)  	movq	%r8,16(%rdi)
  116 (0.0%)  	movq	%r9,24(%rdi)
  116 (0.0%)  	movq	128(%rsp),%rax
  116 (0.0%)  	leaq	128(%rsp),%rbx
  116 (0.0%)  	movq	0+224(%rsp),%r9
  116 (0.0%)  	movq	8+224(%rsp),%r10
  116 (0.0%)  	leaq	0+224(%rsp),%rsi
  116 (0.0%)  	movq	16+224(%rsp),%r11
  116 (0.0%)  	movq	24+224(%rsp),%r12
  116 (0.0%)  	leaq	256(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	320(%rsp),%rax
  116 (0.0%)  	leaq	320(%rsp),%rbx
  116 (0.0%)  	movq	0+64(%rsp),%r9
  116 (0.0%)  	movq	8+64(%rsp),%r10
  116 (0.0%)  	leaq	0+64(%rsp),%rsi
  116 (0.0%)  	movq	16+64(%rsp),%r11
  116 (0.0%)  	movq	24+64(%rsp),%r12
  116 (0.0%)  	leaq	320(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	leaq	256(%rsp),%rbx
  116 (0.0%)  	leaq	320(%rsp),%rdi
  232 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
    .         .byte	102,72,15,126,199
    .         
  116 (0.0%)  	movdqa	%xmm5,%xmm0
  116 (0.0%)  	movdqa	%xmm5,%xmm1
  116 (0.0%)  	pandn	352(%rsp),%xmm0
  116 (0.0%)  	movdqa	%xmm5,%xmm2
  116 (0.0%)  	pandn	352+16(%rsp),%xmm1
  116 (0.0%)  	movdqa	%xmm5,%xmm3
  116 (0.0%)  	pand	544(%rsp),%xmm2
  116 (0.0%)  	pand	544+16(%rsp),%xmm3
  116 (0.0%)  	por	%xmm0,%xmm2
  116 (0.0%)  	por	%xmm1,%xmm3
    .         
  116 (0.0%)  	movdqa	%xmm4,%xmm0
  116 (0.0%)  	movdqa	%xmm4,%xmm1
  116 (0.0%)  	pandn	%xmm2,%xmm0
  116 (0.0%)  	movdqa	%xmm4,%xmm2
  116 (0.0%)  	pandn	%xmm3,%xmm1
  116 (0.0%)  	movdqa	%xmm4,%xmm3
  116 (0.0%)  	pand	448(%rsp),%xmm2
  116 (0.0%)  	pand	448+16(%rsp),%xmm3
  116 (0.0%)  	por	%xmm0,%xmm2
  116 (0.0%)  	por	%xmm1,%xmm3
  116 (0.0%)  	movdqu	%xmm2,64(%rdi)
  116 (0.0%)  	movdqu	%xmm3,80(%rdi)
    .         
  116 (0.0%)  	movdqa	%xmm5,%xmm0
  116 (0.0%)  	movdqa	%xmm5,%xmm1
  116 (0.0%)  	pandn	288(%rsp),%xmm0
  116 (0.0%)  	movdqa	%xmm5,%xmm2
  116 (0.0%)  	pandn	288+16(%rsp),%xmm1
  116 (0.0%)  	movdqa	%xmm5,%xmm3
  116 (0.0%)  	pand	480(%rsp),%xmm2
  116 (0.0%)  	pand	480+16(%rsp),%xmm3
  116 (0.0%)  	por	%xmm0,%xmm2
  116 (0.0%)  	por	%xmm1,%xmm3
    .         
  116 (0.0%)  	movdqa	%xmm4,%xmm0
  116 (0.0%)  	movdqa	%xmm4,%xmm1
  116 (0.0%)  	pandn	%xmm2,%xmm0
  116 (0.0%)  	movdqa	%xmm4,%xmm2
  116 (0.0%)  	pandn	%xmm3,%xmm1
  116 (0.0%)  	movdqa	%xmm4,%xmm3
  116 (0.0%)  	pand	384(%rsp),%xmm2
  116 (0.0%)  	pand	384+16(%rsp),%xmm3
  116 (0.0%)  	por	%xmm0,%xmm2
  116 (0.0%)  	por	%xmm1,%xmm3
  116 (0.0%)  	movdqu	%xmm2,0(%rdi)
  116 (0.0%)  	movdqu	%xmm3,16(%rdi)
    .         
  116 (0.0%)  	movdqa	%xmm5,%xmm0
  116 (0.0%)  	movdqa	%xmm5,%xmm1
  116 (0.0%)  	pandn	320(%rsp),%xmm0
  116 (0.0%)  	movdqa	%xmm5,%xmm2
  116 (0.0%)  	pandn	320+16(%rsp),%xmm1
  116 (0.0%)  	movdqa	%xmm5,%xmm3
  116 (0.0%)  	pand	512(%rsp),%xmm2
  116 (0.0%)  	pand	512+16(%rsp),%xmm3
  116 (0.0%)  	por	%xmm0,%xmm2
  116 (0.0%)  	por	%xmm1,%xmm3
    .         
  116 (0.0%)  	movdqa	%xmm4,%xmm0
  116 (0.0%)  	movdqa	%xmm4,%xmm1
  116 (0.0%)  	pandn	%xmm2,%xmm0
  116 (0.0%)  	movdqa	%xmm4,%xmm2
  116 (0.0%)  	pandn	%xmm3,%xmm1
  116 (0.0%)  	movdqa	%xmm4,%xmm3
  116 (0.0%)  	pand	416(%rsp),%xmm2
  116 (0.0%)  	pand	416+16(%rsp),%xmm3
  116 (0.0%)  	por	%xmm0,%xmm2
  116 (0.0%)  	por	%xmm1,%xmm3
  116 (0.0%)  	movdqu	%xmm2,32(%rdi)
  116 (0.0%)  	movdqu	%xmm3,48(%rdi)
    .         
    .         .Ladd_doneq:
  116 (0.0%)  	leaq	576+56(%rsp),%rsi
    .         .cfi_def_cfa	%rsi,8
  116 (0.0%)  	movq	-48(%rsi),%r15
    .         .cfi_restore	%r15
  116 (0.0%)  	movq	-40(%rsi),%r14
    .         .cfi_restore	%r14
  116 (0.0%)  	movq	-32(%rsi),%r13
    .         .cfi_restore	%r13
  116 (0.0%)  	movq	-24(%rsi),%r12
    .         .cfi_restore	%r12
  116 (0.0%)  	movq	-16(%rsi),%rbx
    .         .cfi_restore	%rbx
  116 (0.0%)  	movq	-8(%rsi),%rbp
    .         .cfi_restore	%rbp
  232 (0.0%)  	leaq	(%rsi),%rsp
    .         .cfi_def_cfa_register	%rsp
    .         .Lpoint_addq_epilogue:
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	ecp_nistz256_point_add,.-ecp_nistz256_point_add
    .         .globl	ecp_nistz256_point_add_affine
    .         .hidden ecp_nistz256_point_add_affine
    .         .type	ecp_nistz256_point_add_affine,@function
    .         .align	32
    .         ecp_nistz256_point_add_affine:
    .         .cfi_startproc	
   72 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
   72 (0.0%)  	movq	8(%rcx),%rcx
   72 (0.0%)  	andl	$0x80100,%ecx
   72 (0.0%)  	cmpl	$0x80100,%ecx
   72 (0.0%)  	je	.Lpoint_add_affinex
   72 (0.0%)  	pushq	%rbp
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbp,-16
   72 (0.0%)  	pushq	%rbx
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbx,-24
   72 (0.0%)  	pushq	%r12
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r12,-32
   72 (0.0%)  	pushq	%r13
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r13,-40
   72 (0.0%)  	pushq	%r14
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r14,-48
   72 (0.0%)  	pushq	%r15
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r15,-56
   72 (0.0%)  	subq	$480+8,%rsp
    .         .cfi_adjust_cfa_offset	32*15+8
    .         .Ladd_affineq_body:
    .         
   72 (0.0%)  	movdqu	0(%rsi),%xmm0
   72 (0.0%)  	movq	%rdx,%rbx
   72 (0.0%)  	movdqu	16(%rsi),%xmm1
   72 (0.0%)  	movdqu	32(%rsi),%xmm2
   72 (0.0%)  	movdqu	48(%rsi),%xmm3
   72 (0.0%)  	movdqu	64(%rsi),%xmm4
   72 (0.0%)  	movdqu	80(%rsi),%xmm5
   72 (0.0%)  	movq	64+0(%rsi),%rax
   72 (0.0%)  	movq	64+8(%rsi),%r14
   72 (0.0%)  	movq	64+16(%rsi),%r15
   72 (0.0%)  	movq	64+24(%rsi),%r8
   72 (0.0%)  	movdqa	%xmm0,320(%rsp)
   72 (0.0%)  	movdqa	%xmm1,320+16(%rsp)
   72 (0.0%)  	movdqa	%xmm2,352(%rsp)
   72 (0.0%)  	movdqa	%xmm3,352+16(%rsp)
   72 (0.0%)  	movdqa	%xmm4,384(%rsp)
   72 (0.0%)  	movdqa	%xmm5,384+16(%rsp)
   72 (0.0%)  	por	%xmm4,%xmm5
    .         
   72 (0.0%)  	movdqu	0(%rbx),%xmm0
   72 (0.0%)  	pshufd	$0xb1,%xmm5,%xmm3
   72 (0.0%)  	movdqu	16(%rbx),%xmm1
   72 (0.0%)  	movdqu	32(%rbx),%xmm2
   72 (0.0%)  	por	%xmm3,%xmm5
   72 (0.0%)  	movdqu	48(%rbx),%xmm3
   72 (0.0%)  	movdqa	%xmm0,416(%rsp)
   72 (0.0%)  	pshufd	$0x1e,%xmm5,%xmm4
   72 (0.0%)  	movdqa	%xmm1,416+16(%rsp)
  144 (0.0%)  	por	%xmm0,%xmm1
    .         .byte	102,72,15,110,199
   72 (0.0%)  	movdqa	%xmm2,448(%rsp)
   72 (0.0%)  	movdqa	%xmm3,448+16(%rsp)
   72 (0.0%)  	por	%xmm2,%xmm3
   72 (0.0%)  	por	%xmm4,%xmm5
   72 (0.0%)  	pxor	%xmm4,%xmm4
   72 (0.0%)  	por	%xmm1,%xmm3
    .         
   72 (0.0%)  	leaq	64-0(%rsi),%rsi
   72 (0.0%)  	leaq	32(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
   72 (0.0%)  	pcmpeqd	%xmm4,%xmm5
   72 (0.0%)  	pshufd	$0xb1,%xmm3,%xmm4
   72 (0.0%)  	movq	0(%rbx),%rax
    .         
   72 (0.0%)  	movq	%r12,%r9
   72 (0.0%)  	por	%xmm3,%xmm4
   72 (0.0%)  	pshufd	$0,%xmm5,%xmm5
   72 (0.0%)  	pshufd	$0x1e,%xmm4,%xmm3
   72 (0.0%)  	movq	%r13,%r10
   72 (0.0%)  	por	%xmm3,%xmm4
   72 (0.0%)  	pxor	%xmm3,%xmm3
   72 (0.0%)  	movq	%r14,%r11
   72 (0.0%)  	pcmpeqd	%xmm3,%xmm4
   72 (0.0%)  	pshufd	$0,%xmm4,%xmm4
    .         
   72 (0.0%)  	leaq	32-0(%rsp),%rsi
   72 (0.0%)  	movq	%r15,%r12
   72 (0.0%)  	leaq	0(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
   72 (0.0%)  	leaq	320(%rsp),%rbx
   72 (0.0%)  	leaq	64(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
   72 (0.0%)  	movq	384(%rsp),%rax
   72 (0.0%)  	leaq	384(%rsp),%rbx
   72 (0.0%)  	movq	0+32(%rsp),%r9
   72 (0.0%)  	movq	8+32(%rsp),%r10
   72 (0.0%)  	leaq	0+32(%rsp),%rsi
   72 (0.0%)  	movq	16+32(%rsp),%r11
   72 (0.0%)  	movq	24+32(%rsp),%r12
   72 (0.0%)  	leaq	32(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
   72 (0.0%)  	movq	384(%rsp),%rax
   72 (0.0%)  	leaq	384(%rsp),%rbx
   72 (0.0%)  	movq	0+64(%rsp),%r9
   72 (0.0%)  	movq	8+64(%rsp),%r10
   72 (0.0%)  	leaq	0+64(%rsp),%rsi
   72 (0.0%)  	movq	16+64(%rsp),%r11
   72 (0.0%)  	movq	24+64(%rsp),%r12
   72 (0.0%)  	leaq	288(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
   72 (0.0%)  	movq	448(%rsp),%rax
   72 (0.0%)  	leaq	448(%rsp),%rbx
   72 (0.0%)  	movq	0+32(%rsp),%r9
   72 (0.0%)  	movq	8+32(%rsp),%r10
   72 (0.0%)  	leaq	0+32(%rsp),%rsi
   72 (0.0%)  	movq	16+32(%rsp),%r11
   72 (0.0%)  	movq	24+32(%rsp),%r12
   72 (0.0%)  	leaq	32(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
   72 (0.0%)  	leaq	352(%rsp),%rbx
   72 (0.0%)  	leaq	96(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
   72 (0.0%)  	movq	0+64(%rsp),%rax
   72 (0.0%)  	movq	8+64(%rsp),%r14
   72 (0.0%)  	leaq	0+64(%rsp),%rsi
   72 (0.0%)  	movq	16+64(%rsp),%r15
   72 (0.0%)  	movq	24+64(%rsp),%r8
   72 (0.0%)  	leaq	128(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
   72 (0.0%)  	movq	0+96(%rsp),%rax
   72 (0.0%)  	movq	8+96(%rsp),%r14
   72 (0.0%)  	leaq	0+96(%rsp),%rsi
   72 (0.0%)  	movq	16+96(%rsp),%r15
   72 (0.0%)  	movq	24+96(%rsp),%r8
   72 (0.0%)  	leaq	192(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
   72 (0.0%)  	movq	128(%rsp),%rax
   72 (0.0%)  	leaq	128(%rsp),%rbx
   72 (0.0%)  	movq	0+64(%rsp),%r9
   72 (0.0%)  	movq	8+64(%rsp),%r10
   72 (0.0%)  	leaq	0+64(%rsp),%rsi
   72 (0.0%)  	movq	16+64(%rsp),%r11
   72 (0.0%)  	movq	24+64(%rsp),%r12
   72 (0.0%)  	leaq	160(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
   72 (0.0%)  	movq	320(%rsp),%rax
   72 (0.0%)  	leaq	320(%rsp),%rbx
   72 (0.0%)  	movq	0+128(%rsp),%r9
   72 (0.0%)  	movq	8+128(%rsp),%r10
   72 (0.0%)  	leaq	0+128(%rsp),%rsi
   72 (0.0%)  	movq	16+128(%rsp),%r11
   72 (0.0%)  	movq	24+128(%rsp),%r12
   72 (0.0%)  	leaq	0(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
    .         
    .         
    .         
   72 (0.0%)  	xorq	%r11,%r11
   72 (0.0%)  	addq	%r12,%r12
   72 (0.0%)  	leaq	192(%rsp),%rsi
   72 (0.0%)  	adcq	%r13,%r13
   72 (0.0%)  	movq	%r12,%rax
   72 (0.0%)  	adcq	%r8,%r8
   72 (0.0%)  	adcq	%r9,%r9
   72 (0.0%)  	movq	%r13,%rbp
   72 (0.0%)  	adcq	$0,%r11
    .         
   72 (0.0%)  	subq	$-1,%r12
   72 (0.0%)  	movq	%r8,%rcx
   72 (0.0%)  	sbbq	%r14,%r13
   72 (0.0%)  	sbbq	$0,%r8
   72 (0.0%)  	movq	%r9,%r10
   72 (0.0%)  	sbbq	%r15,%r9
   72 (0.0%)  	sbbq	$0,%r11
    .         
   72 (0.0%)  	cmovcq	%rax,%r12
   72 (0.0%)  	movq	0(%rsi),%rax
   72 (0.0%)  	cmovcq	%rbp,%r13
   72 (0.0%)  	movq	8(%rsi),%rbp
   72 (0.0%)  	cmovcq	%rcx,%r8
   72 (0.0%)  	movq	16(%rsi),%rcx
   72 (0.0%)  	cmovcq	%r10,%r9
   72 (0.0%)  	movq	24(%rsi),%r10
    .         
   72 (0.0%)  	call	__ecp_nistz256_subq
    .         
   72 (0.0%)  	leaq	160(%rsp),%rbx
   72 (0.0%)  	leaq	224(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
   72 (0.0%)  	movq	0+0(%rsp),%rax
   72 (0.0%)  	movq	0+8(%rsp),%rbp
   72 (0.0%)  	movq	0+16(%rsp),%rcx
   72 (0.0%)  	movq	0+24(%rsp),%r10
   72 (0.0%)  	leaq	64(%rsp),%rdi
    .         
   72 (0.0%)  	call	__ecp_nistz256_subq
    .         
   72 (0.0%)  	movq	%r12,0(%rdi)
   72 (0.0%)  	movq	%r13,8(%rdi)
   72 (0.0%)  	movq	%r8,16(%rdi)
   72 (0.0%)  	movq	%r9,24(%rdi)
   72 (0.0%)  	movq	352(%rsp),%rax
   72 (0.0%)  	leaq	352(%rsp),%rbx
   72 (0.0%)  	movq	0+160(%rsp),%r9
   72 (0.0%)  	movq	8+160(%rsp),%r10
   72 (0.0%)  	leaq	0+160(%rsp),%rsi
   72 (0.0%)  	movq	16+160(%rsp),%r11
   72 (0.0%)  	movq	24+160(%rsp),%r12
   72 (0.0%)  	leaq	32(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
   72 (0.0%)  	movq	96(%rsp),%rax
   72 (0.0%)  	leaq	96(%rsp),%rbx
   72 (0.0%)  	movq	0+64(%rsp),%r9
   72 (0.0%)  	movq	8+64(%rsp),%r10
   72 (0.0%)  	leaq	0+64(%rsp),%rsi
   72 (0.0%)  	movq	16+64(%rsp),%r11
   72 (0.0%)  	movq	24+64(%rsp),%r12
   72 (0.0%)  	leaq	64(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
   72 (0.0%)  	leaq	32(%rsp),%rbx
   72 (0.0%)  	leaq	256(%rsp),%rdi
  144 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
    .         .byte	102,72,15,126,199
    .         
   72 (0.0%)  	movdqa	%xmm5,%xmm0
   72 (0.0%)  	movdqa	%xmm5,%xmm1
   72 (0.0%)  	pandn	288(%rsp),%xmm0
   72 (0.0%)  	movdqa	%xmm5,%xmm2
   72 (0.0%)  	pandn	288+16(%rsp),%xmm1
   72 (0.0%)  	movdqa	%xmm5,%xmm3
   72 (0.0%)  	pand	.LONE_mont(%rip),%xmm2
   72 (0.0%)  	pand	.LONE_mont+16(%rip),%xmm3
   72 (0.0%)  	por	%xmm0,%xmm2
   72 (0.0%)  	por	%xmm1,%xmm3
    .         
   72 (0.0%)  	movdqa	%xmm4,%xmm0
   72 (0.0%)  	movdqa	%xmm4,%xmm1
   72 (0.0%)  	pandn	%xmm2,%xmm0
   72 (0.0%)  	movdqa	%xmm4,%xmm2
   72 (0.0%)  	pandn	%xmm3,%xmm1
   72 (0.0%)  	movdqa	%xmm4,%xmm3
   72 (0.0%)  	pand	384(%rsp),%xmm2
   72 (0.0%)  	pand	384+16(%rsp),%xmm3
   72 (0.0%)  	por	%xmm0,%xmm2
   72 (0.0%)  	por	%xmm1,%xmm3
   72 (0.0%)  	movdqu	%xmm2,64(%rdi)
   72 (0.0%)  	movdqu	%xmm3,80(%rdi)
    .         
   72 (0.0%)  	movdqa	%xmm5,%xmm0
   72 (0.0%)  	movdqa	%xmm5,%xmm1
   72 (0.0%)  	pandn	224(%rsp),%xmm0
   72 (0.0%)  	movdqa	%xmm5,%xmm2
   72 (0.0%)  	pandn	224+16(%rsp),%xmm1
   72 (0.0%)  	movdqa	%xmm5,%xmm3
   72 (0.0%)  	pand	416(%rsp),%xmm2
   72 (0.0%)  	pand	416+16(%rsp),%xmm3
   72 (0.0%)  	por	%xmm0,%xmm2
   72 (0.0%)  	por	%xmm1,%xmm3
    .         
   72 (0.0%)  	movdqa	%xmm4,%xmm0
   72 (0.0%)  	movdqa	%xmm4,%xmm1
   72 (0.0%)  	pandn	%xmm2,%xmm0
   72 (0.0%)  	movdqa	%xmm4,%xmm2
   72 (0.0%)  	pandn	%xmm3,%xmm1
   72 (0.0%)  	movdqa	%xmm4,%xmm3
   72 (0.0%)  	pand	320(%rsp),%xmm2
   72 (0.0%)  	pand	320+16(%rsp),%xmm3
   72 (0.0%)  	por	%xmm0,%xmm2
   72 (0.0%)  	por	%xmm1,%xmm3
   72 (0.0%)  	movdqu	%xmm2,0(%rdi)
   72 (0.0%)  	movdqu	%xmm3,16(%rdi)
    .         
   72 (0.0%)  	movdqa	%xmm5,%xmm0
   72 (0.0%)  	movdqa	%xmm5,%xmm1
   72 (0.0%)  	pandn	256(%rsp),%xmm0
   72 (0.0%)  	movdqa	%xmm5,%xmm2
   72 (0.0%)  	pandn	256+16(%rsp),%xmm1
   72 (0.0%)  	movdqa	%xmm5,%xmm3
   72 (0.0%)  	pand	448(%rsp),%xmm2
   72 (0.0%)  	pand	448+16(%rsp),%xmm3
   72 (0.0%)  	por	%xmm0,%xmm2
   72 (0.0%)  	por	%xmm1,%xmm3
    .         
   72 (0.0%)  	movdqa	%xmm4,%xmm0
   72 (0.0%)  	movdqa	%xmm4,%xmm1
   72 (0.0%)  	pandn	%xmm2,%xmm0
   72 (0.0%)  	movdqa	%xmm4,%xmm2
   72 (0.0%)  	pandn	%xmm3,%xmm1
   72 (0.0%)  	movdqa	%xmm4,%xmm3
   72 (0.0%)  	pand	352(%rsp),%xmm2
   72 (0.0%)  	pand	352+16(%rsp),%xmm3
   72 (0.0%)  	por	%xmm0,%xmm2
   72 (0.0%)  	por	%xmm1,%xmm3
   72 (0.0%)  	movdqu	%xmm2,32(%rdi)
   72 (0.0%)  	movdqu	%xmm3,48(%rdi)
    .         
   72 (0.0%)  	leaq	480+56(%rsp),%rsi
    .         .cfi_def_cfa	%rsi,8
   72 (0.0%)  	movq	-48(%rsi),%r15
    .         .cfi_restore	%r15
   72 (0.0%)  	movq	-40(%rsi),%r14
    .         .cfi_restore	%r14
   72 (0.0%)  	movq	-32(%rsi),%r13
    .         .cfi_restore	%r13
   72 (0.0%)  	movq	-24(%rsi),%r12
    .         .cfi_restore	%r12
   72 (0.0%)  	movq	-16(%rsi),%rbx
    .         .cfi_restore	%rbx
   72 (0.0%)  	movq	-8(%rsi),%rbp
    .         .cfi_restore	%rbp
  144 (0.0%)  	leaq	(%rsi),%rsp
    .         .cfi_def_cfa_register	%rsp
    .         .Ladd_affineq_epilogue:
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	ecp_nistz256_point_add_affine,.-ecp_nistz256_point_add_affine
    .         .type	__ecp_nistz256_add_tox,@function
    .         .align	32
    .         __ecp_nistz256_add_tox:
-- line 3417 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha1-x86_64.S
--------------------------------------------------------------------------------
Ir_______ 

-- line 9 ----------------------------------------
 .         .hidden OPENSSL_ia32cap_P
 .         
 .         .globl	sha1_block_data_order
 .         .hidden sha1_block_data_order
 .         .type	sha1_block_data_order,@function
 .         .align	16
 .         sha1_block_data_order:
 .         .cfi_startproc	
16 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r10
16 (0.0%)  	movl	0(%r10),%r9d
16 (0.0%)  	movl	4(%r10),%r8d
16 (0.0%)  	movl	8(%r10),%r10d
16 (0.0%)  	testl	$512,%r8d
16 (0.0%)  	jz	.Lialu
16 (0.0%)  	testl	$536870912,%r10d
16 (0.0%)  	jnz	_shaext_shortcut
16 (0.0%)  	andl	$296,%r10d
16 (0.0%)  	cmpl	$296,%r10d
16 (0.0%)  	je	_avx2_shortcut
 .         	andl	$268435456,%r8d
 .         	andl	$1073741824,%r9d
 .         	orl	%r9d,%r8d
 .         	cmpl	$1342177280,%r8d
 .         	je	_avx_shortcut
 .         	jmp	_ssse3_shortcut
 .         
 .         .align	16
-- line 35 ----------------------------------------
-- line 3750 ----------------------------------------
 .         	.byte	0xf3,0xc3
 .         .cfi_endproc	
 .         .size	sha1_block_data_order_avx,.-sha1_block_data_order_avx
 .         .type	sha1_block_data_order_avx2,@function
 .         .align	16
 .         sha1_block_data_order_avx2:
 .         _avx2_shortcut:
 .         .cfi_startproc	
16 (0.0%)  	movq	%rsp,%r11
 .         .cfi_def_cfa_register	%r11
16 (0.0%)  	pushq	%rbx
 .         .cfi_offset	%rbx,-16
16 (0.0%)  	pushq	%rbp
 .         .cfi_offset	%rbp,-24
16 (0.0%)  	pushq	%r12
 .         .cfi_offset	%r12,-32
16 (0.0%)  	pushq	%r13
 .         .cfi_offset	%r13,-40
16 (0.0%)  	pushq	%r14
 .         .cfi_offset	%r14,-48
16 (0.0%)  	vzeroupper
16 (0.0%)  	movq	%rdi,%r8
16 (0.0%)  	movq	%rsi,%r9
16 (0.0%)  	movq	%rdx,%r10
 .         
16 (0.0%)  	leaq	-640(%rsp),%rsp
16 (0.0%)  	shlq	$6,%r10
16 (0.0%)  	leaq	64(%r9),%r13
16 (0.0%)  	andq	$-128,%rsp
16 (0.0%)  	addq	%r9,%r10
16 (0.0%)  	leaq	K_XX_XX+64(%rip),%r14
 .         
16 (0.0%)  	movl	0(%r8),%eax
16 (0.0%)  	cmpq	%r10,%r13
16 (0.0%)  	cmovaeq	%r9,%r13
16 (0.0%)  	movl	4(%r8),%ebp
16 (0.0%)  	movl	8(%r8),%ecx
16 (0.0%)  	movl	12(%r8),%edx
16 (0.0%)  	movl	16(%r8),%esi
16 (0.0%)  	vmovdqu	64(%r14),%ymm6
 .         
16 (0.0%)  	vmovdqu	(%r9),%xmm0
16 (0.0%)  	vmovdqu	16(%r9),%xmm1
16 (0.0%)  	vmovdqu	32(%r9),%xmm2
16 (0.0%)  	vmovdqu	48(%r9),%xmm3
16 (0.0%)  	leaq	64(%r9),%r9
16 (0.0%)  	vinserti128	$1,(%r13),%ymm0,%ymm0
16 (0.0%)  	vinserti128	$1,16(%r13),%ymm1,%ymm1
16 (0.0%)  	vpshufb	%ymm6,%ymm0,%ymm0
16 (0.0%)  	vinserti128	$1,32(%r13),%ymm2,%ymm2
16 (0.0%)  	vpshufb	%ymm6,%ymm1,%ymm1
16 (0.0%)  	vinserti128	$1,48(%r13),%ymm3,%ymm3
16 (0.0%)  	vpshufb	%ymm6,%ymm2,%ymm2
16 (0.0%)  	vmovdqu	-64(%r14),%ymm11
16 (0.0%)  	vpshufb	%ymm6,%ymm3,%ymm3
 .         
16 (0.0%)  	vpaddd	%ymm11,%ymm0,%ymm4
16 (0.0%)  	vpaddd	%ymm11,%ymm1,%ymm5
16 (0.0%)  	vmovdqu	%ymm4,0(%rsp)
16 (0.0%)  	vpaddd	%ymm11,%ymm2,%ymm6
16 (0.0%)  	vmovdqu	%ymm5,32(%rsp)
16 (0.0%)  	vpaddd	%ymm11,%ymm3,%ymm7
16 (0.0%)  	vmovdqu	%ymm6,64(%rsp)
16 (0.0%)  	vmovdqu	%ymm7,96(%rsp)
16 (0.0%)  	vpalignr	$8,%ymm0,%ymm1,%ymm4
16 (0.0%)  	vpsrldq	$4,%ymm3,%ymm8
16 (0.0%)  	vpxor	%ymm0,%ymm4,%ymm4
16 (0.0%)  	vpxor	%ymm2,%ymm8,%ymm8
16 (0.0%)  	vpxor	%ymm8,%ymm4,%ymm4
16 (0.0%)  	vpsrld	$31,%ymm4,%ymm8
16 (0.0%)  	vpslldq	$12,%ymm4,%ymm10
16 (0.0%)  	vpaddd	%ymm4,%ymm4,%ymm4
16 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
16 (0.0%)  	vpor	%ymm8,%ymm4,%ymm4
16 (0.0%)  	vpslld	$2,%ymm10,%ymm10
16 (0.0%)  	vpxor	%ymm9,%ymm4,%ymm4
16 (0.0%)  	vpxor	%ymm10,%ymm4,%ymm4
16 (0.0%)  	vpaddd	%ymm11,%ymm4,%ymm9
16 (0.0%)  	vmovdqu	%ymm9,128(%rsp)
16 (0.0%)  	vpalignr	$8,%ymm1,%ymm2,%ymm5
16 (0.0%)  	vpsrldq	$4,%ymm4,%ymm8
16 (0.0%)  	vpxor	%ymm1,%ymm5,%ymm5
16 (0.0%)  	vpxor	%ymm3,%ymm8,%ymm8
16 (0.0%)  	vpxor	%ymm8,%ymm5,%ymm5
16 (0.0%)  	vpsrld	$31,%ymm5,%ymm8
16 (0.0%)  	vmovdqu	-32(%r14),%ymm11
16 (0.0%)  	vpslldq	$12,%ymm5,%ymm10
16 (0.0%)  	vpaddd	%ymm5,%ymm5,%ymm5
16 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
16 (0.0%)  	vpor	%ymm8,%ymm5,%ymm5
16 (0.0%)  	vpslld	$2,%ymm10,%ymm10
16 (0.0%)  	vpxor	%ymm9,%ymm5,%ymm5
16 (0.0%)  	vpxor	%ymm10,%ymm5,%ymm5
16 (0.0%)  	vpaddd	%ymm11,%ymm5,%ymm9
16 (0.0%)  	vmovdqu	%ymm9,160(%rsp)
16 (0.0%)  	vpalignr	$8,%ymm2,%ymm3,%ymm6
16 (0.0%)  	vpsrldq	$4,%ymm5,%ymm8
16 (0.0%)  	vpxor	%ymm2,%ymm6,%ymm6
16 (0.0%)  	vpxor	%ymm4,%ymm8,%ymm8
16 (0.0%)  	vpxor	%ymm8,%ymm6,%ymm6
16 (0.0%)  	vpsrld	$31,%ymm6,%ymm8
16 (0.0%)  	vpslldq	$12,%ymm6,%ymm10
16 (0.0%)  	vpaddd	%ymm6,%ymm6,%ymm6
16 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
16 (0.0%)  	vpor	%ymm8,%ymm6,%ymm6
16 (0.0%)  	vpslld	$2,%ymm10,%ymm10
16 (0.0%)  	vpxor	%ymm9,%ymm6,%ymm6
16 (0.0%)  	vpxor	%ymm10,%ymm6,%ymm6
16 (0.0%)  	vpaddd	%ymm11,%ymm6,%ymm9
16 (0.0%)  	vmovdqu	%ymm9,192(%rsp)
16 (0.0%)  	vpalignr	$8,%ymm3,%ymm4,%ymm7
16 (0.0%)  	vpsrldq	$4,%ymm6,%ymm8
16 (0.0%)  	vpxor	%ymm3,%ymm7,%ymm7
16 (0.0%)  	vpxor	%ymm5,%ymm8,%ymm8
16 (0.0%)  	vpxor	%ymm8,%ymm7,%ymm7
16 (0.0%)  	vpsrld	$31,%ymm7,%ymm8
16 (0.0%)  	vpslldq	$12,%ymm7,%ymm10
16 (0.0%)  	vpaddd	%ymm7,%ymm7,%ymm7
16 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
16 (0.0%)  	vpor	%ymm8,%ymm7,%ymm7
16 (0.0%)  	vpslld	$2,%ymm10,%ymm10
16 (0.0%)  	vpxor	%ymm9,%ymm7,%ymm7
16 (0.0%)  	vpxor	%ymm10,%ymm7,%ymm7
16 (0.0%)  	vpaddd	%ymm11,%ymm7,%ymm9
16 (0.0%)  	vmovdqu	%ymm9,224(%rsp)
16 (0.0%)  	leaq	128(%rsp),%r13
16 (0.0%)  	jmp	.Loop_avx2
 .         .align	32
 .         .Loop_avx2:
26 (0.0%)  	rorxl	$2,%ebp,%ebx
26 (0.0%)  	andnl	%edx,%ebp,%edi
26 (0.0%)  	andl	%ecx,%ebp
26 (0.0%)  	xorl	%edi,%ebp
26 (0.0%)  	jmp	.Lalign32_1
 .         .align	32
 .         .Lalign32_1:
26 (0.0%)  	vpalignr	$8,%ymm6,%ymm7,%ymm8
26 (0.0%)  	vpxor	%ymm4,%ymm0,%ymm0
26 (0.0%)  	addl	-128(%r13),%esi
26 (0.0%)  	andnl	%ecx,%eax,%edi
26 (0.0%)  	vpxor	%ymm1,%ymm0,%ymm0
26 (0.0%)  	addl	%ebp,%esi
26 (0.0%)  	rorxl	$27,%eax,%r12d
26 (0.0%)  	rorxl	$2,%eax,%ebp
26 (0.0%)  	vpxor	%ymm8,%ymm0,%ymm0
26 (0.0%)  	andl	%ebx,%eax
26 (0.0%)  	addl	%r12d,%esi
26 (0.0%)  	xorl	%edi,%eax
26 (0.0%)  	vpsrld	$30,%ymm0,%ymm8
26 (0.0%)  	vpslld	$2,%ymm0,%ymm0
26 (0.0%)  	addl	-124(%r13),%edx
26 (0.0%)  	andnl	%ebx,%esi,%edi
26 (0.0%)  	addl	%eax,%edx
26 (0.0%)  	rorxl	$27,%esi,%r12d
26 (0.0%)  	rorxl	$2,%esi,%eax
26 (0.0%)  	andl	%ebp,%esi
26 (0.0%)  	vpor	%ymm8,%ymm0,%ymm0
26 (0.0%)  	addl	%r12d,%edx
26 (0.0%)  	xorl	%edi,%esi
26 (0.0%)  	addl	-120(%r13),%ecx
26 (0.0%)  	andnl	%ebp,%edx,%edi
26 (0.0%)  	vpaddd	%ymm11,%ymm0,%ymm9
26 (0.0%)  	addl	%esi,%ecx
26 (0.0%)  	rorxl	$27,%edx,%r12d
26 (0.0%)  	rorxl	$2,%edx,%esi
26 (0.0%)  	andl	%eax,%edx
26 (0.0%)  	vmovdqu	%ymm9,256(%rsp)
26 (0.0%)  	addl	%r12d,%ecx
26 (0.0%)  	xorl	%edi,%edx
26 (0.0%)  	addl	-116(%r13),%ebx
26 (0.0%)  	andnl	%eax,%ecx,%edi
26 (0.0%)  	addl	%edx,%ebx
26 (0.0%)  	rorxl	$27,%ecx,%r12d
26 (0.0%)  	rorxl	$2,%ecx,%edx
26 (0.0%)  	andl	%esi,%ecx
26 (0.0%)  	addl	%r12d,%ebx
26 (0.0%)  	xorl	%edi,%ecx
26 (0.0%)  	addl	-96(%r13),%ebp
26 (0.0%)  	andnl	%esi,%ebx,%edi
26 (0.0%)  	addl	%ecx,%ebp
26 (0.0%)  	rorxl	$27,%ebx,%r12d
26 (0.0%)  	rorxl	$2,%ebx,%ecx
26 (0.0%)  	andl	%edx,%ebx
26 (0.0%)  	addl	%r12d,%ebp
26 (0.0%)  	xorl	%edi,%ebx
26 (0.0%)  	vpalignr	$8,%ymm7,%ymm0,%ymm8
26 (0.0%)  	vpxor	%ymm5,%ymm1,%ymm1
26 (0.0%)  	addl	-92(%r13),%eax
26 (0.0%)  	andnl	%edx,%ebp,%edi
26 (0.0%)  	vpxor	%ymm2,%ymm1,%ymm1
26 (0.0%)  	addl	%ebx,%eax
26 (0.0%)  	rorxl	$27,%ebp,%r12d
26 (0.0%)  	rorxl	$2,%ebp,%ebx
26 (0.0%)  	vpxor	%ymm8,%ymm1,%ymm1
26 (0.0%)  	andl	%ecx,%ebp
26 (0.0%)  	addl	%r12d,%eax
26 (0.0%)  	xorl	%edi,%ebp
26 (0.0%)  	vpsrld	$30,%ymm1,%ymm8
26 (0.0%)  	vpslld	$2,%ymm1,%ymm1
26 (0.0%)  	addl	-88(%r13),%esi
26 (0.0%)  	andnl	%ecx,%eax,%edi
26 (0.0%)  	addl	%ebp,%esi
26 (0.0%)  	rorxl	$27,%eax,%r12d
26 (0.0%)  	rorxl	$2,%eax,%ebp
26 (0.0%)  	andl	%ebx,%eax
26 (0.0%)  	vpor	%ymm8,%ymm1,%ymm1
26 (0.0%)  	addl	%r12d,%esi
26 (0.0%)  	xorl	%edi,%eax
26 (0.0%)  	addl	-84(%r13),%edx
26 (0.0%)  	andnl	%ebx,%esi,%edi
26 (0.0%)  	vpaddd	%ymm11,%ymm1,%ymm9
26 (0.0%)  	addl	%eax,%edx
26 (0.0%)  	rorxl	$27,%esi,%r12d
26 (0.0%)  	rorxl	$2,%esi,%eax
26 (0.0%)  	andl	%ebp,%esi
26 (0.0%)  	vmovdqu	%ymm9,288(%rsp)
26 (0.0%)  	addl	%r12d,%edx
26 (0.0%)  	xorl	%edi,%esi
26 (0.0%)  	addl	-64(%r13),%ecx
26 (0.0%)  	andnl	%ebp,%edx,%edi
26 (0.0%)  	addl	%esi,%ecx
26 (0.0%)  	rorxl	$27,%edx,%r12d
26 (0.0%)  	rorxl	$2,%edx,%esi
26 (0.0%)  	andl	%eax,%edx
26 (0.0%)  	addl	%r12d,%ecx
26 (0.0%)  	xorl	%edi,%edx
26 (0.0%)  	addl	-60(%r13),%ebx
26 (0.0%)  	andnl	%eax,%ecx,%edi
26 (0.0%)  	addl	%edx,%ebx
26 (0.0%)  	rorxl	$27,%ecx,%r12d
26 (0.0%)  	rorxl	$2,%ecx,%edx
26 (0.0%)  	andl	%esi,%ecx
26 (0.0%)  	addl	%r12d,%ebx
26 (0.0%)  	xorl	%edi,%ecx
26 (0.0%)  	vpalignr	$8,%ymm0,%ymm1,%ymm8
26 (0.0%)  	vpxor	%ymm6,%ymm2,%ymm2
26 (0.0%)  	addl	-56(%r13),%ebp
26 (0.0%)  	andnl	%esi,%ebx,%edi
26 (0.0%)  	vpxor	%ymm3,%ymm2,%ymm2
26 (0.0%)  	vmovdqu	0(%r14),%ymm11
26 (0.0%)  	addl	%ecx,%ebp
26 (0.0%)  	rorxl	$27,%ebx,%r12d
26 (0.0%)  	rorxl	$2,%ebx,%ecx
26 (0.0%)  	vpxor	%ymm8,%ymm2,%ymm2
26 (0.0%)  	andl	%edx,%ebx
26 (0.0%)  	addl	%r12d,%ebp
26 (0.0%)  	xorl	%edi,%ebx
26 (0.0%)  	vpsrld	$30,%ymm2,%ymm8
26 (0.0%)  	vpslld	$2,%ymm2,%ymm2
26 (0.0%)  	addl	-52(%r13),%eax
26 (0.0%)  	andnl	%edx,%ebp,%edi
26 (0.0%)  	addl	%ebx,%eax
26 (0.0%)  	rorxl	$27,%ebp,%r12d
26 (0.0%)  	rorxl	$2,%ebp,%ebx
26 (0.0%)  	andl	%ecx,%ebp
26 (0.0%)  	vpor	%ymm8,%ymm2,%ymm2
26 (0.0%)  	addl	%r12d,%eax
26 (0.0%)  	xorl	%edi,%ebp
26 (0.0%)  	addl	-32(%r13),%esi
26 (0.0%)  	andnl	%ecx,%eax,%edi
26 (0.0%)  	vpaddd	%ymm11,%ymm2,%ymm9
26 (0.0%)  	addl	%ebp,%esi
26 (0.0%)  	rorxl	$27,%eax,%r12d
26 (0.0%)  	rorxl	$2,%eax,%ebp
26 (0.0%)  	andl	%ebx,%eax
26 (0.0%)  	vmovdqu	%ymm9,320(%rsp)
26 (0.0%)  	addl	%r12d,%esi
26 (0.0%)  	xorl	%edi,%eax
26 (0.0%)  	addl	-28(%r13),%edx
26 (0.0%)  	andnl	%ebx,%esi,%edi
26 (0.0%)  	addl	%eax,%edx
26 (0.0%)  	rorxl	$27,%esi,%r12d
26 (0.0%)  	rorxl	$2,%esi,%eax
26 (0.0%)  	andl	%ebp,%esi
26 (0.0%)  	addl	%r12d,%edx
26 (0.0%)  	xorl	%edi,%esi
26 (0.0%)  	addl	-24(%r13),%ecx
26 (0.0%)  	andnl	%ebp,%edx,%edi
26 (0.0%)  	addl	%esi,%ecx
26 (0.0%)  	rorxl	$27,%edx,%r12d
26 (0.0%)  	rorxl	$2,%edx,%esi
26 (0.0%)  	andl	%eax,%edx
26 (0.0%)  	addl	%r12d,%ecx
26 (0.0%)  	xorl	%edi,%edx
26 (0.0%)  	vpalignr	$8,%ymm1,%ymm2,%ymm8
26 (0.0%)  	vpxor	%ymm7,%ymm3,%ymm3
26 (0.0%)  	addl	-20(%r13),%ebx
26 (0.0%)  	andnl	%eax,%ecx,%edi
26 (0.0%)  	vpxor	%ymm4,%ymm3,%ymm3
26 (0.0%)  	addl	%edx,%ebx
26 (0.0%)  	rorxl	$27,%ecx,%r12d
26 (0.0%)  	rorxl	$2,%ecx,%edx
26 (0.0%)  	vpxor	%ymm8,%ymm3,%ymm3
26 (0.0%)  	andl	%esi,%ecx
26 (0.0%)  	addl	%r12d,%ebx
26 (0.0%)  	xorl	%edi,%ecx
26 (0.0%)  	vpsrld	$30,%ymm3,%ymm8
26 (0.0%)  	vpslld	$2,%ymm3,%ymm3
26 (0.0%)  	addl	0(%r13),%ebp
26 (0.0%)  	andnl	%esi,%ebx,%edi
26 (0.0%)  	addl	%ecx,%ebp
26 (0.0%)  	rorxl	$27,%ebx,%r12d
26 (0.0%)  	rorxl	$2,%ebx,%ecx
26 (0.0%)  	andl	%edx,%ebx
26 (0.0%)  	vpor	%ymm8,%ymm3,%ymm3
26 (0.0%)  	addl	%r12d,%ebp
26 (0.0%)  	xorl	%edi,%ebx
26 (0.0%)  	addl	4(%r13),%eax
26 (0.0%)  	andnl	%edx,%ebp,%edi
26 (0.0%)  	vpaddd	%ymm11,%ymm3,%ymm9
26 (0.0%)  	addl	%ebx,%eax
26 (0.0%)  	rorxl	$27,%ebp,%r12d
26 (0.0%)  	rorxl	$2,%ebp,%ebx
26 (0.0%)  	andl	%ecx,%ebp
26 (0.0%)  	vmovdqu	%ymm9,352(%rsp)
26 (0.0%)  	addl	%r12d,%eax
26 (0.0%)  	xorl	%edi,%ebp
26 (0.0%)  	addl	8(%r13),%esi
26 (0.0%)  	andnl	%ecx,%eax,%edi
26 (0.0%)  	addl	%ebp,%esi
26 (0.0%)  	rorxl	$27,%eax,%r12d
26 (0.0%)  	rorxl	$2,%eax,%ebp
26 (0.0%)  	andl	%ebx,%eax
26 (0.0%)  	addl	%r12d,%esi
26 (0.0%)  	xorl	%edi,%eax
26 (0.0%)  	addl	12(%r13),%edx
26 (0.0%)  	leal	(%rdx,%rax,1),%edx
26 (0.0%)  	rorxl	$27,%esi,%r12d
26 (0.0%)  	rorxl	$2,%esi,%eax
26 (0.0%)  	xorl	%ebp,%esi
26 (0.0%)  	addl	%r12d,%edx
26 (0.0%)  	xorl	%ebx,%esi
26 (0.0%)  	vpalignr	$8,%ymm2,%ymm3,%ymm8
26 (0.0%)  	vpxor	%ymm0,%ymm4,%ymm4
26 (0.0%)  	addl	32(%r13),%ecx
26 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
26 (0.0%)  	vpxor	%ymm5,%ymm4,%ymm4
26 (0.0%)  	rorxl	$27,%edx,%r12d
26 (0.0%)  	rorxl	$2,%edx,%esi
26 (0.0%)  	xorl	%eax,%edx
26 (0.0%)  	vpxor	%ymm8,%ymm4,%ymm4
26 (0.0%)  	addl	%r12d,%ecx
26 (0.0%)  	xorl	%ebp,%edx
26 (0.0%)  	addl	36(%r13),%ebx
26 (0.0%)  	vpsrld	$30,%ymm4,%ymm8
26 (0.0%)  	vpslld	$2,%ymm4,%ymm4
26 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
26 (0.0%)  	rorxl	$27,%ecx,%r12d
26 (0.0%)  	rorxl	$2,%ecx,%edx
26 (0.0%)  	xorl	%esi,%ecx
26 (0.0%)  	addl	%r12d,%ebx
26 (0.0%)  	xorl	%eax,%ecx
26 (0.0%)  	vpor	%ymm8,%ymm4,%ymm4
26 (0.0%)  	addl	40(%r13),%ebp
26 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
26 (0.0%)  	rorxl	$27,%ebx,%r12d
26 (0.0%)  	rorxl	$2,%ebx,%ecx
26 (0.0%)  	vpaddd	%ymm11,%ymm4,%ymm9
26 (0.0%)  	xorl	%edx,%ebx
26 (0.0%)  	addl	%r12d,%ebp
26 (0.0%)  	xorl	%esi,%ebx
26 (0.0%)  	addl	44(%r13),%eax
26 (0.0%)  	vmovdqu	%ymm9,384(%rsp)
26 (0.0%)  	leal	(%rax,%rbx,1),%eax
26 (0.0%)  	rorxl	$27,%ebp,%r12d
26 (0.0%)  	rorxl	$2,%ebp,%ebx
26 (0.0%)  	xorl	%ecx,%ebp
26 (0.0%)  	addl	%r12d,%eax
26 (0.0%)  	xorl	%edx,%ebp
26 (0.0%)  	addl	64(%r13),%esi
26 (0.0%)  	leal	(%rsi,%rbp,1),%esi
26 (0.0%)  	rorxl	$27,%eax,%r12d
26 (0.0%)  	rorxl	$2,%eax,%ebp
26 (0.0%)  	xorl	%ebx,%eax
26 (0.0%)  	addl	%r12d,%esi
26 (0.0%)  	xorl	%ecx,%eax
26 (0.0%)  	vpalignr	$8,%ymm3,%ymm4,%ymm8
26 (0.0%)  	vpxor	%ymm1,%ymm5,%ymm5
26 (0.0%)  	addl	68(%r13),%edx
26 (0.0%)  	leal	(%rdx,%rax,1),%edx
26 (0.0%)  	vpxor	%ymm6,%ymm5,%ymm5
26 (0.0%)  	rorxl	$27,%esi,%r12d
26 (0.0%)  	rorxl	$2,%esi,%eax
26 (0.0%)  	xorl	%ebp,%esi
26 (0.0%)  	vpxor	%ymm8,%ymm5,%ymm5
26 (0.0%)  	addl	%r12d,%edx
26 (0.0%)  	xorl	%ebx,%esi
26 (0.0%)  	addl	72(%r13),%ecx
26 (0.0%)  	vpsrld	$30,%ymm5,%ymm8
26 (0.0%)  	vpslld	$2,%ymm5,%ymm5
26 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
26 (0.0%)  	rorxl	$27,%edx,%r12d
26 (0.0%)  	rorxl	$2,%edx,%esi
26 (0.0%)  	xorl	%eax,%edx
26 (0.0%)  	addl	%r12d,%ecx
26 (0.0%)  	xorl	%ebp,%edx
26 (0.0%)  	vpor	%ymm8,%ymm5,%ymm5
26 (0.0%)  	addl	76(%r13),%ebx
26 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
26 (0.0%)  	rorxl	$27,%ecx,%r12d
26 (0.0%)  	rorxl	$2,%ecx,%edx
26 (0.0%)  	vpaddd	%ymm11,%ymm5,%ymm9
26 (0.0%)  	xorl	%esi,%ecx
26 (0.0%)  	addl	%r12d,%ebx
26 (0.0%)  	xorl	%eax,%ecx
26 (0.0%)  	addl	96(%r13),%ebp
26 (0.0%)  	vmovdqu	%ymm9,416(%rsp)
26 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
26 (0.0%)  	rorxl	$27,%ebx,%r12d
26 (0.0%)  	rorxl	$2,%ebx,%ecx
26 (0.0%)  	xorl	%edx,%ebx
26 (0.0%)  	addl	%r12d,%ebp
26 (0.0%)  	xorl	%esi,%ebx
26 (0.0%)  	addl	100(%r13),%eax
26 (0.0%)  	leal	(%rax,%rbx,1),%eax
26 (0.0%)  	rorxl	$27,%ebp,%r12d
26 (0.0%)  	rorxl	$2,%ebp,%ebx
26 (0.0%)  	xorl	%ecx,%ebp
26 (0.0%)  	addl	%r12d,%eax
26 (0.0%)  	xorl	%edx,%ebp
26 (0.0%)  	vpalignr	$8,%ymm4,%ymm5,%ymm8
26 (0.0%)  	vpxor	%ymm2,%ymm6,%ymm6
26 (0.0%)  	addl	104(%r13),%esi
26 (0.0%)  	leal	(%rsi,%rbp,1),%esi
26 (0.0%)  	vpxor	%ymm7,%ymm6,%ymm6
26 (0.0%)  	rorxl	$27,%eax,%r12d
26 (0.0%)  	rorxl	$2,%eax,%ebp
26 (0.0%)  	xorl	%ebx,%eax
26 (0.0%)  	vpxor	%ymm8,%ymm6,%ymm6
26 (0.0%)  	addl	%r12d,%esi
26 (0.0%)  	xorl	%ecx,%eax
26 (0.0%)  	addl	108(%r13),%edx
26 (0.0%)  	leaq	256(%r13),%r13
26 (0.0%)  	vpsrld	$30,%ymm6,%ymm8
26 (0.0%)  	vpslld	$2,%ymm6,%ymm6
26 (0.0%)  	leal	(%rdx,%rax,1),%edx
26 (0.0%)  	rorxl	$27,%esi,%r12d
26 (0.0%)  	rorxl	$2,%esi,%eax
26 (0.0%)  	xorl	%ebp,%esi
26 (0.0%)  	addl	%r12d,%edx
26 (0.0%)  	xorl	%ebx,%esi
26 (0.0%)  	vpor	%ymm8,%ymm6,%ymm6
26 (0.0%)  	addl	-128(%r13),%ecx
26 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
26 (0.0%)  	rorxl	$27,%edx,%r12d
26 (0.0%)  	rorxl	$2,%edx,%esi
26 (0.0%)  	vpaddd	%ymm11,%ymm6,%ymm9
26 (0.0%)  	xorl	%eax,%edx
26 (0.0%)  	addl	%r12d,%ecx
26 (0.0%)  	xorl	%ebp,%edx
26 (0.0%)  	addl	-124(%r13),%ebx
26 (0.0%)  	vmovdqu	%ymm9,448(%rsp)
26 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
26 (0.0%)  	rorxl	$27,%ecx,%r12d
26 (0.0%)  	rorxl	$2,%ecx,%edx
26 (0.0%)  	xorl	%esi,%ecx
26 (0.0%)  	addl	%r12d,%ebx
26 (0.0%)  	xorl	%eax,%ecx
26 (0.0%)  	addl	-120(%r13),%ebp
26 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
26 (0.0%)  	rorxl	$27,%ebx,%r12d
26 (0.0%)  	rorxl	$2,%ebx,%ecx
26 (0.0%)  	xorl	%edx,%ebx
26 (0.0%)  	addl	%r12d,%ebp
26 (0.0%)  	xorl	%esi,%ebx
26 (0.0%)  	vpalignr	$8,%ymm5,%ymm6,%ymm8
26 (0.0%)  	vpxor	%ymm3,%ymm7,%ymm7
26 (0.0%)  	addl	-116(%r13),%eax
26 (0.0%)  	leal	(%rax,%rbx,1),%eax
26 (0.0%)  	vpxor	%ymm0,%ymm7,%ymm7
26 (0.0%)  	vmovdqu	32(%r14),%ymm11
26 (0.0%)  	rorxl	$27,%ebp,%r12d
26 (0.0%)  	rorxl	$2,%ebp,%ebx
26 (0.0%)  	xorl	%ecx,%ebp
26 (0.0%)  	vpxor	%ymm8,%ymm7,%ymm7
26 (0.0%)  	addl	%r12d,%eax
26 (0.0%)  	xorl	%edx,%ebp
26 (0.0%)  	addl	-96(%r13),%esi
26 (0.0%)  	vpsrld	$30,%ymm7,%ymm8
26 (0.0%)  	vpslld	$2,%ymm7,%ymm7
26 (0.0%)  	leal	(%rsi,%rbp,1),%esi
26 (0.0%)  	rorxl	$27,%eax,%r12d
26 (0.0%)  	rorxl	$2,%eax,%ebp
26 (0.0%)  	xorl	%ebx,%eax
26 (0.0%)  	addl	%r12d,%esi
26 (0.0%)  	xorl	%ecx,%eax
26 (0.0%)  	vpor	%ymm8,%ymm7,%ymm7
26 (0.0%)  	addl	-92(%r13),%edx
26 (0.0%)  	leal	(%rdx,%rax,1),%edx
26 (0.0%)  	rorxl	$27,%esi,%r12d
26 (0.0%)  	rorxl	$2,%esi,%eax
26 (0.0%)  	vpaddd	%ymm11,%ymm7,%ymm9
26 (0.0%)  	xorl	%ebp,%esi
26 (0.0%)  	addl	%r12d,%edx
26 (0.0%)  	xorl	%ebx,%esi
26 (0.0%)  	addl	-88(%r13),%ecx
26 (0.0%)  	vmovdqu	%ymm9,480(%rsp)
26 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
26 (0.0%)  	rorxl	$27,%edx,%r12d
26 (0.0%)  	rorxl	$2,%edx,%esi
26 (0.0%)  	xorl	%eax,%edx
26 (0.0%)  	addl	%r12d,%ecx
26 (0.0%)  	xorl	%ebp,%edx
26 (0.0%)  	addl	-84(%r13),%ebx
26 (0.0%)  	movl	%esi,%edi
26 (0.0%)  	xorl	%eax,%edi
26 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
26 (0.0%)  	rorxl	$27,%ecx,%r12d
26 (0.0%)  	rorxl	$2,%ecx,%edx
26 (0.0%)  	xorl	%esi,%ecx
26 (0.0%)  	addl	%r12d,%ebx
26 (0.0%)  	andl	%edi,%ecx
26 (0.0%)  	jmp	.Lalign32_2
 .         .align	32
 .         .Lalign32_2:
26 (0.0%)  	vpalignr	$8,%ymm6,%ymm7,%ymm8
26 (0.0%)  	vpxor	%ymm4,%ymm0,%ymm0
26 (0.0%)  	addl	-64(%r13),%ebp
26 (0.0%)  	xorl	%esi,%ecx
26 (0.0%)  	vpxor	%ymm1,%ymm0,%ymm0
26 (0.0%)  	movl	%edx,%edi
26 (0.0%)  	xorl	%esi,%edi
26 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
26 (0.0%)  	vpxor	%ymm8,%ymm0,%ymm0
26 (0.0%)  	rorxl	$27,%ebx,%r12d
26 (0.0%)  	rorxl	$2,%ebx,%ecx
26 (0.0%)  	xorl	%edx,%ebx
26 (0.0%)  	vpsrld	$30,%ymm0,%ymm8
26 (0.0%)  	vpslld	$2,%ymm0,%ymm0
26 (0.0%)  	addl	%r12d,%ebp
26 (0.0%)  	andl	%edi,%ebx
26 (0.0%)  	addl	-60(%r13),%eax
26 (0.0%)  	xorl	%edx,%ebx
26 (0.0%)  	movl	%ecx,%edi
26 (0.0%)  	xorl	%edx,%edi
26 (0.0%)  	vpor	%ymm8,%ymm0,%ymm0
26 (0.0%)  	leal	(%rax,%rbx,1),%eax
26 (0.0%)  	rorxl	$27,%ebp,%r12d
26 (0.0%)  	rorxl	$2,%ebp,%ebx
26 (0.0%)  	xorl	%ecx,%ebp
26 (0.0%)  	vpaddd	%ymm11,%ymm0,%ymm9
26 (0.0%)  	addl	%r12d,%eax
26 (0.0%)  	andl	%edi,%ebp
26 (0.0%)  	addl	-56(%r13),%esi
26 (0.0%)  	xorl	%ecx,%ebp
26 (0.0%)  	vmovdqu	%ymm9,512(%rsp)
26 (0.0%)  	movl	%ebx,%edi
26 (0.0%)  	xorl	%ecx,%edi
26 (0.0%)  	leal	(%rsi,%rbp,1),%esi
26 (0.0%)  	rorxl	$27,%eax,%r12d
26 (0.0%)  	rorxl	$2,%eax,%ebp
26 (0.0%)  	xorl	%ebx,%eax
26 (0.0%)  	addl	%r12d,%esi
26 (0.0%)  	andl	%edi,%eax
26 (0.0%)  	addl	-52(%r13),%edx
26 (0.0%)  	xorl	%ebx,%eax
26 (0.0%)  	movl	%ebp,%edi
26 (0.0%)  	xorl	%ebx,%edi
26 (0.0%)  	leal	(%rdx,%rax,1),%edx
26 (0.0%)  	rorxl	$27,%esi,%r12d
26 (0.0%)  	rorxl	$2,%esi,%eax
26 (0.0%)  	xorl	%ebp,%esi
26 (0.0%)  	addl	%r12d,%edx
26 (0.0%)  	andl	%edi,%esi
26 (0.0%)  	addl	-32(%r13),%ecx
26 (0.0%)  	xorl	%ebp,%esi
26 (0.0%)  	movl	%eax,%edi
26 (0.0%)  	xorl	%ebp,%edi
26 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
26 (0.0%)  	rorxl	$27,%edx,%r12d
26 (0.0%)  	rorxl	$2,%edx,%esi
26 (0.0%)  	xorl	%eax,%edx
26 (0.0%)  	addl	%r12d,%ecx
26 (0.0%)  	andl	%edi,%edx
26 (0.0%)  	vpalignr	$8,%ymm7,%ymm0,%ymm8
26 (0.0%)  	vpxor	%ymm5,%ymm1,%ymm1
26 (0.0%)  	addl	-28(%r13),%ebx
26 (0.0%)  	xorl	%eax,%edx
26 (0.0%)  	vpxor	%ymm2,%ymm1,%ymm1
26 (0.0%)  	movl	%esi,%edi
26 (0.0%)  	xorl	%eax,%edi
26 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
26 (0.0%)  	vpxor	%ymm8,%ymm1,%ymm1
26 (0.0%)  	rorxl	$27,%ecx,%r12d
26 (0.0%)  	rorxl	$2,%ecx,%edx
26 (0.0%)  	xorl	%esi,%ecx
26 (0.0%)  	vpsrld	$30,%ymm1,%ymm8
26 (0.0%)  	vpslld	$2,%ymm1,%ymm1
26 (0.0%)  	addl	%r12d,%ebx
26 (0.0%)  	andl	%edi,%ecx
26 (0.0%)  	addl	-24(%r13),%ebp
26 (0.0%)  	xorl	%esi,%ecx
26 (0.0%)  	movl	%edx,%edi
26 (0.0%)  	xorl	%esi,%edi
26 (0.0%)  	vpor	%ymm8,%ymm1,%ymm1
26 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
26 (0.0%)  	rorxl	$27,%ebx,%r12d
26 (0.0%)  	rorxl	$2,%ebx,%ecx
26 (0.0%)  	xorl	%edx,%ebx
26 (0.0%)  	vpaddd	%ymm11,%ymm1,%ymm9
26 (0.0%)  	addl	%r12d,%ebp
26 (0.0%)  	andl	%edi,%ebx
26 (0.0%)  	addl	-20(%r13),%eax
26 (0.0%)  	xorl	%edx,%ebx
26 (0.0%)  	vmovdqu	%ymm9,544(%rsp)
26 (0.0%)  	movl	%ecx,%edi
26 (0.0%)  	xorl	%edx,%edi
26 (0.0%)  	leal	(%rax,%rbx,1),%eax
26 (0.0%)  	rorxl	$27,%ebp,%r12d
26 (0.0%)  	rorxl	$2,%ebp,%ebx
26 (0.0%)  	xorl	%ecx,%ebp
26 (0.0%)  	addl	%r12d,%eax
26 (0.0%)  	andl	%edi,%ebp
26 (0.0%)  	addl	0(%r13),%esi
26 (0.0%)  	xorl	%ecx,%ebp
26 (0.0%)  	movl	%ebx,%edi
26 (0.0%)  	xorl	%ecx,%edi
26 (0.0%)  	leal	(%rsi,%rbp,1),%esi
26 (0.0%)  	rorxl	$27,%eax,%r12d
26 (0.0%)  	rorxl	$2,%eax,%ebp
26 (0.0%)  	xorl	%ebx,%eax
26 (0.0%)  	addl	%r12d,%esi
26 (0.0%)  	andl	%edi,%eax
26 (0.0%)  	addl	4(%r13),%edx
26 (0.0%)  	xorl	%ebx,%eax
26 (0.0%)  	movl	%ebp,%edi
26 (0.0%)  	xorl	%ebx,%edi
26 (0.0%)  	leal	(%rdx,%rax,1),%edx
26 (0.0%)  	rorxl	$27,%esi,%r12d
26 (0.0%)  	rorxl	$2,%esi,%eax
26 (0.0%)  	xorl	%ebp,%esi
26 (0.0%)  	addl	%r12d,%edx
26 (0.0%)  	andl	%edi,%esi
26 (0.0%)  	vpalignr	$8,%ymm0,%ymm1,%ymm8
26 (0.0%)  	vpxor	%ymm6,%ymm2,%ymm2
26 (0.0%)  	addl	8(%r13),%ecx
26 (0.0%)  	xorl	%ebp,%esi
26 (0.0%)  	vpxor	%ymm3,%ymm2,%ymm2
26 (0.0%)  	movl	%eax,%edi
26 (0.0%)  	xorl	%ebp,%edi
26 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
26 (0.0%)  	vpxor	%ymm8,%ymm2,%ymm2
26 (0.0%)  	rorxl	$27,%edx,%r12d
26 (0.0%)  	rorxl	$2,%edx,%esi
26 (0.0%)  	xorl	%eax,%edx
26 (0.0%)  	vpsrld	$30,%ymm2,%ymm8
26 (0.0%)  	vpslld	$2,%ymm2,%ymm2
26 (0.0%)  	addl	%r12d,%ecx
26 (0.0%)  	andl	%edi,%edx
26 (0.0%)  	addl	12(%r13),%ebx
26 (0.0%)  	xorl	%eax,%edx
26 (0.0%)  	movl	%esi,%edi
26 (0.0%)  	xorl	%eax,%edi
26 (0.0%)  	vpor	%ymm8,%ymm2,%ymm2
26 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
26 (0.0%)  	rorxl	$27,%ecx,%r12d
26 (0.0%)  	rorxl	$2,%ecx,%edx
26 (0.0%)  	xorl	%esi,%ecx
26 (0.0%)  	vpaddd	%ymm11,%ymm2,%ymm9
26 (0.0%)  	addl	%r12d,%ebx
26 (0.0%)  	andl	%edi,%ecx
26 (0.0%)  	addl	32(%r13),%ebp
26 (0.0%)  	xorl	%esi,%ecx
26 (0.0%)  	vmovdqu	%ymm9,576(%rsp)
26 (0.0%)  	movl	%edx,%edi
26 (0.0%)  	xorl	%esi,%edi
26 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
26 (0.0%)  	rorxl	$27,%ebx,%r12d
26 (0.0%)  	rorxl	$2,%ebx,%ecx
26 (0.0%)  	xorl	%edx,%ebx
26 (0.0%)  	addl	%r12d,%ebp
26 (0.0%)  	andl	%edi,%ebx
26 (0.0%)  	addl	36(%r13),%eax
26 (0.0%)  	xorl	%edx,%ebx
26 (0.0%)  	movl	%ecx,%edi
26 (0.0%)  	xorl	%edx,%edi
26 (0.0%)  	leal	(%rax,%rbx,1),%eax
26 (0.0%)  	rorxl	$27,%ebp,%r12d
26 (0.0%)  	rorxl	$2,%ebp,%ebx
26 (0.0%)  	xorl	%ecx,%ebp
26 (0.0%)  	addl	%r12d,%eax
26 (0.0%)  	andl	%edi,%ebp
26 (0.0%)  	addl	40(%r13),%esi
26 (0.0%)  	xorl	%ecx,%ebp
26 (0.0%)  	movl	%ebx,%edi
26 (0.0%)  	xorl	%ecx,%edi
26 (0.0%)  	leal	(%rsi,%rbp,1),%esi
26 (0.0%)  	rorxl	$27,%eax,%r12d
26 (0.0%)  	rorxl	$2,%eax,%ebp
26 (0.0%)  	xorl	%ebx,%eax
26 (0.0%)  	addl	%r12d,%esi
26 (0.0%)  	andl	%edi,%eax
26 (0.0%)  	vpalignr	$8,%ymm1,%ymm2,%ymm8
26 (0.0%)  	vpxor	%ymm7,%ymm3,%ymm3
26 (0.0%)  	addl	44(%r13),%edx
26 (0.0%)  	xorl	%ebx,%eax
26 (0.0%)  	vpxor	%ymm4,%ymm3,%ymm3
26 (0.0%)  	movl	%ebp,%edi
26 (0.0%)  	xorl	%ebx,%edi
26 (0.0%)  	leal	(%rdx,%rax,1),%edx
26 (0.0%)  	vpxor	%ymm8,%ymm3,%ymm3
26 (0.0%)  	rorxl	$27,%esi,%r12d
26 (0.0%)  	rorxl	$2,%esi,%eax
26 (0.0%)  	xorl	%ebp,%esi
26 (0.0%)  	vpsrld	$30,%ymm3,%ymm8
26 (0.0%)  	vpslld	$2,%ymm3,%ymm3
26 (0.0%)  	addl	%r12d,%edx
26 (0.0%)  	andl	%edi,%esi
26 (0.0%)  	addl	64(%r13),%ecx
26 (0.0%)  	xorl	%ebp,%esi
26 (0.0%)  	movl	%eax,%edi
26 (0.0%)  	xorl	%ebp,%edi
26 (0.0%)  	vpor	%ymm8,%ymm3,%ymm3
26 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
26 (0.0%)  	rorxl	$27,%edx,%r12d
26 (0.0%)  	rorxl	$2,%edx,%esi
26 (0.0%)  	xorl	%eax,%edx
26 (0.0%)  	vpaddd	%ymm11,%ymm3,%ymm9
26 (0.0%)  	addl	%r12d,%ecx
26 (0.0%)  	andl	%edi,%edx
26 (0.0%)  	addl	68(%r13),%ebx
26 (0.0%)  	xorl	%eax,%edx
26 (0.0%)  	vmovdqu	%ymm9,608(%rsp)
26 (0.0%)  	movl	%esi,%edi
26 (0.0%)  	xorl	%eax,%edi
26 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
26 (0.0%)  	rorxl	$27,%ecx,%r12d
26 (0.0%)  	rorxl	$2,%ecx,%edx
26 (0.0%)  	xorl	%esi,%ecx
26 (0.0%)  	addl	%r12d,%ebx
26 (0.0%)  	andl	%edi,%ecx
26 (0.0%)  	addl	72(%r13),%ebp
26 (0.0%)  	xorl	%esi,%ecx
26 (0.0%)  	movl	%edx,%edi
26 (0.0%)  	xorl	%esi,%edi
26 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
26 (0.0%)  	rorxl	$27,%ebx,%r12d
26 (0.0%)  	rorxl	$2,%ebx,%ecx
26 (0.0%)  	xorl	%edx,%ebx
26 (0.0%)  	addl	%r12d,%ebp
26 (0.0%)  	andl	%edi,%ebx
26 (0.0%)  	addl	76(%r13),%eax
26 (0.0%)  	xorl	%edx,%ebx
26 (0.0%)  	leal	(%rax,%rbx,1),%eax
26 (0.0%)  	rorxl	$27,%ebp,%r12d
26 (0.0%)  	rorxl	$2,%ebp,%ebx
26 (0.0%)  	xorl	%ecx,%ebp
26 (0.0%)  	addl	%r12d,%eax
26 (0.0%)  	xorl	%edx,%ebp
26 (0.0%)  	addl	96(%r13),%esi
26 (0.0%)  	leal	(%rsi,%rbp,1),%esi
26 (0.0%)  	rorxl	$27,%eax,%r12d
26 (0.0%)  	rorxl	$2,%eax,%ebp
26 (0.0%)  	xorl	%ebx,%eax
26 (0.0%)  	addl	%r12d,%esi
26 (0.0%)  	xorl	%ecx,%eax
26 (0.0%)  	addl	100(%r13),%edx
26 (0.0%)  	leal	(%rdx,%rax,1),%edx
26 (0.0%)  	rorxl	$27,%esi,%r12d
26 (0.0%)  	rorxl	$2,%esi,%eax
26 (0.0%)  	xorl	%ebp,%esi
26 (0.0%)  	addl	%r12d,%edx
26 (0.0%)  	xorl	%ebx,%esi
26 (0.0%)  	addl	104(%r13),%ecx
26 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
26 (0.0%)  	rorxl	$27,%edx,%r12d
26 (0.0%)  	rorxl	$2,%edx,%esi
26 (0.0%)  	xorl	%eax,%edx
26 (0.0%)  	addl	%r12d,%ecx
26 (0.0%)  	xorl	%ebp,%edx
26 (0.0%)  	addl	108(%r13),%ebx
26 (0.0%)  	leaq	256(%r13),%r13
26 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
26 (0.0%)  	rorxl	$27,%ecx,%r12d
26 (0.0%)  	rorxl	$2,%ecx,%edx
26 (0.0%)  	xorl	%esi,%ecx
26 (0.0%)  	addl	%r12d,%ebx
26 (0.0%)  	xorl	%eax,%ecx
26 (0.0%)  	addl	-128(%r13),%ebp
26 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
26 (0.0%)  	rorxl	$27,%ebx,%r12d
26 (0.0%)  	rorxl	$2,%ebx,%ecx
26 (0.0%)  	xorl	%edx,%ebx
26 (0.0%)  	addl	%r12d,%ebp
26 (0.0%)  	xorl	%esi,%ebx
26 (0.0%)  	addl	-124(%r13),%eax
26 (0.0%)  	leal	(%rax,%rbx,1),%eax
26 (0.0%)  	rorxl	$27,%ebp,%r12d
26 (0.0%)  	rorxl	$2,%ebp,%ebx
26 (0.0%)  	xorl	%ecx,%ebp
26 (0.0%)  	addl	%r12d,%eax
26 (0.0%)  	xorl	%edx,%ebp
26 (0.0%)  	addl	-120(%r13),%esi
26 (0.0%)  	leal	(%rsi,%rbp,1),%esi
26 (0.0%)  	rorxl	$27,%eax,%r12d
26 (0.0%)  	rorxl	$2,%eax,%ebp
26 (0.0%)  	xorl	%ebx,%eax
26 (0.0%)  	addl	%r12d,%esi
26 (0.0%)  	xorl	%ecx,%eax
26 (0.0%)  	addl	-116(%r13),%edx
26 (0.0%)  	leal	(%rdx,%rax,1),%edx
26 (0.0%)  	rorxl	$27,%esi,%r12d
26 (0.0%)  	rorxl	$2,%esi,%eax
26 (0.0%)  	xorl	%ebp,%esi
26 (0.0%)  	addl	%r12d,%edx
26 (0.0%)  	xorl	%ebx,%esi
26 (0.0%)  	addl	-96(%r13),%ecx
26 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
26 (0.0%)  	rorxl	$27,%edx,%r12d
26 (0.0%)  	rorxl	$2,%edx,%esi
26 (0.0%)  	xorl	%eax,%edx
26 (0.0%)  	addl	%r12d,%ecx
26 (0.0%)  	xorl	%ebp,%edx
26 (0.0%)  	addl	-92(%r13),%ebx
26 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
26 (0.0%)  	rorxl	$27,%ecx,%r12d
26 (0.0%)  	rorxl	$2,%ecx,%edx
26 (0.0%)  	xorl	%esi,%ecx
26 (0.0%)  	addl	%r12d,%ebx
26 (0.0%)  	xorl	%eax,%ecx
26 (0.0%)  	addl	-88(%r13),%ebp
26 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
26 (0.0%)  	rorxl	$27,%ebx,%r12d
26 (0.0%)  	rorxl	$2,%ebx,%ecx
26 (0.0%)  	xorl	%edx,%ebx
26 (0.0%)  	addl	%r12d,%ebp
26 (0.0%)  	xorl	%esi,%ebx
26 (0.0%)  	addl	-84(%r13),%eax
26 (0.0%)  	leal	(%rax,%rbx,1),%eax
26 (0.0%)  	rorxl	$27,%ebp,%r12d
26 (0.0%)  	rorxl	$2,%ebp,%ebx
26 (0.0%)  	xorl	%ecx,%ebp
26 (0.0%)  	addl	%r12d,%eax
26 (0.0%)  	xorl	%edx,%ebp
26 (0.0%)  	addl	-64(%r13),%esi
26 (0.0%)  	leal	(%rsi,%rbp,1),%esi
26 (0.0%)  	rorxl	$27,%eax,%r12d
26 (0.0%)  	rorxl	$2,%eax,%ebp
26 (0.0%)  	xorl	%ebx,%eax
26 (0.0%)  	addl	%r12d,%esi
26 (0.0%)  	xorl	%ecx,%eax
26 (0.0%)  	addl	-60(%r13),%edx
26 (0.0%)  	leal	(%rdx,%rax,1),%edx
26 (0.0%)  	rorxl	$27,%esi,%r12d
26 (0.0%)  	rorxl	$2,%esi,%eax
26 (0.0%)  	xorl	%ebp,%esi
26 (0.0%)  	addl	%r12d,%edx
26 (0.0%)  	xorl	%ebx,%esi
26 (0.0%)  	addl	-56(%r13),%ecx
26 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
26 (0.0%)  	rorxl	$27,%edx,%r12d
26 (0.0%)  	rorxl	$2,%edx,%esi
26 (0.0%)  	xorl	%eax,%edx
26 (0.0%)  	addl	%r12d,%ecx
26 (0.0%)  	xorl	%ebp,%edx
26 (0.0%)  	addl	-52(%r13),%ebx
26 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
26 (0.0%)  	rorxl	$27,%ecx,%r12d
26 (0.0%)  	rorxl	$2,%ecx,%edx
26 (0.0%)  	xorl	%esi,%ecx
26 (0.0%)  	addl	%r12d,%ebx
26 (0.0%)  	xorl	%eax,%ecx
26 (0.0%)  	addl	-32(%r13),%ebp
26 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
26 (0.0%)  	rorxl	$27,%ebx,%r12d
26 (0.0%)  	rorxl	$2,%ebx,%ecx
26 (0.0%)  	xorl	%edx,%ebx
26 (0.0%)  	addl	%r12d,%ebp
26 (0.0%)  	xorl	%esi,%ebx
26 (0.0%)  	addl	-28(%r13),%eax
26 (0.0%)  	leal	(%rax,%rbx,1),%eax
26 (0.0%)  	rorxl	$27,%ebp,%r12d
26 (0.0%)  	rorxl	$2,%ebp,%ebx
26 (0.0%)  	xorl	%ecx,%ebp
26 (0.0%)  	addl	%r12d,%eax
26 (0.0%)  	xorl	%edx,%ebp
26 (0.0%)  	addl	-24(%r13),%esi
26 (0.0%)  	leal	(%rsi,%rbp,1),%esi
26 (0.0%)  	rorxl	$27,%eax,%r12d
26 (0.0%)  	rorxl	$2,%eax,%ebp
26 (0.0%)  	xorl	%ebx,%eax
26 (0.0%)  	addl	%r12d,%esi
26 (0.0%)  	xorl	%ecx,%eax
26 (0.0%)  	addl	-20(%r13),%edx
26 (0.0%)  	leal	(%rdx,%rax,1),%edx
26 (0.0%)  	rorxl	$27,%esi,%r12d
26 (0.0%)  	addl	%r12d,%edx
26 (0.0%)  	leaq	128(%r9),%r13
26 (0.0%)  	leaq	128(%r9),%rdi
26 (0.0%)  	cmpq	%r10,%r13
26 (0.0%)  	cmovaeq	%r9,%r13
 .         
 .         
26 (0.0%)  	addl	0(%r8),%edx
26 (0.0%)  	addl	4(%r8),%esi
26 (0.0%)  	addl	8(%r8),%ebp
26 (0.0%)  	movl	%edx,0(%r8)
26 (0.0%)  	addl	12(%r8),%ebx
26 (0.0%)  	movl	%esi,4(%r8)
26 (0.0%)  	movl	%edx,%eax
26 (0.0%)  	addl	16(%r8),%ecx
26 (0.0%)  	movl	%ebp,%r12d
26 (0.0%)  	movl	%ebp,8(%r8)
26 (0.0%)  	movl	%ebx,%edx
 .         
26 (0.0%)  	movl	%ebx,12(%r8)
26 (0.0%)  	movl	%esi,%ebp
26 (0.0%)  	movl	%ecx,16(%r8)
 .         
26 (0.0%)  	movl	%ecx,%esi
26 (0.0%)  	movl	%r12d,%ecx
 .         
 .         
26 (0.0%)  	cmpq	%r10,%r9
26 (0.0%)  	je	.Ldone_avx2
12 (0.0%)  	vmovdqu	64(%r14),%ymm6
12 (0.0%)  	cmpq	%r10,%rdi
12 (0.0%)  	ja	.Last_avx2
 .         
10 (0.0%)  	vmovdqu	-64(%rdi),%xmm0
10 (0.0%)  	vmovdqu	-48(%rdi),%xmm1
10 (0.0%)  	vmovdqu	-32(%rdi),%xmm2
10 (0.0%)  	vmovdqu	-16(%rdi),%xmm3
10 (0.0%)  	vinserti128	$1,0(%r13),%ymm0,%ymm0
10 (0.0%)  	vinserti128	$1,16(%r13),%ymm1,%ymm1
10 (0.0%)  	vinserti128	$1,32(%r13),%ymm2,%ymm2
10 (0.0%)  	vinserti128	$1,48(%r13),%ymm3,%ymm3
10 (0.0%)  	jmp	.Last_avx2
 .         
 .         .align	32
 .         .Last_avx2:
12 (0.0%)  	leaq	128+16(%rsp),%r13
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	andnl	%edx,%ebp,%edi
12 (0.0%)  	andl	%ecx,%ebp
12 (0.0%)  	xorl	%edi,%ebp
12 (0.0%)  	subq	$-128,%r9
12 (0.0%)  	addl	-128(%r13),%esi
12 (0.0%)  	andnl	%ecx,%eax,%edi
12 (0.0%)  	addl	%ebp,%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	andl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%edi,%eax
12 (0.0%)  	addl	-124(%r13),%edx
12 (0.0%)  	andnl	%ebx,%esi,%edi
12 (0.0%)  	addl	%eax,%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	andl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%edi,%esi
12 (0.0%)  	addl	-120(%r13),%ecx
12 (0.0%)  	andnl	%ebp,%edx,%edi
12 (0.0%)  	addl	%esi,%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	andl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%edi,%edx
12 (0.0%)  	addl	-116(%r13),%ebx
12 (0.0%)  	andnl	%eax,%ecx,%edi
12 (0.0%)  	addl	%edx,%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	andl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%edi,%ecx
12 (0.0%)  	addl	-96(%r13),%ebp
12 (0.0%)  	andnl	%esi,%ebx,%edi
12 (0.0%)  	addl	%ecx,%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	andl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%edi,%ebx
12 (0.0%)  	addl	-92(%r13),%eax
12 (0.0%)  	andnl	%edx,%ebp,%edi
12 (0.0%)  	addl	%ebx,%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	andl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edi,%ebp
12 (0.0%)  	addl	-88(%r13),%esi
12 (0.0%)  	andnl	%ecx,%eax,%edi
12 (0.0%)  	addl	%ebp,%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	andl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%edi,%eax
12 (0.0%)  	addl	-84(%r13),%edx
12 (0.0%)  	andnl	%ebx,%esi,%edi
12 (0.0%)  	addl	%eax,%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	andl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%edi,%esi
12 (0.0%)  	addl	-64(%r13),%ecx
12 (0.0%)  	andnl	%ebp,%edx,%edi
12 (0.0%)  	addl	%esi,%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	andl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%edi,%edx
12 (0.0%)  	addl	-60(%r13),%ebx
12 (0.0%)  	andnl	%eax,%ecx,%edi
12 (0.0%)  	addl	%edx,%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	andl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%edi,%ecx
12 (0.0%)  	addl	-56(%r13),%ebp
12 (0.0%)  	andnl	%esi,%ebx,%edi
12 (0.0%)  	addl	%ecx,%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	andl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%edi,%ebx
12 (0.0%)  	addl	-52(%r13),%eax
12 (0.0%)  	andnl	%edx,%ebp,%edi
12 (0.0%)  	addl	%ebx,%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	andl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edi,%ebp
12 (0.0%)  	addl	-32(%r13),%esi
12 (0.0%)  	andnl	%ecx,%eax,%edi
12 (0.0%)  	addl	%ebp,%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	andl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%edi,%eax
12 (0.0%)  	addl	-28(%r13),%edx
12 (0.0%)  	andnl	%ebx,%esi,%edi
12 (0.0%)  	addl	%eax,%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	andl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%edi,%esi
12 (0.0%)  	addl	-24(%r13),%ecx
12 (0.0%)  	andnl	%ebp,%edx,%edi
12 (0.0%)  	addl	%esi,%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	andl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%edi,%edx
12 (0.0%)  	addl	-20(%r13),%ebx
12 (0.0%)  	andnl	%eax,%ecx,%edi
12 (0.0%)  	addl	%edx,%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	andl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%edi,%ecx
12 (0.0%)  	addl	0(%r13),%ebp
12 (0.0%)  	andnl	%esi,%ebx,%edi
12 (0.0%)  	addl	%ecx,%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	andl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%edi,%ebx
12 (0.0%)  	addl	4(%r13),%eax
12 (0.0%)  	andnl	%edx,%ebp,%edi
12 (0.0%)  	addl	%ebx,%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	andl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edi,%ebp
12 (0.0%)  	addl	8(%r13),%esi
12 (0.0%)  	andnl	%ecx,%eax,%edi
12 (0.0%)  	addl	%ebp,%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	andl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%edi,%eax
12 (0.0%)  	addl	12(%r13),%edx
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%ebx,%esi
12 (0.0%)  	addl	32(%r13),%ecx
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%ebp,%edx
12 (0.0%)  	addl	36(%r13),%ebx
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%eax,%ecx
12 (0.0%)  	addl	40(%r13),%ebp
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%esi,%ebx
12 (0.0%)  	addl	44(%r13),%eax
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edx,%ebp
12 (0.0%)  	addl	64(%r13),%esi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%ecx,%eax
12 (0.0%)  	vmovdqu	-64(%r14),%ymm11
12 (0.0%)  	vpshufb	%ymm6,%ymm0,%ymm0
12 (0.0%)  	addl	68(%r13),%edx
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%ebx,%esi
12 (0.0%)  	addl	72(%r13),%ecx
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%ebp,%edx
12 (0.0%)  	addl	76(%r13),%ebx
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%eax,%ecx
12 (0.0%)  	addl	96(%r13),%ebp
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%esi,%ebx
12 (0.0%)  	addl	100(%r13),%eax
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edx,%ebp
12 (0.0%)  	vpshufb	%ymm6,%ymm1,%ymm1
12 (0.0%)  	vpaddd	%ymm11,%ymm0,%ymm8
12 (0.0%)  	addl	104(%r13),%esi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%ecx,%eax
12 (0.0%)  	addl	108(%r13),%edx
12 (0.0%)  	leaq	256(%r13),%r13
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%ebx,%esi
12 (0.0%)  	addl	-128(%r13),%ecx
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%ebp,%edx
12 (0.0%)  	addl	-124(%r13),%ebx
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%eax,%ecx
12 (0.0%)  	addl	-120(%r13),%ebp
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%esi,%ebx
12 (0.0%)  	vmovdqu	%ymm8,0(%rsp)
12 (0.0%)  	vpshufb	%ymm6,%ymm2,%ymm2
12 (0.0%)  	vpaddd	%ymm11,%ymm1,%ymm9
12 (0.0%)  	addl	-116(%r13),%eax
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edx,%ebp
12 (0.0%)  	addl	-96(%r13),%esi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%ecx,%eax
12 (0.0%)  	addl	-92(%r13),%edx
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%ebx,%esi
12 (0.0%)  	addl	-88(%r13),%ecx
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%ebp,%edx
12 (0.0%)  	addl	-84(%r13),%ebx
12 (0.0%)  	movl	%esi,%edi
12 (0.0%)  	xorl	%eax,%edi
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	andl	%edi,%ecx
12 (0.0%)  	vmovdqu	%ymm9,32(%rsp)
12 (0.0%)  	vpshufb	%ymm6,%ymm3,%ymm3
12 (0.0%)  	vpaddd	%ymm11,%ymm2,%ymm6
12 (0.0%)  	addl	-64(%r13),%ebp
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	movl	%edx,%edi
12 (0.0%)  	xorl	%esi,%edi
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	andl	%edi,%ebx
12 (0.0%)  	addl	-60(%r13),%eax
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	movl	%ecx,%edi
12 (0.0%)  	xorl	%edx,%edi
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	andl	%edi,%ebp
12 (0.0%)  	addl	-56(%r13),%esi
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	movl	%ebx,%edi
12 (0.0%)  	xorl	%ecx,%edi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	andl	%edi,%eax
12 (0.0%)  	addl	-52(%r13),%edx
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	movl	%ebp,%edi
12 (0.0%)  	xorl	%ebx,%edi
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	andl	%edi,%esi
12 (0.0%)  	addl	-32(%r13),%ecx
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	movl	%eax,%edi
12 (0.0%)  	xorl	%ebp,%edi
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	andl	%edi,%edx
12 (0.0%)  	jmp	.Lalign32_3
 .         .align	32
 .         .Lalign32_3:
12 (0.0%)  	vmovdqu	%ymm6,64(%rsp)
12 (0.0%)  	vpaddd	%ymm11,%ymm3,%ymm7
12 (0.0%)  	addl	-28(%r13),%ebx
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	movl	%esi,%edi
12 (0.0%)  	xorl	%eax,%edi
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	andl	%edi,%ecx
12 (0.0%)  	addl	-24(%r13),%ebp
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	movl	%edx,%edi
12 (0.0%)  	xorl	%esi,%edi
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	andl	%edi,%ebx
12 (0.0%)  	addl	-20(%r13),%eax
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	movl	%ecx,%edi
12 (0.0%)  	xorl	%edx,%edi
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	andl	%edi,%ebp
12 (0.0%)  	addl	0(%r13),%esi
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	movl	%ebx,%edi
12 (0.0%)  	xorl	%ecx,%edi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	andl	%edi,%eax
12 (0.0%)  	addl	4(%r13),%edx
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	movl	%ebp,%edi
12 (0.0%)  	xorl	%ebx,%edi
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	andl	%edi,%esi
12 (0.0%)  	vmovdqu	%ymm7,96(%rsp)
12 (0.0%)  	addl	8(%r13),%ecx
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	movl	%eax,%edi
12 (0.0%)  	xorl	%ebp,%edi
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	andl	%edi,%edx
12 (0.0%)  	addl	12(%r13),%ebx
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	movl	%esi,%edi
12 (0.0%)  	xorl	%eax,%edi
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	andl	%edi,%ecx
12 (0.0%)  	addl	32(%r13),%ebp
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	movl	%edx,%edi
12 (0.0%)  	xorl	%esi,%edi
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	andl	%edi,%ebx
12 (0.0%)  	addl	36(%r13),%eax
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	movl	%ecx,%edi
12 (0.0%)  	xorl	%edx,%edi
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	andl	%edi,%ebp
12 (0.0%)  	addl	40(%r13),%esi
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	movl	%ebx,%edi
12 (0.0%)  	xorl	%ecx,%edi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	andl	%edi,%eax
12 (0.0%)  	vpalignr	$8,%ymm0,%ymm1,%ymm4
12 (0.0%)  	addl	44(%r13),%edx
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	movl	%ebp,%edi
12 (0.0%)  	xorl	%ebx,%edi
12 (0.0%)  	vpsrldq	$4,%ymm3,%ymm8
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	vpxor	%ymm0,%ymm4,%ymm4
12 (0.0%)  	vpxor	%ymm2,%ymm8,%ymm8
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	vpxor	%ymm8,%ymm4,%ymm4
12 (0.0%)  	andl	%edi,%esi
12 (0.0%)  	addl	64(%r13),%ecx
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	movl	%eax,%edi
12 (0.0%)  	vpsrld	$31,%ymm4,%ymm8
12 (0.0%)  	xorl	%ebp,%edi
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	vpslldq	$12,%ymm4,%ymm10
12 (0.0%)  	vpaddd	%ymm4,%ymm4,%ymm4
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
12 (0.0%)  	vpor	%ymm8,%ymm4,%ymm4
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	andl	%edi,%edx
12 (0.0%)  	vpslld	$2,%ymm10,%ymm10
12 (0.0%)  	vpxor	%ymm9,%ymm4,%ymm4
12 (0.0%)  	addl	68(%r13),%ebx
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	vpxor	%ymm10,%ymm4,%ymm4
12 (0.0%)  	movl	%esi,%edi
12 (0.0%)  	xorl	%eax,%edi
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	vpaddd	%ymm11,%ymm4,%ymm9
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	vmovdqu	%ymm9,128(%rsp)
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	andl	%edi,%ecx
12 (0.0%)  	addl	72(%r13),%ebp
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	movl	%edx,%edi
12 (0.0%)  	xorl	%esi,%edi
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	andl	%edi,%ebx
12 (0.0%)  	addl	76(%r13),%eax
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edx,%ebp
12 (0.0%)  	vpalignr	$8,%ymm1,%ymm2,%ymm5
12 (0.0%)  	addl	96(%r13),%esi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	vpsrldq	$4,%ymm4,%ymm8
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%ecx,%eax
12 (0.0%)  	vpxor	%ymm1,%ymm5,%ymm5
12 (0.0%)  	vpxor	%ymm3,%ymm8,%ymm8
12 (0.0%)  	addl	100(%r13),%edx
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	vpxor	%ymm8,%ymm5,%ymm5
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	vpsrld	$31,%ymm5,%ymm8
12 (0.0%)  	vmovdqu	-32(%r14),%ymm11
12 (0.0%)  	xorl	%ebx,%esi
12 (0.0%)  	addl	104(%r13),%ecx
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	vpslldq	$12,%ymm5,%ymm10
12 (0.0%)  	vpaddd	%ymm5,%ymm5,%ymm5
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
12 (0.0%)  	vpor	%ymm8,%ymm5,%ymm5
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	vpslld	$2,%ymm10,%ymm10
12 (0.0%)  	vpxor	%ymm9,%ymm5,%ymm5
12 (0.0%)  	xorl	%ebp,%edx
12 (0.0%)  	addl	108(%r13),%ebx
12 (0.0%)  	leaq	256(%r13),%r13
12 (0.0%)  	vpxor	%ymm10,%ymm5,%ymm5
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	vpaddd	%ymm11,%ymm5,%ymm9
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%eax,%ecx
12 (0.0%)  	vmovdqu	%ymm9,160(%rsp)
12 (0.0%)  	addl	-128(%r13),%ebp
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%esi,%ebx
12 (0.0%)  	vpalignr	$8,%ymm2,%ymm3,%ymm6
12 (0.0%)  	addl	-124(%r13),%eax
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	vpsrldq	$4,%ymm5,%ymm8
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edx,%ebp
12 (0.0%)  	vpxor	%ymm2,%ymm6,%ymm6
12 (0.0%)  	vpxor	%ymm4,%ymm8,%ymm8
12 (0.0%)  	addl	-120(%r13),%esi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	vpxor	%ymm8,%ymm6,%ymm6
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	vpsrld	$31,%ymm6,%ymm8
12 (0.0%)  	xorl	%ecx,%eax
12 (0.0%)  	addl	-116(%r13),%edx
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	vpslldq	$12,%ymm6,%ymm10
12 (0.0%)  	vpaddd	%ymm6,%ymm6,%ymm6
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
12 (0.0%)  	vpor	%ymm8,%ymm6,%ymm6
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	vpslld	$2,%ymm10,%ymm10
12 (0.0%)  	vpxor	%ymm9,%ymm6,%ymm6
12 (0.0%)  	xorl	%ebx,%esi
12 (0.0%)  	addl	-96(%r13),%ecx
12 (0.0%)  	vpxor	%ymm10,%ymm6,%ymm6
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	vpaddd	%ymm11,%ymm6,%ymm9
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%ebp,%edx
12 (0.0%)  	vmovdqu	%ymm9,192(%rsp)
12 (0.0%)  	addl	-92(%r13),%ebx
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%eax,%ecx
12 (0.0%)  	vpalignr	$8,%ymm3,%ymm4,%ymm7
12 (0.0%)  	addl	-88(%r13),%ebp
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	vpsrldq	$4,%ymm6,%ymm8
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%esi,%ebx
12 (0.0%)  	vpxor	%ymm3,%ymm7,%ymm7
12 (0.0%)  	vpxor	%ymm5,%ymm8,%ymm8
12 (0.0%)  	addl	-84(%r13),%eax
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	vpxor	%ymm8,%ymm7,%ymm7
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	vpsrld	$31,%ymm7,%ymm8
12 (0.0%)  	xorl	%edx,%ebp
12 (0.0%)  	addl	-64(%r13),%esi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	vpslldq	$12,%ymm7,%ymm10
12 (0.0%)  	vpaddd	%ymm7,%ymm7,%ymm7
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
12 (0.0%)  	vpor	%ymm8,%ymm7,%ymm7
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	vpslld	$2,%ymm10,%ymm10
12 (0.0%)  	vpxor	%ymm9,%ymm7,%ymm7
12 (0.0%)  	xorl	%ecx,%eax
12 (0.0%)  	addl	-60(%r13),%edx
12 (0.0%)  	vpxor	%ymm10,%ymm7,%ymm7
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	vpaddd	%ymm11,%ymm7,%ymm9
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%ebx,%esi
12 (0.0%)  	vmovdqu	%ymm9,224(%rsp)
12 (0.0%)  	addl	-56(%r13),%ecx
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%ebp,%edx
12 (0.0%)  	addl	-52(%r13),%ebx
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%eax,%ecx
12 (0.0%)  	addl	-32(%r13),%ebp
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%esi,%ebx
12 (0.0%)  	addl	-28(%r13),%eax
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edx,%ebp
12 (0.0%)  	addl	-24(%r13),%esi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%ecx,%eax
12 (0.0%)  	addl	-20(%r13),%edx
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	leaq	128(%rsp),%r13
 .         
 .         
12 (0.0%)  	addl	0(%r8),%edx
12 (0.0%)  	addl	4(%r8),%esi
12 (0.0%)  	addl	8(%r8),%ebp
12 (0.0%)  	movl	%edx,0(%r8)
12 (0.0%)  	addl	12(%r8),%ebx
12 (0.0%)  	movl	%esi,4(%r8)
12 (0.0%)  	movl	%edx,%eax
12 (0.0%)  	addl	16(%r8),%ecx
12 (0.0%)  	movl	%ebp,%r12d
12 (0.0%)  	movl	%ebp,8(%r8)
12 (0.0%)  	movl	%ebx,%edx
 .         
12 (0.0%)  	movl	%ebx,12(%r8)
12 (0.0%)  	movl	%esi,%ebp
12 (0.0%)  	movl	%ecx,16(%r8)
 .         
12 (0.0%)  	movl	%ecx,%esi
12 (0.0%)  	movl	%r12d,%ecx
 .         
 .         
12 (0.0%)  	cmpq	%r10,%r9
12 (0.0%)  	jbe	.Loop_avx2
 .         
 .         .Ldone_avx2:
16 (0.0%)  	vzeroupper
16 (0.0%)  	movq	-40(%r11),%r14
 .         .cfi_restore	%r14
16 (0.0%)  	movq	-32(%r11),%r13
 .         .cfi_restore	%r13
16 (0.0%)  	movq	-24(%r11),%r12
 .         .cfi_restore	%r12
16 (0.0%)  	movq	-16(%r11),%rbp
 .         .cfi_restore	%rbp
16 (0.0%)  	movq	-8(%r11),%rbx
 .         .cfi_restore	%rbx
32 (0.0%)  	leaq	(%r11),%rsp
 .         .cfi_def_cfa_register	%rsp
 .         .Lepilogue_avx2:
 .         	.byte	0xf3,0xc3
 .         .cfi_endproc	
 .         .size	sha1_block_data_order_avx2,.-sha1_block_data_order_avx2
 .         .section	.rodata
 .         .align	64
 .         K_XX_XX:
-- line 5448 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha256-x86_64.S
--------------------------------------------------------------------------------
Ir________ 

-- line 9 ----------------------------------------
  .         .extern	OPENSSL_ia32cap_P
  .         .hidden OPENSSL_ia32cap_P
  .         .globl	sha256_block_data_order
  .         .hidden sha256_block_data_order
  .         .type	sha256_block_data_order,@function
  .         .align	16
  .         sha256_block_data_order:
  .         .cfi_startproc	
226 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r11
226 (0.0%)  	movl	0(%r11),%r9d
226 (0.0%)  	movl	4(%r11),%r10d
226 (0.0%)  	movl	8(%r11),%r11d
226 (0.0%)  	testl	$536870912,%r11d
226 (0.0%)  	jnz	.Lshaext_shortcut
226 (0.0%)  	andl	$1073741824,%r9d
226 (0.0%)  	andl	$268435968,%r10d
226 (0.0%)  	orl	%r9d,%r10d
226 (0.0%)  	cmpl	$1342177792,%r10d
226 (0.0%)  	je	.Lavx_shortcut
  .         	testl	$512,%r10d
  .         	jnz	.Lssse3_shortcut
  .         	movq	%rsp,%rax
  .         .cfi_def_cfa_register	%rax
  .         	pushq	%rbx
  .         .cfi_offset	%rbx,-16
  .         	pushq	%rbp
  .         .cfi_offset	%rbp,-24
-- line 35 ----------------------------------------
-- line 3105 ----------------------------------------
  .         	.byte	0xf3,0xc3
  .         .cfi_endproc	
  .         .size	sha256_block_data_order_ssse3,.-sha256_block_data_order_ssse3
  .         .type	sha256_block_data_order_avx,@function
  .         .align	64
  .         sha256_block_data_order_avx:
  .         .cfi_startproc	
  .         .Lavx_shortcut:
226 (0.0%)  	movq	%rsp,%rax
  .         .cfi_def_cfa_register	%rax
226 (0.0%)  	pushq	%rbx
  .         .cfi_offset	%rbx,-16
226 (0.0%)  	pushq	%rbp
  .         .cfi_offset	%rbp,-24
226 (0.0%)  	pushq	%r12
  .         .cfi_offset	%r12,-32
226 (0.0%)  	pushq	%r13
  .         .cfi_offset	%r13,-40
226 (0.0%)  	pushq	%r14
  .         .cfi_offset	%r14,-48
226 (0.0%)  	pushq	%r15
  .         .cfi_offset	%r15,-56
226 (0.0%)  	shlq	$4,%rdx
226 (0.0%)  	subq	$96,%rsp
226 (0.0%)  	leaq	(%rsi,%rdx,4),%rdx
226 (0.0%)  	andq	$-64,%rsp
226 (0.0%)  	movq	%rdi,64+0(%rsp)
226 (0.0%)  	movq	%rsi,64+8(%rsp)
226 (0.0%)  	movq	%rdx,64+16(%rsp)
226 (0.0%)  	movq	%rax,88(%rsp)
  .         .cfi_escape	0x0f,0x06,0x77,0xd8,0x00,0x06,0x23,0x08
  .         .Lprologue_avx:
  .         
226 (0.0%)  	vzeroupper
226 (0.0%)  	movl	0(%rdi),%eax
226 (0.0%)  	movl	4(%rdi),%ebx
226 (0.0%)  	movl	8(%rdi),%ecx
226 (0.0%)  	movl	12(%rdi),%edx
226 (0.0%)  	movl	16(%rdi),%r8d
226 (0.0%)  	movl	20(%rdi),%r9d
226 (0.0%)  	movl	24(%rdi),%r10d
226 (0.0%)  	movl	28(%rdi),%r11d
226 (0.0%)  	vmovdqa	K256+512+32(%rip),%xmm8
226 (0.0%)  	vmovdqa	K256+512+64(%rip),%xmm9
226 (0.0%)  	jmp	.Lloop_avx
  .         .align	16
  .         .Lloop_avx:
275 (0.0%)  	vmovdqa	K256+512(%rip),%xmm7
275 (0.0%)  	vmovdqu	0(%rsi),%xmm0
275 (0.0%)  	vmovdqu	16(%rsi),%xmm1
275 (0.0%)  	vmovdqu	32(%rsi),%xmm2
275 (0.0%)  	vmovdqu	48(%rsi),%xmm3
275 (0.0%)  	vpshufb	%xmm7,%xmm0,%xmm0
275 (0.0%)  	leaq	K256(%rip),%rbp
275 (0.0%)  	vpshufb	%xmm7,%xmm1,%xmm1
275 (0.0%)  	vpshufb	%xmm7,%xmm2,%xmm2
275 (0.0%)  	vpaddd	0(%rbp),%xmm0,%xmm4
275 (0.0%)  	vpshufb	%xmm7,%xmm3,%xmm3
275 (0.0%)  	vpaddd	32(%rbp),%xmm1,%xmm5
275 (0.0%)  	vpaddd	64(%rbp),%xmm2,%xmm6
275 (0.0%)  	vpaddd	96(%rbp),%xmm3,%xmm7
275 (0.0%)  	vmovdqa	%xmm4,0(%rsp)
275 (0.0%)  	movl	%eax,%r14d
275 (0.0%)  	vmovdqa	%xmm5,16(%rsp)
275 (0.0%)  	movl	%ebx,%edi
275 (0.0%)  	vmovdqa	%xmm6,32(%rsp)
275 (0.0%)  	xorl	%ecx,%edi
275 (0.0%)  	vmovdqa	%xmm7,48(%rsp)
275 (0.0%)  	movl	%r8d,%r13d
275 (0.0%)  	jmp	.Lavx_00_47
  .         
  .         .align	16
  .         .Lavx_00_47:
825 (0.0%)  	subq	$-128,%rbp
825 (0.0%)  	vpalignr	$4,%xmm0,%xmm1,%xmm4
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	movl	%r14d,%eax
825 (0.0%)  	movl	%r9d,%r12d
825 (0.0%)  	vpalignr	$4,%xmm2,%xmm3,%xmm7
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	xorl	%r8d,%r13d
825 (0.0%)  	xorl	%r10d,%r12d
825 (0.0%)  	vpsrld	$7,%xmm4,%xmm6
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	xorl	%eax,%r14d
825 (0.0%)  	andl	%r8d,%r12d
825 (0.0%)  	vpaddd	%xmm7,%xmm0,%xmm0
825 (0.0%)  	xorl	%r8d,%r13d
825 (0.0%)  	addl	0(%rsp),%r11d
825 (0.0%)  	movl	%eax,%r15d
825 (0.0%)  	vpsrld	$3,%xmm4,%xmm7
825 (0.0%)  	xorl	%r10d,%r12d
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	xorl	%ebx,%r15d
825 (0.0%)  	vpslld	$14,%xmm4,%xmm5
825 (0.0%)  	addl	%r12d,%r11d
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	andl	%r15d,%edi
825 (0.0%)  	vpxor	%xmm6,%xmm7,%xmm4
825 (0.0%)  	xorl	%eax,%r14d
825 (0.0%)  	addl	%r13d,%r11d
825 (0.0%)  	xorl	%ebx,%edi
825 (0.0%)  	vpshufd	$250,%xmm3,%xmm7
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	addl	%r11d,%edx
825 (0.0%)  	addl	%edi,%r11d
825 (0.0%)  	vpsrld	$11,%xmm6,%xmm6
825 (0.0%)  	movl	%edx,%r13d
825 (0.0%)  	addl	%r11d,%r14d
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
825 (0.0%)  	movl	%r14d,%r11d
825 (0.0%)  	movl	%r8d,%r12d
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	vpslld	$11,%xmm5,%xmm5
825 (0.0%)  	xorl	%edx,%r13d
825 (0.0%)  	xorl	%r9d,%r12d
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	vpxor	%xmm6,%xmm4,%xmm4
825 (0.0%)  	xorl	%r11d,%r14d
825 (0.0%)  	andl	%edx,%r12d
825 (0.0%)  	xorl	%edx,%r13d
825 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
825 (0.0%)  	addl	4(%rsp),%r10d
825 (0.0%)  	movl	%r11d,%edi
825 (0.0%)  	xorl	%r9d,%r12d
825 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	xorl	%eax,%edi
825 (0.0%)  	addl	%r12d,%r10d
825 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	andl	%edi,%r15d
825 (0.0%)  	xorl	%r11d,%r14d
825 (0.0%)  	vpaddd	%xmm4,%xmm0,%xmm0
825 (0.0%)  	addl	%r13d,%r10d
825 (0.0%)  	xorl	%eax,%r15d
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	addl	%r10d,%ecx
825 (0.0%)  	addl	%r15d,%r10d
825 (0.0%)  	movl	%ecx,%r13d
825 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
825 (0.0%)  	addl	%r10d,%r14d
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	movl	%r14d,%r10d
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	movl	%edx,%r12d
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	xorl	%ecx,%r13d
825 (0.0%)  	vpshufb	%xmm8,%xmm6,%xmm6
825 (0.0%)  	xorl	%r8d,%r12d
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	xorl	%r10d,%r14d
825 (0.0%)  	vpaddd	%xmm6,%xmm0,%xmm0
825 (0.0%)  	andl	%ecx,%r12d
825 (0.0%)  	xorl	%ecx,%r13d
825 (0.0%)  	addl	8(%rsp),%r9d
825 (0.0%)  	vpshufd	$80,%xmm0,%xmm7
825 (0.0%)  	movl	%r10d,%r15d
825 (0.0%)  	xorl	%r8d,%r12d
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
825 (0.0%)  	xorl	%r11d,%r15d
825 (0.0%)  	addl	%r12d,%r9d
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
825 (0.0%)  	andl	%r15d,%edi
825 (0.0%)  	xorl	%r10d,%r14d
825 (0.0%)  	addl	%r13d,%r9d
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	xorl	%r11d,%edi
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	addl	%r9d,%ebx
825 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
825 (0.0%)  	addl	%edi,%r9d
825 (0.0%)  	movl	%ebx,%r13d
825 (0.0%)  	addl	%r9d,%r14d
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	movl	%r14d,%r9d
825 (0.0%)  	movl	%ecx,%r12d
825 (0.0%)  	vpshufb	%xmm9,%xmm6,%xmm6
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	xorl	%ebx,%r13d
825 (0.0%)  	xorl	%edx,%r12d
825 (0.0%)  	vpaddd	%xmm6,%xmm0,%xmm0
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	xorl	%r9d,%r14d
825 (0.0%)  	andl	%ebx,%r12d
825 (0.0%)  	vpaddd	0(%rbp),%xmm0,%xmm6
825 (0.0%)  	xorl	%ebx,%r13d
825 (0.0%)  	addl	12(%rsp),%r8d
825 (0.0%)  	movl	%r9d,%edi
825 (0.0%)  	xorl	%edx,%r12d
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	xorl	%r10d,%edi
825 (0.0%)  	addl	%r12d,%r8d
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	andl	%edi,%r15d
825 (0.0%)  	xorl	%r9d,%r14d
825 (0.0%)  	addl	%r13d,%r8d
825 (0.0%)  	xorl	%r10d,%r15d
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	addl	%r8d,%eax
825 (0.0%)  	addl	%r15d,%r8d
825 (0.0%)  	movl	%eax,%r13d
825 (0.0%)  	addl	%r8d,%r14d
825 (0.0%)  	vmovdqa	%xmm6,0(%rsp)
825 (0.0%)  	vpalignr	$4,%xmm1,%xmm2,%xmm4
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	movl	%r14d,%r8d
825 (0.0%)  	movl	%ebx,%r12d
825 (0.0%)  	vpalignr	$4,%xmm3,%xmm0,%xmm7
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	xorl	%eax,%r13d
825 (0.0%)  	xorl	%ecx,%r12d
825 (0.0%)  	vpsrld	$7,%xmm4,%xmm6
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	xorl	%r8d,%r14d
825 (0.0%)  	andl	%eax,%r12d
825 (0.0%)  	vpaddd	%xmm7,%xmm1,%xmm1
825 (0.0%)  	xorl	%eax,%r13d
825 (0.0%)  	addl	16(%rsp),%edx
825 (0.0%)  	movl	%r8d,%r15d
825 (0.0%)  	vpsrld	$3,%xmm4,%xmm7
825 (0.0%)  	xorl	%ecx,%r12d
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	xorl	%r9d,%r15d
825 (0.0%)  	vpslld	$14,%xmm4,%xmm5
825 (0.0%)  	addl	%r12d,%edx
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	andl	%r15d,%edi
825 (0.0%)  	vpxor	%xmm6,%xmm7,%xmm4
825 (0.0%)  	xorl	%r8d,%r14d
825 (0.0%)  	addl	%r13d,%edx
825 (0.0%)  	xorl	%r9d,%edi
825 (0.0%)  	vpshufd	$250,%xmm0,%xmm7
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	addl	%edx,%r11d
825 (0.0%)  	addl	%edi,%edx
825 (0.0%)  	vpsrld	$11,%xmm6,%xmm6
825 (0.0%)  	movl	%r11d,%r13d
825 (0.0%)  	addl	%edx,%r14d
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
825 (0.0%)  	movl	%r14d,%edx
825 (0.0%)  	movl	%eax,%r12d
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	vpslld	$11,%xmm5,%xmm5
825 (0.0%)  	xorl	%r11d,%r13d
825 (0.0%)  	xorl	%ebx,%r12d
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	vpxor	%xmm6,%xmm4,%xmm4
825 (0.0%)  	xorl	%edx,%r14d
825 (0.0%)  	andl	%r11d,%r12d
825 (0.0%)  	xorl	%r11d,%r13d
825 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
825 (0.0%)  	addl	20(%rsp),%ecx
825 (0.0%)  	movl	%edx,%edi
825 (0.0%)  	xorl	%ebx,%r12d
825 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	xorl	%r8d,%edi
825 (0.0%)  	addl	%r12d,%ecx
825 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	andl	%edi,%r15d
825 (0.0%)  	xorl	%edx,%r14d
825 (0.0%)  	vpaddd	%xmm4,%xmm1,%xmm1
825 (0.0%)  	addl	%r13d,%ecx
825 (0.0%)  	xorl	%r8d,%r15d
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	addl	%ecx,%r10d
825 (0.0%)  	addl	%r15d,%ecx
825 (0.0%)  	movl	%r10d,%r13d
825 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
825 (0.0%)  	addl	%ecx,%r14d
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	movl	%r14d,%ecx
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	movl	%r11d,%r12d
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	xorl	%r10d,%r13d
825 (0.0%)  	vpshufb	%xmm8,%xmm6,%xmm6
825 (0.0%)  	xorl	%eax,%r12d
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	xorl	%ecx,%r14d
825 (0.0%)  	vpaddd	%xmm6,%xmm1,%xmm1
825 (0.0%)  	andl	%r10d,%r12d
825 (0.0%)  	xorl	%r10d,%r13d
825 (0.0%)  	addl	24(%rsp),%ebx
825 (0.0%)  	vpshufd	$80,%xmm1,%xmm7
825 (0.0%)  	movl	%ecx,%r15d
825 (0.0%)  	xorl	%eax,%r12d
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
825 (0.0%)  	xorl	%edx,%r15d
825 (0.0%)  	addl	%r12d,%ebx
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
825 (0.0%)  	andl	%r15d,%edi
825 (0.0%)  	xorl	%ecx,%r14d
825 (0.0%)  	addl	%r13d,%ebx
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	xorl	%edx,%edi
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	addl	%ebx,%r9d
825 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
825 (0.0%)  	addl	%edi,%ebx
825 (0.0%)  	movl	%r9d,%r13d
825 (0.0%)  	addl	%ebx,%r14d
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	movl	%r14d,%ebx
825 (0.0%)  	movl	%r10d,%r12d
825 (0.0%)  	vpshufb	%xmm9,%xmm6,%xmm6
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	xorl	%r9d,%r13d
825 (0.0%)  	xorl	%r11d,%r12d
825 (0.0%)  	vpaddd	%xmm6,%xmm1,%xmm1
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	xorl	%ebx,%r14d
825 (0.0%)  	andl	%r9d,%r12d
825 (0.0%)  	vpaddd	32(%rbp),%xmm1,%xmm6
825 (0.0%)  	xorl	%r9d,%r13d
825 (0.0%)  	addl	28(%rsp),%eax
825 (0.0%)  	movl	%ebx,%edi
825 (0.0%)  	xorl	%r11d,%r12d
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	xorl	%ecx,%edi
825 (0.0%)  	addl	%r12d,%eax
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	andl	%edi,%r15d
825 (0.0%)  	xorl	%ebx,%r14d
825 (0.0%)  	addl	%r13d,%eax
825 (0.0%)  	xorl	%ecx,%r15d
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	addl	%eax,%r8d
825 (0.0%)  	addl	%r15d,%eax
825 (0.0%)  	movl	%r8d,%r13d
825 (0.0%)  	addl	%eax,%r14d
825 (0.0%)  	vmovdqa	%xmm6,16(%rsp)
825 (0.0%)  	vpalignr	$4,%xmm2,%xmm3,%xmm4
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	movl	%r14d,%eax
825 (0.0%)  	movl	%r9d,%r12d
825 (0.0%)  	vpalignr	$4,%xmm0,%xmm1,%xmm7
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	xorl	%r8d,%r13d
825 (0.0%)  	xorl	%r10d,%r12d
825 (0.0%)  	vpsrld	$7,%xmm4,%xmm6
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	xorl	%eax,%r14d
825 (0.0%)  	andl	%r8d,%r12d
825 (0.0%)  	vpaddd	%xmm7,%xmm2,%xmm2
825 (0.0%)  	xorl	%r8d,%r13d
825 (0.0%)  	addl	32(%rsp),%r11d
825 (0.0%)  	movl	%eax,%r15d
825 (0.0%)  	vpsrld	$3,%xmm4,%xmm7
825 (0.0%)  	xorl	%r10d,%r12d
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	xorl	%ebx,%r15d
825 (0.0%)  	vpslld	$14,%xmm4,%xmm5
825 (0.0%)  	addl	%r12d,%r11d
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	andl	%r15d,%edi
825 (0.0%)  	vpxor	%xmm6,%xmm7,%xmm4
825 (0.0%)  	xorl	%eax,%r14d
825 (0.0%)  	addl	%r13d,%r11d
825 (0.0%)  	xorl	%ebx,%edi
825 (0.0%)  	vpshufd	$250,%xmm1,%xmm7
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	addl	%r11d,%edx
825 (0.0%)  	addl	%edi,%r11d
825 (0.0%)  	vpsrld	$11,%xmm6,%xmm6
825 (0.0%)  	movl	%edx,%r13d
825 (0.0%)  	addl	%r11d,%r14d
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
825 (0.0%)  	movl	%r14d,%r11d
825 (0.0%)  	movl	%r8d,%r12d
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	vpslld	$11,%xmm5,%xmm5
825 (0.0%)  	xorl	%edx,%r13d
825 (0.0%)  	xorl	%r9d,%r12d
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	vpxor	%xmm6,%xmm4,%xmm4
825 (0.0%)  	xorl	%r11d,%r14d
825 (0.0%)  	andl	%edx,%r12d
825 (0.0%)  	xorl	%edx,%r13d
825 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
825 (0.0%)  	addl	36(%rsp),%r10d
825 (0.0%)  	movl	%r11d,%edi
825 (0.0%)  	xorl	%r9d,%r12d
825 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	xorl	%eax,%edi
825 (0.0%)  	addl	%r12d,%r10d
825 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	andl	%edi,%r15d
825 (0.0%)  	xorl	%r11d,%r14d
825 (0.0%)  	vpaddd	%xmm4,%xmm2,%xmm2
825 (0.0%)  	addl	%r13d,%r10d
825 (0.0%)  	xorl	%eax,%r15d
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	addl	%r10d,%ecx
825 (0.0%)  	addl	%r15d,%r10d
825 (0.0%)  	movl	%ecx,%r13d
825 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
825 (0.0%)  	addl	%r10d,%r14d
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	movl	%r14d,%r10d
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	movl	%edx,%r12d
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	xorl	%ecx,%r13d
825 (0.0%)  	vpshufb	%xmm8,%xmm6,%xmm6
825 (0.0%)  	xorl	%r8d,%r12d
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	xorl	%r10d,%r14d
825 (0.0%)  	vpaddd	%xmm6,%xmm2,%xmm2
825 (0.0%)  	andl	%ecx,%r12d
825 (0.0%)  	xorl	%ecx,%r13d
825 (0.0%)  	addl	40(%rsp),%r9d
825 (0.0%)  	vpshufd	$80,%xmm2,%xmm7
825 (0.0%)  	movl	%r10d,%r15d
825 (0.0%)  	xorl	%r8d,%r12d
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
825 (0.0%)  	xorl	%r11d,%r15d
825 (0.0%)  	addl	%r12d,%r9d
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
825 (0.0%)  	andl	%r15d,%edi
825 (0.0%)  	xorl	%r10d,%r14d
825 (0.0%)  	addl	%r13d,%r9d
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	xorl	%r11d,%edi
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	addl	%r9d,%ebx
825 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
825 (0.0%)  	addl	%edi,%r9d
825 (0.0%)  	movl	%ebx,%r13d
825 (0.0%)  	addl	%r9d,%r14d
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	movl	%r14d,%r9d
825 (0.0%)  	movl	%ecx,%r12d
825 (0.0%)  	vpshufb	%xmm9,%xmm6,%xmm6
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	xorl	%ebx,%r13d
825 (0.0%)  	xorl	%edx,%r12d
825 (0.0%)  	vpaddd	%xmm6,%xmm2,%xmm2
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	xorl	%r9d,%r14d
825 (0.0%)  	andl	%ebx,%r12d
825 (0.0%)  	vpaddd	64(%rbp),%xmm2,%xmm6
825 (0.0%)  	xorl	%ebx,%r13d
825 (0.0%)  	addl	44(%rsp),%r8d
825 (0.0%)  	movl	%r9d,%edi
825 (0.0%)  	xorl	%edx,%r12d
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	xorl	%r10d,%edi
825 (0.0%)  	addl	%r12d,%r8d
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	andl	%edi,%r15d
825 (0.0%)  	xorl	%r9d,%r14d
825 (0.0%)  	addl	%r13d,%r8d
825 (0.0%)  	xorl	%r10d,%r15d
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	addl	%r8d,%eax
825 (0.0%)  	addl	%r15d,%r8d
825 (0.0%)  	movl	%eax,%r13d
825 (0.0%)  	addl	%r8d,%r14d
825 (0.0%)  	vmovdqa	%xmm6,32(%rsp)
825 (0.0%)  	vpalignr	$4,%xmm3,%xmm0,%xmm4
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	movl	%r14d,%r8d
825 (0.0%)  	movl	%ebx,%r12d
825 (0.0%)  	vpalignr	$4,%xmm1,%xmm2,%xmm7
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	xorl	%eax,%r13d
825 (0.0%)  	xorl	%ecx,%r12d
825 (0.0%)  	vpsrld	$7,%xmm4,%xmm6
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	xorl	%r8d,%r14d
825 (0.0%)  	andl	%eax,%r12d
825 (0.0%)  	vpaddd	%xmm7,%xmm3,%xmm3
825 (0.0%)  	xorl	%eax,%r13d
825 (0.0%)  	addl	48(%rsp),%edx
825 (0.0%)  	movl	%r8d,%r15d
825 (0.0%)  	vpsrld	$3,%xmm4,%xmm7
825 (0.0%)  	xorl	%ecx,%r12d
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	xorl	%r9d,%r15d
825 (0.0%)  	vpslld	$14,%xmm4,%xmm5
825 (0.0%)  	addl	%r12d,%edx
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	andl	%r15d,%edi
825 (0.0%)  	vpxor	%xmm6,%xmm7,%xmm4
825 (0.0%)  	xorl	%r8d,%r14d
825 (0.0%)  	addl	%r13d,%edx
825 (0.0%)  	xorl	%r9d,%edi
825 (0.0%)  	vpshufd	$250,%xmm2,%xmm7
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	addl	%edx,%r11d
825 (0.0%)  	addl	%edi,%edx
825 (0.0%)  	vpsrld	$11,%xmm6,%xmm6
825 (0.0%)  	movl	%r11d,%r13d
825 (0.0%)  	addl	%edx,%r14d
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
825 (0.0%)  	movl	%r14d,%edx
825 (0.0%)  	movl	%eax,%r12d
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	vpslld	$11,%xmm5,%xmm5
825 (0.0%)  	xorl	%r11d,%r13d
825 (0.0%)  	xorl	%ebx,%r12d
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	vpxor	%xmm6,%xmm4,%xmm4
825 (0.0%)  	xorl	%edx,%r14d
825 (0.0%)  	andl	%r11d,%r12d
825 (0.0%)  	xorl	%r11d,%r13d
825 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
825 (0.0%)  	addl	52(%rsp),%ecx
825 (0.0%)  	movl	%edx,%edi
825 (0.0%)  	xorl	%ebx,%r12d
825 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	xorl	%r8d,%edi
825 (0.0%)  	addl	%r12d,%ecx
825 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	andl	%edi,%r15d
825 (0.0%)  	xorl	%edx,%r14d
825 (0.0%)  	vpaddd	%xmm4,%xmm3,%xmm3
825 (0.0%)  	addl	%r13d,%ecx
825 (0.0%)  	xorl	%r8d,%r15d
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	addl	%ecx,%r10d
825 (0.0%)  	addl	%r15d,%ecx
825 (0.0%)  	movl	%r10d,%r13d
825 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
825 (0.0%)  	addl	%ecx,%r14d
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	movl	%r14d,%ecx
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	movl	%r11d,%r12d
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	xorl	%r10d,%r13d
825 (0.0%)  	vpshufb	%xmm8,%xmm6,%xmm6
825 (0.0%)  	xorl	%eax,%r12d
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	xorl	%ecx,%r14d
825 (0.0%)  	vpaddd	%xmm6,%xmm3,%xmm3
825 (0.0%)  	andl	%r10d,%r12d
825 (0.0%)  	xorl	%r10d,%r13d
825 (0.0%)  	addl	56(%rsp),%ebx
825 (0.0%)  	vpshufd	$80,%xmm3,%xmm7
825 (0.0%)  	movl	%ecx,%r15d
825 (0.0%)  	xorl	%eax,%r12d
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
825 (0.0%)  	xorl	%edx,%r15d
825 (0.0%)  	addl	%r12d,%ebx
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
825 (0.0%)  	andl	%r15d,%edi
825 (0.0%)  	xorl	%ecx,%r14d
825 (0.0%)  	addl	%r13d,%ebx
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	xorl	%edx,%edi
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	addl	%ebx,%r9d
825 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
825 (0.0%)  	addl	%edi,%ebx
825 (0.0%)  	movl	%r9d,%r13d
825 (0.0%)  	addl	%ebx,%r14d
825 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
825 (0.0%)  	shrdl	$14,%r13d,%r13d
825 (0.0%)  	movl	%r14d,%ebx
825 (0.0%)  	movl	%r10d,%r12d
825 (0.0%)  	vpshufb	%xmm9,%xmm6,%xmm6
825 (0.0%)  	shrdl	$9,%r14d,%r14d
825 (0.0%)  	xorl	%r9d,%r13d
825 (0.0%)  	xorl	%r11d,%r12d
825 (0.0%)  	vpaddd	%xmm6,%xmm3,%xmm3
825 (0.0%)  	shrdl	$5,%r13d,%r13d
825 (0.0%)  	xorl	%ebx,%r14d
825 (0.0%)  	andl	%r9d,%r12d
825 (0.0%)  	vpaddd	96(%rbp),%xmm3,%xmm6
825 (0.0%)  	xorl	%r9d,%r13d
825 (0.0%)  	addl	60(%rsp),%eax
825 (0.0%)  	movl	%ebx,%edi
825 (0.0%)  	xorl	%r11d,%r12d
825 (0.0%)  	shrdl	$11,%r14d,%r14d
825 (0.0%)  	xorl	%ecx,%edi
825 (0.0%)  	addl	%r12d,%eax
825 (0.0%)  	shrdl	$6,%r13d,%r13d
825 (0.0%)  	andl	%edi,%r15d
825 (0.0%)  	xorl	%ebx,%r14d
825 (0.0%)  	addl	%r13d,%eax
825 (0.0%)  	xorl	%ecx,%r15d
825 (0.0%)  	shrdl	$2,%r14d,%r14d
825 (0.0%)  	addl	%eax,%r8d
825 (0.0%)  	addl	%r15d,%eax
825 (0.0%)  	movl	%r8d,%r13d
825 (0.0%)  	addl	%eax,%r14d
825 (0.0%)  	vmovdqa	%xmm6,48(%rsp)
825 (0.0%)  	cmpb	$0,131(%rbp)
825 (0.0%)  	jne	.Lavx_00_47
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%eax
275 (0.0%)  	movl	%r9d,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%r8d,%r13d
275 (0.0%)  	xorl	%r10d,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%eax,%r14d
275 (0.0%)  	andl	%r8d,%r12d
275 (0.0%)  	xorl	%r8d,%r13d
275 (0.0%)  	addl	0(%rsp),%r11d
275 (0.0%)  	movl	%eax,%r15d
275 (0.0%)  	xorl	%r10d,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%ebx,%r15d
275 (0.0%)  	addl	%r12d,%r11d
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%r15d,%edi
275 (0.0%)  	xorl	%eax,%r14d
275 (0.0%)  	addl	%r13d,%r11d
275 (0.0%)  	xorl	%ebx,%edi
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%r11d,%edx
275 (0.0%)  	addl	%edi,%r11d
275 (0.0%)  	movl	%edx,%r13d
275 (0.0%)  	addl	%r11d,%r14d
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%r11d
275 (0.0%)  	movl	%r8d,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%edx,%r13d
275 (0.0%)  	xorl	%r9d,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%r11d,%r14d
275 (0.0%)  	andl	%edx,%r12d
275 (0.0%)  	xorl	%edx,%r13d
275 (0.0%)  	addl	4(%rsp),%r10d
275 (0.0%)  	movl	%r11d,%edi
275 (0.0%)  	xorl	%r9d,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%eax,%edi
275 (0.0%)  	addl	%r12d,%r10d
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%edi,%r15d
275 (0.0%)  	xorl	%r11d,%r14d
275 (0.0%)  	addl	%r13d,%r10d
275 (0.0%)  	xorl	%eax,%r15d
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%r10d,%ecx
275 (0.0%)  	addl	%r15d,%r10d
275 (0.0%)  	movl	%ecx,%r13d
275 (0.0%)  	addl	%r10d,%r14d
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%r10d
275 (0.0%)  	movl	%edx,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%ecx,%r13d
275 (0.0%)  	xorl	%r8d,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%r10d,%r14d
275 (0.0%)  	andl	%ecx,%r12d
275 (0.0%)  	xorl	%ecx,%r13d
275 (0.0%)  	addl	8(%rsp),%r9d
275 (0.0%)  	movl	%r10d,%r15d
275 (0.0%)  	xorl	%r8d,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%r11d,%r15d
275 (0.0%)  	addl	%r12d,%r9d
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%r15d,%edi
275 (0.0%)  	xorl	%r10d,%r14d
275 (0.0%)  	addl	%r13d,%r9d
275 (0.0%)  	xorl	%r11d,%edi
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%r9d,%ebx
275 (0.0%)  	addl	%edi,%r9d
275 (0.0%)  	movl	%ebx,%r13d
275 (0.0%)  	addl	%r9d,%r14d
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%r9d
275 (0.0%)  	movl	%ecx,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%ebx,%r13d
275 (0.0%)  	xorl	%edx,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%r9d,%r14d
275 (0.0%)  	andl	%ebx,%r12d
275 (0.0%)  	xorl	%ebx,%r13d
275 (0.0%)  	addl	12(%rsp),%r8d
275 (0.0%)  	movl	%r9d,%edi
275 (0.0%)  	xorl	%edx,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%r10d,%edi
275 (0.0%)  	addl	%r12d,%r8d
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%edi,%r15d
275 (0.0%)  	xorl	%r9d,%r14d
275 (0.0%)  	addl	%r13d,%r8d
275 (0.0%)  	xorl	%r10d,%r15d
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%r8d,%eax
275 (0.0%)  	addl	%r15d,%r8d
275 (0.0%)  	movl	%eax,%r13d
275 (0.0%)  	addl	%r8d,%r14d
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%r8d
275 (0.0%)  	movl	%ebx,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%eax,%r13d
275 (0.0%)  	xorl	%ecx,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%r8d,%r14d
275 (0.0%)  	andl	%eax,%r12d
275 (0.0%)  	xorl	%eax,%r13d
275 (0.0%)  	addl	16(%rsp),%edx
275 (0.0%)  	movl	%r8d,%r15d
275 (0.0%)  	xorl	%ecx,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%r9d,%r15d
275 (0.0%)  	addl	%r12d,%edx
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%r15d,%edi
275 (0.0%)  	xorl	%r8d,%r14d
275 (0.0%)  	addl	%r13d,%edx
275 (0.0%)  	xorl	%r9d,%edi
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%edx,%r11d
275 (0.0%)  	addl	%edi,%edx
275 (0.0%)  	movl	%r11d,%r13d
275 (0.0%)  	addl	%edx,%r14d
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%edx
275 (0.0%)  	movl	%eax,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%r11d,%r13d
275 (0.0%)  	xorl	%ebx,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%edx,%r14d
275 (0.0%)  	andl	%r11d,%r12d
275 (0.0%)  	xorl	%r11d,%r13d
275 (0.0%)  	addl	20(%rsp),%ecx
275 (0.0%)  	movl	%edx,%edi
275 (0.0%)  	xorl	%ebx,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%r8d,%edi
275 (0.0%)  	addl	%r12d,%ecx
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%edi,%r15d
275 (0.0%)  	xorl	%edx,%r14d
275 (0.0%)  	addl	%r13d,%ecx
275 (0.0%)  	xorl	%r8d,%r15d
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%ecx,%r10d
275 (0.0%)  	addl	%r15d,%ecx
275 (0.0%)  	movl	%r10d,%r13d
275 (0.0%)  	addl	%ecx,%r14d
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%ecx
275 (0.0%)  	movl	%r11d,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%r10d,%r13d
275 (0.0%)  	xorl	%eax,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%ecx,%r14d
275 (0.0%)  	andl	%r10d,%r12d
275 (0.0%)  	xorl	%r10d,%r13d
275 (0.0%)  	addl	24(%rsp),%ebx
275 (0.0%)  	movl	%ecx,%r15d
275 (0.0%)  	xorl	%eax,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%edx,%r15d
275 (0.0%)  	addl	%r12d,%ebx
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%r15d,%edi
275 (0.0%)  	xorl	%ecx,%r14d
275 (0.0%)  	addl	%r13d,%ebx
275 (0.0%)  	xorl	%edx,%edi
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%ebx,%r9d
275 (0.0%)  	addl	%edi,%ebx
275 (0.0%)  	movl	%r9d,%r13d
275 (0.0%)  	addl	%ebx,%r14d
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%ebx
275 (0.0%)  	movl	%r10d,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%r9d,%r13d
275 (0.0%)  	xorl	%r11d,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%ebx,%r14d
275 (0.0%)  	andl	%r9d,%r12d
275 (0.0%)  	xorl	%r9d,%r13d
275 (0.0%)  	addl	28(%rsp),%eax
275 (0.0%)  	movl	%ebx,%edi
275 (0.0%)  	xorl	%r11d,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%ecx,%edi
275 (0.0%)  	addl	%r12d,%eax
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%edi,%r15d
275 (0.0%)  	xorl	%ebx,%r14d
275 (0.0%)  	addl	%r13d,%eax
275 (0.0%)  	xorl	%ecx,%r15d
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%eax,%r8d
275 (0.0%)  	addl	%r15d,%eax
275 (0.0%)  	movl	%r8d,%r13d
275 (0.0%)  	addl	%eax,%r14d
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%eax
275 (0.0%)  	movl	%r9d,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%r8d,%r13d
275 (0.0%)  	xorl	%r10d,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%eax,%r14d
275 (0.0%)  	andl	%r8d,%r12d
275 (0.0%)  	xorl	%r8d,%r13d
275 (0.0%)  	addl	32(%rsp),%r11d
275 (0.0%)  	movl	%eax,%r15d
275 (0.0%)  	xorl	%r10d,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%ebx,%r15d
275 (0.0%)  	addl	%r12d,%r11d
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%r15d,%edi
275 (0.0%)  	xorl	%eax,%r14d
275 (0.0%)  	addl	%r13d,%r11d
275 (0.0%)  	xorl	%ebx,%edi
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%r11d,%edx
275 (0.0%)  	addl	%edi,%r11d
275 (0.0%)  	movl	%edx,%r13d
275 (0.0%)  	addl	%r11d,%r14d
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%r11d
275 (0.0%)  	movl	%r8d,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%edx,%r13d
275 (0.0%)  	xorl	%r9d,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%r11d,%r14d
275 (0.0%)  	andl	%edx,%r12d
275 (0.0%)  	xorl	%edx,%r13d
275 (0.0%)  	addl	36(%rsp),%r10d
275 (0.0%)  	movl	%r11d,%edi
275 (0.0%)  	xorl	%r9d,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%eax,%edi
275 (0.0%)  	addl	%r12d,%r10d
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%edi,%r15d
275 (0.0%)  	xorl	%r11d,%r14d
275 (0.0%)  	addl	%r13d,%r10d
275 (0.0%)  	xorl	%eax,%r15d
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%r10d,%ecx
275 (0.0%)  	addl	%r15d,%r10d
275 (0.0%)  	movl	%ecx,%r13d
275 (0.0%)  	addl	%r10d,%r14d
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%r10d
275 (0.0%)  	movl	%edx,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%ecx,%r13d
275 (0.0%)  	xorl	%r8d,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%r10d,%r14d
275 (0.0%)  	andl	%ecx,%r12d
275 (0.0%)  	xorl	%ecx,%r13d
275 (0.0%)  	addl	40(%rsp),%r9d
275 (0.0%)  	movl	%r10d,%r15d
275 (0.0%)  	xorl	%r8d,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%r11d,%r15d
275 (0.0%)  	addl	%r12d,%r9d
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%r15d,%edi
275 (0.0%)  	xorl	%r10d,%r14d
275 (0.0%)  	addl	%r13d,%r9d
275 (0.0%)  	xorl	%r11d,%edi
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%r9d,%ebx
275 (0.0%)  	addl	%edi,%r9d
275 (0.0%)  	movl	%ebx,%r13d
275 (0.0%)  	addl	%r9d,%r14d
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%r9d
275 (0.0%)  	movl	%ecx,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%ebx,%r13d
275 (0.0%)  	xorl	%edx,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%r9d,%r14d
275 (0.0%)  	andl	%ebx,%r12d
275 (0.0%)  	xorl	%ebx,%r13d
275 (0.0%)  	addl	44(%rsp),%r8d
275 (0.0%)  	movl	%r9d,%edi
275 (0.0%)  	xorl	%edx,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%r10d,%edi
275 (0.0%)  	addl	%r12d,%r8d
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%edi,%r15d
275 (0.0%)  	xorl	%r9d,%r14d
275 (0.0%)  	addl	%r13d,%r8d
275 (0.0%)  	xorl	%r10d,%r15d
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%r8d,%eax
275 (0.0%)  	addl	%r15d,%r8d
275 (0.0%)  	movl	%eax,%r13d
275 (0.0%)  	addl	%r8d,%r14d
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%r8d
275 (0.0%)  	movl	%ebx,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%eax,%r13d
275 (0.0%)  	xorl	%ecx,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%r8d,%r14d
275 (0.0%)  	andl	%eax,%r12d
275 (0.0%)  	xorl	%eax,%r13d
275 (0.0%)  	addl	48(%rsp),%edx
275 (0.0%)  	movl	%r8d,%r15d
275 (0.0%)  	xorl	%ecx,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%r9d,%r15d
275 (0.0%)  	addl	%r12d,%edx
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%r15d,%edi
275 (0.0%)  	xorl	%r8d,%r14d
275 (0.0%)  	addl	%r13d,%edx
275 (0.0%)  	xorl	%r9d,%edi
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%edx,%r11d
275 (0.0%)  	addl	%edi,%edx
275 (0.0%)  	movl	%r11d,%r13d
275 (0.0%)  	addl	%edx,%r14d
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%edx
275 (0.0%)  	movl	%eax,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%r11d,%r13d
275 (0.0%)  	xorl	%ebx,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%edx,%r14d
275 (0.0%)  	andl	%r11d,%r12d
275 (0.0%)  	xorl	%r11d,%r13d
275 (0.0%)  	addl	52(%rsp),%ecx
275 (0.0%)  	movl	%edx,%edi
275 (0.0%)  	xorl	%ebx,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%r8d,%edi
275 (0.0%)  	addl	%r12d,%ecx
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%edi,%r15d
275 (0.0%)  	xorl	%edx,%r14d
275 (0.0%)  	addl	%r13d,%ecx
275 (0.0%)  	xorl	%r8d,%r15d
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%ecx,%r10d
275 (0.0%)  	addl	%r15d,%ecx
275 (0.0%)  	movl	%r10d,%r13d
275 (0.0%)  	addl	%ecx,%r14d
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%ecx
275 (0.0%)  	movl	%r11d,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%r10d,%r13d
275 (0.0%)  	xorl	%eax,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%ecx,%r14d
275 (0.0%)  	andl	%r10d,%r12d
275 (0.0%)  	xorl	%r10d,%r13d
275 (0.0%)  	addl	56(%rsp),%ebx
275 (0.0%)  	movl	%ecx,%r15d
275 (0.0%)  	xorl	%eax,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%edx,%r15d
275 (0.0%)  	addl	%r12d,%ebx
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%r15d,%edi
275 (0.0%)  	xorl	%ecx,%r14d
275 (0.0%)  	addl	%r13d,%ebx
275 (0.0%)  	xorl	%edx,%edi
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%ebx,%r9d
275 (0.0%)  	addl	%edi,%ebx
275 (0.0%)  	movl	%r9d,%r13d
275 (0.0%)  	addl	%ebx,%r14d
275 (0.0%)  	shrdl	$14,%r13d,%r13d
275 (0.0%)  	movl	%r14d,%ebx
275 (0.0%)  	movl	%r10d,%r12d
275 (0.0%)  	shrdl	$9,%r14d,%r14d
275 (0.0%)  	xorl	%r9d,%r13d
275 (0.0%)  	xorl	%r11d,%r12d
275 (0.0%)  	shrdl	$5,%r13d,%r13d
275 (0.0%)  	xorl	%ebx,%r14d
275 (0.0%)  	andl	%r9d,%r12d
275 (0.0%)  	xorl	%r9d,%r13d
275 (0.0%)  	addl	60(%rsp),%eax
275 (0.0%)  	movl	%ebx,%edi
275 (0.0%)  	xorl	%r11d,%r12d
275 (0.0%)  	shrdl	$11,%r14d,%r14d
275 (0.0%)  	xorl	%ecx,%edi
275 (0.0%)  	addl	%r12d,%eax
275 (0.0%)  	shrdl	$6,%r13d,%r13d
275 (0.0%)  	andl	%edi,%r15d
275 (0.0%)  	xorl	%ebx,%r14d
275 (0.0%)  	addl	%r13d,%eax
275 (0.0%)  	xorl	%ecx,%r15d
275 (0.0%)  	shrdl	$2,%r14d,%r14d
275 (0.0%)  	addl	%eax,%r8d
275 (0.0%)  	addl	%r15d,%eax
275 (0.0%)  	movl	%r8d,%r13d
275 (0.0%)  	addl	%eax,%r14d
275 (0.0%)  	movq	64+0(%rsp),%rdi
275 (0.0%)  	movl	%r14d,%eax
  .         
275 (0.0%)  	addl	0(%rdi),%eax
275 (0.0%)  	leaq	64(%rsi),%rsi
275 (0.0%)  	addl	4(%rdi),%ebx
275 (0.0%)  	addl	8(%rdi),%ecx
275 (0.0%)  	addl	12(%rdi),%edx
275 (0.0%)  	addl	16(%rdi),%r8d
275 (0.0%)  	addl	20(%rdi),%r9d
275 (0.0%)  	addl	24(%rdi),%r10d
275 (0.0%)  	addl	28(%rdi),%r11d
  .         
275 (0.0%)  	cmpq	64+16(%rsp),%rsi
  .         
275 (0.0%)  	movl	%eax,0(%rdi)
275 (0.0%)  	movl	%ebx,4(%rdi)
275 (0.0%)  	movl	%ecx,8(%rdi)
275 (0.0%)  	movl	%edx,12(%rdi)
275 (0.0%)  	movl	%r8d,16(%rdi)
275 (0.0%)  	movl	%r9d,20(%rdi)
275 (0.0%)  	movl	%r10d,24(%rdi)
275 (0.0%)  	movl	%r11d,28(%rdi)
275 (0.0%)  	jb	.Lloop_avx
  .         
226 (0.0%)  	movq	88(%rsp),%rsi
  .         .cfi_def_cfa	%rsi,8
226 (0.0%)  	vzeroupper
226 (0.0%)  	movq	-48(%rsi),%r15
  .         .cfi_restore	%r15
226 (0.0%)  	movq	-40(%rsi),%r14
  .         .cfi_restore	%r14
226 (0.0%)  	movq	-32(%rsi),%r13
  .         .cfi_restore	%r13
226 (0.0%)  	movq	-24(%rsi),%r12
  .         .cfi_restore	%r12
226 (0.0%)  	movq	-16(%rsi),%rbp
  .         .cfi_restore	%rbp
226 (0.0%)  	movq	-8(%rsi),%rbx
  .         .cfi_restore	%rbx
452 (0.0%)  	leaq	(%rsi),%rsp
  .         .cfi_def_cfa_register	%rsp
  .         .Lepilogue_avx:
  .         	.byte	0xf3,0xc3
  .         .cfi_endproc	
  .         .size	sha256_block_data_order_avx,.-sha256_block_data_order_avx
  .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha512-x86_64.S
--------------------------------------------------------------------------------
Ir_______ 

-- line 9 ----------------------------------------
 .         .extern	OPENSSL_ia32cap_P
 .         .hidden OPENSSL_ia32cap_P
 .         .globl	sha512_block_data_order
 .         .hidden sha512_block_data_order
 .         .type	sha512_block_data_order,@function
 .         .align	16
 .         sha512_block_data_order:
 .         .cfi_startproc	
17 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r11
17 (0.0%)  	movl	0(%r11),%r9d
17 (0.0%)  	movl	4(%r11),%r10d
17 (0.0%)  	movl	8(%r11),%r11d
17 (0.0%)  	andl	$1073741824,%r9d
17 (0.0%)  	andl	$268435968,%r10d
17 (0.0%)  	orl	%r9d,%r10d
17 (0.0%)  	cmpl	$1342177792,%r10d
17 (0.0%)  	je	.Lavx_shortcut
 .         	movq	%rsp,%rax
 .         .cfi_def_cfa_register	%rax
 .         	pushq	%rbx
 .         .cfi_offset	%rbx,-16
 .         	pushq	%rbp
 .         .cfi_offset	%rbp,-24
 .         	pushq	%r12
 .         .cfi_offset	%r12,-32
-- line 33 ----------------------------------------
-- line 1818 ----------------------------------------
 .         .quad	0x0001020304050607,0x08090a0b0c0d0e0f
 .         .byte	83,72,65,53,49,50,32,98,108,111,99,107,32,116,114,97,110,115,102,111,114,109,32,102,111,114,32,120,56,54,95,54,52,44,32,67,82,89,80,84,79,71,65,77,83,32,98,121,32,60,97,112,112,114,111,64,111,112,101,110,115,115,108,46,111,114,103,62,0
 .         .text	
 .         .type	sha512_block_data_order_avx,@function
 .         .align	64
 .         sha512_block_data_order_avx:
 .         .cfi_startproc	
 .         .Lavx_shortcut:
17 (0.0%)  	movq	%rsp,%rax
 .         .cfi_def_cfa_register	%rax
17 (0.0%)  	pushq	%rbx
 .         .cfi_offset	%rbx,-16
17 (0.0%)  	pushq	%rbp
 .         .cfi_offset	%rbp,-24
17 (0.0%)  	pushq	%r12
 .         .cfi_offset	%r12,-32
17 (0.0%)  	pushq	%r13
 .         .cfi_offset	%r13,-40
17 (0.0%)  	pushq	%r14
 .         .cfi_offset	%r14,-48
17 (0.0%)  	pushq	%r15
 .         .cfi_offset	%r15,-56
17 (0.0%)  	shlq	$4,%rdx
17 (0.0%)  	subq	$160,%rsp
17 (0.0%)  	leaq	(%rsi,%rdx,8),%rdx
17 (0.0%)  	andq	$-64,%rsp
17 (0.0%)  	movq	%rdi,128+0(%rsp)
17 (0.0%)  	movq	%rsi,128+8(%rsp)
17 (0.0%)  	movq	%rdx,128+16(%rsp)
17 (0.0%)  	movq	%rax,152(%rsp)
 .         .cfi_escape	0x0f,0x06,0x77,0x98,0x01,0x06,0x23,0x08
 .         .Lprologue_avx:
 .         
17 (0.0%)  	vzeroupper
17 (0.0%)  	movq	0(%rdi),%rax
17 (0.0%)  	movq	8(%rdi),%rbx
17 (0.0%)  	movq	16(%rdi),%rcx
17 (0.0%)  	movq	24(%rdi),%rdx
17 (0.0%)  	movq	32(%rdi),%r8
17 (0.0%)  	movq	40(%rdi),%r9
17 (0.0%)  	movq	48(%rdi),%r10
17 (0.0%)  	movq	56(%rdi),%r11
17 (0.0%)  	jmp	.Lloop_avx
 .         .align	16
 .         .Lloop_avx:
23 (0.0%)  	vmovdqa	K512+1280(%rip),%xmm11
23 (0.0%)  	vmovdqu	0(%rsi),%xmm0
23 (0.0%)  	leaq	K512+128(%rip),%rbp
23 (0.0%)  	vmovdqu	16(%rsi),%xmm1
23 (0.0%)  	vmovdqu	32(%rsi),%xmm2
23 (0.0%)  	vpshufb	%xmm11,%xmm0,%xmm0
23 (0.0%)  	vmovdqu	48(%rsi),%xmm3
23 (0.0%)  	vpshufb	%xmm11,%xmm1,%xmm1
23 (0.0%)  	vmovdqu	64(%rsi),%xmm4
23 (0.0%)  	vpshufb	%xmm11,%xmm2,%xmm2
23 (0.0%)  	vmovdqu	80(%rsi),%xmm5
23 (0.0%)  	vpshufb	%xmm11,%xmm3,%xmm3
23 (0.0%)  	vmovdqu	96(%rsi),%xmm6
23 (0.0%)  	vpshufb	%xmm11,%xmm4,%xmm4
23 (0.0%)  	vmovdqu	112(%rsi),%xmm7
23 (0.0%)  	vpshufb	%xmm11,%xmm5,%xmm5
23 (0.0%)  	vpaddq	-128(%rbp),%xmm0,%xmm8
23 (0.0%)  	vpshufb	%xmm11,%xmm6,%xmm6
23 (0.0%)  	vpaddq	-96(%rbp),%xmm1,%xmm9
23 (0.0%)  	vpshufb	%xmm11,%xmm7,%xmm7
23 (0.0%)  	vpaddq	-64(%rbp),%xmm2,%xmm10
23 (0.0%)  	vpaddq	-32(%rbp),%xmm3,%xmm11
23 (0.0%)  	vmovdqa	%xmm8,0(%rsp)
23 (0.0%)  	vpaddq	0(%rbp),%xmm4,%xmm8
23 (0.0%)  	vmovdqa	%xmm9,16(%rsp)
23 (0.0%)  	vpaddq	32(%rbp),%xmm5,%xmm9
23 (0.0%)  	vmovdqa	%xmm10,32(%rsp)
23 (0.0%)  	vpaddq	64(%rbp),%xmm6,%xmm10
23 (0.0%)  	vmovdqa	%xmm11,48(%rsp)
23 (0.0%)  	vpaddq	96(%rbp),%xmm7,%xmm11
23 (0.0%)  	vmovdqa	%xmm8,64(%rsp)
23 (0.0%)  	movq	%rax,%r14
23 (0.0%)  	vmovdqa	%xmm9,80(%rsp)
23 (0.0%)  	movq	%rbx,%rdi
23 (0.0%)  	vmovdqa	%xmm10,96(%rsp)
23 (0.0%)  	xorq	%rcx,%rdi
23 (0.0%)  	vmovdqa	%xmm11,112(%rsp)
23 (0.0%)  	movq	%r8,%r13
23 (0.0%)  	jmp	.Lavx_00_47
 .         
 .         .align	16
 .         .Lavx_00_47:
92 (0.0%)  	addq	$256,%rbp
92 (0.0%)  	vpalignr	$8,%xmm0,%xmm1,%xmm8
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%rax
92 (0.0%)  	vpalignr	$8,%xmm4,%xmm5,%xmm11
92 (0.0%)  	movq	%r9,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
92 (0.0%)  	xorq	%r8,%r13
92 (0.0%)  	xorq	%r10,%r12
92 (0.0%)  	vpaddq	%xmm11,%xmm0,%xmm0
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%rax,%r14
92 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
92 (0.0%)  	andq	%r8,%r12
92 (0.0%)  	xorq	%r8,%r13
92 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
92 (0.0%)  	addq	0(%rsp),%r11
92 (0.0%)  	movq	%rax,%r15
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
92 (0.0%)  	xorq	%r10,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
92 (0.0%)  	xorq	%rbx,%r15
92 (0.0%)  	addq	%r12,%r11
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%r15,%rdi
92 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
92 (0.0%)  	xorq	%rax,%r14
92 (0.0%)  	addq	%r13,%r11
92 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
92 (0.0%)  	xorq	%rbx,%rdi
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	vpsrlq	$6,%xmm7,%xmm11
92 (0.0%)  	addq	%r11,%rdx
92 (0.0%)  	addq	%rdi,%r11
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	movq	%rdx,%r13
92 (0.0%)  	addq	%r11,%r14
92 (0.0%)  	vpsllq	$3,%xmm7,%xmm10
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%r11
92 (0.0%)  	vpaddq	%xmm8,%xmm0,%xmm0
92 (0.0%)  	movq	%r8,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$19,%xmm7,%xmm9
92 (0.0%)  	xorq	%rdx,%r13
92 (0.0%)  	xorq	%r9,%r12
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%r11,%r14
92 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
92 (0.0%)  	andq	%rdx,%r12
92 (0.0%)  	xorq	%rdx,%r13
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	addq	8(%rsp),%r10
92 (0.0%)  	movq	%r11,%rdi
92 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
92 (0.0%)  	xorq	%r9,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	xorq	%rax,%rdi
92 (0.0%)  	addq	%r12,%r10
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%rdi,%r15
92 (0.0%)  	vpaddq	%xmm11,%xmm0,%xmm0
92 (0.0%)  	xorq	%r11,%r14
92 (0.0%)  	addq	%r13,%r10
92 (0.0%)  	vpaddq	-128(%rbp),%xmm0,%xmm10
92 (0.0%)  	xorq	%rax,%r15
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	addq	%r10,%rcx
92 (0.0%)  	addq	%r15,%r10
92 (0.0%)  	movq	%rcx,%r13
92 (0.0%)  	addq	%r10,%r14
92 (0.0%)  	vmovdqa	%xmm10,0(%rsp)
92 (0.0%)  	vpalignr	$8,%xmm1,%xmm2,%xmm8
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%r10
92 (0.0%)  	vpalignr	$8,%xmm5,%xmm6,%xmm11
92 (0.0%)  	movq	%rdx,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
92 (0.0%)  	xorq	%rcx,%r13
92 (0.0%)  	xorq	%r8,%r12
92 (0.0%)  	vpaddq	%xmm11,%xmm1,%xmm1
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%r10,%r14
92 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
92 (0.0%)  	andq	%rcx,%r12
92 (0.0%)  	xorq	%rcx,%r13
92 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
92 (0.0%)  	addq	16(%rsp),%r9
92 (0.0%)  	movq	%r10,%r15
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
92 (0.0%)  	xorq	%r8,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
92 (0.0%)  	xorq	%r11,%r15
92 (0.0%)  	addq	%r12,%r9
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%r15,%rdi
92 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
92 (0.0%)  	xorq	%r10,%r14
92 (0.0%)  	addq	%r13,%r9
92 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
92 (0.0%)  	xorq	%r11,%rdi
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	vpsrlq	$6,%xmm0,%xmm11
92 (0.0%)  	addq	%r9,%rbx
92 (0.0%)  	addq	%rdi,%r9
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	movq	%rbx,%r13
92 (0.0%)  	addq	%r9,%r14
92 (0.0%)  	vpsllq	$3,%xmm0,%xmm10
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%r9
92 (0.0%)  	vpaddq	%xmm8,%xmm1,%xmm1
92 (0.0%)  	movq	%rcx,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$19,%xmm0,%xmm9
92 (0.0%)  	xorq	%rbx,%r13
92 (0.0%)  	xorq	%rdx,%r12
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%r9,%r14
92 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
92 (0.0%)  	andq	%rbx,%r12
92 (0.0%)  	xorq	%rbx,%r13
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	addq	24(%rsp),%r8
92 (0.0%)  	movq	%r9,%rdi
92 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
92 (0.0%)  	xorq	%rdx,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	xorq	%r10,%rdi
92 (0.0%)  	addq	%r12,%r8
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%rdi,%r15
92 (0.0%)  	vpaddq	%xmm11,%xmm1,%xmm1
92 (0.0%)  	xorq	%r9,%r14
92 (0.0%)  	addq	%r13,%r8
92 (0.0%)  	vpaddq	-96(%rbp),%xmm1,%xmm10
92 (0.0%)  	xorq	%r10,%r15
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	addq	%r8,%rax
92 (0.0%)  	addq	%r15,%r8
92 (0.0%)  	movq	%rax,%r13
92 (0.0%)  	addq	%r8,%r14
92 (0.0%)  	vmovdqa	%xmm10,16(%rsp)
92 (0.0%)  	vpalignr	$8,%xmm2,%xmm3,%xmm8
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%r8
92 (0.0%)  	vpalignr	$8,%xmm6,%xmm7,%xmm11
92 (0.0%)  	movq	%rbx,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
92 (0.0%)  	xorq	%rax,%r13
92 (0.0%)  	xorq	%rcx,%r12
92 (0.0%)  	vpaddq	%xmm11,%xmm2,%xmm2
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%r8,%r14
92 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
92 (0.0%)  	andq	%rax,%r12
92 (0.0%)  	xorq	%rax,%r13
92 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
92 (0.0%)  	addq	32(%rsp),%rdx
92 (0.0%)  	movq	%r8,%r15
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
92 (0.0%)  	xorq	%rcx,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
92 (0.0%)  	xorq	%r9,%r15
92 (0.0%)  	addq	%r12,%rdx
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%r15,%rdi
92 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
92 (0.0%)  	xorq	%r8,%r14
92 (0.0%)  	addq	%r13,%rdx
92 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
92 (0.0%)  	xorq	%r9,%rdi
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	vpsrlq	$6,%xmm1,%xmm11
92 (0.0%)  	addq	%rdx,%r11
92 (0.0%)  	addq	%rdi,%rdx
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	movq	%r11,%r13
92 (0.0%)  	addq	%rdx,%r14
92 (0.0%)  	vpsllq	$3,%xmm1,%xmm10
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%rdx
92 (0.0%)  	vpaddq	%xmm8,%xmm2,%xmm2
92 (0.0%)  	movq	%rax,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$19,%xmm1,%xmm9
92 (0.0%)  	xorq	%r11,%r13
92 (0.0%)  	xorq	%rbx,%r12
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%rdx,%r14
92 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
92 (0.0%)  	andq	%r11,%r12
92 (0.0%)  	xorq	%r11,%r13
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	addq	40(%rsp),%rcx
92 (0.0%)  	movq	%rdx,%rdi
92 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
92 (0.0%)  	xorq	%rbx,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	xorq	%r8,%rdi
92 (0.0%)  	addq	%r12,%rcx
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%rdi,%r15
92 (0.0%)  	vpaddq	%xmm11,%xmm2,%xmm2
92 (0.0%)  	xorq	%rdx,%r14
92 (0.0%)  	addq	%r13,%rcx
92 (0.0%)  	vpaddq	-64(%rbp),%xmm2,%xmm10
92 (0.0%)  	xorq	%r8,%r15
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	addq	%rcx,%r10
92 (0.0%)  	addq	%r15,%rcx
92 (0.0%)  	movq	%r10,%r13
92 (0.0%)  	addq	%rcx,%r14
92 (0.0%)  	vmovdqa	%xmm10,32(%rsp)
92 (0.0%)  	vpalignr	$8,%xmm3,%xmm4,%xmm8
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%rcx
92 (0.0%)  	vpalignr	$8,%xmm7,%xmm0,%xmm11
92 (0.0%)  	movq	%r11,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
92 (0.0%)  	xorq	%r10,%r13
92 (0.0%)  	xorq	%rax,%r12
92 (0.0%)  	vpaddq	%xmm11,%xmm3,%xmm3
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%rcx,%r14
92 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
92 (0.0%)  	andq	%r10,%r12
92 (0.0%)  	xorq	%r10,%r13
92 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
92 (0.0%)  	addq	48(%rsp),%rbx
92 (0.0%)  	movq	%rcx,%r15
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
92 (0.0%)  	xorq	%rax,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
92 (0.0%)  	xorq	%rdx,%r15
92 (0.0%)  	addq	%r12,%rbx
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%r15,%rdi
92 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
92 (0.0%)  	xorq	%rcx,%r14
92 (0.0%)  	addq	%r13,%rbx
92 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
92 (0.0%)  	xorq	%rdx,%rdi
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	vpsrlq	$6,%xmm2,%xmm11
92 (0.0%)  	addq	%rbx,%r9
92 (0.0%)  	addq	%rdi,%rbx
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	movq	%r9,%r13
92 (0.0%)  	addq	%rbx,%r14
92 (0.0%)  	vpsllq	$3,%xmm2,%xmm10
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%rbx
92 (0.0%)  	vpaddq	%xmm8,%xmm3,%xmm3
92 (0.0%)  	movq	%r10,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$19,%xmm2,%xmm9
92 (0.0%)  	xorq	%r9,%r13
92 (0.0%)  	xorq	%r11,%r12
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%rbx,%r14
92 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
92 (0.0%)  	andq	%r9,%r12
92 (0.0%)  	xorq	%r9,%r13
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	addq	56(%rsp),%rax
92 (0.0%)  	movq	%rbx,%rdi
92 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
92 (0.0%)  	xorq	%r11,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	xorq	%rcx,%rdi
92 (0.0%)  	addq	%r12,%rax
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%rdi,%r15
92 (0.0%)  	vpaddq	%xmm11,%xmm3,%xmm3
92 (0.0%)  	xorq	%rbx,%r14
92 (0.0%)  	addq	%r13,%rax
92 (0.0%)  	vpaddq	-32(%rbp),%xmm3,%xmm10
92 (0.0%)  	xorq	%rcx,%r15
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	addq	%rax,%r8
92 (0.0%)  	addq	%r15,%rax
92 (0.0%)  	movq	%r8,%r13
92 (0.0%)  	addq	%rax,%r14
92 (0.0%)  	vmovdqa	%xmm10,48(%rsp)
92 (0.0%)  	vpalignr	$8,%xmm4,%xmm5,%xmm8
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%rax
92 (0.0%)  	vpalignr	$8,%xmm0,%xmm1,%xmm11
92 (0.0%)  	movq	%r9,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
92 (0.0%)  	xorq	%r8,%r13
92 (0.0%)  	xorq	%r10,%r12
92 (0.0%)  	vpaddq	%xmm11,%xmm4,%xmm4
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%rax,%r14
92 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
92 (0.0%)  	andq	%r8,%r12
92 (0.0%)  	xorq	%r8,%r13
92 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
92 (0.0%)  	addq	64(%rsp),%r11
92 (0.0%)  	movq	%rax,%r15
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
92 (0.0%)  	xorq	%r10,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
92 (0.0%)  	xorq	%rbx,%r15
92 (0.0%)  	addq	%r12,%r11
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%r15,%rdi
92 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
92 (0.0%)  	xorq	%rax,%r14
92 (0.0%)  	addq	%r13,%r11
92 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
92 (0.0%)  	xorq	%rbx,%rdi
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	vpsrlq	$6,%xmm3,%xmm11
92 (0.0%)  	addq	%r11,%rdx
92 (0.0%)  	addq	%rdi,%r11
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	movq	%rdx,%r13
92 (0.0%)  	addq	%r11,%r14
92 (0.0%)  	vpsllq	$3,%xmm3,%xmm10
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%r11
92 (0.0%)  	vpaddq	%xmm8,%xmm4,%xmm4
92 (0.0%)  	movq	%r8,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$19,%xmm3,%xmm9
92 (0.0%)  	xorq	%rdx,%r13
92 (0.0%)  	xorq	%r9,%r12
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%r11,%r14
92 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
92 (0.0%)  	andq	%rdx,%r12
92 (0.0%)  	xorq	%rdx,%r13
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	addq	72(%rsp),%r10
92 (0.0%)  	movq	%r11,%rdi
92 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
92 (0.0%)  	xorq	%r9,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	xorq	%rax,%rdi
92 (0.0%)  	addq	%r12,%r10
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%rdi,%r15
92 (0.0%)  	vpaddq	%xmm11,%xmm4,%xmm4
92 (0.0%)  	xorq	%r11,%r14
92 (0.0%)  	addq	%r13,%r10
92 (0.0%)  	vpaddq	0(%rbp),%xmm4,%xmm10
92 (0.0%)  	xorq	%rax,%r15
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	addq	%r10,%rcx
92 (0.0%)  	addq	%r15,%r10
92 (0.0%)  	movq	%rcx,%r13
92 (0.0%)  	addq	%r10,%r14
92 (0.0%)  	vmovdqa	%xmm10,64(%rsp)
92 (0.0%)  	vpalignr	$8,%xmm5,%xmm6,%xmm8
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%r10
92 (0.0%)  	vpalignr	$8,%xmm1,%xmm2,%xmm11
92 (0.0%)  	movq	%rdx,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
92 (0.0%)  	xorq	%rcx,%r13
92 (0.0%)  	xorq	%r8,%r12
92 (0.0%)  	vpaddq	%xmm11,%xmm5,%xmm5
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%r10,%r14
92 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
92 (0.0%)  	andq	%rcx,%r12
92 (0.0%)  	xorq	%rcx,%r13
92 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
92 (0.0%)  	addq	80(%rsp),%r9
92 (0.0%)  	movq	%r10,%r15
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
92 (0.0%)  	xorq	%r8,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
92 (0.0%)  	xorq	%r11,%r15
92 (0.0%)  	addq	%r12,%r9
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%r15,%rdi
92 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
92 (0.0%)  	xorq	%r10,%r14
92 (0.0%)  	addq	%r13,%r9
92 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
92 (0.0%)  	xorq	%r11,%rdi
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	vpsrlq	$6,%xmm4,%xmm11
92 (0.0%)  	addq	%r9,%rbx
92 (0.0%)  	addq	%rdi,%r9
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	movq	%rbx,%r13
92 (0.0%)  	addq	%r9,%r14
92 (0.0%)  	vpsllq	$3,%xmm4,%xmm10
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%r9
92 (0.0%)  	vpaddq	%xmm8,%xmm5,%xmm5
92 (0.0%)  	movq	%rcx,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$19,%xmm4,%xmm9
92 (0.0%)  	xorq	%rbx,%r13
92 (0.0%)  	xorq	%rdx,%r12
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%r9,%r14
92 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
92 (0.0%)  	andq	%rbx,%r12
92 (0.0%)  	xorq	%rbx,%r13
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	addq	88(%rsp),%r8
92 (0.0%)  	movq	%r9,%rdi
92 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
92 (0.0%)  	xorq	%rdx,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	xorq	%r10,%rdi
92 (0.0%)  	addq	%r12,%r8
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%rdi,%r15
92 (0.0%)  	vpaddq	%xmm11,%xmm5,%xmm5
92 (0.0%)  	xorq	%r9,%r14
92 (0.0%)  	addq	%r13,%r8
92 (0.0%)  	vpaddq	32(%rbp),%xmm5,%xmm10
92 (0.0%)  	xorq	%r10,%r15
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	addq	%r8,%rax
92 (0.0%)  	addq	%r15,%r8
92 (0.0%)  	movq	%rax,%r13
92 (0.0%)  	addq	%r8,%r14
92 (0.0%)  	vmovdqa	%xmm10,80(%rsp)
92 (0.0%)  	vpalignr	$8,%xmm6,%xmm7,%xmm8
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%r8
92 (0.0%)  	vpalignr	$8,%xmm2,%xmm3,%xmm11
92 (0.0%)  	movq	%rbx,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
92 (0.0%)  	xorq	%rax,%r13
92 (0.0%)  	xorq	%rcx,%r12
92 (0.0%)  	vpaddq	%xmm11,%xmm6,%xmm6
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%r8,%r14
92 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
92 (0.0%)  	andq	%rax,%r12
92 (0.0%)  	xorq	%rax,%r13
92 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
92 (0.0%)  	addq	96(%rsp),%rdx
92 (0.0%)  	movq	%r8,%r15
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
92 (0.0%)  	xorq	%rcx,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
92 (0.0%)  	xorq	%r9,%r15
92 (0.0%)  	addq	%r12,%rdx
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%r15,%rdi
92 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
92 (0.0%)  	xorq	%r8,%r14
92 (0.0%)  	addq	%r13,%rdx
92 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
92 (0.0%)  	xorq	%r9,%rdi
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	vpsrlq	$6,%xmm5,%xmm11
92 (0.0%)  	addq	%rdx,%r11
92 (0.0%)  	addq	%rdi,%rdx
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	movq	%r11,%r13
92 (0.0%)  	addq	%rdx,%r14
92 (0.0%)  	vpsllq	$3,%xmm5,%xmm10
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%rdx
92 (0.0%)  	vpaddq	%xmm8,%xmm6,%xmm6
92 (0.0%)  	movq	%rax,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$19,%xmm5,%xmm9
92 (0.0%)  	xorq	%r11,%r13
92 (0.0%)  	xorq	%rbx,%r12
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%rdx,%r14
92 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
92 (0.0%)  	andq	%r11,%r12
92 (0.0%)  	xorq	%r11,%r13
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	addq	104(%rsp),%rcx
92 (0.0%)  	movq	%rdx,%rdi
92 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
92 (0.0%)  	xorq	%rbx,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	xorq	%r8,%rdi
92 (0.0%)  	addq	%r12,%rcx
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%rdi,%r15
92 (0.0%)  	vpaddq	%xmm11,%xmm6,%xmm6
92 (0.0%)  	xorq	%rdx,%r14
92 (0.0%)  	addq	%r13,%rcx
92 (0.0%)  	vpaddq	64(%rbp),%xmm6,%xmm10
92 (0.0%)  	xorq	%r8,%r15
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	addq	%rcx,%r10
92 (0.0%)  	addq	%r15,%rcx
92 (0.0%)  	movq	%r10,%r13
92 (0.0%)  	addq	%rcx,%r14
92 (0.0%)  	vmovdqa	%xmm10,96(%rsp)
92 (0.0%)  	vpalignr	$8,%xmm7,%xmm0,%xmm8
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%rcx
92 (0.0%)  	vpalignr	$8,%xmm3,%xmm4,%xmm11
92 (0.0%)  	movq	%r11,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
92 (0.0%)  	xorq	%r10,%r13
92 (0.0%)  	xorq	%rax,%r12
92 (0.0%)  	vpaddq	%xmm11,%xmm7,%xmm7
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%rcx,%r14
92 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
92 (0.0%)  	andq	%r10,%r12
92 (0.0%)  	xorq	%r10,%r13
92 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
92 (0.0%)  	addq	112(%rsp),%rbx
92 (0.0%)  	movq	%rcx,%r15
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
92 (0.0%)  	xorq	%rax,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
92 (0.0%)  	xorq	%rdx,%r15
92 (0.0%)  	addq	%r12,%rbx
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%r15,%rdi
92 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
92 (0.0%)  	xorq	%rcx,%r14
92 (0.0%)  	addq	%r13,%rbx
92 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
92 (0.0%)  	xorq	%rdx,%rdi
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	vpsrlq	$6,%xmm6,%xmm11
92 (0.0%)  	addq	%rbx,%r9
92 (0.0%)  	addq	%rdi,%rbx
92 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
92 (0.0%)  	movq	%r9,%r13
92 (0.0%)  	addq	%rbx,%r14
92 (0.0%)  	vpsllq	$3,%xmm6,%xmm10
92 (0.0%)  	shrdq	$23,%r13,%r13
92 (0.0%)  	movq	%r14,%rbx
92 (0.0%)  	vpaddq	%xmm8,%xmm7,%xmm7
92 (0.0%)  	movq	%r10,%r12
92 (0.0%)  	shrdq	$5,%r14,%r14
92 (0.0%)  	vpsrlq	$19,%xmm6,%xmm9
92 (0.0%)  	xorq	%r9,%r13
92 (0.0%)  	xorq	%r11,%r12
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	shrdq	$4,%r13,%r13
92 (0.0%)  	xorq	%rbx,%r14
92 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
92 (0.0%)  	andq	%r9,%r12
92 (0.0%)  	xorq	%r9,%r13
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	addq	120(%rsp),%rax
92 (0.0%)  	movq	%rbx,%rdi
92 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
92 (0.0%)  	xorq	%r11,%r12
92 (0.0%)  	shrdq	$6,%r14,%r14
92 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
92 (0.0%)  	xorq	%rcx,%rdi
92 (0.0%)  	addq	%r12,%rax
92 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
92 (0.0%)  	shrdq	$14,%r13,%r13
92 (0.0%)  	andq	%rdi,%r15
92 (0.0%)  	vpaddq	%xmm11,%xmm7,%xmm7
92 (0.0%)  	xorq	%rbx,%r14
92 (0.0%)  	addq	%r13,%rax
92 (0.0%)  	vpaddq	96(%rbp),%xmm7,%xmm10
92 (0.0%)  	xorq	%rcx,%r15
92 (0.0%)  	shrdq	$28,%r14,%r14
92 (0.0%)  	addq	%rax,%r8
92 (0.0%)  	addq	%r15,%rax
92 (0.0%)  	movq	%r8,%r13
92 (0.0%)  	addq	%rax,%r14
92 (0.0%)  	vmovdqa	%xmm10,112(%rsp)
92 (0.0%)  	cmpb	$0,135(%rbp)
92 (0.0%)  	jne	.Lavx_00_47
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%rax
23 (0.0%)  	movq	%r9,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%r8,%r13
23 (0.0%)  	xorq	%r10,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%rax,%r14
23 (0.0%)  	andq	%r8,%r12
23 (0.0%)  	xorq	%r8,%r13
23 (0.0%)  	addq	0(%rsp),%r11
23 (0.0%)  	movq	%rax,%r15
23 (0.0%)  	xorq	%r10,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%rbx,%r15
23 (0.0%)  	addq	%r12,%r11
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%r15,%rdi
23 (0.0%)  	xorq	%rax,%r14
23 (0.0%)  	addq	%r13,%r11
23 (0.0%)  	xorq	%rbx,%rdi
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%r11,%rdx
23 (0.0%)  	addq	%rdi,%r11
23 (0.0%)  	movq	%rdx,%r13
23 (0.0%)  	addq	%r11,%r14
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%r11
23 (0.0%)  	movq	%r8,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%rdx,%r13
23 (0.0%)  	xorq	%r9,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%r11,%r14
23 (0.0%)  	andq	%rdx,%r12
23 (0.0%)  	xorq	%rdx,%r13
23 (0.0%)  	addq	8(%rsp),%r10
23 (0.0%)  	movq	%r11,%rdi
23 (0.0%)  	xorq	%r9,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%rax,%rdi
23 (0.0%)  	addq	%r12,%r10
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%rdi,%r15
23 (0.0%)  	xorq	%r11,%r14
23 (0.0%)  	addq	%r13,%r10
23 (0.0%)  	xorq	%rax,%r15
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%r10,%rcx
23 (0.0%)  	addq	%r15,%r10
23 (0.0%)  	movq	%rcx,%r13
23 (0.0%)  	addq	%r10,%r14
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%r10
23 (0.0%)  	movq	%rdx,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%rcx,%r13
23 (0.0%)  	xorq	%r8,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%r10,%r14
23 (0.0%)  	andq	%rcx,%r12
23 (0.0%)  	xorq	%rcx,%r13
23 (0.0%)  	addq	16(%rsp),%r9
23 (0.0%)  	movq	%r10,%r15
23 (0.0%)  	xorq	%r8,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%r11,%r15
23 (0.0%)  	addq	%r12,%r9
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%r15,%rdi
23 (0.0%)  	xorq	%r10,%r14
23 (0.0%)  	addq	%r13,%r9
23 (0.0%)  	xorq	%r11,%rdi
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%r9,%rbx
23 (0.0%)  	addq	%rdi,%r9
23 (0.0%)  	movq	%rbx,%r13
23 (0.0%)  	addq	%r9,%r14
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%r9
23 (0.0%)  	movq	%rcx,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%rbx,%r13
23 (0.0%)  	xorq	%rdx,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%r9,%r14
23 (0.0%)  	andq	%rbx,%r12
23 (0.0%)  	xorq	%rbx,%r13
23 (0.0%)  	addq	24(%rsp),%r8
23 (0.0%)  	movq	%r9,%rdi
23 (0.0%)  	xorq	%rdx,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%r10,%rdi
23 (0.0%)  	addq	%r12,%r8
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%rdi,%r15
23 (0.0%)  	xorq	%r9,%r14
23 (0.0%)  	addq	%r13,%r8
23 (0.0%)  	xorq	%r10,%r15
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%r8,%rax
23 (0.0%)  	addq	%r15,%r8
23 (0.0%)  	movq	%rax,%r13
23 (0.0%)  	addq	%r8,%r14
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%r8
23 (0.0%)  	movq	%rbx,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%rax,%r13
23 (0.0%)  	xorq	%rcx,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%r8,%r14
23 (0.0%)  	andq	%rax,%r12
23 (0.0%)  	xorq	%rax,%r13
23 (0.0%)  	addq	32(%rsp),%rdx
23 (0.0%)  	movq	%r8,%r15
23 (0.0%)  	xorq	%rcx,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%r9,%r15
23 (0.0%)  	addq	%r12,%rdx
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%r15,%rdi
23 (0.0%)  	xorq	%r8,%r14
23 (0.0%)  	addq	%r13,%rdx
23 (0.0%)  	xorq	%r9,%rdi
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%rdx,%r11
23 (0.0%)  	addq	%rdi,%rdx
23 (0.0%)  	movq	%r11,%r13
23 (0.0%)  	addq	%rdx,%r14
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%rdx
23 (0.0%)  	movq	%rax,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%r11,%r13
23 (0.0%)  	xorq	%rbx,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%rdx,%r14
23 (0.0%)  	andq	%r11,%r12
23 (0.0%)  	xorq	%r11,%r13
23 (0.0%)  	addq	40(%rsp),%rcx
23 (0.0%)  	movq	%rdx,%rdi
23 (0.0%)  	xorq	%rbx,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%r8,%rdi
23 (0.0%)  	addq	%r12,%rcx
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%rdi,%r15
23 (0.0%)  	xorq	%rdx,%r14
23 (0.0%)  	addq	%r13,%rcx
23 (0.0%)  	xorq	%r8,%r15
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%rcx,%r10
23 (0.0%)  	addq	%r15,%rcx
23 (0.0%)  	movq	%r10,%r13
23 (0.0%)  	addq	%rcx,%r14
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%rcx
23 (0.0%)  	movq	%r11,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%r10,%r13
23 (0.0%)  	xorq	%rax,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%rcx,%r14
23 (0.0%)  	andq	%r10,%r12
23 (0.0%)  	xorq	%r10,%r13
23 (0.0%)  	addq	48(%rsp),%rbx
23 (0.0%)  	movq	%rcx,%r15
23 (0.0%)  	xorq	%rax,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%rdx,%r15
23 (0.0%)  	addq	%r12,%rbx
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%r15,%rdi
23 (0.0%)  	xorq	%rcx,%r14
23 (0.0%)  	addq	%r13,%rbx
23 (0.0%)  	xorq	%rdx,%rdi
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%rbx,%r9
23 (0.0%)  	addq	%rdi,%rbx
23 (0.0%)  	movq	%r9,%r13
23 (0.0%)  	addq	%rbx,%r14
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%rbx
23 (0.0%)  	movq	%r10,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%r9,%r13
23 (0.0%)  	xorq	%r11,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%rbx,%r14
23 (0.0%)  	andq	%r9,%r12
23 (0.0%)  	xorq	%r9,%r13
23 (0.0%)  	addq	56(%rsp),%rax
23 (0.0%)  	movq	%rbx,%rdi
23 (0.0%)  	xorq	%r11,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%rcx,%rdi
23 (0.0%)  	addq	%r12,%rax
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%rdi,%r15
23 (0.0%)  	xorq	%rbx,%r14
23 (0.0%)  	addq	%r13,%rax
23 (0.0%)  	xorq	%rcx,%r15
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%rax,%r8
23 (0.0%)  	addq	%r15,%rax
23 (0.0%)  	movq	%r8,%r13
23 (0.0%)  	addq	%rax,%r14
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%rax
23 (0.0%)  	movq	%r9,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%r8,%r13
23 (0.0%)  	xorq	%r10,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%rax,%r14
23 (0.0%)  	andq	%r8,%r12
23 (0.0%)  	xorq	%r8,%r13
23 (0.0%)  	addq	64(%rsp),%r11
23 (0.0%)  	movq	%rax,%r15
23 (0.0%)  	xorq	%r10,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%rbx,%r15
23 (0.0%)  	addq	%r12,%r11
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%r15,%rdi
23 (0.0%)  	xorq	%rax,%r14
23 (0.0%)  	addq	%r13,%r11
23 (0.0%)  	xorq	%rbx,%rdi
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%r11,%rdx
23 (0.0%)  	addq	%rdi,%r11
23 (0.0%)  	movq	%rdx,%r13
23 (0.0%)  	addq	%r11,%r14
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%r11
23 (0.0%)  	movq	%r8,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%rdx,%r13
23 (0.0%)  	xorq	%r9,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%r11,%r14
23 (0.0%)  	andq	%rdx,%r12
23 (0.0%)  	xorq	%rdx,%r13
23 (0.0%)  	addq	72(%rsp),%r10
23 (0.0%)  	movq	%r11,%rdi
23 (0.0%)  	xorq	%r9,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%rax,%rdi
23 (0.0%)  	addq	%r12,%r10
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%rdi,%r15
23 (0.0%)  	xorq	%r11,%r14
23 (0.0%)  	addq	%r13,%r10
23 (0.0%)  	xorq	%rax,%r15
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%r10,%rcx
23 (0.0%)  	addq	%r15,%r10
23 (0.0%)  	movq	%rcx,%r13
23 (0.0%)  	addq	%r10,%r14
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%r10
23 (0.0%)  	movq	%rdx,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%rcx,%r13
23 (0.0%)  	xorq	%r8,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%r10,%r14
23 (0.0%)  	andq	%rcx,%r12
23 (0.0%)  	xorq	%rcx,%r13
23 (0.0%)  	addq	80(%rsp),%r9
23 (0.0%)  	movq	%r10,%r15
23 (0.0%)  	xorq	%r8,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%r11,%r15
23 (0.0%)  	addq	%r12,%r9
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%r15,%rdi
23 (0.0%)  	xorq	%r10,%r14
23 (0.0%)  	addq	%r13,%r9
23 (0.0%)  	xorq	%r11,%rdi
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%r9,%rbx
23 (0.0%)  	addq	%rdi,%r9
23 (0.0%)  	movq	%rbx,%r13
23 (0.0%)  	addq	%r9,%r14
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%r9
23 (0.0%)  	movq	%rcx,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%rbx,%r13
23 (0.0%)  	xorq	%rdx,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%r9,%r14
23 (0.0%)  	andq	%rbx,%r12
23 (0.0%)  	xorq	%rbx,%r13
23 (0.0%)  	addq	88(%rsp),%r8
23 (0.0%)  	movq	%r9,%rdi
23 (0.0%)  	xorq	%rdx,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%r10,%rdi
23 (0.0%)  	addq	%r12,%r8
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%rdi,%r15
23 (0.0%)  	xorq	%r9,%r14
23 (0.0%)  	addq	%r13,%r8
23 (0.0%)  	xorq	%r10,%r15
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%r8,%rax
23 (0.0%)  	addq	%r15,%r8
23 (0.0%)  	movq	%rax,%r13
23 (0.0%)  	addq	%r8,%r14
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%r8
23 (0.0%)  	movq	%rbx,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%rax,%r13
23 (0.0%)  	xorq	%rcx,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%r8,%r14
23 (0.0%)  	andq	%rax,%r12
23 (0.0%)  	xorq	%rax,%r13
23 (0.0%)  	addq	96(%rsp),%rdx
23 (0.0%)  	movq	%r8,%r15
23 (0.0%)  	xorq	%rcx,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%r9,%r15
23 (0.0%)  	addq	%r12,%rdx
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%r15,%rdi
23 (0.0%)  	xorq	%r8,%r14
23 (0.0%)  	addq	%r13,%rdx
23 (0.0%)  	xorq	%r9,%rdi
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%rdx,%r11
23 (0.0%)  	addq	%rdi,%rdx
23 (0.0%)  	movq	%r11,%r13
23 (0.0%)  	addq	%rdx,%r14
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%rdx
23 (0.0%)  	movq	%rax,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%r11,%r13
23 (0.0%)  	xorq	%rbx,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%rdx,%r14
23 (0.0%)  	andq	%r11,%r12
23 (0.0%)  	xorq	%r11,%r13
23 (0.0%)  	addq	104(%rsp),%rcx
23 (0.0%)  	movq	%rdx,%rdi
23 (0.0%)  	xorq	%rbx,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%r8,%rdi
23 (0.0%)  	addq	%r12,%rcx
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%rdi,%r15
23 (0.0%)  	xorq	%rdx,%r14
23 (0.0%)  	addq	%r13,%rcx
23 (0.0%)  	xorq	%r8,%r15
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%rcx,%r10
23 (0.0%)  	addq	%r15,%rcx
23 (0.0%)  	movq	%r10,%r13
23 (0.0%)  	addq	%rcx,%r14
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%rcx
23 (0.0%)  	movq	%r11,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%r10,%r13
23 (0.0%)  	xorq	%rax,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%rcx,%r14
23 (0.0%)  	andq	%r10,%r12
23 (0.0%)  	xorq	%r10,%r13
23 (0.0%)  	addq	112(%rsp),%rbx
23 (0.0%)  	movq	%rcx,%r15
23 (0.0%)  	xorq	%rax,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%rdx,%r15
23 (0.0%)  	addq	%r12,%rbx
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%r15,%rdi
23 (0.0%)  	xorq	%rcx,%r14
23 (0.0%)  	addq	%r13,%rbx
23 (0.0%)  	xorq	%rdx,%rdi
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%rbx,%r9
23 (0.0%)  	addq	%rdi,%rbx
23 (0.0%)  	movq	%r9,%r13
23 (0.0%)  	addq	%rbx,%r14
23 (0.0%)  	shrdq	$23,%r13,%r13
23 (0.0%)  	movq	%r14,%rbx
23 (0.0%)  	movq	%r10,%r12
23 (0.0%)  	shrdq	$5,%r14,%r14
23 (0.0%)  	xorq	%r9,%r13
23 (0.0%)  	xorq	%r11,%r12
23 (0.0%)  	shrdq	$4,%r13,%r13
23 (0.0%)  	xorq	%rbx,%r14
23 (0.0%)  	andq	%r9,%r12
23 (0.0%)  	xorq	%r9,%r13
23 (0.0%)  	addq	120(%rsp),%rax
23 (0.0%)  	movq	%rbx,%rdi
23 (0.0%)  	xorq	%r11,%r12
23 (0.0%)  	shrdq	$6,%r14,%r14
23 (0.0%)  	xorq	%rcx,%rdi
23 (0.0%)  	addq	%r12,%rax
23 (0.0%)  	shrdq	$14,%r13,%r13
23 (0.0%)  	andq	%rdi,%r15
23 (0.0%)  	xorq	%rbx,%r14
23 (0.0%)  	addq	%r13,%rax
23 (0.0%)  	xorq	%rcx,%r15
23 (0.0%)  	shrdq	$28,%r14,%r14
23 (0.0%)  	addq	%rax,%r8
23 (0.0%)  	addq	%r15,%rax
23 (0.0%)  	movq	%r8,%r13
23 (0.0%)  	addq	%rax,%r14
23 (0.0%)  	movq	128+0(%rsp),%rdi
23 (0.0%)  	movq	%r14,%rax
 .         
23 (0.0%)  	addq	0(%rdi),%rax
23 (0.0%)  	leaq	128(%rsi),%rsi
23 (0.0%)  	addq	8(%rdi),%rbx
23 (0.0%)  	addq	16(%rdi),%rcx
23 (0.0%)  	addq	24(%rdi),%rdx
23 (0.0%)  	addq	32(%rdi),%r8
23 (0.0%)  	addq	40(%rdi),%r9
23 (0.0%)  	addq	48(%rdi),%r10
23 (0.0%)  	addq	56(%rdi),%r11
 .         
23 (0.0%)  	cmpq	128+16(%rsp),%rsi
 .         
23 (0.0%)  	movq	%rax,0(%rdi)
23 (0.0%)  	movq	%rbx,8(%rdi)
23 (0.0%)  	movq	%rcx,16(%rdi)
23 (0.0%)  	movq	%rdx,24(%rdi)
23 (0.0%)  	movq	%r8,32(%rdi)
23 (0.0%)  	movq	%r9,40(%rdi)
23 (0.0%)  	movq	%r10,48(%rdi)
23 (0.0%)  	movq	%r11,56(%rdi)
23 (0.0%)  	jb	.Lloop_avx
 .         
17 (0.0%)  	movq	152(%rsp),%rsi
 .         .cfi_def_cfa	%rsi,8
17 (0.0%)  	vzeroupper
17 (0.0%)  	movq	-48(%rsi),%r15
 .         .cfi_restore	%r15
17 (0.0%)  	movq	-40(%rsi),%r14
 .         .cfi_restore	%r14
17 (0.0%)  	movq	-32(%rsi),%r13
 .         .cfi_restore	%r13
17 (0.0%)  	movq	-24(%rsi),%r12
 .         .cfi_restore	%r12
17 (0.0%)  	movq	-16(%rsi),%rbp
 .         .cfi_restore	%rbp
17 (0.0%)  	movq	-8(%rsi),%rbx
 .         .cfi_restore	%rbx
34 (0.0%)  	leaq	(%rsi),%rsp
 .         .cfi_def_cfa_register	%rsp
 .         .Lepilogue_avx:
 .         	.byte	0xf3,0xc3
 .         .cfi_endproc	
 .         .size	sha512_block_data_order_avx,.-sha512_block_data_order_avx
 .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont.S
--------------------------------------------------------------------------------
Ir___________ 

-- line 10 ----------------------------------------
     .         .hidden OPENSSL_ia32cap_P
     .         
     .         .globl	bn_mul_mont
     .         .hidden bn_mul_mont
     .         .type	bn_mul_mont,@function
     .         .align	16
     .         bn_mul_mont:
     .         .cfi_startproc	
 1,011 (0.0%)  	movl	%r9d,%r9d
 1,011 (0.0%)  	movq	%rsp,%rax
     .         .cfi_def_cfa_register	%rax
 1,011 (0.0%)  	testl	$3,%r9d
 1,011 (0.0%)  	jnz	.Lmul_enter
    66 (0.0%)  	cmpl	$8,%r9d
    66 (0.0%)  	jb	.Lmul_enter
     .         	leaq	OPENSSL_ia32cap_P(%rip),%r11
     .         	movl	8(%r11),%r11d
     .         	cmpq	%rsi,%rdx
     .         	jne	.Lmul4x_enter
     .         	testl	$7,%r9d
     .         	jz	.Lsqr8x_enter
     .         	jmp	.Lmul4x_enter
     .         
     .         .align	16
     .         .Lmul_enter:
 1,011 (0.0%)  	pushq	%rbx
     .         .cfi_offset	%rbx,-16
 1,011 (0.0%)  	pushq	%rbp
     .         .cfi_offset	%rbp,-24
 1,011 (0.0%)  	pushq	%r12
     .         .cfi_offset	%r12,-32
 1,011 (0.0%)  	pushq	%r13
     .         .cfi_offset	%r13,-40
 1,011 (0.0%)  	pushq	%r14
     .         .cfi_offset	%r14,-48
 1,011 (0.0%)  	pushq	%r15
     .         .cfi_offset	%r15,-56
     .         
 1,011 (0.0%)  	negq	%r9
 1,011 (0.0%)  	movq	%rsp,%r11
 1,011 (0.0%)  	leaq	-16(%rsp,%r9,8),%r10
 1,011 (0.0%)  	negq	%r9
 1,011 (0.0%)  	andq	$-1024,%r10
     .         
     .         
     .         
     .         
     .         
     .         
     .         
     .         
     .         
 1,011 (0.0%)  	subq	%r10,%r11
 1,011 (0.0%)  	andq	$-4096,%r11
 1,011 (0.0%)  	leaq	(%r10,%r11,1),%rsp
 1,011 (0.0%)  	movq	(%rsp),%r11
 1,011 (0.0%)  	cmpq	%r10,%rsp
 1,011 (0.0%)  	ja	.Lmul_page_walk
 1,011 (0.0%)  	jmp	.Lmul_page_walk_done
     .         
     .         .align	16
     .         .Lmul_page_walk:
     .         	leaq	-4096(%rsp),%rsp
     .         	movq	(%rsp),%r11
     .         	cmpq	%r10,%rsp
     .         	ja	.Lmul_page_walk
     .         .Lmul_page_walk_done:
     .         
 1,011 (0.0%)  	movq	%rax,8(%rsp,%r9,8)
     .         .cfi_escape	0x0f,0x0a,0x77,0x08,0x79,0x00,0x38,0x1e,0x22,0x06,0x23,0x08
     .         .Lmul_body:
 1,011 (0.0%)  	movq	%rdx,%r12
 1,011 (0.0%)  	movq	(%r8),%r8
 1,011 (0.0%)  	movq	(%r12),%rbx
 1,011 (0.0%)  	movq	(%rsi),%rax
     .         
 1,011 (0.0%)  	xorq	%r14,%r14
 1,011 (0.0%)  	xorq	%r15,%r15
     .         
 1,011 (0.0%)  	movq	%r8,%rbp
 1,011 (0.0%)  	mulq	%rbx
 1,011 (0.0%)  	movq	%rax,%r10
 1,011 (0.0%)  	movq	(%rcx),%rax
     .         
 1,011 (0.0%)  	imulq	%r10,%rbp
 1,011 (0.0%)  	movq	%rdx,%r11
     .         
 1,011 (0.0%)  	mulq	%rbp
 1,011 (0.0%)  	addq	%rax,%r10
 1,011 (0.0%)  	movq	8(%rsi),%rax
 1,011 (0.0%)  	adcq	$0,%rdx
 1,011 (0.0%)  	movq	%rdx,%r13
     .         
 1,011 (0.0%)  	leaq	1(%r15),%r15
 1,011 (0.0%)  	jmp	.L1st_enter
     .         
     .         .align	16
     .         .L1st:
 3,912 (0.0%)  	addq	%rax,%r13
 3,912 (0.0%)  	movq	(%rsi,%r15,8),%rax
 3,912 (0.0%)  	adcq	$0,%rdx
 3,912 (0.0%)  	addq	%r11,%r13
 3,912 (0.0%)  	movq	%r10,%r11
 3,912 (0.0%)  	adcq	$0,%rdx
 3,912 (0.0%)  	movq	%r13,-16(%rsp,%r15,8)
 3,912 (0.0%)  	movq	%rdx,%r13
     .         
     .         .L1st_enter:
 4,923 (0.0%)  	mulq	%rbx
 4,923 (0.0%)  	addq	%rax,%r11
 4,923 (0.0%)  	movq	(%rcx,%r15,8),%rax
 4,923 (0.0%)  	adcq	$0,%rdx
 4,923 (0.0%)  	leaq	1(%r15),%r15
 4,923 (0.0%)  	movq	%rdx,%r10
     .         
 4,923 (0.0%)  	mulq	%rbp
 4,923 (0.0%)  	cmpq	%r9,%r15
 4,923 (0.0%)  	jne	.L1st
     .         
 1,011 (0.0%)  	addq	%rax,%r13
 1,011 (0.0%)  	movq	(%rsi),%rax
 1,011 (0.0%)  	adcq	$0,%rdx
 1,011 (0.0%)  	addq	%r11,%r13
 1,011 (0.0%)  	adcq	$0,%rdx
 1,011 (0.0%)  	movq	%r13,-16(%rsp,%r15,8)
 1,011 (0.0%)  	movq	%rdx,%r13
 1,011 (0.0%)  	movq	%r10,%r11
     .         
 1,011 (0.0%)  	xorq	%rdx,%rdx
 1,011 (0.0%)  	addq	%r11,%r13
 1,011 (0.0%)  	adcq	$0,%rdx
 1,011 (0.0%)  	movq	%r13,-8(%rsp,%r9,8)
 1,011 (0.0%)  	movq	%rdx,(%rsp,%r9,8)
     .         
 1,011 (0.0%)  	leaq	1(%r14),%r14
 1,011 (0.0%)  	jmp	.Louter
     .         .align	16
     .         .Louter:
 4,923 (0.0%)  	movq	(%r12,%r14,8),%rbx
 4,923 (0.0%)  	xorq	%r15,%r15
 4,923 (0.0%)  	movq	%r8,%rbp
 4,923 (0.0%)  	movq	(%rsp),%r10
 4,923 (0.0%)  	mulq	%rbx
 4,923 (0.0%)  	addq	%rax,%r10
 4,923 (0.0%)  	movq	(%rcx),%rax
 4,923 (0.0%)  	adcq	$0,%rdx
     .         
 4,923 (0.0%)  	imulq	%r10,%rbp
 4,923 (0.0%)  	movq	%rdx,%r11
     .         
 4,923 (0.0%)  	mulq	%rbp
 4,923 (0.0%)  	addq	%rax,%r10
 4,923 (0.0%)  	movq	8(%rsi),%rax
 4,923 (0.0%)  	adcq	$0,%rdx
 4,923 (0.0%)  	movq	8(%rsp),%r10
 4,923 (0.0%)  	movq	%rdx,%r13
     .         
 4,923 (0.0%)  	leaq	1(%r15),%r15
 4,923 (0.0%)  	jmp	.Linner_enter
     .         
     .         .align	16
     .         .Linner:
19,296 (0.2%)  	addq	%rax,%r13
19,296 (0.2%)  	movq	(%rsi,%r15,8),%rax
19,296 (0.2%)  	adcq	$0,%rdx
19,296 (0.2%)  	addq	%r10,%r13
19,296 (0.2%)  	movq	(%rsp,%r15,8),%r10
19,296 (0.2%)  	adcq	$0,%rdx
19,296 (0.2%)  	movq	%r13,-16(%rsp,%r15,8)
19,296 (0.2%)  	movq	%rdx,%r13
     .         
     .         .Linner_enter:
24,219 (0.2%)  	mulq	%rbx
24,219 (0.2%)  	addq	%rax,%r11
24,219 (0.2%)  	movq	(%rcx,%r15,8),%rax
24,219 (0.2%)  	adcq	$0,%rdx
24,219 (0.2%)  	addq	%r11,%r10
24,219 (0.2%)  	movq	%rdx,%r11
24,219 (0.2%)  	adcq	$0,%r11
24,219 (0.2%)  	leaq	1(%r15),%r15
     .         
24,219 (0.2%)  	mulq	%rbp
24,219 (0.2%)  	cmpq	%r9,%r15
24,219 (0.2%)  	jne	.Linner
     .         
 4,923 (0.0%)  	addq	%rax,%r13
 4,923 (0.0%)  	movq	(%rsi),%rax
 4,923 (0.0%)  	adcq	$0,%rdx
 4,923 (0.0%)  	addq	%r10,%r13
 4,923 (0.0%)  	movq	(%rsp,%r15,8),%r10
 4,923 (0.0%)  	adcq	$0,%rdx
 4,923 (0.0%)  	movq	%r13,-16(%rsp,%r15,8)
 4,923 (0.0%)  	movq	%rdx,%r13
     .         
 4,923 (0.0%)  	xorq	%rdx,%rdx
 4,923 (0.0%)  	addq	%r11,%r13
 4,923 (0.0%)  	adcq	$0,%rdx
 4,923 (0.0%)  	addq	%r10,%r13
 4,923 (0.0%)  	adcq	$0,%rdx
 4,923 (0.0%)  	movq	%r13,-8(%rsp,%r9,8)
 4,923 (0.0%)  	movq	%rdx,(%rsp,%r9,8)
     .         
 4,923 (0.0%)  	leaq	1(%r14),%r14
 4,923 (0.0%)  	cmpq	%r9,%r14
 4,923 (0.0%)  	jb	.Louter
     .         
 1,011 (0.0%)  	xorq	%r14,%r14
 1,011 (0.0%)  	movq	(%rsp),%rax
 1,011 (0.0%)  	movq	%r9,%r15
     .         
     .         .align	16
 5,934 (0.1%)  .Lsub:	sbbq	(%rcx,%r14,8),%rax
 5,934 (0.1%)  	movq	%rax,(%rdi,%r14,8)
 5,934 (0.1%)  	movq	8(%rsp,%r14,8),%rax
 5,934 (0.1%)  	leaq	1(%r14),%r14
 5,934 (0.1%)  	decq	%r15
 5,934 (0.1%)  	jnz	.Lsub
     .         
 1,011 (0.0%)  	sbbq	$0,%rax
 1,011 (0.0%)  	movq	$-1,%rbx
 1,011 (0.0%)  	xorq	%rax,%rbx
 1,011 (0.0%)  	xorq	%r14,%r14
 1,011 (0.0%)  	movq	%r9,%r15
     .         
     .         .Lcopy:
 5,934 (0.1%)  	movq	(%rdi,%r14,8),%rcx
 5,934 (0.1%)  	movq	(%rsp,%r14,8),%rdx
 5,934 (0.1%)  	andq	%rbx,%rcx
 5,934 (0.1%)  	andq	%rax,%rdx
 5,934 (0.1%)  	movq	%r9,(%rsp,%r14,8)
 5,934 (0.1%)  	orq	%rcx,%rdx
 5,934 (0.1%)  	movq	%rdx,(%rdi,%r14,8)
 5,934 (0.1%)  	leaq	1(%r14),%r14
 5,934 (0.1%)  	subq	$1,%r15
 5,934 (0.1%)  	jnz	.Lcopy
     .         
 1,011 (0.0%)  	movq	8(%rsp,%r9,8),%rsi
     .         .cfi_def_cfa	%rsi,8
 1,011 (0.0%)  	movq	$1,%rax
 1,011 (0.0%)  	movq	-48(%rsi),%r15
     .         .cfi_restore	%r15
 1,011 (0.0%)  	movq	-40(%rsi),%r14
     .         .cfi_restore	%r14
 1,011 (0.0%)  	movq	-32(%rsi),%r13
     .         .cfi_restore	%r13
 1,011 (0.0%)  	movq	-24(%rsi),%r12
     .         .cfi_restore	%r12
 1,011 (0.0%)  	movq	-16(%rsi),%rbp
     .         .cfi_restore	%rbp
 1,011 (0.0%)  	movq	-8(%rsi),%rbx
     .         .cfi_restore	%rbx
 2,022 (0.0%)  	leaq	(%rsi),%rsp
     .         .cfi_def_cfa_register	%rsp
     .         .Lmul_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	bn_mul_mont,.-bn_mul_mont
     .         .type	bn_mul4x_mont,@function
     .         .align	16
     .         bn_mul4x_mont:
-- line 269 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/third_party/s2n-bignum/x86_att/p384/bignum_add_p384.S
--------------------------------------------------------------------------------
Ir__________ 

-- line 48 ----------------------------------------
    .                 movq    %rcx, %rdi
    .                 movq    %rdx, %rsi
    .                 movq    %r8, %rdx
    .         #endif
    .         
    .         // Add the inputs as 2^384 * c + [d5;d4;d3;d2;d1;d0] = x + y
    .         // This could be combined with the next block using ADCX and ADOX.
    .         
4,158 (0.0%)          movq    (x), d0
4,158 (0.0%)          addq    (y), d0
4,158 (0.0%)          movq    8(x), d1
4,158 (0.0%)          adcq    8(y), d1
4,158 (0.0%)          movq    16(x), d2
4,158 (0.0%)          adcq    16(y), d2
4,158 (0.0%)          movq    24(x), d3
4,158 (0.0%)          adcq    24(y), d3
4,158 (0.0%)          movq    32(x), d4
4,158 (0.0%)          adcq    32(y), d4
4,158 (0.0%)          movq    40(x), d5
4,158 (0.0%)          adcq    40(y), d5
4,158 (0.0%)          movl    $0, cshort
4,158 (0.0%)          adcq    c, c
    .         
    .         // Now subtract p_384 from 2^384 * c + [d5;d4;d3;d2;d1;d0] to get x + y - p_384
    .         // This is actually done by *adding* the 7-word negation r_384 = 2^448 - p_384
    .         // where r_384 = [-1; 0; 0; 0; 1; 0x00000000ffffffff; 0xffffffff00000001]
    .         
4,158 (0.0%)          movq    $0xffffffff00000001, a
4,158 (0.0%)          addq    a, d0
4,158 (0.0%)          movl    $0x00000000ffffffff, ashort
4,158 (0.0%)          adcq    a, d1
4,158 (0.0%)          adcq    $1, d2
4,158 (0.0%)          adcq    $0, d3
4,158 (0.0%)          adcq    $0, d4
4,158 (0.0%)          adcq    $0, d5
4,158 (0.0%)          adcq    $-1, c
    .         
    .         // Since by hypothesis x < p_384 we know x + y - p_384 < 2^384, so the top
    .         // carry c actually gives us a bitmask for x + y - p_384 < 0, which we
    .         // now use to make r' = mask * (2^384 - p_384) for a compensating subtraction.
    .         // We don't quite have enough ABI-modifiable registers to create all three
    .         // nonzero digits of r while maintaining d0..d5, but make the first two now.
    .         
4,158 (0.0%)          andq    a, c // c = masked 0x00000000ffffffff
4,158 (0.0%)          xorq    a, a
4,158 (0.0%)          subq    c, a // a = masked 0xffffffff00000001
    .         
    .         // Do the first two digits of addition and writeback
    .         
4,158 (0.0%)          subq    a, d0
4,158 (0.0%)          movq    d0, (z)
4,158 (0.0%)          sbbq    c, d1
4,158 (0.0%)          movq    d1, 8(z)
    .         
    .         // Preserve the carry chain while creating the extra masked digit since
    .         // the logical operation will clear CF
    .         
4,158 (0.0%)          sbbq    d0, d0
4,158 (0.0%)          andq    a, c // c = masked 0x0000000000000001
4,158 (0.0%)          negq    d0
    .         
    .         // Do the rest of the addition and writeback
    .         
4,158 (0.0%)          sbbq    c, d2
4,158 (0.0%)          movq    d2, 16(z)
4,158 (0.0%)          sbbq    $0, d3
4,158 (0.0%)          movq    d3, 24(z)
4,158 (0.0%)          sbbq    $0, d4
4,158 (0.0%)          movq    d4, 32(z)
4,158 (0.0%)          sbbq    $0, d5
4,158 (0.0%)          movq    d5, 40(z)
    .         
    .         #if WINDOWS_ABI
    .                 popq   %rsi
    .                 popq   %rdi
    .         #endif
4,158 (0.0%)          ret
    .         
    .         #if defined(__linux__) && defined(__ELF__)
    .         .section .note.GNU-stack,"",%progbits
    .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/third_party/s2n-bignum/x86_att/p384/bignum_montmul_p384_alt.S
--------------------------------------------------------------------------------
Ir___________ 

-- line 114 ----------------------------------------
     .                 pushq   %rsi
     .                 movq    %rcx, %rdi
     .                 movq    %rdx, %rsi
     .                 movq    %r8, %rdx
     .         #endif
     .         
     .         // Save more registers to play with
     .         
 2,989 (0.0%)          pushq   %rbx
 2,989 (0.0%)          pushq   %rbp
 2,989 (0.0%)          pushq   %r12
 2,989 (0.0%)          pushq   %r13
 2,989 (0.0%)          pushq   %r14
 2,989 (0.0%)          pushq   %r15
     .         
     .         // Copy y into a safe register to start with
     .         
 2,989 (0.0%)          movq    %rdx, y
     .         
     .         // Do row 0 computation, which is a bit different:
     .         // set up initial window [%r14,%r13,%r12,%r11,%r10,%r9,%r8] = y[0] * x
     .         // Unlike later, we only need a single carry chain
     .         
 2,989 (0.0%)          movq    (y), %rbx
 2,989 (0.0%)          movq    (x), %rax
 2,989 (0.0%)          mulq    %rbx
 2,989 (0.0%)          movq    %rax, %r8
 2,989 (0.0%)          movq    %rdx, %r9
     .         
 2,989 (0.0%)          movq    8(x), %rax
 2,989 (0.0%)          mulq    %rbx
 2,989 (0.0%)          xorl    %r10d, %r10d
 2,989 (0.0%)          addq    %rax, %r9
 2,989 (0.0%)          adcq    %rdx, %r10
     .         
 2,989 (0.0%)          movq    16(x), %rax
 2,989 (0.0%)          mulq    %rbx
 2,989 (0.0%)          xorl    %r11d, %r11d
 2,989 (0.0%)          addq    %rax, %r10
 2,989 (0.0%)          adcq    %rdx, %r11
     .         
 2,989 (0.0%)          movq    24(x), %rax
 2,989 (0.0%)          mulq    %rbx
 2,989 (0.0%)          xorl    %r12d, %r12d
 2,989 (0.0%)          addq    %rax, %r11
 2,989 (0.0%)          adcq    %rdx, %r12
     .         
 2,989 (0.0%)          movq    32(x), %rax
 2,989 (0.0%)          mulq    %rbx
 2,989 (0.0%)          xorl    %r13d, %r13d
 2,989 (0.0%)          addq    %rax, %r12
 2,989 (0.0%)          adcq    %rdx, %r13
     .         
 2,989 (0.0%)          movq    40(x), %rax
 2,989 (0.0%)          mulq    %rbx
 2,989 (0.0%)          xorl    %r14d, %r14d
 2,989 (0.0%)          addq    %rax, %r13
 2,989 (0.0%)          adcq    %rdx, %r14
     .         
 2,989 (0.0%)          xorl    %r15d, %r15d
     .         
     .         // Montgomery reduce the zeroth window
     .         
59,780 (0.6%)          montredc(%r15, %r14,%r13,%r12,%r11,%r10,%r9,%r8)
     .         
     .         // Add row 1
     .         
 2,989 (0.0%)          movq    8(y), %rbx
14,945 (0.1%)          mulpadi(%r8,%r10,%r9,(x))
17,934 (0.2%)          mulpadd(%r8,%r11,%r10,8(x))
17,934 (0.2%)          mulpadd(%r8,%r12,%r11,16(x))
17,934 (0.2%)          mulpadd(%r8,%r13,%r12,24(x))
17,934 (0.2%)          mulpadd(%r8,%r14,%r13,32(x))
17,934 (0.2%)          mulpadd(%r8,%r15,%r14,40(x))
 2,989 (0.0%)          negq    %r8
     .         
     .         // Montgomery reduce window 1
     .         
59,780 (0.6%)          montredc(%r8, %r15,%r14,%r13,%r12,%r11,%r10,%r9)
     .         
     .         // Add row 2
     .         
 2,989 (0.0%)          movq    16(y), %rbx
14,945 (0.1%)          mulpadi(%r9,%r11,%r10,(x))
17,934 (0.2%)          mulpadd(%r9,%r12,%r11,8(x))
17,934 (0.2%)          mulpadd(%r9,%r13,%r12,16(x))
17,934 (0.2%)          mulpadd(%r9,%r14,%r13,24(x))
17,934 (0.2%)          mulpadd(%r9,%r15,%r14,32(x))
17,934 (0.2%)          mulpadd(%r9,%r8,%r15,40(x))
 2,989 (0.0%)          negq    %r9
     .         
     .         // Montgomery reduce window 2
     .         
59,780 (0.6%)          montredc(%r9, %r8,%r15,%r14,%r13,%r12,%r11,%r10)
     .         
     .         // Add row 3
     .         
 2,989 (0.0%)          movq    24(y), %rbx
14,945 (0.1%)          mulpadi(%r10,%r12,%r11,(x))
17,934 (0.2%)          mulpadd(%r10,%r13,%r12,8(x))
17,934 (0.2%)          mulpadd(%r10,%r14,%r13,16(x))
17,934 (0.2%)          mulpadd(%r10,%r15,%r14,24(x))
17,934 (0.2%)          mulpadd(%r10,%r8,%r15,32(x))
17,934 (0.2%)          mulpadd(%r10,%r9,%r8,40(x))
 2,989 (0.0%)          negq    %r10
     .         
     .         // Montgomery reduce window 3
     .         
59,780 (0.6%)          montredc(%r10, %r9,%r8,%r15,%r14,%r13,%r12,%r11)
     .         
     .         // Add row 4
     .         
 2,989 (0.0%)          movq    32(y), %rbx
14,945 (0.1%)          mulpadi(%r11,%r13,%r12,(x))
17,934 (0.2%)          mulpadd(%r11,%r14,%r13,8(x))
17,934 (0.2%)          mulpadd(%r11,%r15,%r14,16(x))
17,934 (0.2%)          mulpadd(%r11,%r8,%r15,24(x))
17,934 (0.2%)          mulpadd(%r11,%r9,%r8,32(x))
17,934 (0.2%)          mulpadd(%r11,%r10,%r9,40(x))
 2,989 (0.0%)          negq    %r11
     .         
     .         // Montgomery reduce window 4
     .         
59,780 (0.6%)          montredc(%r11, %r10,%r9,%r8,%r15,%r14,%r13,%r12)
     .         
     .         // Add row 5
     .         
 2,989 (0.0%)          movq    40(y), %rbx
14,945 (0.1%)          mulpadi(%r12,%r14,%r13,(x))
17,934 (0.2%)          mulpadd(%r12,%r15,%r14,8(x))
17,934 (0.2%)          mulpadd(%r12,%r8,%r15,16(x))
17,934 (0.2%)          mulpadd(%r12,%r9,%r8,24(x))
17,934 (0.2%)          mulpadd(%r12,%r10,%r9,32(x))
17,934 (0.2%)          mulpadd(%r12,%r11,%r10,40(x))
 2,989 (0.0%)          negq    %r12
     .         
     .         // Montgomery reduce window 5
     .         
59,780 (0.6%)          montredc(%r12, %r11,%r10,%r9,%r8,%r15,%r14,%r13)
     .         
     .         // We now have a pre-reduced 7-word form z = [%r12; %r11;%r10;%r9;%r8;%r15;%r14]
     .         // Next, accumulate in different registers z - p_384, or more precisely
     .         //
     .         //   [%r12; %r13;%rbp;%rdx;%rcx;%rbx;%rax] = z + (2^384 - p_384)
     .         
 2,989 (0.0%)          xorl    %edx, %edx
 2,989 (0.0%)          xorl    %ebp, %ebp
 2,989 (0.0%)          xorl    %r13d, %r13d
     .         
 2,989 (0.0%)          movq    $0xffffffff00000001, %rax
 2,989 (0.0%)          addq    %r14, %rax
 2,989 (0.0%)          movl    $0x00000000ffffffff, %ebx
 2,989 (0.0%)          adcq    %r15, %rbx
 2,989 (0.0%)          movl    $0x0000000000000001, %ecx
 2,989 (0.0%)          adcq    %r8, %rcx
 2,989 (0.0%)          adcq    %r9, %rdx
 2,989 (0.0%)          adcq    %r10, %rbp
 2,989 (0.0%)          adcq    %r11, %r13
 2,989 (0.0%)          adcq    $0, %r12
     .         
     .         // ~ZF <=> %r12 >= 1 <=> z + (2^384 - p_384) >= 2^384 <=> z >= p_384, which
     .         // determines whether to use the further reduced argument or the original z.
     .         
 2,989 (0.0%)          cmovnzq %rax, %r14
 2,989 (0.0%)          cmovnzq %rbx, %r15
 2,989 (0.0%)          cmovnzq %rcx, %r8
 2,989 (0.0%)          cmovnzq %rdx, %r9
 2,989 (0.0%)          cmovnzq %rbp, %r10
 2,989 (0.0%)          cmovnzq %r13, %r11
     .         
     .         // Write back the result
     .         
 2,989 (0.0%)          movq    %r14, (z)
 2,989 (0.0%)          movq    %r15, 8(z)
 2,989 (0.0%)          movq    %r8, 16(z)
 2,989 (0.0%)          movq    %r9, 24(z)
 2,989 (0.0%)          movq    %r10, 32(z)
 2,989 (0.0%)          movq    %r11, 40(z)
     .         
     .         // Restore registers and return
     .         
 2,989 (0.0%)          popq    %r15
 2,989 (0.0%)          popq    %r14
 2,989 (0.0%)          popq    %r13
 2,989 (0.0%)          popq    %r12
 2,989 (0.0%)          popq    %rbp
 2,989 (0.0%)          popq    %rbx
     .         
     .         #if WINDOWS_ABI
     .                 popq   %rsi
     .                 popq   %rdi
     .         #endif
 2,989 (0.0%)          ret
     .         
     .         #if defined(__linux__) && defined(__ELF__)
     .         .section .note.GNU-stack,"",%progbits
     .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/third_party/s2n-bignum/x86_att/p384/bignum_montsqr_p384_alt.S
--------------------------------------------------------------------------------
Ir___________ 

-- line 110 ----------------------------------------
     .                 pushq   %rdi
     .                 pushq   %rsi
     .                 movq    %rcx, %rdi
     .                 movq    %rdx, %rsi
     .         #endif
     .         
     .         // Save more registers to play with
     .         
 3,091 (0.0%)          pushq   %rbx
 3,091 (0.0%)          pushq   %rbp
 3,091 (0.0%)          pushq   %r12
 3,091 (0.0%)          pushq   %r13
 3,091 (0.0%)          pushq   %r14
 3,091 (0.0%)          pushq   %r15
     .         
     .         // Set up an initial window [%rcx;%r15;...%r9] = [34;05;03;01]
     .         // Note that we are using %rcx as the first step past the rotating window
     .         
 3,091 (0.0%)          movq    (x), %rbx
 3,091 (0.0%)          movq    8(x), %rax
 3,091 (0.0%)          mulq    %rbx
 3,091 (0.0%)          movq    %rax, %r9
 3,091 (0.0%)          movq    %rdx, %r10
     .         
 3,091 (0.0%)          movq    24(x), %rax
 3,091 (0.0%)          mulq    %rbx
 3,091 (0.0%)          movq    %rax, %r11
 3,091 (0.0%)          movq    %rdx, %r12
     .         
 3,091 (0.0%)          movq    40(x), %rax
 3,091 (0.0%)          mulq    %rbx
 3,091 (0.0%)          movq    %rax, %r13
 3,091 (0.0%)          movq    %rdx, %r14
     .         
 3,091 (0.0%)          movq    24(x), %rax
 3,091 (0.0%)          mulq     32(x)
 3,091 (0.0%)          movq    %rax, %r15
 3,091 (0.0%)          movq    %rdx, %rcx
     .         
     .         // Chain in the addition of 02 + 12 + 13 + 14 + 15 to that window
     .         // (no carry-out possible)
     .         
 3,091 (0.0%)          movq    16(x), %rbx
15,455 (0.1%)          mulpadi(%rbp,%r11,%r10,(x))
18,546 (0.2%)          mulpadd(%rbp,%r12,%r11,8(x))
 3,091 (0.0%)          movq    8(x), %rbx
18,546 (0.2%)          mulpadd(%rbp,%r13,%r12,24(x))
18,546 (0.2%)          mulpadd(%rbp,%r14,%r13,32(x))
15,455 (0.1%)          mulpade(%rbp,%r15,%r14,40(x))
 3,091 (0.0%)          adcq    $0, %rcx
     .         
     .         // Now chain in the 04 + 23 + 24 + 25 + 35 + 45 terms
     .         // We are running out of registers in our rotating window, so we start
     .         // using %rbx (and hence need care with using mulpadd after this). Thus
     .         // our result so far is in [%rbp;%rbx;%rcx;%r15;...%r9]
     .         
 3,091 (0.0%)          movq    32(x), %rbx
15,455 (0.1%)          mulpadi(%rbp,%r13,%r12,(x))
 3,091 (0.0%)          movq    16(x), %rbx
18,546 (0.2%)          mulpadd(%rbp,%r14,%r13,24(x))
18,546 (0.2%)          mulpadd(%rbp,%r15,%r14,32(x))
18,546 (0.2%)          mulpadd(%rbp,%rcx,%r15,40(x))
     .         
 3,091 (0.0%)          xorl    %ebx, %ebx
 3,091 (0.0%)          movq    24(x), %rax
 3,091 (0.0%)          mulq     40(x)
 3,091 (0.0%)          subq    %rbp, %rdx
 3,091 (0.0%)          xorl    %ebp, %ebp
 3,091 (0.0%)          addq    %rax, %rcx
 3,091 (0.0%)          adcq    %rdx, %rbx
 3,091 (0.0%)          adcl    %ebp, %ebp
 3,091 (0.0%)          movq    32(x), %rax
 3,091 (0.0%)          mulq     40(x)
 3,091 (0.0%)          addq    %rax, %rbx
 3,091 (0.0%)          adcq    %rdx, %rbp
     .         
     .         // Double the window as [%r8;%rbp;%rbx;%rcx;%r15;...%r9]
     .         
 3,091 (0.0%)          xorl    %r8d, %r8d
 3,091 (0.0%)          addq    %r9, %r9
 3,091 (0.0%)          adcq    %r10, %r10
 3,091 (0.0%)          adcq    %r11, %r11
 3,091 (0.0%)          adcq    %r12, %r12
 3,091 (0.0%)          adcq    %r13, %r13
 3,091 (0.0%)          adcq    %r14, %r14
 3,091 (0.0%)          adcq    %r15, %r15
 3,091 (0.0%)          adcq    %rcx, %rcx
 3,091 (0.0%)          adcq    %rbx, %rbx
 3,091 (0.0%)          adcq    %rbp, %rbp
 3,091 (0.0%)          adcl    %r8d, %r8d
     .         
     .         // Add the doubled window to the 00 + 11 + 22 + 33 + 44 + 55 terms
     .         // For one glorious moment the entire squaring result is all in the
     .         // register file as [%rsi;%rbp;%rbx;%rcx;%r15;...;%r8]
     .         // (since we've now finished with x we can re-use %rsi). But since
     .         // we are so close to running out of registers, we do a bit of
     .         // reshuffling and temporary storage in the output buffer.
     .         
 3,091 (0.0%)          movq    (x), %rax
 3,091 (0.0%)          mulq    %rax
 3,091 (0.0%)          movq    %r8, (z)
 3,091 (0.0%)          movq    %rax, %r8
 3,091 (0.0%)          movq    8(x), %rax
 3,091 (0.0%)          movq    %rbp, 8(z)
 3,091 (0.0%)          addq    %rdx, %r9
 3,091 (0.0%)          sbbq    %rbp, %rbp
     .         
 3,091 (0.0%)          mulq    %rax
 3,091 (0.0%)          negq    %rbp
 3,091 (0.0%)          adcq    %rax, %r10
 3,091 (0.0%)          adcq    %rdx, %r11
 3,091 (0.0%)          sbbq    %rbp, %rbp
     .         
 3,091 (0.0%)          movq    16(x), %rax
 3,091 (0.0%)          mulq    %rax
 3,091 (0.0%)          negq    %rbp
 3,091 (0.0%)          adcq    %rax, %r12
 3,091 (0.0%)          adcq    %rdx, %r13
 3,091 (0.0%)          sbbq    %rbp, %rbp
     .         
 3,091 (0.0%)          movq    24(x), %rax
 3,091 (0.0%)          mulq    %rax
 3,091 (0.0%)          negq    %rbp
 3,091 (0.0%)          adcq    %rax, %r14
 3,091 (0.0%)          adcq    %rdx, %r15
 3,091 (0.0%)          sbbq    %rbp, %rbp
     .         
 3,091 (0.0%)          movq    32(x), %rax
 3,091 (0.0%)          mulq    %rax
 3,091 (0.0%)          negq    %rbp
 3,091 (0.0%)          adcq    %rax, %rcx
 3,091 (0.0%)          adcq    %rdx, %rbx
 3,091 (0.0%)          sbbq    %rbp, %rbp
     .         
 3,091 (0.0%)          movq    40(x), %rax
 3,091 (0.0%)          mulq    %rax
 3,091 (0.0%)          negq    %rbp
 3,091 (0.0%)          adcq    8(z), %rax
 3,091 (0.0%)          adcq    (z), %rdx
 3,091 (0.0%)          movq    %rax, %rbp
 3,091 (0.0%)          movq    %rdx, %rsi
     .         
     .         // We need just *one* more register as a temp for the Montgomery steps.
     .         // Since we are writing to the z buffer anyway, make use of that again
     .         // to stash %rbx.
     .         
 3,091 (0.0%)          movq    %rbx, (z)
     .         
     .         // Montgomery reduce the %r13,...,%r8 window 6 times
     .         
58,729 (0.5%)          montreds(%r8,%r13,%r12,%r11,%r10,%r9,%r8)
58,729 (0.5%)          montreds(%r9,%r8,%r13,%r12,%r11,%r10,%r9)
58,729 (0.5%)          montreds(%r10,%r9,%r8,%r13,%r12,%r11,%r10)
58,729 (0.5%)          montreds(%r11,%r10,%r9,%r8,%r13,%r12,%r11)
58,729 (0.5%)          montreds(%r12,%r11,%r10,%r9,%r8,%r13,%r12)
58,729 (0.5%)          montreds(%r13,%r12,%r11,%r10,%r9,%r8,%r13)
     .         
     .         // Now we can safely restore %rbx before accumulating
     .         
 3,091 (0.0%)          movq    (z), %rbx
     .         
 3,091 (0.0%)          addq    %r8, %r14
 3,091 (0.0%)          adcq    %r9, %r15
 3,091 (0.0%)          adcq    %r10, %rcx
 3,091 (0.0%)          adcq    %r11, %rbx
 3,091 (0.0%)          adcq    %r12, %rbp
 3,091 (0.0%)          adcq    %r13, %rsi
 3,091 (0.0%)          movl    $0, %r8d
 3,091 (0.0%)          adcq    %r8, %r8
     .         
     .         // We now have a pre-reduced 7-word form z = [%r8; %rsi;%rbp;%rbx;%rcx;%r15;%r14]
     .         // Next, accumulate in different registers z - p_384, or more precisely
     .         //
     .         //   [%r8; %r13;%r12;%r11;%r10;%r9;%rax] = z + (2^384 - p_384)
     .         
 3,091 (0.0%)          xorq    %r11, %r11
 3,091 (0.0%)          xorq    %r12, %r12
 3,091 (0.0%)          xorq    %r13, %r13
 3,091 (0.0%)          movq    $0xffffffff00000001, %rax
 3,091 (0.0%)          addq    %r14, %rax
 3,091 (0.0%)          movl    $0x00000000ffffffff, %r9d
 3,091 (0.0%)          adcq    %r15, %r9
 3,091 (0.0%)          movl    $0x0000000000000001, %r10d
 3,091 (0.0%)          adcq    %rcx, %r10
 3,091 (0.0%)          adcq    %rbx, %r11
 3,091 (0.0%)          adcq    %rbp, %r12
 3,091 (0.0%)          adcq    %rsi, %r13
 3,091 (0.0%)          adcq    $0, %r8
     .         
     .         // ~ZF <=> %r12 >= 1 <=> z + (2^384 - p_384) >= 2^384 <=> z >= p_384, which
     .         // determines whether to use the further reduced argument or the original z.
     .         
 3,091 (0.0%)          cmovnzq %rax, %r14
 3,091 (0.0%)          cmovnzq %r9, %r15
 3,091 (0.0%)          cmovnzq %r10, %rcx
 3,091 (0.0%)          cmovnzq %r11, %rbx
 3,091 (0.0%)          cmovnzq %r12, %rbp
 3,091 (0.0%)          cmovnzq %r13, %rsi
     .         
     .         // Write back the result
     .         
 3,091 (0.0%)          movq    %r14, (z)
 3,091 (0.0%)          movq    %r15, 8(z)
 3,091 (0.0%)          movq    %rcx, 16(z)
 3,091 (0.0%)          movq    %rbx, 24(z)
 3,091 (0.0%)          movq    %rbp, 32(z)
 3,091 (0.0%)          movq    %rsi, 40(z)
     .         
     .         // Restore registers and return
     .         
 3,091 (0.0%)          popq    %r15
 3,091 (0.0%)          popq    %r14
 3,091 (0.0%)          popq    %r13
 3,091 (0.0%)          popq    %r12
 3,091 (0.0%)          popq    %rbp
 3,091 (0.0%)          popq    %rbx
     .         #if WINDOWS_ABI
     .                 popq   %rsi
     .                 popq   %rdi
     .         #endif
 3,091 (0.0%)          ret
     .         
     .         #if defined(__linux__) && defined(__ELF__)
     .         .section .note.GNU-stack,"",%progbits
     .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/third_party/s2n-bignum/x86_att/p384/bignum_nonzero_6.S
--------------------------------------------------------------------------------
Ir__________ 

-- line 30 ----------------------------------------
    .         #if WINDOWS_ABI
    .                 pushq   %rdi
    .                 pushq   %rsi
    .                 movq    %rcx, %rdi
    .         #endif
    .         
    .         // Generate a = an OR of all the words in the bignum
    .         
  792 (0.0%)          movq    (x), a
  792 (0.0%)          movq    8(x), d
  792 (0.0%)          orq     16(x), a
  792 (0.0%)          orq     24(x), d
  792 (0.0%)          orq     32(x), a
  792 (0.0%)          orq     40(x), d
  792 (0.0%)          orq     d, a
    .         
    .         // Set a standard C condition based on whether a is nonzero
    .         
  792 (0.0%)          movl    $1, dshort
  792 (0.0%)          cmovnzq d, a
    .         
    .         #if WINDOWS_ABI
    .                 popq   %rsi
    .                 popq   %rdi
    .         #endif
4,886 (0.0%)          ret
    .         
    .         #if defined(__linux__) && defined(__ELF__)
    .         .section .note.GNU-stack,"",%progbits
    .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/third_party/s2n-bignum/x86_att/p384/bignum_sub_p384.S
--------------------------------------------------------------------------------
Ir__________ 

-- line 48 ----------------------------------------
    .                 movq    %rdx, %rsi
    .                 movq    %r8, %rdx
    .         #endif
    .         
    .         // Subtract the inputs as [d5;d4;d3;d2;d1;d0] = x - y (modulo 2^384)
    .         // Capture the top carry as a bitmask for the condition x < y
    .         
    .                 movq    (x), d0
4,094 (0.0%)          subq    (y), d0
4,094 (0.0%)          movq    8(x), d1
4,094 (0.0%)          sbbq    8(y), d1
4,094 (0.0%)          movq    16(x), d2
4,094 (0.0%)          sbbq    16(y), d2
4,094 (0.0%)          movq    24(x), d3
4,094 (0.0%)          sbbq    24(y), d3
4,094 (0.0%)          movq    32(x), d4
4,094 (0.0%)          sbbq    32(y), d4
4,094 (0.0%)          movq    40(x), d5
4,094 (0.0%)          sbbq    40(y), d5
4,094 (0.0%)          sbbq    c, c
    .         
    .         // Use mask to make r' = mask * (2^384 - p_384) for a compensating subtraction
    .         // of r_384 = 2^384 - p_384, equivalent to an addition of p_384.
    .         // We don't quite have enough ABI-modifiable registers to create all three
    .         // nonzero digits of r while maintaining d0..d5, but make the first two now.
    .         
4,094 (0.0%)          movl    $0x00000000ffffffff, ashort
4,094 (0.0%)          andq    a, c // c = masked 0x00000000ffffffff
4,094 (0.0%)          xorq    a, a
4,094 (0.0%)          subq    c, a // a = masked 0xffffffff00000001
    .         
    .         // Do the first two digits of addition and writeback
    .         
4,094 (0.0%)          subq    a, d0
4,094 (0.0%)          movq    d0, (z)
4,094 (0.0%)          sbbq    c, d1
4,094 (0.0%)          movq    d1, 8(z)
    .         
    .         // Preserve the carry chain while creating the extra masked digit since
    .         // the logical operation will clear CF
    .         
4,094 (0.0%)          sbbq    d0, d0
4,094 (0.0%)          andq    a, c // c = masked 0x0000000000000001
4,094 (0.0%)          negq    d0
    .         
    .         // Do the rest of the addition and writeback
    .         
4,094 (0.0%)          sbbq    c, d2
4,094 (0.0%)          movq    d2, 16(z)
4,094 (0.0%)          sbbq    $0, d3
4,094 (0.0%)          movq    d3, 24(z)
4,094 (0.0%)          sbbq    $0, d4
4,094 (0.0%)          movq    d4, 32(z)
4,094 (0.0%)          sbbq    $0, d5
4,094 (0.0%)          movq    d5, 40(z)
    .         
    .         #if WINDOWS_ABI
    .                 popq   %rsi
    .                 popq   %rdi
    .         #endif
4,094 (0.0%)          ret
    .         
    .         #if defined(__linux__) && defined(__ELF__)
    .         .section .note.GNU-stack,"",%progbits
    .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 26 ----------------------------------------
     .         #if defined(S2N_LIBCRYPTO_SUPPORTS_EVP_MD5_SHA1_HASH)
     .             return false;
     .         #else
     .             return true;
     .         #endif
     .         }
     .         
     .         static bool s2n_use_evp_impl()
 1,542 (0.0%)  {
   514 (0.0%)      return s2n_is_in_fips_mode();
 1,028 (0.0%)  }
     .         
     .         bool s2n_hash_evp_fully_supported()
     6 (0.0%)  {
    12 (0.0%)      return s2n_use_evp_impl() && !s2n_use_custom_md5_sha1();
     4 (0.0%)  }
     .         
     .         const EVP_MD *s2n_hash_alg_to_evp_md(s2n_hash_algorithm alg)
     .         {
     .             switch (alg) {
     .                 case S2N_HASH_MD5:
     .                     return EVP_md5();
     .                 case S2N_HASH_SHA1:
     .                     return EVP_sha1();
-- line 49 ----------------------------------------
-- line 60 ----------------------------------------
     .                     return EVP_md5_sha1();
     .         #endif
     .                 default:
     .                     return NULL;
     .             }
     .         }
     .         
     .         int s2n_hash_digest_size(s2n_hash_algorithm alg, uint8_t *out)
 1,477 (0.0%)  {
   422 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(out, sizeof(*out)), S2N_ERR_PRECONDITION_VIOLATION);
     .             /* clang-format off */
 2,110 (0.0%)      switch (alg) {
    39 (0.0%)          case S2N_HASH_NONE:     *out = 0;                    break;
     .                 case S2N_HASH_MD5:      *out = MD5_DIGEST_LENGTH;    break;
     .                 case S2N_HASH_SHA1:     *out = SHA_DIGEST_LENGTH;    break;
     .                 case S2N_HASH_SHA224:   *out = SHA224_DIGEST_LENGTH; break;
   588 (0.0%)          case S2N_HASH_SHA256:   *out = SHA256_DIGEST_LENGTH; break;
     6 (0.0%)          case S2N_HASH_SHA384:   *out = SHA384_DIGEST_LENGTH; break;
     .                 case S2N_HASH_SHA512:   *out = SHA512_DIGEST_LENGTH; break;
     .                 case S2N_HASH_MD5_SHA1: *out = MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH; break;
     .                 default:
     .                     POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
     .             }
     .             /* clang-format on */
   211 (0.0%)      return S2N_SUCCESS;
   633 (0.0%)  }
     .         
     .         /* NOTE: s2n_hash_const_time_get_currently_in_hash_block takes advantage of the fact that
     .          * hash_block_size is a power of 2. This is true for all hashes we currently support
     .          * If this ever becomes untrue, this would require fixing*/
     .         int s2n_hash_block_size(s2n_hash_algorithm alg, uint64_t *block_size)
     .         {
     .             POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(block_size, sizeof(*block_size)), S2N_ERR_PRECONDITION_VIOLATION);
     .             /* clang-format off */
-- line 93 ----------------------------------------
-- line 104 ----------------------------------------
     .                         POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
     .             }
     .             /* clang-format on */
     .             return S2N_SUCCESS;
     .         }
     .         
     .         /* Return true if hash algorithm is available, false otherwise. */
     .         bool s2n_hash_is_available(s2n_hash_algorithm alg)
   930 (0.0%)  {
 1,860 (0.0%)      switch (alg) {
     .                 case S2N_HASH_MD5:
     .                 case S2N_HASH_MD5_SHA1:
     .                     /* return false if in FIPS mode, as MD5 algs are not available in FIPS mode. */
     .                     return !s2n_is_in_fips_mode();
     .                 case S2N_HASH_NONE:
     .                 case S2N_HASH_SHA1:
     .                 case S2N_HASH_SHA224:
     .                 case S2N_HASH_SHA256:
     .                 case S2N_HASH_SHA384:
     .                 case S2N_HASH_SHA512:
   372 (0.0%)              return true;
     .                 case S2N_HASH_SENTINEL:
     .                     return false;
     .             }
     .             return false;
   372 (0.0%)  }
     .         
     .         int s2n_hash_is_ready_for_input(struct s2n_hash_state *state)
     .         {
     .             POSIX_PRECONDITION(s2n_hash_state_validate(state));
     .             return state->is_ready_for_input;
     .         }
     .         
     .         static int s2n_low_level_hash_new(struct s2n_hash_state *state)
 1,296 (0.0%)  {
     .             /* s2n_hash_new will always call the corresponding implementation of the s2n_hash
     .              * being used. For the s2n_low_level_hash implementation, new is a no-op.
     .              */
     .         
 5,994 (0.1%)      *state = (struct s2n_hash_state){ 0 };
   162 (0.0%)      return S2N_SUCCESS;
   810 (0.0%)  }
     .         
     .         static int s2n_low_level_hash_init(struct s2n_hash_state *state, s2n_hash_algorithm alg)
 1,316 (0.0%)  {
 1,880 (0.0%)      switch (alg) {
     .                 case S2N_HASH_NONE:
     .                     break;
     .                 case S2N_HASH_MD5:
     .                     POSIX_GUARD_OSSL(MD5_Init(&state->digest.low_level.md5), S2N_ERR_HASH_INIT_FAILED);
     .                     break;
     .                 case S2N_HASH_SHA1:
     .                     POSIX_GUARD_OSSL(SHA1_Init(&state->digest.low_level.sha1), S2N_ERR_HASH_INIT_FAILED);
     .                     break;
     .                 case S2N_HASH_SHA224:
     .                     POSIX_GUARD_OSSL(SHA224_Init(&state->digest.low_level.sha224), S2N_ERR_HASH_INIT_FAILED);
     .                     break;
     .                 case S2N_HASH_SHA256:
 1,104 (0.0%)              POSIX_GUARD_OSSL(SHA256_Init(&state->digest.low_level.sha256), S2N_ERR_HASH_INIT_FAILED);
   368 (0.0%)              break;
     .                 case S2N_HASH_SHA384:
    24 (0.0%)              POSIX_GUARD_OSSL(SHA384_Init(&state->digest.low_level.sha384), S2N_ERR_HASH_INIT_FAILED);
     8 (0.0%)              break;
     .                 case S2N_HASH_SHA512:
     .                     POSIX_GUARD_OSSL(SHA512_Init(&state->digest.low_level.sha512), S2N_ERR_HASH_INIT_FAILED);
     .                     break;
     .                 case S2N_HASH_MD5_SHA1:
     .                     POSIX_GUARD_OSSL(SHA1_Init(&state->digest.low_level.md5_sha1.sha1), S2N_ERR_HASH_INIT_FAILED);
     .                     POSIX_GUARD_OSSL(MD5_Init(&state->digest.low_level.md5_sha1.md5), S2N_ERR_HASH_INIT_FAILED);
     .                     break;
     .         
     .                 default:
     .                     POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
     .             }
     .         
   564 (0.0%)      state->alg = alg;
   376 (0.0%)      state->is_ready_for_input = 1;
   376 (0.0%)      state->currently_in_hash = 0;
     .         
   188 (0.0%)      return 0;
   564 (0.0%)  }
     .         
     .         static int s2n_low_level_hash_update(struct s2n_hash_state *state, const void *data, uint32_t size)
 2,352 (0.0%)  {
 1,176 (0.0%)      POSIX_ENSURE(state->is_ready_for_input, S2N_ERR_HASH_NOT_READY);
     .         
 3,528 (0.0%)      switch (state->alg) {
     .                 case S2N_HASH_NONE:
    32 (0.0%)              break;
     .                 case S2N_HASH_MD5:
    63 (0.0%)              POSIX_GUARD_OSSL(MD5_Update(&state->digest.low_level.md5, data, size), S2N_ERR_HASH_UPDATE_FAILED);
    14 (0.0%)              break;
     .                 case S2N_HASH_SHA1:
    63 (0.0%)              POSIX_GUARD_OSSL(SHA1_Update(&state->digest.low_level.sha1, data, size), S2N_ERR_HASH_UPDATE_FAILED);
    14 (0.0%)              break;
     .                 case S2N_HASH_SHA224:
    63 (0.0%)              POSIX_GUARD_OSSL(SHA224_Update(&state->digest.low_level.sha224, data, size), S2N_ERR_HASH_UPDATE_FAILED);
    14 (0.0%)              break;
     .                 case S2N_HASH_SHA256:
 2,106 (0.0%)              POSIX_GUARD_OSSL(SHA256_Update(&state->digest.low_level.sha256, data, size), S2N_ERR_HASH_UPDATE_FAILED);
   468 (0.0%)              break;
     .                 case S2N_HASH_SHA384:
    81 (0.0%)              POSIX_GUARD_OSSL(SHA384_Update(&state->digest.low_level.sha384, data, size), S2N_ERR_HASH_UPDATE_FAILED);
    18 (0.0%)              break;
     .                 case S2N_HASH_SHA512:
    63 (0.0%)              POSIX_GUARD_OSSL(SHA512_Update(&state->digest.low_level.sha512, data, size), S2N_ERR_HASH_UPDATE_FAILED);
    14 (0.0%)              break;
     .                 case S2N_HASH_MD5_SHA1:
    63 (0.0%)              POSIX_GUARD_OSSL(SHA1_Update(&state->digest.low_level.md5_sha1.sha1, data, size), S2N_ERR_HASH_UPDATE_FAILED);
    63 (0.0%)              POSIX_GUARD_OSSL(MD5_Update(&state->digest.low_level.md5_sha1.md5, data, size), S2N_ERR_HASH_UPDATE_FAILED);
     7 (0.0%)              break;
     .                 default:
     .                     POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
     .             }
     .         
 1,764 (0.0%)      POSIX_ENSURE(size <= (UINT64_MAX - state->currently_in_hash), S2N_ERR_INTEGER_OVERFLOW);
 1,764 (0.0%)      state->currently_in_hash += size;
     .         
   294 (0.0%)      return S2N_SUCCESS;
   882 (0.0%)  }
     .         
     .         static int s2n_low_level_hash_digest(struct s2n_hash_state *state, void *out, uint32_t size)
   912 (0.0%)  {
   456 (0.0%)      POSIX_ENSURE(state->is_ready_for_input, S2N_ERR_HASH_NOT_READY);
     .         
 1,368 (0.0%)      switch (state->alg) {
     .                 case S2N_HASH_NONE:
    16 (0.0%)              break;
     .                 case S2N_HASH_MD5:
     .                     POSIX_ENSURE_EQ(size, MD5_DIGEST_LENGTH);
     .                     POSIX_GUARD_OSSL(MD5_Final(out, &state->digest.low_level.md5), S2N_ERR_HASH_DIGEST_FAILED);
     .                     break;
     .                 case S2N_HASH_SHA1:
     .                     POSIX_ENSURE_EQ(size, SHA_DIGEST_LENGTH);
     .                     POSIX_GUARD_OSSL(SHA1_Final(out, &state->digest.low_level.sha1), S2N_ERR_HASH_DIGEST_FAILED);
     .                     break;
     .                 case S2N_HASH_SHA224:
     .                     POSIX_ENSURE_EQ(size, SHA224_DIGEST_LENGTH);
     .                     POSIX_GUARD_OSSL(SHA224_Final(out, &state->digest.low_level.sha224), S2N_ERR_HASH_DIGEST_FAILED);
     .                     break;
     .                 case S2N_HASH_SHA256:
   208 (0.0%)              POSIX_ENSURE_EQ(size, SHA256_DIGEST_LENGTH);
   832 (0.0%)              POSIX_GUARD_OSSL(SHA256_Final(out, &state->digest.low_level.sha256), S2N_ERR_HASH_DIGEST_FAILED);
   208 (0.0%)              break;
     .                 case S2N_HASH_SHA384:
     4 (0.0%)              POSIX_ENSURE_EQ(size, SHA384_DIGEST_LENGTH);
    16 (0.0%)              POSIX_GUARD_OSSL(SHA384_Final(out, &state->digest.low_level.sha384), S2N_ERR_HASH_DIGEST_FAILED);
     4 (0.0%)              break;
     .                 case S2N_HASH_SHA512:
     .                     POSIX_ENSURE_EQ(size, SHA512_DIGEST_LENGTH);
     .                     POSIX_GUARD_OSSL(SHA512_Final(out, &state->digest.low_level.sha512), S2N_ERR_HASH_DIGEST_FAILED);
     .                     break;
     .                 case S2N_HASH_MD5_SHA1:
     .                     POSIX_ENSURE_EQ(size, MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH);
     .                     POSIX_GUARD_OSSL(SHA1_Final(((uint8_t *) out) + MD5_DIGEST_LENGTH, &state->digest.low_level.md5_sha1.sha1), S2N_ERR_HASH_DIGEST_FAILED);
     .                     POSIX_GUARD_OSSL(MD5_Final(out, &state->digest.low_level.md5_sha1.md5), S2N_ERR_HASH_DIGEST_FAILED);
     .                     break;
     .                 default:
     .                     POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
     .             }
     .         
   228 (0.0%)      state->currently_in_hash = 0;
   228 (0.0%)      state->is_ready_for_input = 0;
   114 (0.0%)      return 0;
   342 (0.0%)  }
     .         
     .         static int s2n_low_level_hash_copy(struct s2n_hash_state *to, struct s2n_hash_state *from)
 1,106 (0.0%)  {
 2,370 (0.0%)      POSIX_CHECKED_MEMCPY(to, from, sizeof(struct s2n_hash_state));
   158 (0.0%)      return 0;
   474 (0.0%)  }
     .         
     .         static int s2n_low_level_hash_reset(struct s2n_hash_state *state)
    10 (0.0%)  {
     .             /* hash_init resets the ready_for_input and currently_in_hash fields. */
    12 (0.0%)      return s2n_low_level_hash_init(state, state->alg);
     4 (0.0%)  }
     .         
     .         static int s2n_low_level_hash_free(struct s2n_hash_state *state)
   648 (0.0%)  {
     .             /* s2n_hash_free will always call the corresponding implementation of the s2n_hash
     .              * being used. For the s2n_low_level_hash implementation, free is a no-op.
     .              */
   324 (0.0%)      state->is_ready_for_input = 0;
   162 (0.0%)      return S2N_SUCCESS;
   324 (0.0%)  }
     .         
     .         static int s2n_evp_hash_new(struct s2n_hash_state *state)
     .         {
     .             POSIX_ENSURE_REF(state->digest.high_level.evp.ctx = S2N_EVP_MD_CTX_NEW());
     .             if (s2n_use_custom_md5_sha1()) {
     .                 POSIX_ENSURE_REF(state->digest.high_level.evp_md5_secondary.ctx = S2N_EVP_MD_CTX_NEW());
     .             }
     .         
-- line 297 ----------------------------------------
-- line 481 ----------------------------------------
     .             .update = &s2n_evp_hash_update,
     .             .digest = &s2n_evp_hash_digest,
     .             .copy = &s2n_evp_hash_copy,
     .             .reset = &s2n_evp_hash_reset,
     .             .free = &s2n_evp_hash_free,
     .         };
     .         
     .         static int s2n_hash_set_impl(struct s2n_hash_state *state)
 2,560 (0.0%)  {
 1,536 (0.0%)      state->hash_impl = &s2n_low_level_hash;
 2,048 (0.0%)      if (s2n_use_evp_impl()) {
     .                 state->hash_impl = &s2n_evp_hash;
     .             }
   512 (0.0%)      return S2N_SUCCESS;
 1,024 (0.0%)  }
     .         
     .         int s2n_hash_new(struct s2n_hash_state *state)
   972 (0.0%)  {
   324 (0.0%)      POSIX_ENSURE_REF(state);
     .             /* Set hash_impl on initial hash creation.
     .              * When in FIPS mode, the EVP API's must be used for hashes.
     .              */
   810 (0.0%)      POSIX_GUARD(s2n_hash_set_impl(state));
     .         
   810 (0.0%)      POSIX_ENSURE_REF(state->hash_impl->alloc);
     .         
 1,296 (0.0%)      POSIX_GUARD(state->hash_impl->alloc(state));
   162 (0.0%)      return S2N_SUCCESS;
   486 (0.0%)  }
     .         
     .         S2N_RESULT s2n_hash_state_validate(struct s2n_hash_state *state)
11,640 (0.1%)  {
 3,880 (0.0%)      RESULT_ENSURE_REF(state);
 1,940 (0.0%)      return S2N_RESULT_OK;
 5,820 (0.1%)  }
     .         
     .         int s2n_hash_allow_md5_for_fips(struct s2n_hash_state *state)
     .         {
     .             POSIX_ENSURE_REF(state);
     .             /* Ensure that hash_impl is set, as it may have been reset for s2n_hash_state on s2n_connection_wipe.
     .              * When in FIPS mode, the EVP API's must be used for hashes.
     .              */
     .             POSIX_GUARD(s2n_hash_set_impl(state));
     .         
     .             POSIX_ENSURE_REF(state->hash_impl->allow_md5_for_fips);
     .         
     .             return state->hash_impl->allow_md5_for_fips(state);
     .         }
     .         
     .         int s2n_hash_init(struct s2n_hash_state *state, s2n_hash_algorithm alg)
 1,860 (0.0%)  {
   372 (0.0%)      POSIX_ENSURE_REF(state);
     .             /* Ensure that hash_impl is set, as it may have been reset for s2n_hash_state on s2n_connection_wipe.
     .              * When in FIPS mode, the EVP API's must be used for hashes.
     .              */
   930 (0.0%)      POSIX_GUARD(s2n_hash_set_impl(state));
     .         
   186 (0.0%)      bool is_md5_allowed_for_fips = false;
 2,046 (0.0%)      POSIX_GUARD_RESULT(s2n_digest_is_md5_allowed_for_fips(&state->digest.high_level.evp, &is_md5_allowed_for_fips));
     .         
   930 (0.0%)      if (s2n_hash_is_available(alg) || ((alg == S2N_HASH_MD5 || alg == S2N_HASH_MD5_SHA1) && is_md5_allowed_for_fips)) {
     .                 /* s2n will continue to initialize an "unavailable" hash when s2n is in FIPS mode and
     .                  * FIPS is forcing the hash to be made available.
     .                  */
   930 (0.0%)          POSIX_ENSURE_REF(state->hash_impl->init);
     .         
 1,674 (0.0%)          return state->hash_impl->init(state, alg);
     .             } else {
     .                 POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
     .             }
 1,116 (0.0%)  }
     .         
     .         int s2n_hash_update(struct s2n_hash_state *state, const void *data, uint32_t size)
 2,352 (0.0%)  {
 4,410 (0.0%)      POSIX_PRECONDITION(s2n_hash_state_validate(state));
 1,168 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_PRECONDITION_VIOLATION);
 1,470 (0.0%)      POSIX_ENSURE_REF(state->hash_impl->update);
     .         
 2,646 (0.0%)      return state->hash_impl->update(state, data, size);
   882 (0.0%)  }
     .         
     .         int s2n_hash_digest(struct s2n_hash_state *state, void *out, uint32_t size)
   912 (0.0%)  {
 1,710 (0.0%)      POSIX_PRECONDITION(s2n_hash_state_validate(state));
   440 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(out, size), S2N_ERR_PRECONDITION_VIOLATION);
   570 (0.0%)      POSIX_ENSURE_REF(state->hash_impl->digest);
     .         
 1,026 (0.0%)      return state->hash_impl->digest(state, out, size);
   342 (0.0%)  }
     .         
     .         int s2n_hash_copy(struct s2n_hash_state *to, struct s2n_hash_state *from)
 1,106 (0.0%)  {
 2,370 (0.0%)      POSIX_PRECONDITION(s2n_hash_state_validate(to));
 2,370 (0.0%)      POSIX_PRECONDITION(s2n_hash_state_validate(from));
   790 (0.0%)      POSIX_ENSURE_REF(from->hash_impl->copy);
     .         
 1,264 (0.0%)      return from->hash_impl->copy(to, from);
   474 (0.0%)  }
     .         
     .         int s2n_hash_reset(struct s2n_hash_state *state)
    12 (0.0%)  {
     4 (0.0%)      POSIX_ENSURE_REF(state);
     .             /* Ensure that hash_impl is set, as it may have been reset for s2n_hash_state on s2n_connection_wipe.
     .              * When in FIPS mode, the EVP API's must be used for hashes.
     .              */
    10 (0.0%)      POSIX_GUARD(s2n_hash_set_impl(state));
     .         
    10 (0.0%)      POSIX_ENSURE_REF(state->hash_impl->reset);
     .         
    12 (0.0%)      return state->hash_impl->reset(state);
     6 (0.0%)  }
     .         
     .         int s2n_hash_free(struct s2n_hash_state *state)
   972 (0.0%)  {
   324 (0.0%)      if (state == NULL) {
     .                 return S2N_SUCCESS;
     .             }
     .             /* Ensure that hash_impl is set, as it may have been reset for s2n_hash_state on s2n_connection_wipe.
     .              * When in FIPS mode, the EVP API's must be used for hashes.
     .              */
   810 (0.0%)      POSIX_GUARD(s2n_hash_set_impl(state));
     .         
   810 (0.0%)      POSIX_ENSURE_REF(state->hash_impl->free);
     .         
   972 (0.0%)      return state->hash_impl->free(state);
   486 (0.0%)  }
     .         
     .         int s2n_hash_get_currently_in_hash_total(struct s2n_hash_state *state, uint64_t *out)
   672 (0.0%)  {
 1,440 (0.0%)      POSIX_PRECONDITION(s2n_hash_state_validate(state));
   192 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(out, sizeof(*out)), S2N_ERR_PRECONDITION_VIOLATION);
   384 (0.0%)      POSIX_ENSURE(state->is_ready_for_input, S2N_ERR_HASH_NOT_READY);
     .         
   384 (0.0%)      *out = state->currently_in_hash;
    96 (0.0%)      return S2N_SUCCESS;
   288 (0.0%)  }
     .         
     .         /* Calculate, in constant time, the number of bytes currently in the hash_block */
     .         int s2n_hash_const_time_get_currently_in_hash_block(struct s2n_hash_state *state, uint64_t *out)
     .         {
     .             POSIX_PRECONDITION(s2n_hash_state_validate(state));
     .             POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(out, sizeof(*out)), S2N_ERR_PRECONDITION_VIOLATION);
     .             POSIX_ENSURE(state->is_ready_for_input, S2N_ERR_HASH_NOT_READY);
     .             uint64_t hash_block_size = 0;
-- line 624 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 44 ----------------------------------------
     .             case S2N_HASH_MD5_SHA1:   /* Fall through ... */
     .             default:
     .                 POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
     .             }
     .             return S2N_SUCCESS;
     .         }
     .         
     .         int s2n_hmac_hash_alg(s2n_hmac_algorithm hmac_alg, s2n_hash_algorithm *out)
 1,792 (0.0%)  {
   512 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(out, sizeof(*out)), S2N_ERR_PRECONDITION_VIOLATION);
 2,560 (0.0%)      switch(hmac_alg) {
    39 (0.0%)      case S2N_HMAC_NONE:       *out = S2N_HASH_NONE;   break;
     .             case S2N_HMAC_MD5:        *out = S2N_HASH_MD5;    break;
     .             case S2N_HMAC_SHA1:       *out = S2N_HASH_SHA1;   break;
     .             case S2N_HMAC_SHA224:     *out = S2N_HASH_SHA224; break;
   729 (0.0%)      case S2N_HMAC_SHA256:     *out = S2N_HASH_SHA256; break;
     .             case S2N_HMAC_SHA384:     *out = S2N_HASH_SHA384; break;
     .             case S2N_HMAC_SHA512:     *out = S2N_HASH_SHA512; break;
     .             case S2N_HMAC_SSLv3_MD5:  *out = S2N_HASH_MD5;    break;
     .             case S2N_HMAC_SSLv3_SHA1: *out = S2N_HASH_SHA1;   break;
     .             default:
     .                 POSIX_BAIL(S2N_ERR_HMAC_INVALID_ALGORITHM);
     .             }
   256 (0.0%)      return S2N_SUCCESS;
   768 (0.0%)  }
     .         
     .         int s2n_hmac_digest_size(s2n_hmac_algorithm hmac_alg, uint8_t *out)
 1,773 (0.0%)  {
     .             s2n_hash_algorithm hash_alg;
 1,379 (0.0%)      POSIX_GUARD(s2n_hmac_hash_alg(hmac_alg, &hash_alg));
 1,379 (0.0%)      POSIX_GUARD(s2n_hash_digest_size(hash_alg, out));
   197 (0.0%)      return S2N_SUCCESS;
   985 (0.0%)  }
     .         
     .         /* Return 1 if hmac algorithm is available, 0 otherwise. */
     .         bool s2n_hmac_is_available(s2n_hmac_algorithm hmac_alg)
   230 (0.0%)  {
   368 (0.0%)      switch(hmac_alg) {
     .             case S2N_HMAC_MD5:
     .             case S2N_HMAC_SSLv3_MD5:
     .             case S2N_HMAC_SSLv3_SHA1:
     .                 /* Some libcryptos, such as OpenSSL, disable MD5 by default when in FIPS mode, which is
     .                  * required in order to negotiate SSLv3. However, this is supported in AWS-LC.
     .                  */
     .                 return !s2n_is_in_fips_mode() || s2n_libcrypto_is_awslc();
     .             case S2N_HMAC_NONE:
     .             case S2N_HMAC_SHA1:
     .             case S2N_HMAC_SHA224:
     .             case S2N_HMAC_SHA256:
     .             case S2N_HMAC_SHA384:
     .             case S2N_HMAC_SHA512:
    92 (0.0%)          return true;
     .             }
     .             return false;
    92 (0.0%)  }
     .         
     .         static int s2n_sslv3_mac_init(struct s2n_hmac_state *state, s2n_hmac_algorithm alg, const void *key, uint32_t klen)
     .         {
     .             for (int i = 0; i < state->xor_pad_size; i++) {
     .                 state->xor_pad[i] = 0x36;
     .             }
     .         
     .             POSIX_GUARD(s2n_hash_update(&state->inner_just_key, key, klen));
-- line 106 ----------------------------------------
-- line 112 ----------------------------------------
     .         
     .             POSIX_GUARD(s2n_hash_update(&state->outer_just_key, key, klen));
     .             POSIX_GUARD(s2n_hash_update(&state->outer_just_key, state->xor_pad, state->xor_pad_size));
     .         
     .             return S2N_SUCCESS;
     .         }
     .         
     .         static int s2n_tls_hmac_init(struct s2n_hmac_state *state, s2n_hmac_algorithm alg, const void *key, uint32_t klen)
   414 (0.0%)  {
   276 (0.0%)      memset(&state->xor_pad, 0, sizeof(state->xor_pad));
     .         
   230 (0.0%)      if (klen > state->xor_pad_size) {
     .                 POSIX_GUARD(s2n_hash_update(&state->outer, key, klen));
     .                 POSIX_GUARD(s2n_hash_digest(&state->outer, state->digest_pad, state->digest_size));
     .                 POSIX_CHECKED_MEMCPY(state->xor_pad, state->digest_pad, state->digest_size);
     .             } else {
   782 (0.0%)          POSIX_CHECKED_MEMCPY(state->xor_pad, key, klen);
     .             }
     .         
17,986 (0.2%)      for (int i = 0; i < state->xor_pad_size; i++) {
29,440 (0.3%)          state->xor_pad[i] ^= 0x36;
     .             }
     .         
   552 (0.0%)      POSIX_GUARD(s2n_hash_update(&state->inner_just_key, state->xor_pad, state->xor_pad_size));
     .         
     .             /* 0x36 xor 0x5c == 0x6a */
17,986 (0.2%)      for (int i = 0; i < state->xor_pad_size; i++) {
29,440 (0.3%)          state->xor_pad[i] ^= 0x6a;
     .             }
     .         
   552 (0.0%)      POSIX_GUARD(s2n_hash_update(&state->outer_just_key, state->xor_pad, state->xor_pad_size));
    46 (0.0%)      return S2N_SUCCESS;
   138 (0.0%)  }
     .         
     .         int s2n_hmac_xor_pad_size(s2n_hmac_algorithm hmac_alg, uint16_t *xor_pad_size)
   322 (0.0%)  {
    92 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(xor_pad_size, sizeof(*xor_pad_size)), S2N_ERR_PRECONDITION_VIOLATION);
   460 (0.0%)      switch(hmac_alg) {
     .             case S2N_HMAC_NONE:       *xor_pad_size = 64;   break;
     .             case S2N_HMAC_MD5:        *xor_pad_size = 64;   break;
     .             case S2N_HMAC_SHA1:       *xor_pad_size = 64;   break;
     .             case S2N_HMAC_SHA224:     *xor_pad_size = 64;   break;
   138 (0.0%)      case S2N_HMAC_SHA256:     *xor_pad_size = 64;   break;
     .             case S2N_HMAC_SHA384:     *xor_pad_size = 128;  break;
     .             case S2N_HMAC_SHA512:     *xor_pad_size = 128;  break;
     .             case S2N_HMAC_SSLv3_MD5:  *xor_pad_size = 48;   break;
     .             case S2N_HMAC_SSLv3_SHA1: *xor_pad_size = 40;   break;
     .             default:
     .                 POSIX_BAIL(S2N_ERR_HMAC_INVALID_ALGORITHM);
     .             }
    46 (0.0%)      return S2N_SUCCESS;
   138 (0.0%)  }
     .         
     .         int s2n_hmac_hash_block_size(s2n_hmac_algorithm hmac_alg, uint16_t *block_size)
   322 (0.0%)  {
    92 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(block_size, sizeof(*block_size)), S2N_ERR_PRECONDITION_VIOLATION);
   460 (0.0%)      switch(hmac_alg) {
     .             case S2N_HMAC_NONE:       *block_size = 64;   break;
     .             case S2N_HMAC_MD5:        *block_size = 64;   break;
     .             case S2N_HMAC_SHA1:       *block_size = 64;   break;
     .             case S2N_HMAC_SHA224:     *block_size = 64;   break;
   138 (0.0%)      case S2N_HMAC_SHA256:     *block_size = 64;   break;
     .             case S2N_HMAC_SHA384:     *block_size = 128;  break;
     .             case S2N_HMAC_SHA512:     *block_size = 128;  break;
     .             case S2N_HMAC_SSLv3_MD5:  *block_size = 64;   break;
     .             case S2N_HMAC_SSLv3_SHA1: *block_size = 64;   break;
     .             default:
     .                 POSIX_BAIL(S2N_ERR_HMAC_INVALID_ALGORITHM);
     .             }
    46 (0.0%)      return S2N_SUCCESS;
   138 (0.0%)  }
     .         
     .         int s2n_hmac_new(struct s2n_hmac_state *state)
   240 (0.0%)  {
    80 (0.0%)      POSIX_ENSURE_REF(state);
   240 (0.0%)      POSIX_GUARD(s2n_hash_new(&state->inner));
   240 (0.0%)      POSIX_GUARD(s2n_hash_new(&state->inner_just_key));
   240 (0.0%)      POSIX_GUARD(s2n_hash_new(&state->outer));
   240 (0.0%)      POSIX_GUARD(s2n_hash_new(&state->outer_just_key));
   600 (0.0%)      POSIX_POSTCONDITION(s2n_hmac_state_validate(state));
    40 (0.0%)      return S2N_SUCCESS;
   120 (0.0%)  }
     .         
     .         S2N_RESULT s2n_hmac_state_validate(struct s2n_hmac_state *state)
 1,680 (0.0%)  {
   560 (0.0%)      RESULT_ENSURE_REF(state);
 2,520 (0.0%)      RESULT_GUARD(s2n_hash_state_validate(&state->inner));
 2,520 (0.0%)      RESULT_GUARD(s2n_hash_state_validate(&state->inner_just_key));
 2,520 (0.0%)      RESULT_GUARD(s2n_hash_state_validate(&state->outer));
 2,520 (0.0%)      RESULT_GUARD(s2n_hash_state_validate(&state->outer_just_key));
   280 (0.0%)      return S2N_RESULT_OK;
   840 (0.0%)  }
     .         
     .         int s2n_hmac_init(struct s2n_hmac_state *state, s2n_hmac_algorithm alg, const void *key, uint32_t klen)
   552 (0.0%)  {
    92 (0.0%)      POSIX_ENSURE_REF(state);
   276 (0.0%)      if (!s2n_hmac_is_available(alg)) {
     .                 /* Prevent hmacs from being used if they are not available. */
     .                 POSIX_BAIL(S2N_ERR_HMAC_INVALID_ALGORITHM);
     .             }
     .         
   138 (0.0%)      state->alg = alg;
   368 (0.0%)      POSIX_GUARD(s2n_hmac_hash_block_size(alg, &state->hash_block_size));
    92 (0.0%)      state->currently_in_hash_block = 0;
   368 (0.0%)      POSIX_GUARD(s2n_hmac_xor_pad_size(alg, &state->xor_pad_size));
   368 (0.0%)      POSIX_GUARD(s2n_hmac_digest_size(alg, &state->digest_size));
     .         
   184 (0.0%)      POSIX_ENSURE_GTE(sizeof(state->xor_pad), state->xor_pad_size);
   184 (0.0%)      POSIX_ENSURE_GTE(sizeof(state->digest_pad), state->digest_size);
     .             /* key needs to be as large as the biggest block size */
   184 (0.0%)      POSIX_ENSURE_GTE(sizeof(state->xor_pad), state->hash_block_size);
     .         
     .             s2n_hash_algorithm hash_alg;
   322 (0.0%)      POSIX_GUARD(s2n_hmac_hash_alg(alg, &hash_alg));
     .         
   368 (0.0%)      POSIX_GUARD(s2n_hash_init(&state->inner, hash_alg));
   368 (0.0%)      POSIX_GUARD(s2n_hash_init(&state->inner_just_key, hash_alg));
   368 (0.0%)      POSIX_GUARD(s2n_hash_init(&state->outer, hash_alg));
   368 (0.0%)      POSIX_GUARD(s2n_hash_init(&state->outer_just_key, hash_alg));
     .         
   184 (0.0%)      if (alg == S2N_HMAC_SSLv3_SHA1 || alg == S2N_HMAC_SSLv3_MD5) {
     .                 POSIX_GUARD(s2n_sslv3_mac_init(state, alg, key, klen));
     .             } else {
   368 (0.0%)          POSIX_GUARD(s2n_tls_hmac_init(state, alg, key, klen));
     .             }
     .         
     .             /* Once we have produced inner_just_key and outer_just_key, don't need the key material in xor_pad, so wipe it.
     .              * Since xor_pad is used as a source of bytes in s2n_hmac_digest_two_compression_rounds,
     .              * this also prevents uninitilized bytes being used.
     .              */
   276 (0.0%)      memset(&state->xor_pad, 0, sizeof(state->xor_pad));
   230 (0.0%)      POSIX_GUARD(s2n_hmac_reset(state));
     .         
    46 (0.0%)      return S2N_SUCCESS;
   276 (0.0%)  }
     .         
     .         int s2n_hmac_update(struct s2n_hmac_state *state, const void *in, uint32_t size)
   752 (0.0%)  {
 1,410 (0.0%)      POSIX_PRECONDITION(s2n_hmac_state_validate(state));
   376 (0.0%)      POSIX_ENSURE(state->hash_block_size != 0, S2N_ERR_PRECONDITION_VIOLATION);
     .             /* Keep track of how much of the current hash block is full
     .              *
     .              * Why the 4294949760 constant in this code? 4294949760 is the highest 32-bit
     .              * value that is congruent to 0 modulo all of our HMAC block sizes, that is also
     .              * at least 16k smaller than 2^32. It therefore has no effect on the mathematical
     .              * result, and no valid record size can cause it to overflow.
     .              *
     .              * The value was found with the following python code;
-- line 259 ----------------------------------------
-- line 265 ----------------------------------------
     .              *   x -= 1
     .              * print x
     .              *
     .              * What it does do however is ensure that the mod operation takes a
     .              * constant number of instruction cycles, regardless of the size of the
     .              * input. On some platforms, including Intel, the operation can take a
     .              * smaller number of cycles if the input is "small".
     .              */
    94 (0.0%)      const uint32_t HIGHEST_32_BIT = 4294949760;
   376 (0.0%)      POSIX_ENSURE(size <= (UINT32_MAX - HIGHEST_32_BIT), S2N_ERR_INTEGER_OVERFLOW);
   940 (0.0%)      uint32_t value = (HIGHEST_32_BIT + size) % state->hash_block_size;
   940 (0.0%)      POSIX_GUARD(s2n_add_overflow(state->currently_in_hash_block, value, &state->currently_in_hash_block));
 1,034 (0.0%)      state->currently_in_hash_block %= state->hash_block_size;
     .         
   658 (0.0%)      return s2n_hash_update(&state->inner, in, size);
   282 (0.0%)  }
     .         
     .         int s2n_hmac_digest(struct s2n_hmac_state *state, void *out, uint32_t size)
   350 (0.0%)  {
   750 (0.0%)      POSIX_PRECONDITION(s2n_hmac_state_validate(state));
   600 (0.0%)      POSIX_GUARD(s2n_hash_digest(&state->inner, state->digest_pad, state->digest_size));
   450 (0.0%)      POSIX_GUARD(s2n_hash_copy(&state->outer, &state->outer_just_key));
   600 (0.0%)      POSIX_GUARD(s2n_hash_update(&state->outer, state->digest_pad, state->digest_size));
     .         
   350 (0.0%)      return s2n_hash_digest(&state->outer, out, size);
   100 (0.0%)  }
     .         
     .         int s2n_hmac_digest_two_compression_rounds(struct s2n_hmac_state *state, void *out, uint32_t size)
     .         {
     .             /* Do the "real" work of this function. */
     .             POSIX_GUARD(s2n_hmac_digest(state, out, size));
     .         
     .             /* If there were 9 or more bytes of space left in the current hash block
     .              * then the serialized length, plus an 0x80 byte, will have fit in that block.
-- line 298 ----------------------------------------
-- line 310 ----------------------------------------
     .             /* Can't reuse a hash after it has been finalized, so reset and push another block in */
     .             POSIX_GUARD(s2n_hash_reset(&state->inner));
     .         
     .             /* No-op s2n_hash_update to normalize timing and guard against Lucky13. This does not affect the value of *out. */
     .             return s2n_hash_update(&state->inner, state->xor_pad, state->hash_block_size);
     .         }
     .         
     .         int s2n_hmac_free(struct s2n_hmac_state *state)
   200 (0.0%)  {
    80 (0.0%)      if (state) {
   240 (0.0%)          POSIX_GUARD(s2n_hash_free(&state->inner));
   240 (0.0%)          POSIX_GUARD(s2n_hash_free(&state->inner_just_key));
   240 (0.0%)          POSIX_GUARD(s2n_hash_free(&state->outer));
   240 (0.0%)          POSIX_GUARD(s2n_hash_free(&state->outer_just_key));
     .             }
     .         
    40 (0.0%)      return S2N_SUCCESS;
    80 (0.0%)  }
     .         
     .         int s2n_hmac_reset(struct s2n_hmac_state *state)
   864 (0.0%)  {
 1,440 (0.0%)      POSIX_PRECONDITION(s2n_hmac_state_validate(state));
   384 (0.0%)      POSIX_ENSURE(state->hash_block_size != 0, S2N_ERR_PRECONDITION_VIOLATION);
   864 (0.0%)      POSIX_GUARD(s2n_hash_copy(&state->inner, &state->inner_just_key));
     .         
    96 (0.0%)      uint64_t bytes_in_hash = 0;
   768 (0.0%)      POSIX_GUARD(s2n_hash_get_currently_in_hash_total(&state->inner, &bytes_in_hash));
   864 (0.0%)      bytes_in_hash %= state->hash_block_size;
   384 (0.0%)      POSIX_ENSURE(bytes_in_hash <= UINT32_MAX, S2N_ERR_INTEGER_OVERFLOW);
     .             /* The length of the key is not private, so don't need to do tricky math here */
   384 (0.0%)      state->currently_in_hash_block = bytes_in_hash;
    96 (0.0%)      return S2N_SUCCESS;
   576 (0.0%)  }
     .         
     .         int s2n_hmac_digest_verify(const void *a, const void *b, uint32_t len)
    28 (0.0%)  {
    36 (0.0%)      return S2N_SUCCESS - !s2n_constant_time_equals(a, b, len);
     8 (0.0%)  }
     .         
     .         int s2n_hmac_copy(struct s2n_hmac_state *to, struct s2n_hmac_state *from)
     .         {
     .             POSIX_PRECONDITION(s2n_hmac_state_validate(to));
     .             POSIX_PRECONDITION(s2n_hmac_state_validate(from));
     .             /* memcpy cannot be used on s2n_hmac_state as the underlying s2n_hash implementation's
     .              * copy must be used. This is enforced when the s2n_hash implementation is s2n_evp_hash.
     .              */
-- line 355 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 18 ----------------------------------------
     .         #include <sys/param.h>
     .         
     .         #include "error/s2n_errno.h"
     .         #include "utils/s2n_blob.h"
     .         #include "utils/s2n_mem.h"
     .         #include "utils/s2n_safety.h"
     .         
     .         S2N_RESULT s2n_stuffer_validate(const struct s2n_stuffer *stuffer)
23,970 (0.2%)  {
     .             /**
     .              * Note that we do not assert any properties on the tainted field,
     .              * as any boolean value in that field is valid.
     .              */
 7,990 (0.1%)      RESULT_ENSURE_REF(stuffer);
31,960 (0.3%)      RESULT_GUARD(s2n_blob_validate(&stuffer->blob));
43,384 (0.4%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(stuffer->growable, stuffer->alloced), S2N_ERR_SAFETY);
     .         
     .             /* <= is valid because we can have a fully written/read stuffer */
35,955 (0.3%)      RESULT_DEBUG_ENSURE(stuffer->high_water_mark <= stuffer->blob.size, S2N_ERR_SAFETY);
35,955 (0.3%)      RESULT_DEBUG_ENSURE(stuffer->write_cursor <= stuffer->high_water_mark, S2N_ERR_SAFETY);
35,955 (0.3%)      RESULT_DEBUG_ENSURE(stuffer->read_cursor <= stuffer->write_cursor, S2N_ERR_SAFETY);
 3,995 (0.0%)      return S2N_RESULT_OK;
11,985 (0.1%)  }
     .         
     .         S2N_RESULT s2n_stuffer_reservation_validate(const struct s2n_stuffer_reservation *reservation)
   306 (0.0%)  {
     .             /**
     .              * Note that we need two dereferences here to decrease proof complexity
     .              * for CBMC (see https://github.com/awslabs/s2n/issues/2290). We can roll back
     .              * this change once CBMC can handle common subexpression elimination.
     .              */
   102 (0.0%)      RESULT_ENSURE_REF(reservation);
   255 (0.0%)      const struct s2n_stuffer_reservation reserve_obj = *reservation;
   408 (0.0%)      RESULT_GUARD(s2n_stuffer_validate(reserve_obj.stuffer));
   561 (0.0%)      const struct s2n_stuffer stuffer_obj = *(reserve_obj.stuffer);
     .         
     .             /* Verify that write_cursor + length can be represented as a uint32_t without overflow */
   306 (0.0%)      RESULT_ENSURE_LTE(reserve_obj.write_cursor, UINT32_MAX - reserve_obj.length);
     .             /* The entire reservation must fit between the stuffer read and write cursors */
   357 (0.0%)      RESULT_ENSURE_LTE(reserve_obj.write_cursor + reserve_obj.length, stuffer_obj.write_cursor);
   204 (0.0%)      RESULT_ENSURE_GTE(reserve_obj.write_cursor, stuffer_obj.read_cursor);
     .         
    51 (0.0%)      return S2N_RESULT_OK;
   153 (0.0%)  }
     .         
     .         int s2n_stuffer_init(struct s2n_stuffer *stuffer, struct s2n_blob *in)
   560 (0.0%)  {
   160 (0.0%)      POSIX_ENSURE_MUT(stuffer);
 1,200 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(in));
   640 (0.0%)      stuffer->blob = *in;
   160 (0.0%)      stuffer->read_cursor = 0;
   160 (0.0%)      stuffer->write_cursor = 0;
   160 (0.0%)      stuffer->high_water_mark = 0;
   320 (0.0%)      stuffer->alloced = 0;
   320 (0.0%)      stuffer->growable = 0;
   320 (0.0%)      stuffer->tainted = 0;
 1,200 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    80 (0.0%)      return S2N_SUCCESS;
   240 (0.0%)  }
     .         
     .         int s2n_stuffer_init_written(struct s2n_stuffer *stuffer, struct s2n_blob *in)
     7 (0.0%)  {
     2 (0.0%)      POSIX_ENSURE_REF(in);
     7 (0.0%)      POSIX_GUARD(s2n_stuffer_init(stuffer, in));
     8 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(stuffer, in->size));
     1 (0.0%)      return S2N_SUCCESS;
     3 (0.0%)  }
     .         
     .         int s2n_stuffer_alloc(struct s2n_stuffer *stuffer, const uint32_t size)
    28 (0.0%)  {
     8 (0.0%)      POSIX_ENSURE_REF(stuffer);
    20 (0.0%)      *stuffer = (struct s2n_stuffer){ 0 };
    28 (0.0%)      POSIX_GUARD(s2n_alloc(&stuffer->blob, size));
    28 (0.0%)      POSIX_GUARD(s2n_stuffer_init(stuffer, &stuffer->blob));
     .         
    16 (0.0%)      stuffer->alloced = 1;
     .         
    60 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     4 (0.0%)      return S2N_SUCCESS;
    12 (0.0%)  }
     .         
     .         int s2n_stuffer_growable_alloc(struct s2n_stuffer *stuffer, const uint32_t size)
    12 (0.0%)  {
    14 (0.0%)      POSIX_GUARD(s2n_stuffer_alloc(stuffer, size));
     .         
     8 (0.0%)      stuffer->growable = 1;
     .         
    30 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     2 (0.0%)      return S2N_SUCCESS;
     4 (0.0%)  }
     .         
     .         int s2n_stuffer_free(struct s2n_stuffer *stuffer)
   110 (0.0%)  {
   330 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
   110 (0.0%)      if (stuffer->alloced) {
    20 (0.0%)          POSIX_GUARD(s2n_free(&stuffer->blob));
     .             }
   110 (0.0%)      *stuffer = (struct s2n_stuffer){ 0 };
    22 (0.0%)      return S2N_SUCCESS;
    44 (0.0%)  }
     .         
     .         int s2n_stuffer_free_without_wipe(struct s2n_stuffer *stuffer)
     .         {
     .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
     .             if (stuffer->alloced) {
     .                 POSIX_GUARD(s2n_free_without_wipe(&stuffer->blob));
     .             }
     .             *stuffer = (struct s2n_stuffer){ 0 };
     .             return S2N_SUCCESS;
     .         }
     .         
     .         int s2n_stuffer_resize(struct s2n_stuffer *stuffer, const uint32_t size)
    28 (0.0%)  {
    60 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    20 (0.0%)      POSIX_ENSURE(!stuffer->tainted, S2N_ERR_RESIZE_TAINTED_STUFFER);
    20 (0.0%)      POSIX_ENSURE(stuffer->growable, S2N_ERR_RESIZE_STATIC_STUFFER);
     .         
    16 (0.0%)      if (size == stuffer->blob.size) {
     4 (0.0%)          return S2N_SUCCESS;
     .             }
     .         
     4 (0.0%)      if (size == 0) {
     6 (0.0%)          s2n_stuffer_wipe(stuffer);
     8 (0.0%)          return s2n_free(&stuffer->blob);
     .             }
     .         
     .             if (size < stuffer->blob.size) {
     .                 POSIX_CHECKED_MEMSET(stuffer->blob.data + size, S2N_WIPE_PATTERN, (stuffer->blob.size - size));
     .                 if (stuffer->read_cursor > size) {
     .                     stuffer->read_cursor = size;
     .                 }
     .                 if (stuffer->write_cursor > size) {
-- line 149 ----------------------------------------
-- line 155 ----------------------------------------
     .                 stuffer->blob.size = size;
     .                 POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     .                 return S2N_SUCCESS;
     .             }
     .         
     .             POSIX_GUARD(s2n_realloc(&stuffer->blob, size));
     .             POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     .             return S2N_SUCCESS;
    12 (0.0%)  }
     .         
     .         int s2n_stuffer_resize_if_empty(struct s2n_stuffer *stuffer, const uint32_t size)
   140 (0.0%)  {
   300 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    80 (0.0%)      if (stuffer->blob.data == NULL) {
    10 (0.0%)          POSIX_ENSURE(!stuffer->tainted, S2N_ERR_RESIZE_TAINTED_STUFFER);
    10 (0.0%)          POSIX_ENSURE(stuffer->growable, S2N_ERR_RESIZE_STATIC_STUFFER);
    14 (0.0%)          POSIX_GUARD(s2n_realloc(&stuffer->blob, size));
     .             }
   300 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    20 (0.0%)      return S2N_SUCCESS;
    60 (0.0%)  }
     .         
     .         int s2n_stuffer_rewrite(struct s2n_stuffer *stuffer)
   270 (0.0%)  {
   810 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
   108 (0.0%)      stuffer->write_cursor = 0;
   108 (0.0%)      stuffer->read_cursor = 0;
   810 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    54 (0.0%)      return S2N_SUCCESS;
   108 (0.0%)  }
     .         
     .         int s2n_stuffer_rewind_read(struct s2n_stuffer *stuffer, const uint32_t size)
   161 (0.0%)  {
   345 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    92 (0.0%)      POSIX_ENSURE(stuffer->read_cursor >= size, S2N_ERR_STUFFER_OUT_OF_DATA);
   138 (0.0%)      stuffer->read_cursor -= size;
   345 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    23 (0.0%)      return S2N_SUCCESS;
    69 (0.0%)  }
     .         
     .         int s2n_stuffer_reread(struct s2n_stuffer *stuffer)
   330 (0.0%)  {
   990 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
   132 (0.0%)      stuffer->read_cursor = 0;
    66 (0.0%)      return S2N_SUCCESS;
   132 (0.0%)  }
     .         
     .         int s2n_stuffer_wipe_n(struct s2n_stuffer *stuffer, const uint32_t size)
    98 (0.0%)  {
   210 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    84 (0.0%)      uint32_t wipe_size = MIN(size, stuffer->write_cursor);
     .         
    84 (0.0%)      stuffer->write_cursor -= wipe_size;
   112 (0.0%)      stuffer->read_cursor = MIN(stuffer->read_cursor, stuffer->write_cursor);
   238 (0.0%)      POSIX_CHECKED_MEMSET(stuffer->blob.data + stuffer->write_cursor, S2N_WIPE_PATTERN, wipe_size);
     .         
   210 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    14 (0.0%)      return S2N_SUCCESS;
    42 (0.0%)  }
     .         
     .         bool s2n_stuffer_is_consumed(struct s2n_stuffer *stuffer)
    36 (0.0%)  {
   144 (0.0%)      return stuffer && (stuffer->read_cursor == stuffer->write_cursor) && !stuffer->tainted;
    18 (0.0%)  }
     .         
     .         int s2n_stuffer_wipe(struct s2n_stuffer *stuffer)
   294 (0.0%)  {
   735 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
   196 (0.0%)      if (!s2n_stuffer_is_wiped(stuffer)) {
   810 (0.0%)          POSIX_CHECKED_MEMSET(stuffer->blob.data, S2N_WIPE_PATTERN, stuffer->high_water_mark);
     .             }
     .         
   196 (0.0%)      stuffer->tainted = 0;
    98 (0.0%)      stuffer->write_cursor = 0;
    98 (0.0%)      stuffer->read_cursor = 0;
    98 (0.0%)      stuffer->high_water_mark = 0;
   735 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    49 (0.0%)      return S2N_SUCCESS;
   147 (0.0%)  }
     .         
     .         int s2n_stuffer_skip_read(struct s2n_stuffer *stuffer, uint32_t n)
 1,862 (0.0%)  {
 3,990 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 1,862 (0.0%)      POSIX_ENSURE(s2n_stuffer_data_available(stuffer) >= n, S2N_ERR_STUFFER_OUT_OF_DATA);
     .         
 1,596 (0.0%)      stuffer->read_cursor += n;
   266 (0.0%)      return S2N_SUCCESS;
   798 (0.0%)  }
     .         
     .         void *s2n_stuffer_raw_read(struct s2n_stuffer *stuffer, uint32_t data_len)
   420 (0.0%)  {
   490 (0.0%)      PTR_GUARD_POSIX(s2n_stuffer_skip_read(stuffer, data_len));
     .         
   280 (0.0%)      stuffer->tainted = 1;
     .         
   910 (0.0%)      return (stuffer->blob.data) ? (stuffer->blob.data + stuffer->read_cursor - data_len) : NULL;
   140 (0.0%)  }
     .         
     .         int s2n_stuffer_read(struct s2n_stuffer *stuffer, struct s2n_blob *out)
     7 (0.0%)  {
     2 (0.0%)      POSIX_ENSURE_REF(out);
     .         
     8 (0.0%)      return s2n_stuffer_read_bytes(stuffer, out->data, out->size);
     3 (0.0%)  }
     .         
     .         int s2n_stuffer_erase_and_read(struct s2n_stuffer *stuffer, struct s2n_blob *out)
     .         {
     .             POSIX_GUARD(s2n_stuffer_skip_read(stuffer, out->size));
     .         
     .             void *ptr = (stuffer->blob.data) ? (stuffer->blob.data + stuffer->read_cursor - out->size) : NULL;
     .             POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, out->size), S2N_ERR_NULL);
     .         
     .             POSIX_CHECKED_MEMCPY(out->data, ptr, out->size);
     .             POSIX_CHECKED_MEMSET(ptr, 0, out->size);
     .         
     .             return S2N_SUCCESS;
     .         }
     .         
     .         int s2n_stuffer_read_bytes(struct s2n_stuffer *stuffer, uint8_t *data, uint32_t size)
 1,120 (0.0%)  {
   280 (0.0%)      POSIX_ENSURE_REF(data);
 2,100 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
   980 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_read(stuffer, size));
   560 (0.0%)      POSIX_ENSURE_REF(stuffer->blob.data);
 1,260 (0.0%)      void *ptr = stuffer->blob.data + stuffer->read_cursor - size;
     .         
 2,240 (0.0%)      POSIX_CHECKED_MEMCPY(data, ptr, size);
     .         
   140 (0.0%)      return S2N_SUCCESS;
   420 (0.0%)  }
     .         
     .         int s2n_stuffer_erase_and_read_bytes(struct s2n_stuffer *stuffer, uint8_t *data, uint32_t size)
     8 (0.0%)  {
     7 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_read(stuffer, size));
     4 (0.0%)      POSIX_ENSURE_REF(stuffer->blob.data);
     9 (0.0%)      void *ptr = stuffer->blob.data + stuffer->read_cursor - size;
     .         
    16 (0.0%)      POSIX_CHECKED_MEMCPY(data, ptr, size);
    16 (0.0%)      POSIX_CHECKED_MEMSET(ptr, 0, size);
     .         
     1 (0.0%)      return S2N_SUCCESS;
     3 (0.0%)  }
     .         
     .         int s2n_stuffer_skip_write(struct s2n_stuffer *stuffer, const uint32_t n)
 3,258 (0.0%)  {
 8,145 (0.1%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 3,801 (0.0%)      POSIX_GUARD(s2n_stuffer_reserve_space(stuffer, n));
 3,258 (0.0%)      stuffer->write_cursor += n;
 4,344 (0.0%)      stuffer->high_water_mark = MAX(stuffer->write_cursor, stuffer->high_water_mark);
 8,145 (0.1%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
   543 (0.0%)      return S2N_SUCCESS;
 1,086 (0.0%)  }
     .         
     .         void *s2n_stuffer_raw_write(struct s2n_stuffer *stuffer, const uint32_t data_len)
   126 (0.0%)  {
   147 (0.0%)      PTR_GUARD_POSIX(s2n_stuffer_skip_write(stuffer, data_len));
     .         
    84 (0.0%)      stuffer->tainted = 1;
     .         
   273 (0.0%)      return (stuffer->blob.data) ? (stuffer->blob.data + stuffer->write_cursor - data_len) : NULL;
    42 (0.0%)  }
     .         
     .         int s2n_stuffer_write(struct s2n_stuffer *stuffer, const struct s2n_blob *in)
   462 (0.0%)  {
 1,155 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 1,155 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(in));
   616 (0.0%)      return s2n_stuffer_write_bytes(stuffer, in->data, in->size);
   154 (0.0%)  }
     .         
     .         int s2n_stuffer_write_bytes(struct s2n_stuffer *stuffer, const uint8_t *data, const uint32_t size)
 2,336 (0.0%)  {
 1,128 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_SAFETY);
 4,380 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 2,044 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(stuffer, size));
     .         
 2,628 (0.0%)      void *ptr = stuffer->blob.data + stuffer->write_cursor - size;
 1,128 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, size), S2N_ERR_NULL);
     .         
   876 (0.0%)      if (ptr == data) {
    30 (0.0%)          POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     4 (0.0%)          return S2N_SUCCESS;
     .             }
     .         
 4,460 (0.0%)      POSIX_CHECKED_MEMCPY(ptr, data, size);
     .         
 4,350 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
   290 (0.0%)      return S2N_SUCCESS;
   876 (0.0%)  }
     .         
     .         int s2n_stuffer_writev_bytes(struct s2n_stuffer *stuffer, const struct iovec *iov, size_t iov_count, uint32_t offs,
     .                 uint32_t size)
    90 (0.0%)  {
   135 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    18 (0.0%)      POSIX_ENSURE_REF(iov);
    54 (0.0%)      void *ptr = s2n_stuffer_raw_write(stuffer, size);
    36 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, size), S2N_ERR_NULL);
     .         
    36 (0.0%)      size_t size_left = size, to_skip = offs;
    45 (0.0%)      for (size_t i = 0; i < iov_count; i++) {
    72 (0.0%)          if (to_skip >= iov[i].iov_len) {
     .                     to_skip -= iov[i].iov_len;
     .                     continue;
     .                 }
    72 (0.0%)          size_t iov_len_op = iov[i].iov_len - to_skip;
    27 (0.0%)          POSIX_ENSURE_LTE(iov_len_op, UINT32_MAX);
    18 (0.0%)          uint32_t iov_len = (uint32_t) iov_len_op;
    45 (0.0%)          uint32_t iov_size_to_take = MIN(size_left, iov_len);
    72 (0.0%)          POSIX_ENSURE_REF(iov[i].iov_base);
    72 (0.0%)          POSIX_ENSURE_LT(to_skip, iov[i].iov_len);
   207 (0.0%)          POSIX_CHECKED_MEMCPY(ptr, ((uint8_t *) (iov[i].iov_base)) + to_skip, iov_size_to_take);
    18 (0.0%)          size_left -= iov_size_to_take;
    18 (0.0%)          if (size_left == 0) {
     9 (0.0%)              break;
     .                 }
     .                 ptr = (void *) ((uint8_t *) ptr + iov_size_to_take);
     .                 to_skip = 0;
     .             }
     .         
     9 (0.0%)      return S2N_SUCCESS;
    27 (0.0%)  }
     .         
     .         static int s2n_stuffer_copy_impl(struct s2n_stuffer *from, struct s2n_stuffer *to, const uint32_t len)
   216 (0.0%)  {
   189 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_read(from, len));
   189 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(to, len));
     .         
   378 (0.0%)      uint8_t *from_ptr = (from->blob.data) ? (from->blob.data + from->read_cursor - len) : NULL;
   378 (0.0%)      uint8_t *to_ptr = (to->blob.data) ? (to->blob.data + to->write_cursor - len) : NULL;
     .         
   414 (0.0%)      POSIX_CHECKED_MEMCPY(to_ptr, from_ptr, len);
     .         
    27 (0.0%)      return S2N_SUCCESS;
    81 (0.0%)  }
     .         
     .         int s2n_stuffer_reserve_space(struct s2n_stuffer *stuffer, uint32_t n)
 5,630 (0.1%)  {
 8,445 (0.1%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 3,941 (0.0%)      if (s2n_stuffer_space_remaining(stuffer) < n) {
     .                 POSIX_ENSURE(stuffer->growable, S2N_ERR_STUFFER_IS_FULL);
     .                 /* Always grow a stuffer by at least 1k */
     .                 const uint32_t growth = MAX(n - s2n_stuffer_space_remaining(stuffer), S2N_MIN_STUFFER_GROWTH_IN_BYTES);
     .                 uint32_t new_size = 0;
     .                 POSIX_GUARD(s2n_add_overflow(stuffer->blob.size, growth, &new_size));
     .                 POSIX_GUARD(s2n_stuffer_resize(stuffer, new_size));
     .             }
 8,445 (0.1%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
   563 (0.0%)      return S2N_SUCCESS;
 3,378 (0.0%)  }
     .         
     .         /* Copies "len" bytes from "from" to "to".
     .          * If the copy cannot succeed (i.e. there are either not enough bytes available, or there is not enough space to write them
     .          * restore the old value of the stuffer */
     .         int s2n_stuffer_copy(struct s2n_stuffer *from, struct s2n_stuffer *to, const uint32_t len)
   189 (0.0%)  {
    81 (0.0%)      const uint32_t orig_read_cursor = from->read_cursor;
    81 (0.0%)      const uint32_t orig_write_cursor = to->write_cursor;
     .         
   216 (0.0%)      if (s2n_stuffer_copy_impl(from, to, len) < 0) {
     .                 from->read_cursor = orig_read_cursor;
     .                 to->write_cursor = orig_write_cursor;
     .                 S2N_ERROR_PRESERVE_ERRNO();
     .             }
     .         
    27 (0.0%)      return S2N_SUCCESS;
    54 (0.0%)  }
     .         
     .         int s2n_stuffer_extract_blob(struct s2n_stuffer *stuffer, struct s2n_blob *out)
     .         {
     .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
     .             POSIX_ENSURE_REF(out);
     .             POSIX_GUARD(s2n_realloc(out, s2n_stuffer_data_available(stuffer)));
     .         
     .             if (s2n_stuffer_data_available(stuffer) > 0) {
-- line 427 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_network_order.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 15 ----------------------------------------
    .         
    .         #include "error/s2n_errno.h"
    .         #include "stuffer/s2n_stuffer.h"
    .         #include "utils/s2n_annotations.h"
    .         #include "utils/s2n_safety.h"
    .         
    .         /* Writes length bytes of input to stuffer, in network order, starting from the smallest byte of input. */
    .         int s2n_stuffer_write_network_order(struct s2n_stuffer *stuffer, const uint64_t input, const uint8_t length)
  963 (0.0%)  {
  214 (0.0%)      if (length == 0) {
    .                 return S2N_SUCCESS;
    .             }
  214 (0.0%)      POSIX_ENSURE_REF(stuffer);
  214 (0.0%)      POSIX_ENSURE(length <= sizeof(input), S2N_ERR_SAFETY);
  749 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(stuffer, length));
  428 (0.0%)      POSIX_ENSURE_REF(stuffer->blob.data);
  963 (0.0%)      uint8_t *data = stuffer->blob.data + stuffer->write_cursor - length;
1,455 (0.0%)      for (int i = 0; i < length; i++) {
    .                 S2N_INVARIANT(i <= length);
1,150 (0.0%)          uint8_t shift = (length - i - 1) * CHAR_BIT;
2,530 (0.0%)          data[i] = (input >> (shift)) & UINT8_MAX;
    .             }
1,605 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  107 (0.0%)      return S2N_SUCCESS;
  321 (0.0%)  }
    .         
    .         int s2n_stuffer_reserve(struct s2n_stuffer *stuffer, struct s2n_stuffer_reservation *reservation, const uint8_t length)
  153 (0.0%)  {
  255 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
   34 (0.0%)      POSIX_ENSURE_REF(reservation);
    .         
  136 (0.0%)      *reservation = (struct s2n_stuffer_reservation){ .stuffer = stuffer,
   34 (0.0%)          .write_cursor = stuffer->write_cursor,
    .                 .length = length };
    .         
  153 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(stuffer, reservation->length));
  374 (0.0%)      POSIX_CHECKED_MEMSET(stuffer->blob.data + reservation->write_cursor, S2N_WIPE_PATTERN, reservation->length);
  255 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_reservation_validate(reservation));
   17 (0.0%)      return S2N_SUCCESS;
   51 (0.0%)  }
    .         
    .         int s2n_stuffer_read_uint8(struct s2n_stuffer *stuffer, uint8_t *u)
  228 (0.0%)  {
  304 (0.0%)      POSIX_GUARD(s2n_stuffer_read_bytes(stuffer, u, sizeof(uint8_t)));
    .         
   38 (0.0%)      return S2N_SUCCESS;
   76 (0.0%)  }
    .         
    .         int s2n_stuffer_write_uint8(struct s2n_stuffer *stuffer, const uint8_t u)
  770 (0.0%)  {
  880 (0.0%)      POSIX_GUARD(s2n_stuffer_write_bytes(stuffer, &u, sizeof(u)));
    .         
  110 (0.0%)      return S2N_SUCCESS;
  220 (0.0%)  }
    .         
    .         int s2n_stuffer_reserve_uint8(struct s2n_stuffer *stuffer, struct s2n_stuffer_reservation *reservation)
    .         {
    .             return s2n_stuffer_reserve(stuffer, reservation, sizeof(uint8_t));
    .         }
    .         
    .         int s2n_stuffer_read_uint16(struct s2n_stuffer *stuffer, uint16_t *u)
  650 (0.0%)  {
  130 (0.0%)      POSIX_ENSURE_REF(u);
    .             uint8_t data[sizeof(uint16_t)];
    .         
  520 (0.0%)      POSIX_GUARD(s2n_stuffer_read_bytes(stuffer, data, sizeof(data)));
    .         
  390 (0.0%)      *u = data[0] << 8;
  455 (0.0%)      *u |= data[1];
    .         
   65 (0.0%)      return S2N_SUCCESS;
  390 (0.0%)  }
    .         
    .         int s2n_stuffer_write_uint16(struct s2n_stuffer *stuffer, const uint16_t u)
  525 (0.0%)  {
  450 (0.0%)      return s2n_stuffer_write_network_order(stuffer, u, sizeof(u));
  150 (0.0%)  }
    .         
    .         int s2n_stuffer_reserve_uint16(struct s2n_stuffer *stuffer, struct s2n_stuffer_reservation *reservation)
   96 (0.0%)  {
   96 (0.0%)      return s2n_stuffer_reserve(stuffer, reservation, sizeof(uint16_t));
   32 (0.0%)  }
    .         
    .         int s2n_stuffer_read_uint24(struct s2n_stuffer *stuffer, uint32_t *u)
  100 (0.0%)  {
   20 (0.0%)      POSIX_ENSURE_REF(u);
    .             uint8_t data[SIZEOF_UINT24];
    .         
   80 (0.0%)      POSIX_GUARD(s2n_stuffer_read_bytes(stuffer, data, sizeof(data)));
    .         
   60 (0.0%)      *u = data[0] << 16;
   80 (0.0%)      *u |= data[1] << 8;
   70 (0.0%)      *u |= data[2];
    .         
   10 (0.0%)      return S2N_SUCCESS;
   60 (0.0%)  }
    .         
    .         int s2n_stuffer_write_uint24(struct s2n_stuffer *stuffer, const uint32_t u)
   90 (0.0%)  {
   90 (0.0%)      return s2n_stuffer_write_network_order(stuffer, u, SIZEOF_UINT24);
   30 (0.0%)  }
    .         
    .         int s2n_stuffer_reserve_uint24(struct s2n_stuffer *stuffer, struct s2n_stuffer_reservation *reservation)
    6 (0.0%)  {
    6 (0.0%)      return s2n_stuffer_reserve(stuffer, reservation, SIZEOF_UINT24);
    2 (0.0%)  }
    .         
    .         int s2n_stuffer_read_uint32(struct s2n_stuffer *stuffer, uint32_t *u)
    .         {
    .             POSIX_ENSURE_REF(u);
    .             uint8_t data[sizeof(uint32_t)];
    .         
    .             POSIX_GUARD(s2n_stuffer_read_bytes(stuffer, data, sizeof(data)));
    .         
-- line 128 ----------------------------------------
-- line 159 ----------------------------------------
    .         }
    .         
    .         int s2n_stuffer_write_uint64(struct s2n_stuffer *stuffer, const uint64_t u)
    .         {
    .             return s2n_stuffer_write_network_order(stuffer, u, sizeof(u));
    .         }
    .         
    .         static int length_matches_value_check(uint32_t value, uint8_t length)
  136 (0.0%)  {
    .             /* Value is represented as a uint32_t, so shouldn't be assumed larger */
   34 (0.0%)      POSIX_ENSURE(length <= sizeof(uint32_t), S2N_ERR_SIZE_MISMATCH);
    .         
   34 (0.0%)      if (length < sizeof(uint32_t)) {
    .                 /* Value should be less than the maximum for its length */
  119 (0.0%)          const uint32_t size_max = 1 << (length * 8);
   51 (0.0%)          POSIX_ENSURE(value < size_max, S2N_ERR_SIZE_MISMATCH);
    .             }
    .         
   17 (0.0%)      return S2N_SUCCESS;
   51 (0.0%)  }
    .         
    .         static int s2n_stuffer_write_reservation_impl(struct s2n_stuffer_reservation *reservation, const uint32_t u)
  102 (0.0%)  {
   85 (0.0%)      reservation->stuffer->write_cursor = reservation->write_cursor;
  272 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(reservation->stuffer));
    .         
  153 (0.0%)      POSIX_GUARD(length_matches_value_check(u, reservation->length));
  187 (0.0%)      POSIX_GUARD(s2n_stuffer_write_network_order(reservation->stuffer, u, reservation->length));
  272 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(reservation->stuffer));
   17 (0.0%)      return S2N_SUCCESS;
   34 (0.0%)  }
    .         
    .         int s2n_stuffer_write_reservation(struct s2n_stuffer_reservation *reservation, const uint32_t u)
  102 (0.0%)  {
  255 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_reservation_validate(reservation));
   68 (0.0%)      uint32_t old_write_cursor = reservation->stuffer->write_cursor;
  102 (0.0%)      int result = s2n_stuffer_write_reservation_impl(reservation, u);
   68 (0.0%)      reservation->stuffer->write_cursor = old_write_cursor;
   17 (0.0%)      return result;
   34 (0.0%)  }
    .         
    .         int s2n_stuffer_get_vector_size(const struct s2n_stuffer_reservation *reservation, uint32_t *size)
  119 (0.0%)  {
  255 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_reservation_validate(reservation));
   34 (0.0%)      POSIX_ENSURE_REF(size);
  204 (0.0%)      *size = reservation->stuffer->write_cursor - (reservation->write_cursor + reservation->length);
   17 (0.0%)      return S2N_SUCCESS;
   51 (0.0%)  }
    .         
    .         int s2n_stuffer_write_vector_size(struct s2n_stuffer_reservation *reservation)
  128 (0.0%)  {
   16 (0.0%)      uint32_t size = 0;
  112 (0.0%)      POSIX_GUARD(s2n_stuffer_get_vector_size(reservation, &size));
  112 (0.0%)      POSIX_GUARD(s2n_stuffer_write_reservation(reservation, size));
   16 (0.0%)      return S2N_SUCCESS;
   80 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 19 ----------------------------------------
     .         #include <string.h>
     .         #include <sys/param.h>
     .         
     .         #include "api/s2n.h"
     .         #include "error/s2n_errno.h"
     .         #include "utils/s2n_safety.h"
     .         
     .         S2N_RESULT s2n_blob_validate(const struct s2n_blob *b)
27,114 (0.3%)  {
 9,038 (0.1%)      RESULT_ENSURE_REF(b);
32,249 (0.3%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->data == NULL, b->size == 0), S2N_ERR_SAFETY);
32,249 (0.3%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->data == NULL, b->allocated == 0), S2N_ERR_SAFETY);
57,208 (0.5%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->growable == 0, b->allocated == 0), S2N_ERR_SAFETY);
49,751 (0.5%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->growable != 0, b->size <= b->allocated), S2N_ERR_SAFETY);
42,210 (0.4%)      RESULT_DEBUG_ENSURE(S2N_MEM_IS_READABLE(b->data, b->allocated), S2N_ERR_SAFETY);
62,454 (0.6%)      RESULT_DEBUG_ENSURE(S2N_MEM_IS_READABLE(b->data, b->size), S2N_ERR_SAFETY);
 4,519 (0.0%)      return S2N_RESULT_OK;
13,557 (0.1%)  }
     .         
     .         int s2n_blob_init(struct s2n_blob *b, uint8_t *data, uint32_t size)
 1,904 (0.0%)  {
   476 (0.0%)      POSIX_ENSURE_REF(b);
   944 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_SAFETY);
 2,856 (0.0%)      *b = (struct s2n_blob){ .data = data, .size = size, .allocated = 0, .growable = 0 };
 3,570 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(b));
   238 (0.0%)      return S2N_SUCCESS;
   714 (0.0%)  }
     .         
     .         int s2n_blob_zero(struct s2n_blob *b)
   240 (0.0%)  {
   600 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(b));
   720 (0.0%)      POSIX_CHECKED_MEMSET(b->data, 0, MAX(b->allocated, b->size));
   600 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(b));
    40 (0.0%)      return S2N_SUCCESS;
   120 (0.0%)  }
     .         
     .         int s2n_blob_slice(const struct s2n_blob *b, struct s2n_blob *slice, uint32_t offset, uint32_t size)
   144 (0.0%)  {
   180 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(b));
   180 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(slice));
     .         
    12 (0.0%)      uint32_t slice_size = 0;
    96 (0.0%)      POSIX_GUARD(s2n_add_overflow(offset, size, &slice_size));
    60 (0.0%)      POSIX_ENSURE(b->size >= slice_size, S2N_ERR_SIZE_MISMATCH);
   132 (0.0%)      slice->data = (b->data) ? (b->data + offset) : NULL;
    36 (0.0%)      slice->size = size;
    48 (0.0%)      slice->growable = 0;
    24 (0.0%)      slice->allocated = 0;
     .         
   180 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(slice));
    12 (0.0%)      return S2N_SUCCESS;
    72 (0.0%)  }
     .         
     .         int s2n_blob_char_to_lower(struct s2n_blob *b)
     .         {
     .             POSIX_PRECONDITION(s2n_blob_validate(b));
     .             for (size_t i = 0; i < b->size; i++) {
     .                 b->data[i] = tolower(b->data[i]);
     .             }
     .             POSIX_POSTCONDITION(s2n_blob_validate(b));
-- line 78 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_ensure.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 11 ----------------------------------------
    .          * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
    .          * express or implied. See the License for the specific language governing
    .          * permissions and limitations under the License.
    .          */
    .         
    .         #include "utils/s2n_safety.h"
    .         
    .         void *s2n_ensure_memmove_trace(void *to, const void *from, size_t size)
5,632 (0.1%)  {
1,408 (0.0%)      PTR_ENSURE_REF(to);
1,408 (0.0%)      PTR_ENSURE_REF(from);
    .         
    .             /* use memmove instead of memcpy since it'll handle overlapping regions and not result in UB */
4,928 (0.0%)      void *result = memmove(to, from, size);
1,408 (0.0%)      PTR_ENSURE_REF(result);
  704 (0.0%)      return result;
2,112 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 79 ----------------------------------------
     .         #include "utils/s2n_result.h"
     .         
     .         #include <stdbool.h>
     .         
     .         #include "api/s2n.h"
     .         
     .         /* returns true when the result is S2N_RESULT_OK */
     .         inline bool s2n_result_is_ok(s2n_result result)
68,824 (0.6%)  {
51,618 (0.5%)      return result.__error_signal == S2N_SUCCESS;
34,412 (0.3%)  }
     .         
     .         /* returns true when the result is S2N_RESULT_ERROR */
     .         inline bool s2n_result_is_error(s2n_result result)
    64 (0.0%)  {
    48 (0.0%)      return result.__error_signal == S2N_FAILURE;
    32 (0.0%)  }
     .         
     .         /* ignores the returned result of a function */
     .         inline void s2n_result_ignore(s2n_result result)
    40 (0.0%)  {
     .             /* noop */
    30 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir_______________ 

9,542,115 (88.9%)    annotated: files known & above threshold & readable, line numbers known
        0            annotated: files known & above threshold & readable, line numbers unknown
        0          unannotated: files known & above threshold & two or more non-identical
  617,225  (5.7%)  unannotated: files known & above threshold & unreadable 
  570,780  (5.3%)  unannotated: files known & below threshold
    7,845  (0.1%)  unannotated: files unknown

