--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate cachegrind.out.data_transfer
Command:          target/debug/data_transfer
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir_____________________ 

16,280,055,578 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir__________________________  file:function

< 4,762,641,276 (29.3%, 29.3%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c:
  2,920,988,782 (17.9%)           s2n_stuffer_validate
    358,613,676  (2.2%)           s2n_stuffer_reserve_space
    356,516,520  (2.2%)           s2n_stuffer_skip_write
    207,967,970  (1.3%)           s2n_stuffer_write_bytes
    190,841,196  (1.2%)           s2n_stuffer_skip_read
    159,034,330  (1.0%)           s2n_stuffer_read_bytes
     72,351,882  (0.4%)           s2n_stuffer_init
     69,206,148  (0.4%)           s2n_stuffer_wipe
     58,720,368  (0.4%)           s2n_stuffer_rewrite
     57,322,264  (0.4%)           s2n_stuffer_wipe_n
     52,428,900  (0.3%)           s2n_stuffer_reread
     41,943,120  (0.3%)           s2n_stuffer_writev_bytes
     35,651,652  (0.2%)           s2n_stuffer_rewind_read
     31,457,340  (0.2%)           s2n_stuffer_resize_if_empty
     26,913,502  (0.2%)           s2n_stuffer_erase_and_read
     24,466,820  (0.2%)           s2n_stuffer_copy_impl
     23,068,716  (0.1%)           s2n_stuffer_free
     22,369,664  (0.1%)           s2n_stuffer_raw_write
     22,369,664  (0.1%)           s2n_stuffer_raw_read

< 4,366,628,318 (26.8%, 56.1%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c:
  4,144,329,782 (25.5%)           s2n_blob_validate
    188,044,988  (1.2%)           s2n_blob_init
     34,253,548  (0.2%)           s2n_blob_slice

< 1,588,595,670  (9.8%, 65.8%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c:s2n_result_is_ok

<   628,447,748  (3.9%, 69.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h:
    229,289,056  (1.4%)           OPENSSL_memcpy
    106,255,904  (0.7%)           CRYPTO_load_word_le
     89,478,656  (0.5%)           CRYPTO_bswap4
     39,146,912  (0.2%)           CRYPTO_store_word_le
     33,554,496  (0.2%)           OPENSSL_memset
     33,204,970  (0.2%)           CRYPTO_bswap8
     25,165,872  (0.2%)           buffers_alias
     25,165,872  (0.2%)           CRYPTO_store_u64_be
     25,165,872  (0.2%)           CRYPTO_store_u32_be

<   422,926,460  (2.6%, 72.3%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/modes/gcm.c:
    109,052,112  (0.7%)           aws_lc_0_19_0_CRYPTO_gcm128_aad
     82,138,610  (0.5%)           aws_lc_0_19_0_CRYPTO_gcm128_encrypt_ctr32
     82,138,610  (0.5%)           aws_lc_0_19_0_CRYPTO_gcm128_decrypt_ctr32
     51,030,796  (0.3%)           aws_lc_0_19_0_CRYPTO_gcm128_setiv
     51,030,796  (0.3%)           aws_lc_0_19_0_CRYPTO_gcm128_finish
     17,476,300  (0.1%)           aws_lc_0_19_0_CRYPTO_gcm128_tag

<   383,430,022  (2.4%, 74.6%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_write.c:
    266,338,812  (1.6%)           s2n_record_writev
     29,360,184  (0.2%)           s2n_record_max_write_payload_size
     25,864,924  (0.2%)           s2n_tls_record_overhead
     23,767,768  (0.1%)           s2n_record_write_mac
     22,020,138  (0.1%)           s2n_record_write_protocol_version

<   335,196,929  (2.1%, 76.7%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:
    335,196,387  (2.1%)           __memcpy_avx_unaligned_erms

<   294,650,435  (1.8%, 78.5%)  /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/ub_checks.rs:
     89,478,656  (0.5%)           core::ub_checks::is_aligned_and_not_null
     73,400,460  (0.5%)           core::slice::raw::from_raw_parts::precondition_check
     31,457,340  (0.2%)           core::slice::raw::from_raw_parts_mut::precondition_check
     24,117,294  (0.1%)           core::intrinsics::copy_nonoverlapping::precondition_check
     19,223,930  (0.1%)           core::ub_checks::is_nonoverlapping::runtime

<   243,270,096  (1.5%, 80.0%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_recv.c:
     72,351,882  (0.4%)           s2n_read_full_record
     55,225,108  (0.3%)           s2n_recv_impl
     45,438,380  (0.3%)           s2n_read_in_bytes
     33,554,496  (0.2%)           s2n_recv_buffer_in
     20,622,034  (0.1%)           s2n_recv_in_init

<   188,744,040  (1.2%, 81.2%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_read_aead.c:s2n_record_parse_aead

<   165,675,324  (1.0%, 82.2%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_connection.c:
     58,021,316  (0.4%)           s2n_connection_check_io_status
     35,651,652  (0.2%)           s2n_connection_recv_stuffer
     20,971,560  (0.1%)           s2n_connection_send_stuffer

<   153,441,914  (0.9%, 83.1%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_send.c:
     67,458,518  (0.4%)           s2n_sendv_with_offset_impl
     33,554,496  (0.2%)           s2n_flush
     18,175,352  (0.1%)           s2n_sendv_with_offset_total_size
     17,126,774  (0.1%)           s2n_sendv_with_offset

<   153,441,914  (0.9%, 84.1%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_read.c:
     55,924,160  (0.3%)           s2n_record_header_parse
     44,389,802  (0.3%)           s2n_record_parse
     23,767,768  (0.1%)           s2n_tls13_parse_record_type
     16,777,248  (0.1%)           s2n_record_wipe

<   148,548,550  (0.9%, 85.0%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_ensure.c:s2n_ensure_memmove_trace

<   145,402,826  (0.9%, 85.9%)  /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/num/uint_macros.rs:
    111,848,320  (0.7%)           core::ub_checks::is_aligned_and_not_null
     18,874,404  (0.1%)           core::ub_checks::is_nonoverlapping::runtime

<   138,062,770  (0.8%, 86.7%)  /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/slice/index.rs:
     88,080,552  (0.5%)           core::slice::index::range
     17,476,300  (0.1%)           <core::ops::range::Range<usize> as core::slice::index::SliceIndex<[T]>>::index_mut

<   114,994,059  (0.7%, 87.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/cipher/e_aes.c:
     34,952,600  (0.2%)           aead_aes_gcm_seal_scatter_impl
     30,758,288  (0.2%)           aead_aes_gcm_open_gather_impl
     23,418,247  (0.1%)           aead_aes_gcm_tls13_seal_scatter

<   107,304,482  (0.7%, 88.1%)  /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/alloc/src/collections/vec_deque/mod.rs:
     37,748,808  (0.2%)           alloc::collections::vec_deque::VecDeque<T,A>::slice_ranges
     22,369,664  (0.1%)           alloc::collections::vec_deque::VecDeque<T,A>::to_physical_idx
     21,670,612  (0.1%)           alloc::collections::vec_deque::VecDeque<T,A>::as_slices

<    98,216,806  (0.6%, 88.7%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_network_order.c:
     34,603,074  (0.2%)           s2n_stuffer_write_network_order
     27,962,080  (0.2%)           s2n_stuffer_read_uint16
     17,825,826  (0.1%)           s2n_stuffer_read_uint8

<    93,045,156  (0.6%, 89.3%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_sequence.c:
     66,409,940  (0.4%)           s2n_sequence_number_to_uint64
     26,635,216  (0.2%)           s2n_increment_sequence_number

<    91,226,286  (0.6%, 89.8%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/cipher/aead.c:
     27,263,028  (0.2%)           aws_lc_0_19_0_EVP_AEAD_CTX_seal
     24,466,820  (0.2%)           aws_lc_0_19_0_EVP_AEAD_CTX_open
     23,068,716  (0.1%)           check_alias
     16,427,722  (0.1%)           aws_lc_0_19_0_EVP_AEAD_CTX_open_gather

<    88,080,552  (0.5%, 90.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/ghash-x86_64.S:
     85,983,396  (0.5%)           aws_lc_0_19_0_gcm_gmult_clmul

<    84,934,818  (0.5%, 90.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c:aws_lc_0_19_0_CRYPTO_memcmp

<    83,886,240  (0.5%, 91.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/aes/../modes/internal.h:CRYPTO_xor16

<    79,691,928  (0.5%, 91.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/aesni-x86_64.S:aws_lc_0_19_0_aes_hw_encrypt

<    73,400,464  (0.5%, 92.3%)  /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/cell.rs:
     36,700,230  (0.2%)           core::cell::RefCell<T>::try_borrow_mut
     19,922,982  (0.1%)           core::cell::RefCell<T>::borrow_mut

<    65,710,925  (0.4%, 92.7%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms

<    64,662,310  (0.4%, 93.1%)  /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/ptr/const_ptr.rs:
     50,331,744  (0.3%)           core::ub_checks::is_aligned_and_not_null

<    60,817,524  (0.4%, 93.5%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_early_data_io.c:
     19,573,456  (0.1%)           s2n_is_early_data_io
     19,573,456  (0.1%)           s2n_early_data_record_bytes

<    60,467,998  (0.4%, 93.9%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_aead_cipher_aes_gcm.c:
     30,408,762  (0.2%)           s2n_aead_cipher_aes_gcm_decrypt
     30,059,236  (0.2%)           s2n_aead_cipher_aes_gcm_encrypt

<    57,322,264  (0.4%, 94.2%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls/src/testing.rs:
     40,545,016  (0.2%)           s2n_tls::testing::TestPair::recv_cb
     16,777,248  (0.1%)           s2n_tls::testing::TestPair::send_cb

<    54,875,582  (0.3%, 94.6%)  /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/slice/mod.rs:
     21,670,612  (0.1%)           core::slice::<impl [T]>::split_at_unchecked

<    54,176,530  (0.3%, 94.9%)  /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/std/src/io/impls.rs:
     27,263,028  (0.2%)           std::io::impls::<impl std::io::Read for &[u8]>::read
     23,068,716  (0.1%)           std::io::impls::<impl std::io::Read for alloc::collections::vec_deque::VecDeque<u8,A>>::read

<    52,428,900  (0.3%, 95.2%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_aead.c:s2n_tls13_aead_aad_init

<    44,739,328  (0.3%, 95.5%)  /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/alloc/src/collections/vec_deque/drain.rs:
     30,758,288  (0.2%)           <<alloc::collections::vec_deque::drain::Drain<T,A> as core::ops::drop::Drop>::drop::DropGuard<T,A> as core::ops::drop::Drop>::drop

<    41,943,125  (0.3%, 95.8%)  /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/result.rs:
     22,369,664  (0.1%)           core::result::Result<T,E>::map_err

<    40,894,542  (0.3%, 96.0%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_handshake_io.c:
     29,360,184  (0.2%)           s2n_conn_get_current_message_type

<    37,399,282  (0.2%, 96.2%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_key_update.c:
     19,223,930  (0.1%)           s2n_key_update_send
     18,175,352  (0.1%)           s2n_check_record_limit

<    35,651,658  (0.2%, 96.5%)  /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/cmp.rs:
     19,573,456  (0.1%)           core::cmp::min_by

<    34,603,074  (0.2%, 96.7%)  /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/slice/raw.rs:
     17,126,774  (0.1%)           core::slice::raw::from_raw_parts::precondition_check

<    30,059,236  (0.2%, 96.9%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls/src/error.rs:
     20,272,508  (0.1%)           <T as s2n_tls::error::Pollable>::into_poll

<    29,360,184  (0.2%, 97.0%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_post_handshake.c:
     17,825,826  (0.1%)           s2n_post_handshake_send

<    28,661,146  (0.2%, 97.2%)  /home/ubuntu/proj/s2n/tests/regression/src/bin/data_transfer.rs:
     27,962,094  (0.2%)           data_transfer::main

<    27,263,861  (0.2%, 97.4%)  ???:
     27,263,475  (0.2%)           ???

<    24,466,820  (0.2%, 97.5%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_atomic.c:s2n_atomic_flag_test

<    20,971,582  (0.1%, 97.7%)  /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/intrinsics.rs:
     18,874,404  (0.1%)           core::intrinsics::copy_nonoverlapping::precondition_check

<    18,874,404  (0.1%, 97.8%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_quic_support.c:s2n_connection_is_quic_enabled

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir__________________________  function:file

> 4,144,329,782 (25.5%, 25.5%)  s2n_blob_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c

> 2,920,988,782 (17.9%, 43.4%)  s2n_stuffer_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

> 1,588,595,670  (9.8%, 53.2%)  s2n_result_is_ok:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c

>   358,613,676  (2.2%, 55.4%)  s2n_stuffer_reserve_space:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>   356,516,520  (2.2%, 57.5%)  s2n_stuffer_skip_write:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>   335,196,387  (2.1%, 59.6%)  __memcpy_avx_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

>   266,338,812  (1.6%, 61.2%)  s2n_record_writev:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_write.c

>   251,658,720  (1.5%, 62.8%)  core::ub_checks::is_aligned_and_not_null:
    111,848,320  (0.7%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/num/uint_macros.rs
     89,478,656  (0.5%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/ub_checks.rs
     50,331,744  (0.3%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/ptr/const_ptr.rs

>   229,289,056  (1.4%, 64.2%)  OPENSSL_memcpy:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>   207,967,970  (1.3%, 65.5%)  s2n_stuffer_write_bytes:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>   190,841,196  (1.2%, 66.6%)  s2n_stuffer_skip_read:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>   188,744,040  (1.2%, 67.8%)  s2n_record_parse_aead:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_read_aead.c

>   188,044,988  (1.2%, 69.0%)  s2n_blob_init:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c

>   159,034,330  (1.0%, 69.9%)  s2n_stuffer_read_bytes:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>   148,548,550  (0.9%, 70.9%)  s2n_ensure_memmove_trace:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_ensure.c

>   109,052,112  (0.7%, 71.5%)  aws_lc_0_19_0_CRYPTO_gcm128_aad:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/modes/gcm.c

>   106,255,904  (0.7%, 72.2%)  CRYPTO_load_word_le:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    95,770,124  (0.6%, 72.8%)  core::slice::index::range:
     88,080,552  (0.5%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/slice/index.rs

>    92,973,916  (0.6%, 73.3%)  core::slice::raw::from_raw_parts::precondition_check:
     73,400,460  (0.5%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/ub_checks.rs
     17,126,774  (0.1%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/slice/raw.rs

>    89,478,656  (0.5%, 73.9%)  CRYPTO_bswap4:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    85,983,396  (0.5%, 74.4%)  aws_lc_0_19_0_gcm_gmult_clmul:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/ghash-x86_64.S

>    84,934,818  (0.5%, 74.9%)  aws_lc_0_19_0_CRYPTO_memcmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    83,886,240  (0.5%, 75.4%)  CRYPTO_xor16:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/aes/../modes/internal.h

>    82,138,610  (0.5%, 76.0%)  aws_lc_0_19_0_CRYPTO_gcm128_encrypt_ctr32:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/modes/gcm.c

>    82,138,610  (0.5%, 76.5%)  aws_lc_0_19_0_CRYPTO_gcm128_decrypt_ctr32:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/modes/gcm.c

>    79,691,928  (0.5%, 76.9%)  aws_lc_0_19_0_aes_hw_encrypt:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/aesni-x86_64.S

>    72,351,882  (0.4%, 77.4%)  s2n_stuffer_init:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    72,351,882  (0.4%, 77.8%)  s2n_read_full_record:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_recv.c

>    69,206,148  (0.4%, 78.3%)  s2n_stuffer_wipe:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    67,458,518  (0.4%, 78.7%)  s2n_sendv_with_offset_impl:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_send.c

>    66,409,940  (0.4%, 79.1%)  s2n_sequence_number_to_uint64:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_sequence.c

>    65,710,925  (0.4%, 79.5%)  __memset_avx2_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

>    58,720,368  (0.4%, 79.8%)  s2n_stuffer_rewrite:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    58,021,316  (0.4%, 80.2%)  s2n_connection_check_io_status:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_connection.c

>    57,322,264  (0.4%, 80.6%)  s2n_stuffer_wipe_n:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    55,924,160  (0.3%, 80.9%)  s2n_record_header_parse:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_read.c

>    55,225,108  (0.3%, 81.2%)  s2n_recv_impl:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_recv.c

>    52,428,900  (0.3%, 81.6%)  s2n_tls13_aead_aad_init:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_aead.c

>    52,428,900  (0.3%, 81.9%)  s2n_stuffer_reread:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    51,030,796  (0.3%, 82.2%)  std::io::impls::<impl std::io::Read for &[u8]>::read:
     27,263,028  (0.2%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/std/src/io/impls.rs

>    51,030,796  (0.3%, 82.5%)  aws_lc_0_19_0_CRYPTO_gcm128_setiv:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/modes/gcm.c

>    51,030,796  (0.3%, 82.8%)  aws_lc_0_19_0_CRYPTO_gcm128_finish:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/modes/gcm.c

>    48,234,588  (0.3%, 83.1%)  core::cell::RefCell<T>::try_borrow_mut:
     36,700,230  (0.2%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/cell.rs

>    47,535,536  (0.3%, 83.4%)  core::ub_checks::is_nonoverlapping::runtime:
     19,223,930  (0.1%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/ub_checks.rs
     18,874,404  (0.1%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/num/uint_macros.rs

>    46,836,484  (0.3%, 83.7%)  std::io::impls::<impl std::io::Read for alloc::collections::vec_deque::VecDeque<u8,A>>::read:
     23,068,716  (0.1%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/std/src/io/impls.rs

>    45,438,380  (0.3%, 84.0%)  s2n_read_in_bytes:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_recv.c

>    44,389,802  (0.3%, 84.3%)  s2n_record_parse:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_read.c

>    42,991,698  (0.3%, 84.5%)  core::intrinsics::copy_nonoverlapping::precondition_check:
     24,117,294  (0.1%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/ub_checks.rs
     18,874,404  (0.1%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/intrinsics.rs

>    41,943,120  (0.3%, 84.8%)  s2n_stuffer_writev_bytes:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    40,545,016  (0.2%, 85.0%)  s2n_tls::testing::TestPair::recv_cb:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls/src/testing.rs

>    39,845,964  (0.2%, 85.3%)  core::slice::raw::from_raw_parts_mut::precondition_check:
     31,457,340  (0.2%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/ub_checks.rs

>    39,146,912  (0.2%, 85.5%)  core::slice::<impl [T]>::split_at_unchecked:
     21,670,612  (0.1%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/slice/mod.rs

>    39,146,912  (0.2%, 85.7%)  alloc::collections::vec_deque::VecDeque<T,A>::slice_ranges:
     37,748,808  (0.2%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/alloc/src/collections/vec_deque/mod.rs

>    39,146,912  (0.2%, 86.0%)  CRYPTO_store_word_le:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    35,651,652  (0.2%, 86.2%)  s2n_stuffer_rewind_read:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    35,651,652  (0.2%, 86.4%)  s2n_connection_recv_stuffer:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_connection.c

>    34,952,600  (0.2%, 86.6%)  aead_aes_gcm_seal_scatter_impl:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/cipher/e_aes.c

>    34,603,074  (0.2%, 86.9%)  s2n_stuffer_write_network_order:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_network_order.c

>    34,253,548  (0.2%, 87.1%)  s2n_blob_slice:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c

>    34,253,548  (0.2%, 87.3%)  <<alloc::collections::vec_deque::drain::Drain<T,A> as core::ops::drop::Drop>::drop::DropGuard<T,A> as core::ops::drop::Drop>::drop:
     30,758,288  (0.2%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/alloc/src/collections/vec_deque/drain.rs

>    33,554,496  (0.2%, 87.5%)  s2n_recv_buffer_in:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_recv.c

>    33,554,496  (0.2%, 87.7%)  s2n_flush:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_send.c

>    33,554,496  (0.2%, 87.9%)  OPENSSL_memset:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    33,204,970  (0.2%, 88.1%)  CRYPTO_bswap8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    31,457,340  (0.2%, 88.3%)  s2n_stuffer_resize_if_empty:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    30,758,288  (0.2%, 88.5%)  alloc::collections::vec_deque::VecDeque<T,A>::to_physical_idx:
     22,369,664  (0.1%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/alloc/src/collections/vec_deque/mod.rs

>    30,758,288  (0.2%, 88.7%)  aead_aes_gcm_open_gather_impl:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/cipher/e_aes.c

>    30,408,762  (0.2%, 88.9%)  s2n_aead_cipher_aes_gcm_decrypt:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_aead_cipher_aes_gcm.c

>    30,059,236  (0.2%, 89.0%)  s2n_aead_cipher_aes_gcm_encrypt:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_aead_cipher_aes_gcm.c

>    30,059,236  (0.2%, 89.2%)  alloc::collections::vec_deque::VecDeque<T,A>::as_slices:
     21,670,612  (0.1%)           /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/alloc/src/collections/vec_deque/mod.rs

>    29,360,184  (0.2%, 89.4%)  s2n_record_max_write_payload_size:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_write.c

>    29,360,184  (0.2%, 89.6%)  s2n_conn_get_current_message_type:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_handshake_io.c

>    27,962,094  (0.2%, 89.8%)  data_transfer::main:/home/ubuntu/proj/s2n/tests/regression/src/bin/data_transfer.rs

>    27,962,080  (0.2%, 89.9%)  s2n_stuffer_read_uint16:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_network_order.c

>    27,263,475  (0.2%, 90.1%)  ???:???

>    27,263,028  (0.2%, 90.3%)  aws_lc_0_19_0_EVP_AEAD_CTX_seal:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/cipher/aead.c

>    26,913,502  (0.2%, 90.4%)  s2n_stuffer_erase_and_read:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    26,635,216  (0.2%, 90.6%)  s2n_increment_sequence_number:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_sequence.c

>    25,864,924  (0.2%, 90.8%)  s2n_tls_record_overhead:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_write.c

>    25,165,872  (0.2%, 90.9%)  buffers_alias:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    25,165,872  (0.2%, 91.1%)  CRYPTO_store_u64_be:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    25,165,872  (0.2%, 91.2%)  CRYPTO_store_u32_be:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    24,466,820  (0.2%, 91.4%)  s2n_stuffer_copy_impl:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    24,466,820  (0.2%, 91.5%)  s2n_atomic_flag_test:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_atomic.c

>    24,466,820  (0.2%, 91.7%)  aws_lc_0_19_0_EVP_AEAD_CTX_open:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/cipher/aead.c

>    23,767,768  (0.1%, 91.8%)  s2n_tls13_parse_record_type:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_read.c

>    23,767,768  (0.1%, 92.0%)  s2n_record_write_mac:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_write.c

>    23,418,247  (0.1%, 92.1%)  aead_aes_gcm_tls13_seal_scatter:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/cipher/e_aes.c

>    23,068,716  (0.1%, 92.2%)  s2n_stuffer_free:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    23,068,716  (0.1%, 92.4%)  check_alias:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/cipher/aead.c

>    22,369,664  (0.1%, 92.5%)  s2n_stuffer_raw_write:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    22,369,664  (0.1%, 92.7%)  s2n_stuffer_raw_read:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    22,369,664  (0.1%, 92.8%)  core::result::Result<T,E>::map_err:/rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/result.rs

>    22,020,138  (0.1%, 92.9%)  s2n_record_write_protocol_version:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_write.c

>    20,971,560  (0.1%, 93.1%)  s2n_connection_send_stuffer:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_connection.c

>    20,622,034  (0.1%, 93.2%)  s2n_recv_in_init:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_recv.c

>    20,272,508  (0.1%, 93.3%)  <T as s2n_tls::error::Pollable>::into_poll:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls/src/error.rs

>    19,922,982  (0.1%, 93.4%)  core::cell::RefCell<T>::borrow_mut:/rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/cell.rs

>    19,573,456  (0.1%, 93.6%)  s2n_is_early_data_io:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_early_data_io.c

>    19,573,456  (0.1%, 93.7%)  s2n_early_data_record_bytes:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_early_data_io.c

>    19,573,456  (0.1%, 93.8%)  core::cmp::min_by:/rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/cmp.rs

>    19,223,930  (0.1%, 93.9%)  s2n_key_update_send:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_key_update.c

>    18,874,404  (0.1%, 94.0%)  s2n_tls::testing::TestPair::send_cb:
     16,777,248  (0.1%)           /home/ubuntu/proj/s2n/bindings/rust/s2n-tls/src/testing.rs

>    18,874,404  (0.1%, 94.1%)  s2n_connection_is_quic_enabled:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_quic_support.c

>    18,175,352  (0.1%, 94.3%)  s2n_sendv_with_offset_total_size:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_send.c

>    18,175,352  (0.1%, 94.4%)  s2n_check_record_limit:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_key_update.c

>    17,825,826  (0.1%, 94.5%)  s2n_stuffer_read_uint8:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_network_order.c

>    17,825,826  (0.1%, 94.6%)  s2n_post_handshake_send:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_post_handshake.c

>    17,476,300  (0.1%, 94.7%)  aws_lc_0_19_0_CRYPTO_gcm128_tag:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/modes/gcm.c

>    17,476,300  (0.1%, 94.8%)  <core::ops::range::Range<usize> as core::slice::index::SliceIndex<[T]>>::index_mut:/rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/slice/index.rs

>    17,126,774  (0.1%, 94.9%)  s2n_sendv_with_offset:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_send.c

>    16,777,248  (0.1%, 95.0%)  s2n_record_wipe:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_read.c

>    16,427,722  (0.1%, 95.1%)  aws_lc_0_19_0_EVP_AEAD_CTX_open_gather:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/cipher/aead.c

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h
--------------------------------------------------------------------------------
Ir_______________ 

-- line 218 ----------------------------------------
         .         #define OPENSSL_HAS_BUILTIN(x) 0
         .         #endif
         .         
         .         
         .         // Pointer utility functions.
         .         
         .         // buffers_alias returns one if |a| and |b| alias and zero otherwise.
         .         static inline int buffers_alias(const uint8_t *a, size_t a_len,
 6,291,468 (0.0%)                                  const uint8_t *b, size_t b_len) {
         .           // Cast |a| and |b| to integers. In C, pointer comparisons between unrelated
         .           // objects are undefined whereas pointer to integer conversions are merely
         .           // implementation-defined. We assume the implementation defined it in a sane
         .           // way.
 2,097,156 (0.0%)    uintptr_t a_u = (uintptr_t)a;
 2,097,156 (0.0%)    uintptr_t b_u = (uintptr_t)b;
12,582,936 (0.1%)    return a_u + a_len > b_u && b_u + b_len > a_u;
 2,097,156 (0.0%)  }
         .         
         .         typedef uint8_t stack_align_type;
         .         OPENSSL_STATIC_ASSERT(sizeof(stack_align_type) == 1,
         .                               stack_align_type_is_not_8_bits_long)
         .         
         .         // align_pointer returns |ptr|, advanced to |alignment|. |alignment| must be a
         .         // power of two, and |ptr| must have at least |alignment - 1| bytes of scratch
         .         // space.
-- line 242 ----------------------------------------
-- line 800 ----------------------------------------
         .         static inline uint64_t CRYPTO_bswap8(uint64_t x) {
         .           return _byteswap_uint64(x);
         .         }
         .         #else
         .         static inline uint16_t CRYPTO_bswap2(uint16_t x) {
         .           return (x >> 8) | (x << 8);
         .         }
         .         
16,777,248 (0.1%)  static inline uint32_t CRYPTO_bswap4(uint32_t x) {
 5,592,416 (0.0%)    x = (x >> 16) | (x << 16);
50,331,744 (0.3%)    x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);
 5,592,416 (0.0%)    return x;
11,184,832 (0.1%)  }
         .         
 8,738,150 (0.1%)  static inline uint64_t CRYPTO_bswap8(uint64_t x) {
19,223,930 (0.1%)    return CRYPTO_bswap4(x >> 32) | (((uint64_t)CRYPTO_bswap4(x)) << 32);
 5,242,890 (0.0%)  }
         .         #endif
         .         
         .         
         .         // Language bug workarounds.
         .         //
         .         // Most C standard library functions are undefined if passed NULL, even when the
         .         // corresponding length is zero. This gives them (and, in turn, all functions
         .         // which call them) surprising behavior on empty arrays. Some compilers will
-- line 824 ----------------------------------------
-- line 866 ----------------------------------------
         .         static inline int OPENSSL_memcmp(const void *s1, const void *s2, size_t n) {
         .           if (n == 0) {
         .             return 0;
         .           }
         .         
         .           return memcmp(s1, s2, n);
         .         }
         .         
85,983,396 (0.5%)  static inline void *OPENSSL_memcpy(void *dst, const void *src, size_t n) {
28,661,132 (0.2%)    if (n == 0) {
         .             return dst;
         .           }
         .         
85,983,396 (0.5%)    return memcpy(dst, src, n);
28,661,132 (0.2%)  }
         .         
         .         static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
         .           if (n == 0) {
         .             return dst;
         .           }
         .         
         .           return memmove(dst, src, n);
         .         }
         .         
12,582,936 (0.1%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
 4,194,312 (0.0%)    if (n == 0) {
         .             return dst;
         .           }
         .         
12,582,936 (0.1%)    return memset(dst, c, n);
 4,194,312 (0.0%)  }
         .         
         .         
         .         // Loads and stores.
         .         //
         .         // The following functions load and store sized integers with the specified
         .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
         .         // requirements on the input and output pointers.
         .         
-- line 904 ----------------------------------------
-- line 949 ----------------------------------------
         .         static inline void CRYPTO_store_u32_le(void *out, uint32_t v) {
         .         #if defined(OPENSSL_BIG_ENDIAN)
         .           v = CRYPTO_bswap4(v);
         .         #endif
         .           OPENSSL_memcpy(out, &v, sizeof(v));
         .         
         .         }
         .         
 4,893,364 (0.0%)  static inline uint32_t CRYPTO_load_u32_be(const void *in) {
         .           uint32_t v;
 4,194,312 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
         .         #if defined(OPENSSL_BIG_ENDIAN)
         .           return v;
         .         #else
 2,097,156 (0.0%)    return CRYPTO_bswap4(v);
         .         #endif
 3,495,260 (0.0%)  }
         .         
 6,990,520 (0.0%)  static inline void CRYPTO_store_u32_be(void *out, uint32_t v) {
         .         
         .         #if !defined(OPENSSL_BIG_ENDIAN)
 5,592,416 (0.0%)    v = CRYPTO_bswap4(v);
         .         #endif
 8,388,624 (0.1%)    OPENSSL_memcpy(out, &v, sizeof(v));
         .         
 4,194,312 (0.0%)  }
         .         
         .         static inline uint64_t CRYPTO_load_u64_le(const void *in) {
         .           uint64_t v;
         .           OPENSSL_memcpy(&v, in, sizeof(v));
         .         #if defined(OPENSSL_BIG_ENDIAN)
         .           return CRYPTO_bswap8(v);
         .         #else
         .           return v;
-- line 982 ----------------------------------------
-- line 986 ----------------------------------------
         .         static inline void CRYPTO_store_u64_le(void *out, uint64_t v) {
         .         #if defined(OPENSSL_BIG_ENDIAN)
         .           v = CRYPTO_bswap8(v);
         .         #endif
         .           OPENSSL_memcpy(out, &v, sizeof(v));
         .         
         .         }
         .         
 2,446,682 (0.0%)  static inline uint64_t CRYPTO_load_u64_be(const void *ptr) {
         .           uint64_t ret;
 2,097,156 (0.0%)    OPENSSL_memcpy(&ret, ptr, sizeof(ret));
         .         #if defined(OPENSSL_BIG_ENDIAN)
         .           return ret;
         .         #else
 1,048,578 (0.0%)    return CRYPTO_bswap8(ret);
         .         #endif
 1,747,630 (0.0%)  }
         .         
 6,990,520 (0.0%)  static inline void CRYPTO_store_u64_be(void *out, uint64_t v) {
         .         #if defined(OPENSSL_BIG_ENDIAN)
         .         #else
 5,592,416 (0.0%)    v = CRYPTO_bswap8(v);
         .         #endif
 8,388,624 (0.1%)    OPENSSL_memcpy(out, &v, sizeof(v));
         .         
 4,194,312 (0.0%)  }
         .         
39,146,912 (0.2%)  static inline crypto_word_t CRYPTO_load_word_le(const void *in) {
         .         
         .           crypto_word_t v;
33,554,496 (0.2%)    OPENSSL_memcpy(&v, in, sizeof(v));
         .         #if defined(OPENSSL_BIG_ENDIAN)
         .           return CRYPTO_bswap_word(v);
         .         #else
 5,592,416 (0.0%)    return v;
         .         #endif
27,962,080 (0.2%)  }
         .         
13,981,040 (0.1%)  static inline void CRYPTO_store_word_le(void *out, crypto_word_t v) {
         .         
         .         
         .         #if defined(OPENSSL_BIG_ENDIAN)
         .           v = CRYPTO_bswap_word(v);
         .         #endif
16,777,248 (0.1%)    OPENSSL_memcpy(out, &v, sizeof(v));
         .         
 8,388,624 (0.1%)  }
         .         
         .         static inline crypto_word_t CRYPTO_load_word_be(const void *in) {
         .           crypto_word_t v;
         .           OPENSSL_memcpy(&v, in, sizeof(v));
         .         #if defined(OPENSSL_BIG_ENDIAN)
         .           return v;
         .         #else
         .         #if defined(OPENSSL_64_BIT)
-- line 1040 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/aes/../modes/internal.h
--------------------------------------------------------------------------------
Ir_______________ 

-- line 76 ----------------------------------------
         .         // type signature of |AES_encrypt| and friends or pass in |void*| wrapper
         .         // functions.
         .         //
         .         // These functions are called exclusively with AES, so we use the former.
         .         typedef void (*block128_f)(const uint8_t in[16], uint8_t out[16],
         .                                    const AES_KEY *key);
         .         
         .         OPENSSL_INLINE void CRYPTO_xor16(uint8_t out[16], const uint8_t a[16],
 9,786,728 (0.1%)                                   const uint8_t b[16]) {
         .           // TODO(davidben): Ideally we'd leave this to the compiler, which could use
         .           // vector registers, etc. But the compiler doesn't know that |in| and |out|
         .           // cannot partially alias. |restrict| is slightly two strict (we allow exact
         .           // aliasing), but perhaps in-place could be a separate function?
         .           OPENSSL_STATIC_ASSERT(16 % sizeof(crypto_word_t) == 0,
         .                                 block_cannot_be_evenly_divided_into_crypto_word_t)
13,981,040 (0.1%)    for (size_t i = 0; i < 16; i += sizeof(crypto_word_t)) {
13,981,040 (0.1%)      CRYPTO_store_word_le(
39,146,912 (0.2%)          out + i, CRYPTO_load_word_le(a + i) ^ CRYPTO_load_word_le(b + i));
         .           }
 6,990,520 (0.0%)  }
         .         
         .         
         .         // CTR.
         .         
         .         // ctr128_f is the type of a function that performs CTR-mode encryption.
         .         typedef void (*ctr128_f)(const uint8_t *in, uint8_t *out, size_t blocks,
         .                                  const AES_KEY *key, const uint8_t ivec[16]);
         .         
-- line 103 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/cipher/aead.c
--------------------------------------------------------------------------------
Ir_______________ 

-- line 107 ----------------------------------------
         .           }
         .           ctx->aead->cleanup(ctx);
         .           ctx->aead = NULL;
         .         }
         .         
         .         // check_alias returns 1 if |out| is compatible with |in| and 0 otherwise. If
         .         // |in| and |out| alias, we require that |in| == |out|.
         .         static int check_alias(const uint8_t *in, size_t in_len, const uint8_t *out,
 8,388,624 (0.1%)                         size_t out_len) {
 8,388,624 (0.1%)    if (!buffers_alias(in, in_len, out, out_len)) {
         .             return 1;
         .           }
         .         
 4,194,312 (0.0%)    return in == out;
 2,097,156 (0.0%)  }
         .         
         .         int EVP_AEAD_CTX_seal(const EVP_AEAD_CTX *ctx, uint8_t *out, size_t *out_len,
         .                               size_t max_out_len, const uint8_t *nonce,
         .                               size_t nonce_len, const uint8_t *in, size_t in_len,
 5,941,942 (0.0%)                        const uint8_t *ad, size_t ad_len) {
 2,796,208 (0.0%)    if (in_len + ctx->aead->overhead < in_len /* overflow */) {
         .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_TOO_LARGE);
         .             goto error;
         .           }
         .         
 1,048,578 (0.0%)    if (max_out_len < in_len) {
         .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_BUFFER_TOO_SMALL);
         .             goto error;
         .           }
         .         
 2,796,208 (0.0%)    if (!check_alias(in, in_len, out, max_out_len)) {
         .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_OUTPUT_ALIASES_INPUT);
         .             goto error;
         .           }
         .         
         .           size_t out_tag_len;
10,485,780 (0.1%)    if (ctx->aead->seal_scatter(ctx, out, out + in_len, &out_tag_len,
         .                                       max_out_len - in_len, nonce, nonce_len, in,
         .                                       in_len, NULL, 0, ad, ad_len)) {
 1,747,630 (0.0%)      *out_len = in_len + out_tag_len;
   699,052 (0.0%)      return 1;
         .           }
         .         
         .         error:
         .           // In the event of an error, clear the output buffer so that a caller
         .           // that doesn't check the return value doesn't send raw data.
         .           OPENSSL_memset(out, 0, max_out_len);
         .           *out_len = 0;
         .           return 0;
 1,747,630 (0.0%)  }
         .         
         .         int EVP_AEAD_CTX_seal_scatter(const EVP_AEAD_CTX *ctx, uint8_t *out,
         .                                       uint8_t *out_tag, size_t *out_tag_len,
         .                                       size_t max_out_tag_len, const uint8_t *nonce,
         .                                       size_t nonce_len, const uint8_t *in,
         .                                       size_t in_len, const uint8_t *extra_in,
         .                                       size_t extra_in_len, const uint8_t *ad,
         .                                       size_t ad_len) {
-- line 164 ----------------------------------------
-- line 188 ----------------------------------------
         .           OPENSSL_memset(out_tag, 0, max_out_tag_len);
         .           *out_tag_len = 0;
         .           return 0;
         .         }
         .         
         .         int EVP_AEAD_CTX_open(const EVP_AEAD_CTX *ctx, uint8_t *out, size_t *out_len,
         .                               size_t max_out_len, const uint8_t *nonce,
         .                               size_t nonce_len, const uint8_t *in, size_t in_len,
 3,495,260 (0.0%)                        const uint8_t *ad, size_t ad_len) {
 2,796,208 (0.0%)    if (!check_alias(in, in_len, out, max_out_len)) {
         .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_OUTPUT_ALIASES_INPUT);
         .             goto error;
         .           }
         .         
 1,747,630 (0.0%)    if (ctx->aead->open) {
         .             if (!ctx->aead->open(ctx, out, out_len, max_out_len, nonce, nonce_len, in,
         .                                  in_len, ad, ad_len)) {
         .               goto error;
         .             }
         .             return 1;
         .           }
         .         
         .           // AEADs that use the default implementation of open() must set |tag_len| at
         .           // initialization time.
 1,398,104 (0.0%)    assert(ctx->tag_len);
         .         
 1,747,630 (0.0%)    if (in_len < ctx->tag_len) {
         .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_BAD_DECRYPT);
         .             goto error;
         .           }
         .         
 2,097,156 (0.0%)    size_t plaintext_len = in_len - ctx->tag_len;
 1,048,578 (0.0%)    if (max_out_len < plaintext_len) {
         .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_BUFFER_TOO_SMALL);
         .             goto error;
         .           }
 6,990,520 (0.0%)    if (EVP_AEAD_CTX_open_gather(ctx, out, nonce, nonce_len, in, plaintext_len,
   699,052 (0.0%)                                 in + plaintext_len, ctx->tag_len, ad, ad_len)) {
 1,048,578 (0.0%)      *out_len = plaintext_len;
   699,052 (0.0%)      return 1;
         .           }
         .         
         .         error:
         .           // In the event of an error, clear the output buffer so that a caller
         .           // that doesn't check the return value doesn't try and process bad
         .           // data.
         .           OPENSSL_memset(out, 0, max_out_len);
         .           *out_len = 0;
         .           return 0;
   699,052 (0.0%)  }
         .         
         .         int EVP_AEAD_CTX_open_gather(const EVP_AEAD_CTX *ctx, uint8_t *out,
         .                                      const uint8_t *nonce, size_t nonce_len,
         .                                      const uint8_t *in, size_t in_len,
         .                                      const uint8_t *in_tag, size_t in_tag_len,
 3,495,260 (0.0%)                               const uint8_t *ad, size_t ad_len) {
 2,796,208 (0.0%)    if (!check_alias(in, in_len, out, in_len)) {
         .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_OUTPUT_ALIASES_INPUT);
         .             goto error;
         .           }
         .         
 1,747,630 (0.0%)    if (!ctx->aead->open_gather) {
         .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_CTRL_NOT_IMPLEMENTED);
         .             goto error;
         .           }
         .         
 6,990,520 (0.0%)    if (ctx->aead->open_gather(ctx, out, nonce, nonce_len, in, in_len, in_tag,
         .                                      in_tag_len, ad, ad_len)) {
   699,052 (0.0%)      return 1;
         .           }
         .         
         .         error:
         .           // In the event of an error, clear the output buffer so that a caller
         .           // that doesn't check the return value doesn't try and process bad
         .           // data.
         .           OPENSSL_memset(out, 0, in_len);
         .           return 0;
   699,052 (0.0%)  }
         .         
         .         const EVP_AEAD *EVP_AEAD_CTX_aead(const EVP_AEAD_CTX *ctx) { return ctx->aead; }
         .         
         .         int EVP_AEAD_CTX_get_iv(const EVP_AEAD_CTX *ctx, const uint8_t **out_iv,
         .                                 size_t *out_len) {
         .           if (ctx->aead->get_iv == NULL) {
         .             return 0;
         .           }
-- line 273 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/cipher/e_aes.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 1133 ----------------------------------------
        .         }
        .         
        .         static void aead_aes_gcm_cleanup(EVP_AEAD_CTX *ctx) {}
        .         
        .         static int aead_aes_gcm_seal_scatter_impl(
        .             const struct aead_aes_gcm_ctx *gcm_ctx, uint8_t *out, uint8_t *out_tag,
        .             size_t *out_tag_len, size_t max_out_tag_len, const uint8_t *nonce,
        .             size_t nonce_len, const uint8_t *in, size_t in_len, const uint8_t *extra_in,
6,640,994 (0.0%)      size_t extra_in_len, const uint8_t *ad, size_t ad_len, size_t tag_len) {
1,747,630 (0.0%)    if (extra_in_len + tag_len < tag_len) {
        .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_TOO_LARGE);
        .             return 0;
        .           }
1,747,630 (0.0%)    if (max_out_tag_len < extra_in_len + tag_len) {
        .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_BUFFER_TOO_SMALL);
        .             return 0;
        .           }
  699,052 (0.0%)    if (nonce_len == 0) {
        .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_INVALID_NONCE_SIZE);
        .             return 0;
        .           }
        .         
  699,052 (0.0%)    const AES_KEY *key = &gcm_ctx->ks.ks;
        .         
        .           GCM128_CONTEXT gcm;
1,747,630 (0.0%)    OPENSSL_memset(&gcm, 0, sizeof(gcm));
2,796,208 (0.0%)    OPENSSL_memcpy(&gcm.gcm_key, &gcm_ctx->gcm_key, sizeof(gcm.gcm_key));
2,097,156 (0.0%)    CRYPTO_gcm128_setiv(&gcm, key, nonce, nonce_len);
        .         
3,495,260 (0.0%)    if (ad_len > 0 && !CRYPTO_gcm128_aad(&gcm, ad, ad_len)) {
        .             return 0;
        .           }
        .         
1,398,104 (0.0%)    if (gcm_ctx->ctr) {
3,844,786 (0.0%)      if (!CRYPTO_gcm128_encrypt_ctr32(&gcm, key, in, out, in_len,
  699,052 (0.0%)                                       gcm_ctx->ctr)) {
        .               return 0;
        .             }
        .           } else {
        .             if (!CRYPTO_gcm128_encrypt(&gcm, key, in, out, in_len)) {
        .               return 0;
        .             }
        .           }
        .         
  699,052 (0.0%)    if (extra_in_len) {
        .             if (gcm_ctx->ctr) {
        .               if (!CRYPTO_gcm128_encrypt_ctr32(&gcm, key, extra_in, out_tag,
        .                                                extra_in_len, gcm_ctx->ctr)) {
        .                 return 0;
        .               }
        .             } else {
        .               if (!CRYPTO_gcm128_encrypt(&gcm, key, extra_in, out_tag, extra_in_len)) {
        .                 return 0;
        .               }
        .             }
        .           }
        .         
2,796,208 (0.0%)    CRYPTO_gcm128_tag(&gcm, out_tag + extra_in_len, tag_len);
1,747,630 (0.0%)    *out_tag_len = tag_len + extra_in_len;
        .         
  349,526 (0.0%)    return 1;
1,747,630 (0.0%)  }
        .         
        .         static int aead_aes_gcm_seal_scatter(
        .             const EVP_AEAD_CTX *ctx, uint8_t *out, uint8_t *out_tag,
        .             size_t *out_tag_len, size_t max_out_tag_len, const uint8_t *nonce,
        .             size_t nonce_len, const uint8_t *in, size_t in_len, const uint8_t *extra_in,
3,495,260 (0.0%)      size_t extra_in_len, const uint8_t *ad, size_t ad_len) {
1,048,578 (0.0%)    const struct aead_aes_gcm_ctx *gcm_ctx =
        .               (const struct aead_aes_gcm_ctx *)&ctx->state;
6,291,468 (0.0%)    return aead_aes_gcm_seal_scatter_impl(
        .               gcm_ctx, out, out_tag, out_tag_len, max_out_tag_len, nonce, nonce_len, in,
  699,052 (0.0%)        in_len, extra_in, extra_in_len, ad, ad_len, ctx->tag_len);
  699,052 (0.0%)  }
        .         
        .         static int aead_aes_gcm_open_gather_impl(const struct aead_aes_gcm_ctx *gcm_ctx,
        .                                                  uint8_t *out, const uint8_t *nonce,
        .                                                  size_t nonce_len, const uint8_t *in,
        .                                                  size_t in_len, const uint8_t *in_tag,
        .                                                  size_t in_tag_len, const uint8_t *ad,
5,941,942 (0.0%)                                           size_t ad_len, size_t tag_len) {
        .           uint8_t tag[EVP_AEAD_AES_GCM_TAG_LEN];
        .         
  699,052 (0.0%)    if (nonce_len == 0) {
        .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_INVALID_NONCE_SIZE);
        .             return 0;
        .           }
        .         
1,048,578 (0.0%)    if (in_tag_len != tag_len) {
        .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_BAD_DECRYPT);
        .             return 0;
        .           }
        .         
  699,052 (0.0%)    const AES_KEY *key = &gcm_ctx->ks.ks;
        .         
        .           GCM128_CONTEXT gcm;
1,747,630 (0.0%)    OPENSSL_memset(&gcm, 0, sizeof(gcm));
2,796,208 (0.0%)    OPENSSL_memcpy(&gcm.gcm_key, &gcm_ctx->gcm_key, sizeof(gcm.gcm_key));
2,097,156 (0.0%)    CRYPTO_gcm128_setiv(&gcm, key, nonce, nonce_len);
        .         
2,796,208 (0.0%)    if (!CRYPTO_gcm128_aad(&gcm, ad, ad_len)) {
        .             return 0;
        .           }
        .         
1,398,104 (0.0%)    if (gcm_ctx->ctr) {
3,844,786 (0.0%)      if (!CRYPTO_gcm128_decrypt_ctr32(&gcm, key, in, out, in_len,
  699,052 (0.0%)                                       gcm_ctx->ctr)) {
        .               return 0;
        .             }
        .           } else {
        .             if (!CRYPTO_gcm128_decrypt(&gcm, key, in, out, in_len)) {
        .               return 0;
        .             }
        .           }
        .         
2,097,156 (0.0%)    CRYPTO_gcm128_tag(&gcm, tag, tag_len);
2,796,208 (0.0%)    if (CRYPTO_memcmp(tag, in_tag, tag_len) != 0) {
        .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_BAD_DECRYPT);
        .             return 0;
        .           }
        .         
  349,526 (0.0%)    return 1;
1,747,630 (0.0%)  }
        .         
        .         static int aead_aes_gcm_open_gather(const EVP_AEAD_CTX *ctx, uint8_t *out,
        .                                             const uint8_t *nonce, size_t nonce_len,
        .                                             const uint8_t *in, size_t in_len,
        .                                             const uint8_t *in_tag, size_t in_tag_len,
3,495,260 (0.0%)                                      const uint8_t *ad, size_t ad_len) {
1,048,578 (0.0%)    struct aead_aes_gcm_ctx *gcm_ctx = (struct aead_aes_gcm_ctx *)&ctx->state;
6,291,468 (0.0%)    if (!aead_aes_gcm_open_gather_impl(gcm_ctx, out, nonce, nonce_len, in, in_len,
        .                                              in_tag, in_tag_len, ad, ad_len,
  699,052 (0.0%)                                       ctx->tag_len)) {
        .             return 0;
        .           }
        .         
1,048,578 (0.0%)    AEAD_GCM_verify_service_indicator(ctx);
  349,526 (0.0%)    return 1;
  699,052 (0.0%)  }
        .         
        .         DEFINE_METHOD_FUNCTION(EVP_AEAD, EVP_aead_aes_128_gcm) {
        .           memset(out, 0, sizeof(EVP_AEAD));
        .         
        .           out->key_len = 16;
        .           out->nonce_len = AES_GCM_NONCE_LENGTH;
        .           out->overhead = EVP_AEAD_AES_GCM_TAG_LEN;
        .           out->max_tag_len = EVP_AEAD_AES_GCM_TAG_LEN;
-- line 1279 ----------------------------------------
-- line 1562 ----------------------------------------
        .           ctx->tag_len = actual_tag_len;
        .           return 1;
        .         }
        .         
        .         static int aead_aes_gcm_tls13_seal_scatter(
        .             const EVP_AEAD_CTX *ctx, uint8_t *out, uint8_t *out_tag,
        .             size_t *out_tag_len, size_t max_out_tag_len, const uint8_t *nonce,
        .             size_t nonce_len, const uint8_t *in, size_t in_len, const uint8_t *extra_in,
3,495,260 (0.0%)      size_t extra_in_len, const uint8_t *ad, size_t ad_len) {
1,048,578 (0.0%)    struct aead_aes_gcm_tls13_ctx *gcm_ctx =
        .               (struct aead_aes_gcm_tls13_ctx *)&ctx->state;
        .         
  699,052 (0.0%)    if (nonce_len != AES_GCM_NONCE_LENGTH) {
        .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_UNSUPPORTED_NONCE_SIZE);
        .             return 0;
        .           }
        .         
        .           // The given nonces must be strictly monotonically increasing. See
        .           // https://tools.ietf.org/html/rfc8446#section-5.3 for details of the TLS 1.3
        .           // nonce construction.
        .           uint64_t given_counter =
2,446,682 (0.0%)        CRYPTO_load_u64_be(nonce + nonce_len - sizeof(uint64_t));
        .         
1,398,104 (0.0%)    if (gcm_ctx->first) {
        .             // In the first call the sequence number will be zero and therefore the
        .             // given nonce will be 0 ^ mask = mask.
        3 (0.0%)      gcm_ctx->mask = given_counter;
        2 (0.0%)      gcm_ctx->first = 0;
        .           }
1,048,578 (0.0%)    given_counter ^= gcm_ctx->mask;
        .         
2,097,156 (0.0%)    if (given_counter == UINT64_MAX || given_counter < gcm_ctx->min_next_nonce) {
        .             OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_INVALID_NONCE);
        .             return 0;
        .           }
        .         
1,398,104 (0.0%)    gcm_ctx->min_next_nonce = given_counter + 1;
        .         
7,340,046 (0.0%)    if (aead_aes_gcm_seal_scatter(ctx, out, out_tag, out_tag_len, max_out_tag_len,
        .                                         nonce, nonce_len, in, in_len, extra_in,
        .                                         extra_in_len, ad, ad_len)) {
1,048,578 (0.0%)      AEAD_GCM_verify_service_indicator(ctx);
  699,052 (0.0%)      return 1;
        .           }
        .           return 0;
  699,052 (0.0%)  }
        .         
        .         #define AEAD_AES_GCM_TLS13_STATE_SERDE_VERSION 1
        .         
        .         /*
        .          * AeadAesGCMTls13StateSerializationVersion ::= INTEGER {v1 (1)}
        .          *
        .          * AeadAesGCMTls13State ::= SEQUENCE {
        .          *   serializationVersion AeadAesGCMTls13StateSerializationVersion,
-- line 1615 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/modes/gcm.c
--------------------------------------------------------------------------------
Ir_______________ 

-- line 130 ----------------------------------------
         .         #undef GHASH
         .         #define GHASH(ctx, in, len) \
         .           (*gcm_ghash_p)((ctx)->Xi, (ctx)->gcm_key.Htable, in, len)
         .         #endif  // GCM_FUNCREF
         .         
         .         #if defined(HW_GCM) && defined(OPENSSL_X86_64)
         .         static size_t hw_gcm_encrypt(const uint8_t *in, uint8_t *out, size_t len,
         .                                      const AES_KEY *key, uint8_t ivec[16],
 3,495,260 (0.0%)                               uint8_t Xi[16], const u128 Htable[16]) {
 4,543,838 (0.0%)    return aesni_gcm_encrypt(in, out, len, key, ivec, Htable, Xi);
   699,052 (0.0%)  }
         .         
         .         static size_t hw_gcm_decrypt(const uint8_t *in, uint8_t *out, size_t len,
         .                                      const AES_KEY *key, uint8_t ivec[16],
 3,495,260 (0.0%)                               uint8_t Xi[16], const u128 Htable[16]) {
 4,543,838 (0.0%)    return aesni_gcm_decrypt(in, out, len, key, ivec, Htable, Xi);
   699,052 (0.0%)  }
         .         #endif  // HW_GCM && X86_64
         .         
         .         #if defined(HW_GCM) && defined(OPENSSL_AARCH64)
         .         
         .         static size_t hw_gcm_encrypt(const uint8_t *in, uint8_t *out, size_t len,
         .                                      const AES_KEY *key, uint8_t ivec[16],
         .                                      uint8_t Xi[16], const u128 Htable[16]) {
         .           const size_t len_blocks = len & kSizeTWithoutLower4Bits;
-- line 154 ----------------------------------------
-- line 317 ----------------------------------------
         .         #if defined(OPENSSL_AARCH64) && defined(GHASH_ASM_ARM)
         .           gcm_key->use_hw_gcm_crypt = (gcm_pmull_capable() && block_is_hwaes) ? 1 : 0;
         .         #else
         .           gcm_key->use_hw_gcm_crypt = (is_avx && block_is_hwaes) ? 1 : 0;
         .         #endif
         .         }
         .         
         .         void CRYPTO_gcm128_setiv(GCM128_CONTEXT *ctx, const AES_KEY *key,
 7,689,572 (0.0%)                           const uint8_t *iv, size_t len) {
         .         #ifdef GCM_FUNCREF
 2,097,156 (0.0%)    void (*gcm_gmult_p)(uint8_t Xi[16], const u128 Htable[16]) =
         .               ctx->gcm_key.gmult;
         .         #endif
         .         
 3,495,260 (0.0%)    OPENSSL_memset(&ctx->Yi, 0, sizeof(ctx->Yi));
 4,194,312 (0.0%)    OPENSSL_memset(&ctx->Xi, 0, sizeof(ctx->Xi));
 1,398,104 (0.0%)    ctx->len.aad = 0;
 1,398,104 (0.0%)    ctx->len.msg = 0;
 1,398,104 (0.0%)    ctx->ares = 0;
 1,398,104 (0.0%)    ctx->mres = 0;
         .         
         .         #if defined(GHASH_ASM_X86_64)
 5,592,416 (0.0%)    if (ctx->gcm_key.use_hw_gcm_crypt && crypto_gcm_avx512_enabled()) {
         .             gcm_setiv_avx512(key, ctx, iv, len);
         .             return;
         .           }
         .         #endif
         .         
         .           uint32_t ctr;
 1,398,104 (0.0%)    if (len == 12) {
 4,194,312 (0.0%)      OPENSSL_memcpy(ctx->Yi, iv, 12);
 1,398,104 (0.0%)      ctx->Yi[15] = 1;
 1,398,104 (0.0%)      ctr = 1;
         .           } else {
         .             uint64_t len0 = len;
         .         
         .             while (len >= 16) {
         .               CRYPTO_xor16(ctx->Yi, ctx->Yi, iv);
         .               GCM_MUL(ctx, Yi);
         .               iv += 16;
         .               len -= 16;
-- line 357 ----------------------------------------
-- line 367 ----------------------------------------
         .             OPENSSL_memset(len_block, 0, 8);
         .             CRYPTO_store_u64_be(len_block + 8, len0 << 3);
         .             CRYPTO_xor16(ctx->Yi, ctx->Yi, len_block);
         .         
         .             GCM_MUL(ctx, Yi);
         .             ctr = CRYPTO_load_u32_be(ctx->Yi + 12);
         .           }
         .         
 5,592,416 (0.0%)    (*ctx->gcm_key.block)(ctx->Yi, ctx->EK0, key);
   699,052 (0.0%)    ++ctr;
 4,194,312 (0.0%)    CRYPTO_store_u32_be(ctx->Yi + 12, ctr);
 3,495,260 (0.0%)  }
         .         
 4,893,364 (0.0%)  int CRYPTO_gcm128_aad(GCM128_CONTEXT *ctx, const uint8_t *aad, size_t len) {
         .         #ifdef GCM_FUNCREF
 2,097,156 (0.0%)    void (*gcm_gmult_p)(uint8_t Xi[16], const u128 Htable[16]) =
         .               ctx->gcm_key.gmult;
 2,097,156 (0.0%)    void (*gcm_ghash_p)(uint8_t Xi[16], const u128 Htable[16], const uint8_t *inp,
         .                               size_t len) = ctx->gcm_key.ghash;
         .         #endif
         .         
 2,796,208 (0.0%)    if (ctx->len.msg != 0) {
         .             // The caller must have finished the AAD before providing other input.
         .             return 0;
         .           }
         .         
 3,495,260 (0.0%)    uint64_t alen = ctx->len.aad + len;
 4,194,312 (0.0%)    if (alen > (UINT64_C(1) << 61) || (sizeof(len) == 8 && alen < len)) {
         .             return 0;
         .           }
 2,097,156 (0.0%)    ctx->len.aad = alen;
         .         
 2,097,156 (0.0%)    unsigned n = ctx->ares;
 1,398,104 (0.0%)    if (n) {
         .             while (n && len) {
         .               ctx->Xi[n] ^= *(aad++);
         .               --len;
         .               n = (n + 1) % 16;
         .             }
         .             if (n == 0) {
         .               GCM_MUL(ctx, Xi);
         .             } else {
         .               ctx->ares = n;
         .               return 1;
         .             }
         .           }
         .         
         .           // Process a whole number of blocks.
 2,097,156 (0.0%)    size_t len_blocks = len & kSizeTWithoutLower4Bits;
 1,398,104 (0.0%)    if (len_blocks != 0) {
         .             GHASH(ctx, aad, len_blocks);
         .             aad += len_blocks;
         .             len -= len_blocks;
         .           }
         .         
         .           // Process the remainder.
 1,398,104 (0.0%)    if (len != 0) {
 1,398,104 (0.0%)      n = (unsigned int)len;
17,476,300 (0.1%)      for (size_t i = 0; i < len; ++i) {
55,924,160 (0.3%)        ctx->Xi[i] ^= aad[i];
         .             }
         .           }
         .         
 2,097,156 (0.0%)    ctx->ares = n;
   699,052 (0.0%)    return 1;
 1,398,104 (0.0%)  }
         .         
         .         int CRYPTO_gcm128_encrypt(GCM128_CONTEXT *ctx, const AES_KEY *key,
         .                                   const uint8_t *in, uint8_t *out, size_t len) {
         .           block128_f block = ctx->gcm_key.block;
         .         #ifdef GCM_FUNCREF
         .           void (*gcm_gmult_p)(uint8_t Xi[16], const u128 Htable[16]) =
         .               ctx->gcm_key.gmult;
         .           void (*gcm_ghash_p)(uint8_t Xi[16], const u128 Htable[16], const uint8_t *inp,
-- line 440 ----------------------------------------
-- line 595 ----------------------------------------
         .           }
         .         
         .           ctx->mres = n;
         .           return 1;
         .         }
         .         
         .         int CRYPTO_gcm128_encrypt_ctr32(GCM128_CONTEXT *ctx, const AES_KEY *key,
         .                                         const uint8_t *in, uint8_t *out, size_t len,
 3,495,260 (0.0%)                                  ctr128_f stream) {
         .         #ifdef GCM_FUNCREF
 1,048,578 (0.0%)    void (*gcm_gmult_p)(uint8_t Xi[16], const u128 Htable[16]) =
         .               ctx->gcm_key.gmult;
 1,048,578 (0.0%)    void (*gcm_ghash_p)(uint8_t Xi[16], const u128 Htable[16], const uint8_t *inp,
         .                               size_t len) = ctx->gcm_key.ghash;
         .         #endif
         .         
 1,747,630 (0.0%)    uint64_t mlen = ctx->len.msg + len;
 2,097,156 (0.0%)    if (mlen > ((UINT64_C(1) << 36) - 32) ||
         .               (sizeof(len) == 8 && mlen < len)) {
         .             return 0;
         .           }
 1,048,578 (0.0%)    ctx->len.msg = mlen;
         .         
 1,398,104 (0.0%)    if (ctx->ares) {
         .             // First call to encrypt finalizes GHASH(AAD)
 2,796,208 (0.0%)      GCM_MUL(ctx, Xi);
   699,052 (0.0%)      ctx->ares = 0;
         .           }
         .         
         .         #if defined(GHASH_ASM_X86_64)
 2,796,208 (0.0%)    if (ctx->gcm_key.use_hw_gcm_crypt && crypto_gcm_avx512_enabled() && len > 0) {
         .             aes_gcm_encrypt_avx512(key, ctx, &ctx->mres, in, len, out);
         .             return 1;
         .           }
         .         #endif
         .         
 1,048,578 (0.0%)    unsigned n = ctx->mres;
   699,052 (0.0%)    if (n) {
         .             while (n && len) {
         .               ctx->Xi[n] ^= *(out++) = *(in++) ^ ctx->EKi[n];
         .               --len;
         .               n = (n + 1) % 16;
         .             }
         .             if (n == 0) {
         .               GCM_MUL(ctx, Xi);
         .             } else {
         .               ctx->mres = n;
         .               return 1;
         .             }
         .           }
         .         
         .         #if defined(HW_GCM)
         .           // Check |len| to work around a C language bug. See https://crbug.com/1019588.
 2,446,682 (0.0%)    if (ctx->gcm_key.use_hw_gcm_crypt && len > 0) {
         .             // |hw_gcm_encrypt| may not process all the input given to it. It may
         .             // not process *any* of its input if it is deemed too small.
 4,543,838 (0.0%)      size_t bulk = hw_gcm_encrypt(in, out, len, key, ctx->Yi, ctx->Xi,
   699,052 (0.0%)                                   ctx->gcm_key.Htable);
   699,052 (0.0%)      in += bulk;
   699,052 (0.0%)      out += bulk;
   699,052 (0.0%)      len -= bulk;
         .           }
         .         #endif
         .         
 1,747,630 (0.0%)    uint32_t ctr = CRYPTO_load_u32_be(ctx->Yi + 12);
 1,048,578 (0.0%)    while (len >= GHASH_CHUNK) {
         .             (*stream)(in, out, GHASH_CHUNK / 16, key, ctx->Yi);
         .             ctr += GHASH_CHUNK / 16;
         .             CRYPTO_store_u32_be(ctx->Yi + 12, ctr);
         .             GHASH(ctx, out, GHASH_CHUNK);
         .             out += GHASH_CHUNK;
         .             in += GHASH_CHUNK;
         .             len -= GHASH_CHUNK;
         .           }
 1,048,578 (0.0%)    size_t len_blocks = len & kSizeTWithoutLower4Bits;
   699,052 (0.0%)    if (len_blocks != 0) {
         .             size_t j = len_blocks / 16;
         .         
         .             (*stream)(in, out, j, key, ctx->Yi);
         .             ctr += (unsigned int)j;
         .             CRYPTO_store_u32_be(ctx->Yi + 12, ctr);
         .             in += len_blocks;
         .             len -= len_blocks;
         .             GHASH(ctx, out, len_blocks);
         .             out += len_blocks;
         .           }
   699,052 (0.0%)    if (len) {
 2,796,208 (0.0%)      (*ctx->gcm_key.block)(ctx->Yi, ctx->EKi, key);
   349,526 (0.0%)      ++ctr;
 2,097,156 (0.0%)      CRYPTO_store_u32_be(ctx->Yi + 12, ctr);
 9,087,676 (0.1%)      while (len--) {
29,360,184 (0.2%)        ctx->Xi[n] ^= out[n] = in[n] ^ ctx->EKi[n];
 1,398,104 (0.0%)        ++n;
         .             }
         .           }
         .         
 1,048,578 (0.0%)    ctx->mres = n;
   349,526 (0.0%)    return 1;
   699,052 (0.0%)  }
         .         
         .         int CRYPTO_gcm128_decrypt_ctr32(GCM128_CONTEXT *ctx, const AES_KEY *key,
         .                                         const uint8_t *in, uint8_t *out, size_t len,
 3,495,260 (0.0%)                                  ctr128_f stream) {
         .         #ifdef GCM_FUNCREF
 1,048,578 (0.0%)    void (*gcm_gmult_p)(uint8_t Xi[16], const u128 Htable[16]) =
         .               ctx->gcm_key.gmult;
 1,048,578 (0.0%)    void (*gcm_ghash_p)(uint8_t Xi[16], const u128 Htable[16], const uint8_t *inp,
         .                               size_t len) = ctx->gcm_key.ghash;
         .         #endif
         .         
 1,747,630 (0.0%)    uint64_t mlen = ctx->len.msg + len;
 2,097,156 (0.0%)    if (mlen > ((UINT64_C(1) << 36) - 32) ||
         .               (sizeof(len) == 8 && mlen < len)) {
         .             return 0;
         .           }
 1,048,578 (0.0%)    ctx->len.msg = mlen;
         .         
 1,398,104 (0.0%)    if (ctx->ares) {
         .             // First call to decrypt finalizes GHASH(AAD)
 2,796,208 (0.0%)      GCM_MUL(ctx, Xi);
   699,052 (0.0%)      ctx->ares = 0;
         .           }
         .         
         .         #if defined(GHASH_ASM_X86_64)
 2,796,208 (0.0%)    if (ctx->gcm_key.use_hw_gcm_crypt && crypto_gcm_avx512_enabled() && len > 0) {
         .             aes_gcm_decrypt_avx512(key, ctx, &ctx->mres, in, len, out);
         .             return 1;
         .           }
         .         #endif
         .         
 1,048,578 (0.0%)    unsigned n = ctx->mres;
   699,052 (0.0%)    if (n) {
         .             while (n && len) {
         .               uint8_t c = *(in++);
         .               *(out++) = c ^ ctx->EKi[n];
         .               ctx->Xi[n] ^= c;
         .               --len;
         .               n = (n + 1) % 16;
         .             }
         .             if (n == 0) {
-- line 734 ----------------------------------------
-- line 736 ----------------------------------------
         .             } else {
         .               ctx->mres = n;
         .               return 1;
         .             }
         .           }
         .         
         .         #if defined(HW_GCM)
         .           // Check |len| to work around a C language bug. See https://crbug.com/1019588.
 2,446,682 (0.0%)    if (ctx->gcm_key.use_hw_gcm_crypt && len > 0) {
         .             // |hw_gcm_decrypt| may not process all the input given to it. It may
         .             // not process *any* of its input if it is deemed too small.
 4,543,838 (0.0%)      size_t bulk = hw_gcm_decrypt(in, out, len, key, ctx->Yi, ctx->Xi,
   699,052 (0.0%)                                   ctx->gcm_key.Htable);
   699,052 (0.0%)      in += bulk;
   699,052 (0.0%)      out += bulk;
   699,052 (0.0%)      len -= bulk;
         .           }
         .         #endif
         .         
 1,747,630 (0.0%)    uint32_t ctr = CRYPTO_load_u32_be(ctx->Yi + 12);
 1,048,578 (0.0%)    while (len >= GHASH_CHUNK) {
         .             GHASH(ctx, in, GHASH_CHUNK);
         .             (*stream)(in, out, GHASH_CHUNK / 16, key, ctx->Yi);
         .             ctr += GHASH_CHUNK / 16;
         .             CRYPTO_store_u32_be(ctx->Yi + 12, ctr);
         .             out += GHASH_CHUNK;
         .             in += GHASH_CHUNK;
         .             len -= GHASH_CHUNK;
         .           }
 1,048,578 (0.0%)    size_t len_blocks = len & kSizeTWithoutLower4Bits;
   699,052 (0.0%)    if (len_blocks != 0) {
         .             size_t j = len_blocks / 16;
         .         
         .             GHASH(ctx, in, len_blocks);
         .             (*stream)(in, out, j, key, ctx->Yi);
         .             ctr += (unsigned int)j;
         .             CRYPTO_store_u32_be(ctx->Yi + 12, ctr);
         .             out += len_blocks;
         .             in += len_blocks;
         .             len -= len_blocks;
         .           }
   699,052 (0.0%)    if (len) {
 2,796,208 (0.0%)      (*ctx->gcm_key.block)(ctx->Yi, ctx->EKi, key);
   349,526 (0.0%)      ++ctr;
 2,097,156 (0.0%)      CRYPTO_store_u32_be(ctx->Yi + 12, ctr);
 9,087,676 (0.1%)      while (len--) {
 6,990,520 (0.0%)        uint8_t c = in[n];
11,184,832 (0.1%)        ctx->Xi[n] ^= c;
11,184,832 (0.1%)        out[n] = c ^ ctx->EKi[n];
 1,398,104 (0.0%)        ++n;
         .             }
         .           }
         .         
 1,048,578 (0.0%)    ctx->mres = n;
   349,526 (0.0%)    return 1;
   699,052 (0.0%)  }
         .         
 6,990,520 (0.0%)  int CRYPTO_gcm128_finish(GCM128_CONTEXT *ctx, const uint8_t *tag, size_t len) {
         .         #ifdef GCM_FUNCREF
 2,097,156 (0.0%)    void (*gcm_gmult_p)(uint8_t Xi[16], const u128 Htable[16]) =
         .               ctx->gcm_key.gmult;
         .         #endif
         .         
 2,796,208 (0.0%)    if (ctx->mres || ctx->ares) {
 5,592,416 (0.0%)      GCM_MUL(ctx, Xi);
         .           }
         .         
         .           uint8_t len_block[16];
 4,893,364 (0.0%)    CRYPTO_store_u64_be(len_block, ctx->len.aad << 3);
 5,592,416 (0.0%)    CRYPTO_store_u64_be(len_block + 8, ctx->len.msg << 3);
 5,592,416 (0.0%)    CRYPTO_xor16(ctx->Xi, ctx->Xi, len_block);
 5,592,416 (0.0%)    GCM_MUL(ctx, Xi);
 6,291,468 (0.0%)    CRYPTO_xor16(ctx->Xi, ctx->Xi, ctx->EK0);
         .         
 1,398,104 (0.0%)    if (tag && len <= sizeof(ctx->Xi)) {
         .             return CRYPTO_memcmp(ctx->Xi, tag, len) == 0;
         .           } else {
   699,052 (0.0%)      return 0;
         .           }
 3,495,260 (0.0%)  }
         .         
 4,893,364 (0.0%)  void CRYPTO_gcm128_tag(GCM128_CONTEXT *ctx, unsigned char *tag, size_t len) {
 3,495,260 (0.0%)    CRYPTO_gcm128_finish(ctx, NULL, 0);
 6,990,520 (0.0%)    OPENSSL_memcpy(tag, ctx->Xi, len <= sizeof(ctx->Xi) ? len : sizeof(ctx->Xi));
 2,097,156 (0.0%)  }
         .         
         .         #if defined(OPENSSL_X86) || defined(OPENSSL_X86_64)
         .         int crypto_gcm_clmul_enabled(void) {
         .         #if defined(GHASH_ASM_X86) || defined(GHASH_ASM_X86_64)
         .           return CRYPTO_is_FXSR_capable() && CRYPTO_is_PCLMUL_capable();
         .         #else
         .           return 0;
         .         #endif
         .         }
         .         
 4,194,312 (0.0%)  int crypto_gcm_avx512_enabled(void) {
         .           // This must align with ImplDispatchTest.AEAD_AES_GCM
         .         #if defined(GHASH_ASM_X86_64) && \
         .             !defined(OPENSSL_WINDOWS) && \
         .             !defined(MY_ASSEMBLER_IS_TOO_OLD_FOR_512AVX)
         .             // TODO(awslc): remove the Windows guard once CryptoAlg-1701 is resolved.
 1,398,104 (0.0%)    return (CRYPTO_is_VAES_capable() &&
 4,194,312 (0.0%)            CRYPTO_is_AVX512_capable() &&
         .                   CRYPTO_is_VPCLMULQDQ_capable());
         .         #else
         .           return 0;
         .         #endif
 2,796,208 (0.0%)  }
         .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c
--------------------------------------------------------------------------------
Ir_______________ 

-- line 330 ----------------------------------------
         .         void *OPENSSL_secure_malloc(size_t size) { return OPENSSL_malloc(size); }
         .         
         .         void *OPENSSL_secure_zalloc(size_t size) { return OPENSSL_zalloc(size); }
         .         
         .         void OPENSSL_secure_clear_free(void *ptr, size_t len) {
         .           OPENSSL_clear_free(ptr, len);
         .         }
         .         
 2,097,156 (0.0%)  int CRYPTO_memcmp(const void *in_a, const void *in_b, size_t len) {
   699,052 (0.0%)    const uint8_t *a = in_a;
   699,052 (0.0%)    const uint8_t *b = in_b;
   349,526 (0.0%)    uint8_t x = 0;
         .         
24,117,294 (0.1%)    for (size_t i = 0; i < len; i++) {
55,924,160 (0.3%)      x |= a[i] ^ b[i];
         .           }
         .         
   349,526 (0.0%)    return x;
   699,052 (0.0%)  }
         .         
         .         uint32_t OPENSSL_hash32(const void *ptr, size_t len) {
         .           // These are the FNV-1a parameters for 32 bits.
         .           static const uint32_t kPrime = 16777619u;
         .           static const uint32_t kOffsetBasis = 2166136261u;
         .         
         .           const uint8_t *in = ptr;
         .           uint32_t h = kOffsetBasis;
-- line 356 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/aesni-x86_64.S
--------------------------------------------------------------------------------
Ir_______________ 

-- line 13 ----------------------------------------
         .         .align	16
         .         aes_hw_encrypt:
         .         .cfi_startproc	
         .         #ifdef BORINGSSL_DISPATCH_TEST
         .         .extern	BORINGSSL_function_hit
         .         .hidden BORINGSSL_function_hit
         .         	movb	$1,BORINGSSL_function_hit+1(%rip)
         .         #endif
 1,398,104 (0.0%)  	movups	(%rdi),%xmm2
 1,398,104 (0.0%)  	movl	240(%rdx),%eax
 1,398,104 (0.0%)  	movups	(%rdx),%xmm0
 1,398,104 (0.0%)  	movups	16(%rdx),%xmm1
 1,398,104 (0.0%)  	leaq	32(%rdx),%rdx
13,981,040 (0.1%)  	xorps	%xmm0,%xmm2
         .         .Loop_enc1_1:
         .         .byte	102,15,56,220,209
12,582,936 (0.1%)  	decl	%eax
12,582,936 (0.1%)  	movups	(%rdx),%xmm1
12,582,936 (0.1%)  	leaq	16(%rdx),%rdx
13,981,040 (0.1%)  	jnz	.Loop_enc1_1
         .         .byte	102,15,56,221,209
 1,398,104 (0.0%)  	pxor	%xmm0,%xmm0
 1,398,104 (0.0%)  	pxor	%xmm1,%xmm1
 1,398,104 (0.0%)  	movups	%xmm2,(%rsi)
 2,796,208 (0.0%)  	pxor	%xmm2,%xmm2
         .         	.byte	0xf3,0xc3
         .         .cfi_endproc	
         .         .size	aes_hw_encrypt,.-aes_hw_encrypt
         .         
         .         .globl	aes_hw_decrypt
         .         .hidden aes_hw_decrypt
         .         .type	aes_hw_decrypt,@function
         .         .align	16
-- line 45 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/ghash-x86_64.S
--------------------------------------------------------------------------------
Ir______________ 

-- line 170 ----------------------------------------
        .         .size	gcm_init_clmul,.-gcm_init_clmul
        .         .globl	gcm_gmult_clmul
        .         .hidden gcm_gmult_clmul
        .         .type	gcm_gmult_clmul,@function
        .         .align	16
        .         gcm_gmult_clmul:
        .         .cfi_startproc	
        .         .L_gmult_clmul:
2,097,156 (0.0%)  	movdqu	(%rdi),%xmm0
2,097,156 (0.0%)  	movdqa	.Lbswap_mask(%rip),%xmm5
2,097,156 (0.0%)  	movdqu	(%rsi),%xmm2
4,194,312 (0.0%)  	movdqu	32(%rsi),%xmm4
        .         .byte	102,15,56,0,197
2,097,156 (0.0%)  	movdqa	%xmm0,%xmm1
2,097,156 (0.0%)  	pshufd	$78,%xmm0,%xmm3
8,388,624 (0.1%)  	pxor	%xmm0,%xmm3
        .         .byte	102,15,58,68,194,0
        .         .byte	102,15,58,68,202,17
        .         .byte	102,15,58,68,220,0
2,097,156 (0.0%)  	pxor	%xmm0,%xmm3
2,097,156 (0.0%)  	pxor	%xmm1,%xmm3
        .         
2,097,156 (0.0%)  	movdqa	%xmm3,%xmm4
2,097,156 (0.0%)  	psrldq	$8,%xmm3
2,097,156 (0.0%)  	pslldq	$8,%xmm4
2,097,156 (0.0%)  	pxor	%xmm3,%xmm1
2,097,156 (0.0%)  	pxor	%xmm4,%xmm0
        .         
2,097,156 (0.0%)  	movdqa	%xmm0,%xmm4
2,097,156 (0.0%)  	movdqa	%xmm0,%xmm3
2,097,156 (0.0%)  	psllq	$5,%xmm0
2,097,156 (0.0%)  	pxor	%xmm0,%xmm3
2,097,156 (0.0%)  	psllq	$1,%xmm0
2,097,156 (0.0%)  	pxor	%xmm3,%xmm0
2,097,156 (0.0%)  	psllq	$57,%xmm0
2,097,156 (0.0%)  	movdqa	%xmm0,%xmm3
2,097,156 (0.0%)  	pslldq	$8,%xmm0
2,097,156 (0.0%)  	psrldq	$8,%xmm3
2,097,156 (0.0%)  	pxor	%xmm4,%xmm0
2,097,156 (0.0%)  	pxor	%xmm3,%xmm1
        .         
        .         
2,097,156 (0.0%)  	movdqa	%xmm0,%xmm4
2,097,156 (0.0%)  	psrlq	$1,%xmm0
2,097,156 (0.0%)  	pxor	%xmm4,%xmm1
2,097,156 (0.0%)  	pxor	%xmm0,%xmm4
2,097,156 (0.0%)  	psrlq	$5,%xmm0
2,097,156 (0.0%)  	pxor	%xmm4,%xmm0
2,097,156 (0.0%)  	psrlq	$1,%xmm0
4,194,312 (0.0%)  	pxor	%xmm1,%xmm0
        .         .byte	102,15,56,0,197
4,194,312 (0.0%)  	movdqu	%xmm0,(%rdi)
        .         	.byte	0xf3,0xc3
        .         .cfi_endproc	
        .         .size	gcm_gmult_clmul,.-gcm_gmult_clmul
        .         .globl	gcm_ghash_clmul
        .         .hidden gcm_ghash_clmul
        .         .type	gcm_ghash_clmul,@function
        .         .align	32
        .         gcm_ghash_clmul:
-- line 229 ----------------------------------------
-- line 723 ----------------------------------------
        .         .cfi_endproc	
        .         .size	gcm_init_avx,.-gcm_init_avx
        .         .globl	gcm_gmult_avx
        .         .hidden gcm_gmult_avx
        .         .type	gcm_gmult_avx,@function
        .         .align	32
        .         gcm_gmult_avx:
        .         .cfi_startproc	
2,097,156 (0.0%)  	jmp	.L_gmult_clmul
        .         .cfi_endproc	
        .         .size	gcm_gmult_avx,.-gcm_gmult_avx
        .         .globl	gcm_ghash_avx
        .         .hidden gcm_ghash_avx
        .         .type	gcm_ghash_avx,@function
        .         .align	32
        .         gcm_ghash_avx:
        .         .cfi_startproc	
-- line 739 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_aead_cipher_aes_gcm.c
--------------------------------------------------------------------------------
Ir_______________ 

-- line 42 ----------------------------------------
         .         #else
         .             return (EVP_aes_256_gcm() ? 1 : 0);
         .         #endif
         .         }
         .         
         .         #if defined(S2N_AEAD_AES_GCM_AVAILABLE) /* BoringSSL and AWS-LC AEAD API implementation */
         .         
         .         static int s2n_aead_cipher_aes_gcm_encrypt(struct s2n_session_key *key, struct s2n_blob *iv, struct s2n_blob *aad, struct s2n_blob *in, struct s2n_blob *out)
 4,543,838 (0.0%)  {
   699,052 (0.0%)      POSIX_ENSURE_REF(in);
   699,052 (0.0%)      POSIX_ENSURE_REF(out);
   699,052 (0.0%)      POSIX_ENSURE_REF(iv);
   699,052 (0.0%)      POSIX_ENSURE_REF(key);
   699,052 (0.0%)      POSIX_ENSURE_REF(aad);
         .         
         .             /* The size of the |in| blob includes the size of the data and the size of the AES-GCM tag */
 1,398,104 (0.0%)      POSIX_ENSURE_GTE(in->size, S2N_TLS_GCM_TAG_LEN);
 2,097,156 (0.0%)      POSIX_ENSURE_GTE(out->size, in->size);
 1,398,104 (0.0%)      POSIX_ENSURE_EQ(iv->size, S2N_TLS_GCM_IV_LEN);
         .         
         .             /* Adjust input length to account for the Tag length */
 1,747,630 (0.0%)      size_t in_len = in->size - S2N_TLS_GCM_TAG_LEN;
         .             /* out_len is set by EVP_AEAD_CTX_seal and checked post operation */
   349,526 (0.0%)      size_t out_len = 0;
         .         
10,835,306 (0.1%)      POSIX_GUARD_OSSL(EVP_AEAD_CTX_seal(key->evp_aead_ctx, out->data, &out_len, out->size, iv->data, iv->size, in->data, in_len, aad->data, aad->size), S2N_ERR_ENCRYPT);
         .         
 1,747,630 (0.0%)      S2N_ERROR_IF((in_len + S2N_TLS_GCM_TAG_LEN) != out_len, S2N_ERR_ENCRYPT);
         .         
   349,526 (0.0%)      return S2N_SUCCESS;
 2,097,156 (0.0%)  }
         .         
         .         static int s2n_aead_cipher_aes_gcm_decrypt(struct s2n_session_key *key, struct s2n_blob *iv, struct s2n_blob *aad, struct s2n_blob *in, struct s2n_blob *out)
 4,543,838 (0.0%)  {
   699,052 (0.0%)      POSIX_ENSURE_REF(in);
   699,052 (0.0%)      POSIX_ENSURE_REF(out);
   699,052 (0.0%)      POSIX_ENSURE_REF(iv);
   699,052 (0.0%)      POSIX_ENSURE_REF(key);
   699,052 (0.0%)      POSIX_ENSURE_REF(aad);
         .         
 1,398,104 (0.0%)      POSIX_ENSURE_GTE(in->size, S2N_TLS_GCM_TAG_LEN);
 2,446,682 (0.0%)      POSIX_ENSURE_GTE(out->size, in->size - S2N_TLS_GCM_TAG_LEN);
 1,398,104 (0.0%)      POSIX_ENSURE_EQ(iv->size, S2N_TLS_GCM_IV_LEN);
         .         
         .             /* out_len is set by EVP_AEAD_CTX_open and checked post operation */
   349,526 (0.0%)      size_t out_len = 0;
         .         
11,883,884 (0.1%)      POSIX_GUARD_OSSL(EVP_AEAD_CTX_open(key->evp_aead_ctx, out->data, &out_len, out->size, iv->data, iv->size, in->data, in->size, aad->data, aad->size), S2N_ERR_DECRYPT);
         .         
 2,446,682 (0.0%)      S2N_ERROR_IF((in->size - S2N_TLS_GCM_TAG_LEN) != out_len, S2N_ERR_ENCRYPT);
         .         
   349,526 (0.0%)      return S2N_SUCCESS;
 2,097,156 (0.0%)  }
         .         
         .         static int s2n_aead_cipher_aes128_gcm_set_encryption_key(struct s2n_session_key *key, struct s2n_blob *in)
         .         {
         .             POSIX_ENSURE_REF(key);
         .             POSIX_ENSURE_REF(in);
         .         
         .             POSIX_ENSURE_EQ(in->size, S2N_TLS_AES_128_GCM_KEY_LEN);
         .         
-- line 102 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_sequence.c
--------------------------------------------------------------------------------
Ir_______________ 

-- line 17 ----------------------------------------
         .         
         .         #include "error/s2n_errno.h"
         .         #include "tls/s2n_crypto.h"
         .         #include "utils/s2n_blob.h"
         .         
         .         #define SEQUENCE_NUMBER_POWER 8
         .         
         .         int s2n_increment_sequence_number(struct s2n_blob *sequence_number)
 4,194,312 (0.0%)  {
 4,202,532 (0.0%)      for (uint32_t j = sequence_number->size; j > 0; j--) {
 2,105,376 (0.0%)          uint32_t i = j - 1;
 7,719,712 (0.0%)          sequence_number->data[i] += 1;
 4,912,544 (0.0%)          if (sequence_number->data[i]) {
   699,052 (0.0%)              break;
         .                 }
         .         
         .                 /* RFC 5246 6.1: If a TLS implementation would need to wrap a sequence number, it must
         .                  * renegotiate instead. We don't support renegotiation. Caller needs to create a new session.
         .                  * This condition is very unlikely. It requires 2^64 - 1 records to be sent.
         .                  */
     5,480 (0.0%)          S2N_ERROR_IF(i == 0, S2N_ERR_RECORD_LIMIT);
         .         
         .                 /* seq[i] wrapped, so let it carry */
         .             }
         .         
   699,052 (0.0%)      return 0;
 2,097,156 (0.0%)  }
         .         
         .         int s2n_sequence_number_to_uint64(struct s2n_blob *sequence_number, uint64_t *output)
 2,446,682 (0.0%)  {
   699,052 (0.0%)      POSIX_ENSURE_REF(sequence_number);
         .         
   349,526 (0.0%)      uint8_t shift = 0;
   699,052 (0.0%)      *output = 0;
         .         
10,485,780 (0.1%)      for (uint32_t i = sequence_number->size; i > 0; i--) {
47,535,536 (0.3%)          *output += ((uint64_t) sequence_number->data[i - 1]) << shift;
 2,796,208 (0.0%)          shift += SEQUENCE_NUMBER_POWER;
         .             }
   349,526 (0.0%)      return S2N_SUCCESS;
 1,048,578 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c
--------------------------------------------------------------------------------
Ir________________ 

-- line 18 ----------------------------------------
          .         #include <sys/param.h>
          .         
          .         #include "error/s2n_errno.h"
          .         #include "utils/s2n_blob.h"
          .         #include "utils/s2n_mem.h"
          .         #include "utils/s2n_safety.h"
          .         
          .         S2N_RESULT s2n_stuffer_validate(const struct s2n_stuffer *stuffer)
308,281,932 (1.9%)  {
          .             /**
          .              * Note that we do not assert any properties on the tainted field,
          .              * as any boolean value in that field is valid.
          .              */
102,760,644 (0.6%)      RESULT_ENSURE_REF(stuffer);
411,042,576 (2.5%)      RESULT_GUARD(s2n_blob_validate(&stuffer->blob));
506,113,648 (3.1%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(stuffer->growable, stuffer->alloced), S2N_ERR_SAFETY);
          .         
          .             /* <= is valid because we can have a fully written/read stuffer */
462,422,898 (2.8%)      RESULT_DEBUG_ENSURE(stuffer->high_water_mark <= stuffer->blob.size, S2N_ERR_SAFETY);
462,422,898 (2.8%)      RESULT_DEBUG_ENSURE(stuffer->write_cursor <= stuffer->high_water_mark, S2N_ERR_SAFETY);
462,422,898 (2.8%)      RESULT_DEBUG_ENSURE(stuffer->read_cursor <= stuffer->write_cursor, S2N_ERR_SAFETY);
 51,380,322 (0.3%)      return S2N_RESULT_OK;
154,140,966 (0.9%)  }
          .         
          .         S2N_RESULT s2n_stuffer_reservation_validate(const struct s2n_stuffer_reservation *reservation)
          .         {
          .             /**
          .              * Note that we need two dereferences here to decrease proof complexity
          .              * for CBMC (see https://github.com/awslabs/s2n/issues/2290). We can roll back
          .              * this change once CBMC can handle common subexpression elimination.
          .              */
-- line 48 ----------------------------------------
-- line 56 ----------------------------------------
          .             /* The entire reservation must fit between the stuffer read and write cursors */
          .             RESULT_ENSURE_LTE(reserve_obj.write_cursor + reserve_obj.length, stuffer_obj.write_cursor);
          .             RESULT_ENSURE_GTE(reserve_obj.write_cursor, stuffer_obj.read_cursor);
          .         
          .             return S2N_RESULT_OK;
          .         }
          .         
          .         int s2n_stuffer_init(struct s2n_stuffer *stuffer, struct s2n_blob *in)
  7,340,046 (0.0%)  {
  2,097,156 (0.0%)      POSIX_ENSURE_MUT(stuffer);
 15,728,670 (0.1%)      POSIX_PRECONDITION(s2n_blob_validate(in));
  8,388,624 (0.1%)      stuffer->blob = *in;
  2,097,156 (0.0%)      stuffer->read_cursor = 0;
  2,097,156 (0.0%)      stuffer->write_cursor = 0;
  2,097,156 (0.0%)      stuffer->high_water_mark = 0;
  4,194,312 (0.0%)      stuffer->alloced = 0;
  4,194,312 (0.0%)      stuffer->growable = 0;
  4,194,312 (0.0%)      stuffer->tainted = 0;
 15,728,670 (0.1%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  1,048,578 (0.0%)      return S2N_SUCCESS;
  3,145,734 (0.0%)  }
          .         
          .         int s2n_stuffer_init_written(struct s2n_stuffer *stuffer, struct s2n_blob *in)
          .         {
          .             POSIX_ENSURE_REF(in);
          .             POSIX_GUARD(s2n_stuffer_init(stuffer, in));
          .             POSIX_GUARD(s2n_stuffer_skip_write(stuffer, in->size));
          .             return S2N_SUCCESS;
          .         }
-- line 84 ----------------------------------------
-- line 102 ----------------------------------------
          .         
          .             stuffer->growable = 1;
          .         
          .             POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
          .             return S2N_SUCCESS;
          .         }
          .         
          .         int s2n_stuffer_free(struct s2n_stuffer *stuffer)
  3,495,260 (0.0%)  {
 10,485,780 (0.1%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
  3,495,260 (0.0%)      if (stuffer->alloced) {
          .                 POSIX_GUARD(s2n_free(&stuffer->blob));
          .             }
  3,495,260 (0.0%)      *stuffer = (struct s2n_stuffer){ 0 };
    699,052 (0.0%)      return S2N_SUCCESS;
  1,398,104 (0.0%)  }
          .         
          .         int s2n_stuffer_free_without_wipe(struct s2n_stuffer *stuffer)
          .         {
          .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
          .             if (stuffer->alloced) {
          .                 POSIX_GUARD(s2n_free_without_wipe(&stuffer->blob));
          .             }
          .             *stuffer = (struct s2n_stuffer){ 0 };
          .             return S2N_SUCCESS;
          .         }
          .         
          .         int s2n_stuffer_resize(struct s2n_stuffer *stuffer, const uint32_t size)
  2,446,682 (0.0%)  {
  5,242,890 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
  1,747,630 (0.0%)      POSIX_ENSURE(!stuffer->tainted, S2N_ERR_RESIZE_TAINTED_STUFFER);
  1,747,630 (0.0%)      POSIX_ENSURE(stuffer->growable, S2N_ERR_RESIZE_STATIC_STUFFER);
          .         
  1,398,104 (0.0%)      if (size == stuffer->blob.size) {
    699,052 (0.0%)          return S2N_SUCCESS;
          .             }
          .         
          .             if (size == 0) {
          .                 s2n_stuffer_wipe(stuffer);
          .                 return s2n_free(&stuffer->blob);
          .             }
          .         
          .             if (size < stuffer->blob.size) {
-- line 144 ----------------------------------------
-- line 155 ----------------------------------------
          .                 stuffer->blob.size = size;
          .                 POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
          .                 return S2N_SUCCESS;
          .             }
          .         
          .             POSIX_GUARD(s2n_realloc(&stuffer->blob, size));
          .             POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
          .             return S2N_SUCCESS;
  1,048,578 (0.0%)  }
          .         
          .         int s2n_stuffer_resize_if_empty(struct s2n_stuffer *stuffer, const uint32_t size)
  4,893,364 (0.0%)  {
 10,485,780 (0.1%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
  2,796,208 (0.0%)      if (stuffer->blob.data == NULL) {
          .                 POSIX_ENSURE(!stuffer->tainted, S2N_ERR_RESIZE_TAINTED_STUFFER);
          .                 POSIX_ENSURE(stuffer->growable, S2N_ERR_RESIZE_STATIC_STUFFER);
          .                 POSIX_GUARD(s2n_realloc(&stuffer->blob, size));
          .             }
 10,485,780 (0.1%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    699,052 (0.0%)      return S2N_SUCCESS;
  2,097,156 (0.0%)  }
          .         
          .         int s2n_stuffer_rewrite(struct s2n_stuffer *stuffer)
  6,990,520 (0.0%)  {
 20,971,560 (0.1%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
  2,796,208 (0.0%)      stuffer->write_cursor = 0;
  2,796,208 (0.0%)      stuffer->read_cursor = 0;
 20,971,560 (0.1%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  1,398,104 (0.0%)      return S2N_SUCCESS;
  2,796,208 (0.0%)  }
          .         
          .         int s2n_stuffer_rewind_read(struct s2n_stuffer *stuffer, const uint32_t size)
  4,893,364 (0.0%)  {
 10,485,780 (0.1%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
  2,796,208 (0.0%)      POSIX_ENSURE(stuffer->read_cursor >= size, S2N_ERR_STUFFER_OUT_OF_DATA);
  4,194,312 (0.0%)      stuffer->read_cursor -= size;
 10,485,780 (0.1%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    699,052 (0.0%)      return S2N_SUCCESS;
  2,097,156 (0.0%)  }
          .         
          .         int s2n_stuffer_reread(struct s2n_stuffer *stuffer)
 10,485,780 (0.1%)  {
 31,457,340 (0.2%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
  4,194,312 (0.0%)      stuffer->read_cursor = 0;
  2,097,156 (0.0%)      return S2N_SUCCESS;
  4,194,312 (0.0%)  }
          .         
          .         int s2n_stuffer_wipe_n(struct s2n_stuffer *stuffer, const uint32_t size)
  4,893,364 (0.0%)  {
 10,485,780 (0.1%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
  4,194,312 (0.0%)      uint32_t wipe_size = MIN(size, stuffer->write_cursor);
          .         
  4,194,312 (0.0%)      stuffer->write_cursor -= wipe_size;
  5,592,416 (0.0%)      stuffer->read_cursor = MIN(stuffer->read_cursor, stuffer->write_cursor);
 14,680,092 (0.1%)      POSIX_CHECKED_MEMSET(stuffer->blob.data + stuffer->write_cursor, S2N_WIPE_PATTERN, wipe_size);
          .         
 10,485,780 (0.1%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    699,052 (0.0%)      return S2N_SUCCESS;
  2,097,156 (0.0%)  }
          .         
          .         bool s2n_stuffer_is_consumed(struct s2n_stuffer *stuffer)
  1,398,104 (0.0%)  {
  5,592,416 (0.0%)      return stuffer && (stuffer->read_cursor == stuffer->write_cursor) && !stuffer->tainted;
    699,052 (0.0%)  }
          .         
          .         int s2n_stuffer_wipe(struct s2n_stuffer *stuffer)
  6,291,468 (0.0%)  {
 15,728,670 (0.1%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
  4,194,312 (0.0%)      if (!s2n_stuffer_is_wiped(stuffer)) {
 12,582,936 (0.1%)          POSIX_CHECKED_MEMSET(stuffer->blob.data, S2N_WIPE_PATTERN, stuffer->high_water_mark);
          .             }
          .         
  4,194,312 (0.0%)      stuffer->tainted = 0;
  2,097,156 (0.0%)      stuffer->write_cursor = 0;
  2,097,156 (0.0%)      stuffer->read_cursor = 0;
  2,097,156 (0.0%)      stuffer->high_water_mark = 0;
 15,728,670 (0.1%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  1,048,578 (0.0%)      return S2N_SUCCESS;
  3,145,734 (0.0%)  }
          .         
          .         int s2n_stuffer_skip_read(struct s2n_stuffer *stuffer, uint32_t n)
 34,253,548 (0.2%)  {
 73,400,460 (0.5%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 34,253,548 (0.2%)      POSIX_ENSURE(s2n_stuffer_data_available(stuffer) >= n, S2N_ERR_STUFFER_OUT_OF_DATA);
          .         
 29,360,184 (0.2%)      stuffer->read_cursor += n;
  4,893,364 (0.0%)      return S2N_SUCCESS;
 14,680,092 (0.1%)  }
          .         
          .         void *s2n_stuffer_raw_read(struct s2n_stuffer *stuffer, uint32_t data_len)
  4,194,312 (0.0%)  {
  4,893,364 (0.0%)      PTR_GUARD_POSIX(s2n_stuffer_skip_read(stuffer, data_len));
          .         
  2,796,208 (0.0%)      stuffer->tainted = 1;
          .         
  9,087,676 (0.1%)      return (stuffer->blob.data) ? (stuffer->blob.data + stuffer->read_cursor - data_len) : NULL;
  1,398,104 (0.0%)  }
          .         
          .         int s2n_stuffer_read(struct s2n_stuffer *stuffer, struct s2n_blob *out)
          .         {
          .             POSIX_ENSURE_REF(out);
          .         
          .             return s2n_stuffer_read_bytes(stuffer, out->data, out->size);
          .         }
          .         
          .         int s2n_stuffer_erase_and_read(struct s2n_stuffer *stuffer, struct s2n_blob *out)
  2,446,682 (0.0%)  {
  2,796,208 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_read(stuffer, out->size));
          .         
  5,941,942 (0.0%)      void *ptr = (stuffer->blob.data) ? (stuffer->blob.data + stuffer->read_cursor - out->size) : NULL;
  2,097,156 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, out->size), S2N_ERR_NULL);
          .         
  6,291,468 (0.0%)      POSIX_CHECKED_MEMCPY(out->data, ptr, out->size);
  5,941,942 (0.0%)      POSIX_CHECKED_MEMSET(ptr, 0, out->size);
          .         
    349,526 (0.0%)      return S2N_SUCCESS;
  1,048,578 (0.0%)  }
          .         
          .         int s2n_stuffer_read_bytes(struct s2n_stuffer *stuffer, uint8_t *data, uint32_t size)
 19,573,456 (0.1%)  {
  4,893,364 (0.0%)      POSIX_ENSURE_REF(data);
 36,700,230 (0.2%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 17,126,774 (0.1%)      POSIX_GUARD(s2n_stuffer_skip_read(stuffer, size));
  9,786,728 (0.1%)      POSIX_ENSURE_REF(stuffer->blob.data);
 22,020,138 (0.1%)      void *ptr = stuffer->blob.data + stuffer->read_cursor - size;
          .         
 39,146,912 (0.2%)      POSIX_CHECKED_MEMCPY(data, ptr, size);
          .         
  2,446,682 (0.0%)      return S2N_SUCCESS;
  7,340,046 (0.0%)  }
          .         
          .         int s2n_stuffer_erase_and_read_bytes(struct s2n_stuffer *stuffer, uint8_t *data, uint32_t size)
          .         {
          .             POSIX_GUARD(s2n_stuffer_skip_read(stuffer, size));
          .             POSIX_ENSURE_REF(stuffer->blob.data);
          .             void *ptr = stuffer->blob.data + stuffer->read_cursor - size;
          .         
          .             POSIX_CHECKED_MEMCPY(data, ptr, size);
          .             POSIX_CHECKED_MEMSET(ptr, 0, size);
          .         
          .             return S2N_SUCCESS;
          .         }
          .         
          .         int s2n_stuffer_skip_write(struct s2n_stuffer *stuffer, const uint32_t n)
 35,651,652 (0.2%)  {
 89,129,130 (0.5%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 41,593,594 (0.3%)      POSIX_GUARD(s2n_stuffer_reserve_space(stuffer, n));
 35,651,652 (0.2%)      stuffer->write_cursor += n;
 47,535,536 (0.3%)      stuffer->high_water_mark = MAX(stuffer->write_cursor, stuffer->high_water_mark);
 89,129,130 (0.5%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  5,941,942 (0.0%)      return S2N_SUCCESS;
 11,883,884 (0.1%)  }
          .         
          .         void *s2n_stuffer_raw_write(struct s2n_stuffer *stuffer, const uint32_t data_len)
  4,194,312 (0.0%)  {
  4,893,364 (0.0%)      PTR_GUARD_POSIX(s2n_stuffer_skip_write(stuffer, data_len));
          .         
  2,796,208 (0.0%)      stuffer->tainted = 1;
          .         
  9,087,676 (0.1%)      return (stuffer->blob.data) ? (stuffer->blob.data + stuffer->write_cursor - data_len) : NULL;
  1,398,104 (0.0%)  }
          .         
          .         int s2n_stuffer_write(struct s2n_stuffer *stuffer, const struct s2n_blob *in)
          .         {
          .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
          .             POSIX_PRECONDITION(s2n_blob_validate(in));
          .             return s2n_stuffer_write_bytes(stuffer, in->data, in->size);
          .         }
          .         
          .         int s2n_stuffer_write_bytes(struct s2n_stuffer *stuffer, const uint8_t *data, const uint32_t size)
 19,573,456 (0.1%)  {
  9,786,728 (0.1%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_SAFETY);
 36,700,230 (0.2%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 17,126,774 (0.1%)      POSIX_GUARD(s2n_stuffer_skip_write(stuffer, size));
          .         
 22,020,138 (0.1%)      void *ptr = stuffer->blob.data + stuffer->write_cursor - size;
  9,786,728 (0.1%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, size), S2N_ERR_NULL);
          .         
  7,340,046 (0.0%)      if (ptr == data) {
          .                 POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
          .                 return S2N_SUCCESS;
          .             }
          .         
 39,146,912 (0.2%)      POSIX_CHECKED_MEMCPY(ptr, data, size);
          .         
 36,700,230 (0.2%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  2,446,682 (0.0%)      return S2N_SUCCESS;
  7,340,046 (0.0%)  }
          .         
          .         int s2n_stuffer_writev_bytes(struct s2n_stuffer *stuffer, const struct iovec *iov, size_t iov_count, uint32_t offs,
          .                 uint32_t size)
  3,495,260 (0.0%)  {
  5,242,890 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    699,052 (0.0%)      POSIX_ENSURE_REF(iov);
  2,097,156 (0.0%)      void *ptr = s2n_stuffer_raw_write(stuffer, size);
  1,398,104 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, size), S2N_ERR_NULL);
          .         
  1,398,104 (0.0%)      size_t size_left = size, to_skip = offs;
  1,747,630 (0.0%)      for (size_t i = 0; i < iov_count; i++) {
  2,796,208 (0.0%)          if (to_skip >= iov[i].iov_len) {
          .                     to_skip -= iov[i].iov_len;
          .                     continue;
          .                 }
  2,796,208 (0.0%)          size_t iov_len_op = iov[i].iov_len - to_skip;
  1,048,578 (0.0%)          POSIX_ENSURE_LTE(iov_len_op, UINT32_MAX);
    699,052 (0.0%)          uint32_t iov_len = (uint32_t) iov_len_op;
  1,747,630 (0.0%)          uint32_t iov_size_to_take = MIN(size_left, iov_len);
  2,796,208 (0.0%)          POSIX_ENSURE_REF(iov[i].iov_base);
  2,796,208 (0.0%)          POSIX_ENSURE_LT(to_skip, iov[i].iov_len);
  8,039,098 (0.0%)          POSIX_CHECKED_MEMCPY(ptr, ((uint8_t *) (iov[i].iov_base)) + to_skip, iov_size_to_take);
    699,052 (0.0%)          size_left -= iov_size_to_take;
    699,052 (0.0%)          if (size_left == 0) {
    349,526 (0.0%)              break;
          .                 }
          .                 ptr = (void *) ((uint8_t *) ptr + iov_size_to_take);
          .                 to_skip = 0;
          .             }
          .         
    349,526 (0.0%)      return S2N_SUCCESS;
  1,048,578 (0.0%)  }
          .         
          .         static int s2n_stuffer_copy_impl(struct s2n_stuffer *from, struct s2n_stuffer *to, const uint32_t len)
  2,796,208 (0.0%)  {
  2,446,682 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_read(from, len));
  2,446,682 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(to, len));
          .         
  4,893,364 (0.0%)      uint8_t *from_ptr = (from->blob.data) ? (from->blob.data + from->read_cursor - len) : NULL;
  4,893,364 (0.0%)      uint8_t *to_ptr = (to->blob.data) ? (to->blob.data + to->write_cursor - len) : NULL;
          .         
  5,592,416 (0.0%)      POSIX_CHECKED_MEMCPY(to_ptr, from_ptr, len);
          .         
    349,526 (0.0%)      return S2N_SUCCESS;
  1,048,578 (0.0%)  }
          .         
          .         int s2n_stuffer_reserve_space(struct s2n_stuffer *stuffer, uint32_t n)
 66,409,940 (0.4%)  {
 99,614,910 (0.6%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 46,486,958 (0.3%)      if (s2n_stuffer_space_remaining(stuffer) < n) {
          .                 POSIX_ENSURE(stuffer->growable, S2N_ERR_STUFFER_IS_FULL);
          .                 /* Always grow a stuffer by at least 1k */
          .                 const uint32_t growth = MAX(n - s2n_stuffer_space_remaining(stuffer), S2N_MIN_STUFFER_GROWTH_IN_BYTES);
          .                 uint32_t new_size = 0;
          .                 POSIX_GUARD(s2n_add_overflow(stuffer->blob.size, growth, &new_size));
          .                 POSIX_GUARD(s2n_stuffer_resize(stuffer, new_size));
          .             }
 99,614,910 (0.6%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  6,640,994 (0.0%)      return S2N_SUCCESS;
 39,845,964 (0.2%)  }
          .         
          .         /* Copies "len" bytes from "from" to "to".
          .          * If the copy cannot succeed (i.e. there are either not enough bytes available, or there is not enough space to write them
          .          * restore the old value of the stuffer */
          .         int s2n_stuffer_copy(struct s2n_stuffer *from, struct s2n_stuffer *to, const uint32_t len)
  2,446,682 (0.0%)  {
  1,048,578 (0.0%)      const uint32_t orig_read_cursor = from->read_cursor;
  1,048,578 (0.0%)      const uint32_t orig_write_cursor = to->write_cursor;
          .         
  2,796,208 (0.0%)      if (s2n_stuffer_copy_impl(from, to, len) < 0) {
          .                 from->read_cursor = orig_read_cursor;
          .                 to->write_cursor = orig_write_cursor;
          .                 S2N_ERROR_PRESERVE_ERRNO();
          .             }
          .         
    349,526 (0.0%)      return S2N_SUCCESS;
    699,052 (0.0%)  }
          .         
          .         int s2n_stuffer_extract_blob(struct s2n_stuffer *stuffer, struct s2n_blob *out)
          .         {
          .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
          .             POSIX_ENSURE_REF(out);
          .             POSIX_GUARD(s2n_realloc(out, s2n_stuffer_data_available(stuffer)));
          .         
          .             if (s2n_stuffer_data_available(stuffer) > 0) {
-- line 427 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_network_order.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 15 ----------------------------------------
        .         
        .         #include "error/s2n_errno.h"
        .         #include "stuffer/s2n_stuffer.h"
        .         #include "utils/s2n_annotations.h"
        .         #include "utils/s2n_safety.h"
        .         
        .         /* Writes length bytes of input to stuffer, in network order, starting from the smallest byte of input. */
        .         int s2n_stuffer_write_network_order(struct s2n_stuffer *stuffer, const uint64_t input, const uint8_t length)
3,145,734 (0.0%)  {
  699,052 (0.0%)      if (length == 0) {
        .                 return S2N_SUCCESS;
        .             }
  699,052 (0.0%)      POSIX_ENSURE_REF(stuffer);
  699,052 (0.0%)      POSIX_ENSURE(length <= sizeof(input), S2N_ERR_SAFETY);
2,446,682 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(stuffer, length));
1,398,104 (0.0%)      POSIX_ENSURE_REF(stuffer->blob.data);
3,145,734 (0.0%)      uint8_t *data = stuffer->blob.data + stuffer->write_cursor - length;
4,543,838 (0.0%)      for (int i = 0; i < length; i++) {
        .                 S2N_INVARIANT(i <= length);
3,495,260 (0.0%)          uint8_t shift = (length - i - 1) * CHAR_BIT;
7,689,572 (0.0%)          data[i] = (input >> (shift)) & UINT8_MAX;
        .             }
5,242,890 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  349,526 (0.0%)      return S2N_SUCCESS;
1,048,578 (0.0%)  }
        .         
        .         int s2n_stuffer_reserve(struct s2n_stuffer *stuffer, struct s2n_stuffer_reservation *reservation, const uint8_t length)
        .         {
        .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
        .             POSIX_ENSURE_REF(reservation);
        .         
        .             *reservation = (struct s2n_stuffer_reservation){ .stuffer = stuffer,
        .                 .write_cursor = stuffer->write_cursor,
-- line 47 ----------------------------------------
-- line 49 ----------------------------------------
        .         
        .             POSIX_GUARD(s2n_stuffer_skip_write(stuffer, reservation->length));
        .             POSIX_CHECKED_MEMSET(stuffer->blob.data + reservation->write_cursor, S2N_WIPE_PATTERN, reservation->length);
        .             POSIX_POSTCONDITION(s2n_stuffer_reservation_validate(reservation));
        .             return S2N_SUCCESS;
        .         }
        .         
        .         int s2n_stuffer_read_uint8(struct s2n_stuffer *stuffer, uint8_t *u)
6,291,468 (0.0%)  {
8,388,624 (0.1%)      POSIX_GUARD(s2n_stuffer_read_bytes(stuffer, u, sizeof(uint8_t)));
        .         
1,048,578 (0.0%)      return S2N_SUCCESS;
2,097,156 (0.0%)  }
        .         
        .         int s2n_stuffer_write_uint8(struct s2n_stuffer *stuffer, const uint8_t u)
4,893,364 (0.0%)  {
5,592,416 (0.0%)      POSIX_GUARD(s2n_stuffer_write_bytes(stuffer, &u, sizeof(u)));
        .         
  699,052 (0.0%)      return S2N_SUCCESS;
1,398,104 (0.0%)  }
        .         
        .         int s2n_stuffer_reserve_uint8(struct s2n_stuffer *stuffer, struct s2n_stuffer_reservation *reservation)
        .         {
        .             return s2n_stuffer_reserve(stuffer, reservation, sizeof(uint8_t));
        .         }
        .         
        .         int s2n_stuffer_read_uint16(struct s2n_stuffer *stuffer, uint16_t *u)
6,990,520 (0.0%)  {
1,398,104 (0.0%)      POSIX_ENSURE_REF(u);
        .             uint8_t data[sizeof(uint16_t)];
        .         
5,592,416 (0.0%)      POSIX_GUARD(s2n_stuffer_read_bytes(stuffer, data, sizeof(data)));
        .         
4,194,312 (0.0%)      *u = data[0] << 8;
4,893,364 (0.0%)      *u |= data[1];
        .         
  699,052 (0.0%)      return S2N_SUCCESS;
4,194,312 (0.0%)  }
        .         
        .         int s2n_stuffer_write_uint16(struct s2n_stuffer *stuffer, const uint16_t u)
2,446,682 (0.0%)  {
2,097,156 (0.0%)      return s2n_stuffer_write_network_order(stuffer, u, sizeof(u));
  699,052 (0.0%)  }
        .         
        .         int s2n_stuffer_reserve_uint16(struct s2n_stuffer *stuffer, struct s2n_stuffer_reservation *reservation)
        .         {
        .             return s2n_stuffer_reserve(stuffer, reservation, sizeof(uint16_t));
        .         }
        .         
        .         int s2n_stuffer_read_uint24(struct s2n_stuffer *stuffer, uint32_t *u)
        .         {
-- line 99 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_aead.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 44 ----------------------------------------
        .         
        .             /* Double check no overflow */
        .             RESULT_ENSURE_LTE(idx, ad->size);
        .             return S2N_RESULT_OK;
        .         }
        .         
        .         /* Prepares an AAD (additional authentication data) for a TLS 1.3 AEAD record */
        .         S2N_RESULT s2n_tls13_aead_aad_init(uint16_t record_length, uint8_t tag_length, struct s2n_blob *additional_data)
7,689,572 (0.0%)  {
1,398,104 (0.0%)      RESULT_ENSURE_GT(tag_length, 0);
1,398,104 (0.0%)      RESULT_ENSURE_REF(additional_data);
2,796,208 (0.0%)      RESULT_ENSURE_GTE(additional_data->size, S2N_TLS13_AAD_LEN);
        .         
2,097,156 (0.0%)      uint8_t *data = additional_data->data;
1,398,104 (0.0%)      RESULT_GUARD_PTR(data);
        .         
  699,052 (0.0%)      size_t idx = 0;
        .         
        .             /**
        .              *= https://www.rfc-editor.org/rfc/rfc8446#section-5.2
        .              *# opaque_type:  The outer opaque_type field of a TLSCiphertext record
        .              *#    is always set to the value 23 (application_data) for outward
        .              *#    compatibility with middleboxes accustomed to parsing previous
        .              *#    versions of TLS.  The actual content type of the record is found
        .              *#    in TLSInnerPlaintext.type after decryption.
        .              **/
4,194,312 (0.0%)      data[idx++] = TLS_APPLICATION_DATA;
        .         
        .             /**
        .              *= https://www.rfc-editor.org/rfc/rfc8446#section-5.2
        .              *# legacy_record_version:  The legacy_record_version field is always
        .              *#    0x0303.  TLS 1.3 TLSCiphertexts are not generated until after
        .              *#    TLS 1.3 has been negotiated, so there are no historical
        .              *#    compatibility concerns where other values might be received.  Note
        .              *#    that the handshake protocol, including the ClientHello and
        .              *#    ServerHello messages, authenticates the protocol version, so this
        .              *#    value is redundant.
        .              */
4,194,312 (0.0%)      data[idx++] = 0x03;
4,194,312 (0.0%)      data[idx++] = 0x03;
        .         
        .             /**
        .              *= https://www.rfc-editor.org/rfc/rfc8446#section-5.2
        .              *# length:  The length (in bytes) of the following
        .              *#    TLSCiphertext.encrypted_record, which is the sum of the lengths of
        .              *#    the content and the padding, plus one for the inner content type,
        .              *#    plus any expansion added by the AEAD algorithm.  The length
        .              *#    MUST NOT exceed 2^14 + 256 bytes.  An endpoint that receives a
        .              *#    record that exceeds this length MUST terminate the connection with
        .              *#    a "record_overflow" alert.
        .              */
2,796,208 (0.0%)      uint16_t length = record_length + tag_length;
1,398,104 (0.0%)      RESULT_ENSURE(length <= (1 << 14) + 256, S2N_ERR_RECORD_LIMIT);
6,990,520 (0.0%)      data[idx++] = length >> 8;
4,893,364 (0.0%)      data[idx++] = length & UINT8_MAX;
        .         
        .             /* Double check no overflow */
3,495,260 (0.0%)      RESULT_ENSURE_LTE(idx, additional_data->size);
  699,052 (0.0%)      return S2N_RESULT_OK;
2,097,156 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_connection.c
--------------------------------------------------------------------------------
Ir_______________ 

-- line 1256 ----------------------------------------
         .                     r = nanosleep(&sleep_time, &sleep_time);
         .                 } while (r != 0);
         .             }
         .         
         .             return S2N_RESULT_OK;
         .         }
         .         
         .         S2N_CLEANUP_RESULT s2n_connection_apply_error_blinding(struct s2n_connection **conn)
 4,194,312 (0.0%)  {
 1,398,104 (0.0%)      RESULT_ENSURE_REF(conn);
 2,796,208 (0.0%)      if (*conn == NULL) {
 1,398,104 (0.0%)          return S2N_RESULT_OK;
         .             }
         .         
         .             /* Ensure that conn->in doesn't contain any leftover invalid or unauthenticated data. */
         .             RESULT_GUARD_POSIX(s2n_stuffer_wipe(&(*conn)->in));
         .         
         .             int error_code = s2n_errno;
         .             int error_type = s2n_error_get_type(error_code);
         .         
-- line 1275 ----------------------------------------
-- line 1301 ----------------------------------------
         .                     break;
         .                 default:
         .                     /* Apply blinding to all other errors */
         .                     RESULT_GUARD(s2n_connection_kill(*conn));
         .                     break;
         .             }
         .         
         .             return S2N_RESULT_OK;
 2,097,156 (0.0%)  }
         .         
         .         S2N_RESULT s2n_connection_set_closed(struct s2n_connection *conn)
         .         {
         .             RESULT_ENSURE_REF(conn);
         .             s2n_atomic_flag_set(&conn->read_closed);
         .             s2n_atomic_flag_set(&conn->write_closed);
         .             return S2N_RESULT_OK;
         .         }
-- line 1317 ----------------------------------------
-- line 1389 ----------------------------------------
         .             conn->verify_host_fn = verify_host_fn;
         .             conn->data_for_verify_host = data;
         .             conn->verify_host_fn_overridden = 1;
         .         
         .             return 0;
         .         }
         .         
         .         int s2n_connection_recv_stuffer(struct s2n_stuffer *stuffer, struct s2n_connection *conn, uint32_t len)
 5,592,416 (0.0%)  {
 2,796,208 (0.0%)      POSIX_ENSURE_REF(conn->recv);
         .             /* Make sure we have enough space to write */
 4,893,364 (0.0%)      POSIX_GUARD(s2n_stuffer_reserve_space(stuffer, len));
         .         
   699,052 (0.0%)      int r = 0;
12,582,936 (0.1%)      S2N_IO_RETRY_EINTR(r,
         .                     conn->recv(conn->recv_io_context, stuffer->blob.data + stuffer->write_cursor, len));
 1,398,104 (0.0%)      POSIX_ENSURE(r >= 0, S2N_ERR_RECV_STUFFER_FROM_CONN);
         .         
         .             /* Record just how many bytes we have written */
 4,893,364 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(stuffer, r));
   699,052 (0.0%)      return r;
 2,097,156 (0.0%)  }
         .         
         .         int s2n_connection_send_stuffer(struct s2n_stuffer *stuffer, struct s2n_connection *conn, uint32_t len)
 2,796,208 (0.0%)  {
   699,052 (0.0%)      POSIX_ENSURE_REF(conn);
 1,398,104 (0.0%)      POSIX_ENSURE_REF(conn->send);
 1,747,630 (0.0%)      if (conn->write_fd_broken) {
         .                 POSIX_BAIL(S2N_ERR_SEND_STUFFER_TO_CONN);
         .             }
         .             /* Make sure we even have the data */
 2,446,682 (0.0%)      S2N_ERROR_IF(s2n_stuffer_data_available(stuffer) < len, S2N_ERR_STUFFER_OUT_OF_DATA);
         .         
   349,526 (0.0%)      int w = 0;
 6,291,468 (0.0%)      S2N_IO_RETRY_EINTR(w,
         .                     conn->send(conn->send_io_context, stuffer->blob.data + stuffer->read_cursor, len));
   699,052 (0.0%)      if (w < 0 && errno == EPIPE) {
         .                 conn->write_fd_broken = 1;
         .             }
   699,052 (0.0%)      POSIX_ENSURE(w >= 0, S2N_ERR_SEND_STUFFER_TO_CONN);
         .         
 2,446,682 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_read(stuffer, w));
   349,526 (0.0%)      return w;
 1,048,578 (0.0%)  }
         .         
         .         int s2n_connection_is_managed_corked(const struct s2n_connection *s2n_connection)
         .         {
         .             POSIX_ENSURE_REF(s2n_connection);
         .         
         .             return (s2n_connection->managed_send_io && s2n_connection->corked_io);
         .         }
         .         
-- line 1440 ----------------------------------------
-- line 1458 ----------------------------------------
         .         
         .         struct s2n_cert_chain_and_key *s2n_connection_get_selected_cert(struct s2n_connection *conn)
         .         {
         .             PTR_ENSURE_REF(conn);
         .             return conn->handshake_params.our_chain_and_key;
         .         }
         .         
         .         uint8_t s2n_connection_get_protocol_version(const struct s2n_connection *conn)
 4,194,312 (0.0%)  {
 2,097,156 (0.0%)      if (conn == NULL) {
         .                 return S2N_UNKNOWN_PROTOCOL_VERSION;
         .             }
         .         
 4,194,312 (0.0%)      if (conn->actual_protocol_version != S2N_UNKNOWN_PROTOCOL_VERSION) {
 3,145,734 (0.0%)          return conn->actual_protocol_version;
         .             }
         .         
         .             if (conn->mode == S2N_CLIENT) {
         .                 return conn->client_protocol_version;
         .             }
         .             return conn->server_protocol_version;
 2,097,156 (0.0%)  }
         .         
         .         DEFINE_POINTER_CLEANUP_FUNC(struct s2n_cert_chain *, s2n_cert_chain_free);
         .         
         .         int s2n_connection_get_peer_cert_chain(const struct s2n_connection *conn, struct s2n_cert_chain_and_key *cert_chain_and_key)
         .         {
         .             POSIX_ENSURE_REF(conn);
         .             POSIX_ENSURE_REF(cert_chain_and_key);
         .             POSIX_ENSURE_REF(cert_chain_and_key->cert_chain);
-- line 1487 ----------------------------------------
-- line 1659 ----------------------------------------
         .             }
         .         
         .             *config = conn->config;
         .         
         .             return S2N_SUCCESS;
         .         }
         .         
         .         S2N_RESULT s2n_connection_dynamic_free_out_buffer(struct s2n_connection *conn)
 2,097,156 (0.0%)  {
   699,052 (0.0%)      RESULT_ENSURE_REF(conn);
         .         
         .             /* free the out buffer if we're in dynamic mode and it's completely flushed */
 1,747,630 (0.0%)      if (conn->dynamic_buffers && s2n_stuffer_is_consumed(&conn->out)) {
         .                 /* since outgoing buffers are already encrypted, the buffers don't need to be zeroed, which saves some overhead */
         .                 RESULT_GUARD_POSIX(s2n_stuffer_free_without_wipe(&conn->out));
         .         
         .                 /* reset the stuffer to its initial state */
         .                 RESULT_GUARD_POSIX(s2n_stuffer_growable_alloc(&conn->out, 0));
         .             }
         .         
   349,526 (0.0%)      return S2N_RESULT_OK;
 1,048,578 (0.0%)  }
         .         
         .         S2N_RESULT s2n_connection_dynamic_free_in_buffer(struct s2n_connection *conn)
 2,097,156 (0.0%)  {
   699,052 (0.0%)      RESULT_ENSURE_REF(conn);
         .         
         .             /* free `buffer_in` if we're in dynamic mode and it's completely flushed */
 1,747,630 (0.0%)      if (conn->dynamic_buffers && s2n_stuffer_is_consumed(&conn->buffer_in)) {
         .                 /* when copying the buffer into the application, we use `s2n_stuffer_erase_and_read`, which already zeroes the memory */
         .                 RESULT_GUARD_POSIX(s2n_stuffer_free_without_wipe(&conn->buffer_in));
         .         
         .                 /* reset the stuffer to its initial state */
         .                 RESULT_GUARD_POSIX(s2n_stuffer_growable_alloc(&conn->buffer_in, 0));
         .             }
         .         
   349,526 (0.0%)      return S2N_RESULT_OK;
 1,048,578 (0.0%)  }
         .         
         .         bool s2n_connection_check_io_status(struct s2n_connection *conn, s2n_io_status status)
 6,291,468 (0.0%)  {
 2,097,156 (0.0%)      if (!conn) {
         .                 return false;
         .             }
         .         
 5,242,890 (0.0%)      bool read_closed = s2n_atomic_flag_test(&conn->read_closed);
 5,242,890 (0.0%)      bool write_closed = s2n_atomic_flag_test(&conn->write_closed);
12,582,936 (0.1%)      bool full_duplex = !read_closed && !write_closed;
         .         
         .             /*
         .              *= https://www.rfc-editor.org/rfc/rfc8446#section-6.1
         .              *# Note that this is a change from versions of TLS prior to TLS 1.3 in
         .              *# which implementations were required to react to a "close_notify" by
         .              *# discarding pending writes and sending an immediate "close_notify"
         .              *# alert of their own.
         .              */
 5,242,890 (0.0%)      if (s2n_connection_get_protocol_version(conn) < S2N_TLS13) {
         .                 switch (status) {
         .                     case S2N_IO_WRITABLE:
         .                     case S2N_IO_READABLE:
         .                     case S2N_IO_FULL_DUPLEX:
         .                         return full_duplex;
         .                     case S2N_IO_CLOSED:
         .                         return !full_duplex;
         .                 }
         .             }
         .         
11,883,884 (0.1%)      switch (status) {
         .                 case S2N_IO_WRITABLE:
 2,446,682 (0.0%)              return !write_closed;
         .                 case S2N_IO_READABLE:
 4,893,364 (0.0%)              return !read_closed;
         .                 case S2N_IO_FULL_DUPLEX:
         .                     return full_duplex;
         .                 case S2N_IO_CLOSED:
         .                     return read_closed && write_closed;
         .             }
         .         
         .             return false;
 2,097,156 (0.0%)  }
         .         
         .         S2N_RESULT s2n_connection_get_secure_cipher(struct s2n_connection *conn, const struct s2n_cipher **cipher)
         .         {
         .             RESULT_ENSURE_REF(conn);
         .             RESULT_ENSURE_REF(cipher);
         .             RESULT_ENSURE_REF(conn->secure);
         .             RESULT_ENSURE_REF(conn->secure->cipher_suite);
         .             RESULT_ENSURE_REF(conn->secure->cipher_suite->record_alg);
         .             *cipher = conn->secure->cipher_suite->record_alg->cipher;
         .             return S2N_RESULT_OK;
         .         }
         .         
         .         S2N_RESULT s2n_connection_get_sequence_number(struct s2n_connection *conn,
         .                 s2n_mode mode, struct s2n_blob *seq_num)
 2,796,208 (0.0%)  {
   699,052 (0.0%)      RESULT_ENSURE_REF(conn);
   699,052 (0.0%)      RESULT_ENSURE_REF(seq_num);
 1,398,104 (0.0%)      RESULT_ENSURE_REF(conn->secure);
         .         
   699,052 (0.0%)      switch (mode) {
         .                 case S2N_CLIENT:
         .                     RESULT_GUARD_POSIX(s2n_blob_init(seq_num, conn->secure->client_sequence_number,
         .                             sizeof(conn->secure->client_sequence_number)));
         .                     break;
         .                 case S2N_SERVER:
 3,495,260 (0.0%)              RESULT_GUARD_POSIX(s2n_blob_init(seq_num, conn->secure->server_sequence_number,
         .                             sizeof(conn->secure->server_sequence_number)));
   349,526 (0.0%)              break;
         .                 default:
         .                     RESULT_BAIL(S2N_ERR_SAFETY);
         .             }
         .         
   349,526 (0.0%)      return S2N_RESULT_OK;
 1,048,578 (0.0%)  }
         .         
         .         int s2n_connection_get_key_update_counts(struct s2n_connection *conn,
         .                 uint8_t *send_key_updates, uint8_t *recv_key_updates)
         .         {
         .             POSIX_ENSURE_REF(conn);
         .             POSIX_ENSURE_REF(send_key_updates);
         .             POSIX_ENSURE_REF(recv_key_updates);
         .             *send_key_updates = conn->send_key_updated;
-- line 1780 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_early_data_io.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 42 ----------------------------------------
        .          *= https://www.rfc-editor.org/rfc/rfc8446#section-4.2.10
        .          *# If the client attempts a 0-RTT handshake but the server
        .          *# rejects it, the server will generally not have the 0-RTT record
        .          *# protection keys and must instead use trial decryption (either with
        .          *# the 1-RTT handshake keys or by looking for a cleartext ClientHello in
        .          *# the case of a HelloRetryRequest) to find the first non-0-RTT message.
        .          */
        .         bool s2n_early_data_is_trial_decryption_allowed(struct s2n_connection *conn, uint8_t record_type)
2,446,682 (0.0%)  {
1,398,104 (0.0%)      return conn && (conn->early_data_state == S2N_EARLY_DATA_REJECTED)
        .                     && record_type == TLS_APPLICATION_DATA
        .                     /* Only servers receive early data. */
        .                     && (conn->mode == S2N_SERVER)
        .                     /* Early data is only expected during the handshake. */
1,398,104 (0.0%)              && (s2n_conn_get_current_message_type(conn) != APPLICATION_DATA);
  699,052 (0.0%)  }
        .         
        .         static bool s2n_is_early_data_io(struct s2n_connection *conn)
6,990,520 (0.0%)  {
6,990,520 (0.0%)      if (s2n_conn_get_current_message_type(conn) == APPLICATION_DATA) {
2,796,208 (0.0%)          return false;
        .             }
        .         
        .             /* It would be more accurate to not include this check.
        .              * However, before the early data feature was added, s2n_send and s2n_recv
        .              * did not verify that they were being called after a complete handshake.
        .              * Enforcing that broke several S2N tests, and might have broken customers too.
        .              *
        .              * Therefore, only consider this early data if the customer has indicated that
-- line 70 ----------------------------------------
-- line 73 ----------------------------------------
        .              */
        .             if (conn->early_data_expected
        .                     || (conn->mode == S2N_CLIENT && conn->early_data_state == S2N_EARLY_DATA_REQUESTED)
        .                     || conn->early_data_state == S2N_EARLY_DATA_ACCEPTED
        .                     || conn->early_data_state == S2N_END_OF_EARLY_DATA) {
        .                 return true;
        .             }
        .             return false;
2,796,208 (0.0%)  }
        .         
        .         S2N_RESULT s2n_early_data_record_bytes(struct s2n_connection *conn, ssize_t data_len)
6,990,520 (0.0%)  {
1,398,104 (0.0%)      RESULT_ENSURE_REF(conn);
5,592,416 (0.0%)      if (data_len < 0 || !s2n_is_early_data_io(conn)) {
1,398,104 (0.0%)          return S2N_RESULT_OK;
        .             }
        .         
        .             /* Ensure the bytes read are within the bounds of what we can actually record. */
        .             if ((size_t) data_len > (UINT64_MAX - conn->early_data_bytes)) {
        .                 conn->early_data_bytes = UINT64_MAX;
        .                 RESULT_BAIL(S2N_ERR_INTEGER_OVERFLOW);
        .             }
        .         
-- line 95 ----------------------------------------
-- line 98 ----------------------------------------
        .              * Once we receive too many bytes, we can't proceed with the connection. */
        .             conn->early_data_bytes += data_len;
        .         
        .             uint32_t max_early_data_size = 0;
        .             RESULT_GUARD_POSIX(s2n_connection_get_max_early_data_size(conn, &max_early_data_size));
        .             RESULT_ENSURE(conn->early_data_bytes <= max_early_data_size, S2N_ERR_MAX_EARLY_DATA_SIZE);
        .         
        .             return S2N_RESULT_OK;
4,194,312 (0.0%)  }
        .         
        .         S2N_RESULT s2n_early_data_validate_send(struct s2n_connection *conn, uint32_t bytes_to_send)
3,495,260 (0.0%)  {
  699,052 (0.0%)      RESULT_ENSURE_REF(conn);
2,097,156 (0.0%)      if (!s2n_is_early_data_io(conn)) {
  699,052 (0.0%)          return S2N_RESULT_OK;
        .             }
        .         
        .             RESULT_ENSURE(conn->early_data_expected, S2N_ERR_EARLY_DATA_NOT_ALLOWED);
        .             RESULT_ENSURE(conn->mode == S2N_CLIENT, S2N_ERR_EARLY_DATA_NOT_ALLOWED);
        .             RESULT_ENSURE(conn->early_data_state == S2N_EARLY_DATA_REQUESTED
        .                             || conn->early_data_state == S2N_EARLY_DATA_ACCEPTED,
        .                     S2N_ERR_EARLY_DATA_NOT_ALLOWED);
        .         
        .             uint32_t allowed_early_data_size = 0;
        .             RESULT_GUARD_POSIX(s2n_connection_get_remaining_early_data_size(conn, &allowed_early_data_size));
        .             RESULT_ENSURE(bytes_to_send <= allowed_early_data_size, S2N_ERR_MAX_EARLY_DATA_SIZE);
        .         
        .             return S2N_RESULT_OK;
2,097,156 (0.0%)  }
        .         
        .         S2N_RESULT s2n_early_data_validate_recv(struct s2n_connection *conn)
2,097,156 (0.0%)  {
  699,052 (0.0%)      RESULT_ENSURE_REF(conn);
2,097,156 (0.0%)      if (!s2n_is_early_data_io(conn)) {
  699,052 (0.0%)          return S2N_RESULT_OK;
        .             }
        .         
        .             RESULT_ENSURE(conn->early_data_expected, S2N_ERR_EARLY_DATA_NOT_ALLOWED);
        .             RESULT_ENSURE(conn->mode == S2N_SERVER, S2N_ERR_EARLY_DATA_NOT_ALLOWED);
        .             RESULT_ENSURE(conn->early_data_state == S2N_EARLY_DATA_ACCEPTED, S2N_ERR_EARLY_DATA_NOT_ALLOWED);
        .             RESULT_ENSURE(s2n_conn_get_current_message_type(conn) == END_OF_EARLY_DATA, S2N_ERR_EARLY_DATA_NOT_ALLOWED);
        .             return S2N_RESULT_OK;
1,048,578 (0.0%)  }
        .         
        .         static bool s2n_early_data_can_continue(struct s2n_connection *conn)
        .         {
        .             uint32_t remaining_early_data_size = 0;
        .             return s2n_connection_get_remaining_early_data_size(conn, &remaining_early_data_size) >= S2N_SUCCESS
        .                     && remaining_early_data_size > 0;
        .         }
        .         
-- line 148 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_handshake_io.c
--------------------------------------------------------------------------------
Ir_______________ 

-- line 837 ----------------------------------------
         .         #define EXPECTED_RECORD_TYPE(conn)  ACTIVE_STATE(conn).record_type
         .         #define EXPECTED_MESSAGE_TYPE(conn) ACTIVE_STATE(conn).message_type
         .         
         .         #define CONNECTION_WRITER(conn)    (conn->mode == S2N_CLIENT ? 'C' : 'S')
         .         #define CONNECTION_IS_WRITER(conn) (ACTIVE_STATE(conn).writer == CONNECTION_WRITER(conn))
         .         
         .         /* Only used in our test cases. */
         .         message_type_t s2n_conn_get_current_message_type(const struct s2n_connection *conn)
 5,592,416 (0.0%)  {
20,971,560 (0.1%)      return ACTIVE_MESSAGE(conn);
 2,796,208 (0.0%)  }
         .         
         .         static int s2n_advance_message(struct s2n_connection *conn)
         .         {
         .             /* Get the mode: 'C'lient or 'S'erver */
         .             char previous_writer = ACTIVE_STATE(conn).writer;
         .             char this_mode = CONNECTION_WRITER(conn);
         .         
         .             /* Actually advance the message number */
-- line 855 ----------------------------------------
-- line 1186 ----------------------------------------
         .             if (p != handshake_type_str[handshake_type] && '|' == *(p - 1)) {
         .                 *(p - 1) = '\0';
         .             }
         .         
         .             return handshake_type_str[handshake_type];
         .         }
         .         
         .         S2N_RESULT s2n_handshake_message_send(struct s2n_connection *conn, uint8_t content_type, s2n_blocked_status *blocked)
 4,194,312 (0.0%)  {
   699,052 (0.0%)      RESULT_ENSURE_REF(conn);
 1,048,578 (0.0%)      struct s2n_stuffer *in = &conn->handshake.io;
         .         
 2,097,156 (0.0%)      uint32_t size = s2n_stuffer_data_available(in);
   699,052 (0.0%)      if (size == 0) {
   699,052 (0.0%)          return S2N_RESULT_OK;
         .             }
         .         
         .             if (s2n_connection_is_quic_enabled(conn)) {
         .                 RESULT_GUARD(s2n_quic_write_handshake_message(conn));
         .                 RESULT_GUARD_POSIX(s2n_flush(conn, blocked));
         .                 return S2N_RESULT_OK;
         .             }
         .         
-- line 1208 ----------------------------------------
-- line 1217 ----------------------------------------
         .                 int bytes_written = s2n_record_writev(conn, content_type, &iov, 1,
         .                         total_bytes_written, size - total_bytes_written);
         .                 RESULT_GUARD_POSIX(bytes_written);
         .                 total_bytes_written += bytes_written;
         .                 RESULT_GUARD_POSIX(s2n_stuffer_skip_read(in, bytes_written));
         .                 RESULT_GUARD_POSIX(s2n_flush(conn, blocked));
         .             }
         .             return S2N_RESULT_OK;
 2,097,156 (0.0%)  }
         .         
         .         /* Writing is relatively straight forward, simply write each message out as a record,
         .          * we may fragment a message across multiple records, but we never coalesce multiple
         .          * messages into single records.
         .          * Precondition: secure outbound I/O has already been flushed
         .          */
         .         static int s2n_handshake_write_io(struct s2n_connection *conn)
         .         {
-- line 1233 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_key_update.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 58 ----------------------------------------
        .             } else {
        .                 POSIX_GUARD(s2n_update_application_traffic_keys(conn, S2N_CLIENT, RECEIVING));
        .             }
        .         
        .             return S2N_SUCCESS;
        .         }
        .         
        .         int s2n_key_update_send(struct s2n_connection *conn, s2n_blocked_status *blocked)
3,495,260 (0.0%)  {
  699,052 (0.0%)      POSIX_ENSURE_REF(conn);
1,398,104 (0.0%)      POSIX_ENSURE_REF(conn->secure);
1,398,104 (0.0%)      POSIX_ENSURE_GTE(conn->actual_protocol_version, S2N_TLS13);
        .         
1,048,578 (0.0%)      struct s2n_blob sequence_number = { 0 };
4,194,312 (0.0%)      POSIX_GUARD_RESULT(s2n_connection_get_sequence_number(conn, conn->mode, &sequence_number));
2,446,682 (0.0%)      POSIX_GUARD(s2n_check_record_limit(conn, &sequence_number));
        .         
2,097,156 (0.0%)      if (s2n_atomic_flag_test(&conn->key_update_pending)) {
        .                 POSIX_ENSURE(!conn->ktls_send_enabled, S2N_ERR_KTLS_KEY_LIMIT);
        .         
        .                 /* Flush any buffered records to ensure an empty output buffer.
        .                  *
        .                  * This is important when buffering multiple records because we don't:
        .                  * 1) Respect max fragment length for handshake messages
        .                  * 2) Check if there is sufficient space in the output buffer for
        .                  *    post-handshake messages.
-- line 83 ----------------------------------------
-- line 96 ----------------------------------------
        .         
        .                 /* Update encryption key */
        .                 POSIX_GUARD(s2n_update_application_traffic_keys(conn, conn->mode, SENDING));
        .         
        .                 s2n_atomic_flag_clear(&conn->key_update_pending);
        .                 POSIX_GUARD(s2n_flush(conn, blocked));
        .             }
        .         
  349,526 (0.0%)      return S2N_SUCCESS;
2,097,156 (0.0%)  }
        .         
        .         int s2n_key_update_write(struct s2n_blob *out)
        .         {
        .             POSIX_ENSURE_REF(out);
        .         
        .             struct s2n_stuffer key_update_stuffer = { 0 };
        .             POSIX_GUARD(s2n_stuffer_init(&key_update_stuffer, out));
        .             POSIX_GUARD(s2n_stuffer_write_uint8(&key_update_stuffer, TLS_KEY_UPDATE));
-- line 113 ----------------------------------------
-- line 115 ----------------------------------------
        .         
        .             /* s2n currently does not require peers to update their encryption keys. */
        .             POSIX_GUARD(s2n_stuffer_write_uint8(&key_update_stuffer, key_update_request_val));
        .         
        .             return S2N_SUCCESS;
        .         }
        .         
        .         int s2n_check_record_limit(struct s2n_connection *conn, struct s2n_blob *sequence_number)
3,495,260 (0.0%)  {
  699,052 (0.0%)      POSIX_ENSURE_REF(conn);
  699,052 (0.0%)      POSIX_ENSURE_REF(sequence_number);
1,398,104 (0.0%)      POSIX_ENSURE_REF(conn->secure);
1,747,630 (0.0%)      POSIX_ENSURE_REF(conn->secure->cipher_suite);
2,097,156 (0.0%)      POSIX_ENSURE_REF(conn->secure->cipher_suite->record_alg);
        .         
        .             /*
        .              * This is the sequence number that will be used for the next record,
        .              * because we incremented the sequence number after sending the last record.
        .              */
  349,526 (0.0%)      uint64_t next_seq_num = 0;
2,446,682 (0.0%)      POSIX_GUARD(s2n_sequence_number_to_uint64(sequence_number, &next_seq_num));
        .         
        .             /*
        .              * If the next record is the last record we can send, then the next record needs
        .              * to contain a KeyUpdate message.
        .              *
        .              * This should always trigger on "==", but we use ">=" just in case.
        .              */
2,796,208 (0.0%)      if (next_seq_num >= conn->secure->cipher_suite->record_alg->encryption_limit) {
        .                 s2n_atomic_flag_set(&conn->key_update_pending);
        .             }
        .         
  349,526 (0.0%)      return S2N_SUCCESS;
2,097,156 (0.0%)  }
        .         
        .         int s2n_connection_request_key_update(struct s2n_connection *conn, s2n_peer_key_update peer_request)
        .         {
        .             POSIX_ENSURE_REF(conn);
        .             /* s2n-tls does not currently support requesting key updates from peers */
        .             POSIX_ENSURE(peer_request == S2N_KEY_UPDATE_NOT_REQUESTED, S2N_ERR_INVALID_ARGUMENT);
        .             s2n_atomic_flag_set(&conn->key_update_pending);
        .             return S2N_SUCCESS;
-- line 156 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_post_handshake.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 163 ----------------------------------------
        .             while (s2n_stuffer_data_available(&conn->in)) {
        .                 RESULT_GUARD(s2n_post_handshake_message_recv(conn));
        .                 RESULT_GUARD_POSIX(s2n_stuffer_wipe(&conn->post_handshake.in));
        .             }
        .             return S2N_RESULT_OK;
        .         }
        .         
        .         S2N_RESULT s2n_post_handshake_write_records(struct s2n_connection *conn, s2n_blocked_status *blocked)
2,097,156 (0.0%)  {
1,048,578 (0.0%)      struct s2n_stuffer *message = &conn->handshake.io;
        .         
        .             /* Flush any existing records before we write a new handshake record.
        .              * We do not support buffering multiple handshake records.
        .              */
2,097,156 (0.0%)      if (s2n_stuffer_data_available(message)) {
        .                 RESULT_GUARD_POSIX(s2n_flush(conn, blocked));
        .             }
        .         
3,495,260 (0.0%)      RESULT_GUARD(s2n_handshake_message_send(conn, TLS_HANDSHAKE, blocked));
1,747,630 (0.0%)      RESULT_GUARD_POSIX(s2n_stuffer_wipe(message));
  349,526 (0.0%)      return S2N_RESULT_OK;
  699,052 (0.0%)  }
        .         
        .         int s2n_post_handshake_send(struct s2n_connection *conn, s2n_blocked_status *blocked)
2,446,682 (0.0%)  {
  699,052 (0.0%)      POSIX_ENSURE_REF(conn);
        .         
        .             /* Currently, we only support TLS1.3 post-handshake messages. */
1,398,104 (0.0%)      if (conn->actual_protocol_version < S2N_TLS13) {
        .                 return S2N_SUCCESS;
        .             }
        .         
3,495,260 (0.0%)      POSIX_GUARD_RESULT(s2n_post_handshake_write_records(conn, blocked));
        .         
2,446,682 (0.0%)      POSIX_GUARD(s2n_key_update_send(conn, blocked));
3,495,260 (0.0%)      POSIX_GUARD_RESULT(s2n_tls13_server_nst_send(conn, blocked));
        .         
2,446,682 (0.0%)      POSIX_GUARD(s2n_stuffer_resize(&conn->handshake.io, 0));
  349,526 (0.0%)      return S2N_SUCCESS;
1,048,578 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_quic_support.c
--------------------------------------------------------------------------------
Ir_______________ 

-- line 47 ----------------------------------------
         .             POSIX_GUARD_RESULT(s2n_connection_validate_tls13_support(conn));
         .             /* QUIC support is not currently compatible with recv_buffering */
         .             POSIX_ENSURE(!conn->recv_buffering, S2N_ERR_INVALID_STATE);
         .             conn->quic_enabled = true;
         .             return S2N_SUCCESS;
         .         }
         .         
         .         bool s2n_connection_is_quic_enabled(struct s2n_connection *conn)
 2,796,208 (0.0%)  {
14,680,092 (0.1%)      return (conn && conn->quic_enabled) || (conn && conn->config && conn->config->quic_enabled);
 1,398,104 (0.0%)  }
         .         
         .         bool s2n_connection_are_session_tickets_enabled(struct s2n_connection *conn)
         .         {
         .             return conn && conn->config && conn->config->use_tickets;
         .         }
         .         
         .         int s2n_connection_set_quic_transport_parameters(struct s2n_connection *conn,
         .                 const uint8_t *data_buffer, uint16_t data_len)
-- line 65 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_read.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 94 ----------------------------------------
        .             POSIX_GUARD(s2n_stuffer_reread(header_in));
        .             return 0;
        .         }
        .         
        .         int s2n_record_header_parse(
        .                 struct s2n_connection *conn,
        .                 uint8_t *content_type,
        .                 uint16_t *fragment_length)
7,689,572 (0.0%)  {
2,097,156 (0.0%)      struct s2n_stuffer *in = &conn->header_in;
        .         
4,893,364 (0.0%)      S2N_ERROR_IF(s2n_stuffer_data_available(in) < S2N_TLS_RECORD_HEADER_LENGTH, S2N_ERR_BAD_MESSAGE);
        .         
4,893,364 (0.0%)      POSIX_GUARD(s2n_stuffer_read_uint8(in, content_type));
        .         
        .             uint8_t protocol_version[S2N_TLS_PROTOCOL_VERSION_LEN];
5,592,416 (0.0%)      POSIX_GUARD(s2n_stuffer_read_bytes(in, protocol_version, S2N_TLS_PROTOCOL_VERSION_LEN));
        .         
6,291,468 (0.0%)      const uint8_t version = (protocol_version[0] * 10) + protocol_version[1];
        .             /* We record the protocol version in the first record seen by the server for fingerprinting usecases */
3,495,260 (0.0%)      if (!conn->client_hello.record_version_recorded) {
        .                 conn->client_hello.legacy_record_version = version;
        .                 conn->client_hello.record_version_recorded = 1;
        .             }
        .         
        .             /* https://tools.ietf.org/html/rfc5246#appendix-E.1 states that servers must accept any value {03,XX} as the record
        .              * layer version number for the first TLS record. There is some ambiguity here because the client does not know
        .              * what version to use in the record header prior to receiving the ServerHello. Some client implementations may use
        .              * a garbage value(not {03,XX}) in the ClientHello.
        .              * Choose to be lenient to these clients. After protocol negotiation, we will enforce that all record versions
        .              * match the negotiated version.
        .              */
        .         
7,689,572 (0.0%)      S2N_ERROR_IF(conn->actual_protocol_version_established && MIN(conn->actual_protocol_version, S2N_TLS12) /* check against legacy record version (1.2) in tls 1.3 */
        .                                     != version,
        .                     S2N_ERR_BAD_MESSAGE);
        .         
        .             /* Some servers send fragments that are above the maximum length (e.g.
        .              * Openssl 1.0.1), so we don't check if the fragment length is >
        .              * S2N_TLS_MAXIMUM_FRAGMENT_LENGTH. We allow up to 2^16.
        .              *
        .              *= https://www.rfc-editor.org/rfc/rfc8446#section-5.1
        .              *= type=exception
        .              *= reason=Incorrect implementations exist in the wild. Ignoring instead.
        .              *# The length MUST NOT exceed 2^14 bytes.  An
        .              *# endpoint that receives a record that exceeds this length MUST
        .              *# terminate the connection with a "record_overflow" alert.
        .              */
4,893,364 (0.0%)      POSIX_GUARD(s2n_stuffer_read_uint16(in, fragment_length));
3,495,260 (0.0%)      POSIX_GUARD(s2n_stuffer_reread(in));
        .         
  699,052 (0.0%)      return 0;
4,194,312 (0.0%)  }
        .         
        .         /* In TLS 1.3, handle CCS message as unprotected records all the time.
        .          * https://tools.ietf.org/html/rfc8446#section-5
        .          *
        .          * In TLS 1.2 and TLS 1.3 Alert messages are plaintext or encrypted
        .          * depending on the context of the connection. If we receive an encrypted
        .          * alert, the record type is TLS_APPLICATION_DATA at this point. It will
        .          * be decrypted and processed in s2n_handshake_io. We may receive a
        .          * plaintext alert if we hit an error before the handshake completed
        .          * (like a certificate failed to validate).
        .          * https://tools.ietf.org/html/rfc8446#section-6
        .          *
        .          * This function is specific to TLS 1.3 to avoid changing the behavior
        .          * of existing interpretation of TLS 1.2 alerts. */
        .         static bool s2n_is_tls13_plaintext_content(struct s2n_connection *conn, uint8_t content_type)
4,194,312 (0.0%)  {
6,990,520 (0.0%)      return conn->actual_protocol_version == S2N_TLS13 && (content_type == TLS_ALERT || content_type == TLS_CHANGE_CIPHER_SPEC);
1,398,104 (0.0%)  }
        .         
        .         int s2n_record_parse(struct s2n_connection *conn)
3,145,734 (0.0%)  {
  349,526 (0.0%)      uint8_t content_type = 0;
  349,526 (0.0%)      uint16_t encrypted_length = 0;
2,796,208 (0.0%)      POSIX_GUARD(s2n_record_header_parse(conn, &content_type, &encrypted_length));
        .         
1,048,578 (0.0%)      struct s2n_crypto_parameters *current_client_crypto = conn->client;
1,048,578 (0.0%)      struct s2n_crypto_parameters *current_server_crypto = conn->server;
2,796,208 (0.0%)      if (s2n_is_tls13_plaintext_content(conn, content_type)) {
        .                 POSIX_ENSURE_REF(conn->initial);
        .                 conn->client = conn->initial;
        .                 conn->server = conn->initial;
        .             }
        .         
1,398,104 (0.0%)      const struct s2n_cipher_suite *cipher_suite = conn->client->cipher_suite;
1,398,104 (0.0%)      uint8_t *implicit_iv = conn->client->client_implicit_iv;
1,398,104 (0.0%)      struct s2n_hmac_state *mac = &conn->client->client_record_mac;
1,398,104 (0.0%)      uint8_t *sequence_number = conn->client->client_sequence_number;
1,398,104 (0.0%)      struct s2n_session_key *session_key = &conn->client->client_key;
        .         
1,398,104 (0.0%)      if (conn->mode == S2N_CLIENT) {
1,398,104 (0.0%)          cipher_suite = conn->server->cipher_suite;
1,398,104 (0.0%)          implicit_iv = conn->server->server_implicit_iv;
1,398,104 (0.0%)          mac = &conn->server->server_record_mac;
1,398,104 (0.0%)          sequence_number = conn->server->server_sequence_number;
1,398,104 (0.0%)          session_key = &conn->server->server_key;
        .             }
        .         
2,796,208 (0.0%)      if (s2n_is_tls13_plaintext_content(conn, content_type)) {
        .                 conn->client = current_client_crypto;
        .                 conn->server = current_server_crypto;
        .             }
        .         
        .             /* The NULL stream cipher MUST NEVER be used for ApplicationData.
        .              * If ApplicationData is unencrypted, we can't trust it. */
2,097,156 (0.0%)      if (cipher_suite->record_alg->cipher == &s2n_null_cipher) {
        .                 POSIX_ENSURE(content_type != TLS_APPLICATION_DATA, S2N_ERR_DECRYPT);
        .             }
        .         
3,495,260 (0.0%)      switch (cipher_suite->record_alg->cipher->type) {
        .                 case S2N_AEAD:
5,941,942 (0.0%)              POSIX_GUARD(s2n_record_parse_aead(cipher_suite, conn, content_type, encrypted_length, implicit_iv, mac, sequence_number, session_key));
  699,052 (0.0%)              break;
        .                 case S2N_CBC:
        .                     POSIX_GUARD(s2n_record_parse_cbc(cipher_suite, conn, content_type, encrypted_length, implicit_iv, mac, sequence_number, session_key));
        .                     break;
        .                 case S2N_COMPOSITE:
        .                     POSIX_GUARD(s2n_record_parse_composite(cipher_suite, conn, content_type, encrypted_length, implicit_iv, mac, sequence_number, session_key));
        .                     break;
        .                 case S2N_STREAM:
        .                     POSIX_GUARD(s2n_record_parse_stream(cipher_suite, conn, content_type, encrypted_length, implicit_iv, mac, sequence_number, session_key));
        .                     break;
        .                 default:
        .                     POSIX_BAIL(S2N_ERR_CIPHER_TYPE);
        .                     break;
        .             }
        .         
  349,526 (0.0%)      return 0;
2,097,156 (0.0%)  }
        .         
        .         int s2n_tls13_parse_record_type(struct s2n_stuffer *stuffer, uint8_t *record_type)
2,446,682 (0.0%)  {
2,097,156 (0.0%)      uint32_t bytes_left = s2n_stuffer_data_available(stuffer);
        .         
        .             /* From rfc8446 Section 5.4
        .              * The presence of padding does not change the overall record size
        .              * limitations: the full encoded TLSInnerPlaintext MUST NOT exceed 2^14
        .              * + 1 octets
        .              *
        .              * Certain versions of Java can generate inner plaintexts with lengths up to
        .              * S2N_MAXIMUM_INNER_PLAINTEXT_LENGTH + 16 (See JDK-8221253)
        .              * However, after the padding is stripped, the result will always be no more than
        .              * S2N_MAXIMUM_INNER_PLAINTEXT_LENGTH - 1
        .              */
  699,052 (0.0%)      S2N_ERROR_IF(bytes_left > S2N_MAXIMUM_INNER_PLAINTEXT_LENGTH + 16, S2N_ERR_MAX_INNER_PLAINTEXT_SIZE);
        .         
        .             /* set cursor to the end of the stuffer */
2,446,682 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_read(stuffer, bytes_left));
        .         
        .             /* Record type should have values greater than zero.
        .              * If zero, treat as padding, keep reading and wiping from the back
        .              * until a non-zero value is found
        .              */
  699,052 (0.0%)      *record_type = 0;
3,145,734 (0.0%)      while (*record_type == 0) {
        .                 /* back the cursor by one to read off the last byte */
2,097,156 (0.0%)          POSIX_GUARD(s2n_stuffer_rewind_read(stuffer, 1));
        .         
        .                 /* set the record type */
2,446,682 (0.0%)          POSIX_GUARD(s2n_stuffer_read_uint8(stuffer, record_type));
        .         
        .                 /* wipe the last byte at the end of the stuffer */
2,097,156 (0.0%)          POSIX_GUARD(s2n_stuffer_wipe_n(stuffer, 1));
        .             }
        .         
        .             /* only the original plaintext should remain */
        .             /* now reset the read cursor at where it should be */
1,747,630 (0.0%)      POSIX_GUARD(s2n_stuffer_reread(stuffer));
        .         
        .             /* Even in the incorrect case above with up to 16 extra bytes, we should never see too much data after unpadding */
2,446,682 (0.0%)      S2N_ERROR_IF(s2n_stuffer_data_available(stuffer) > S2N_MAXIMUM_INNER_PLAINTEXT_LENGTH - 1, S2N_ERR_MAX_INNER_PLAINTEXT_SIZE);
        .         
  349,526 (0.0%)      return 0;
1,048,578 (0.0%)  }
        .         
        .         S2N_RESULT s2n_record_wipe(struct s2n_connection *conn)
2,097,156 (0.0%)  {
  699,052 (0.0%)      RESULT_ENSURE_REF(conn);
2,097,156 (0.0%)      RESULT_GUARD_POSIX(s2n_stuffer_wipe(&conn->header_in));
2,097,156 (0.0%)      RESULT_GUARD_POSIX(s2n_stuffer_wipe(&conn->in));
  699,052 (0.0%)      conn->in_status = ENCRYPTED;
        .         
        .             /* Release the memory in conn->in, which un-taints buffer_in */
2,097,156 (0.0%)      RESULT_GUARD_POSIX(s2n_stuffer_free(&conn->in));
1,398,104 (0.0%)      conn->buffer_in.tainted = false;
        .         
        .             /* Reclaim any memory in buffer_in if possible.
        .              * We want to avoid an expensive shift / copy later if possible.
        .              */
2,097,156 (0.0%)      if (s2n_stuffer_is_consumed(&conn->buffer_in)) {
2,097,156 (0.0%)          RESULT_GUARD_POSIX(s2n_stuffer_rewrite(&conn->buffer_in));
        .             }
  349,526 (0.0%)      return S2N_RESULT_OK;
1,048,578 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_read_aead.c
--------------------------------------------------------------------------------
Ir_______________ 

-- line 31 ----------------------------------------
         .                 const struct s2n_cipher_suite *cipher_suite,
         .                 struct s2n_connection *conn,
         .                 uint8_t content_type,
         .                 uint16_t encrypted_length,
         .                 uint8_t *implicit_iv,
         .                 struct s2n_hmac_state *mac,
         .                 uint8_t *sequence_number,
         .                 struct s2n_session_key *session_key)
 6,640,994 (0.0%)  {
 1,747,630 (0.0%)      const int is_tls13_record = cipher_suite->record_alg->flags & S2N_TLS13_RECORD_AEAD_NONCE;
         .             /* TLS 1.3 record protection uses a different 5 byte associated data than TLS 1.2's */
 7,340,046 (0.0%)      s2n_stack_blob(aad, is_tls13_record ? S2N_TLS13_AAD_LEN : S2N_TLS_MAX_AAD_LEN, S2N_TLS_MAX_AAD_LEN);
         .         
 1,048,578 (0.0%)      struct s2n_blob en = { 0 };
 5,242,890 (0.0%)      POSIX_GUARD(s2n_blob_init(&en, s2n_stuffer_raw_read(&conn->in, encrypted_length), encrypted_length));
 1,048,578 (0.0%)      POSIX_ENSURE_REF(en.data);
         .             /* In AEAD mode, the explicit IV is in the record */
 2,796,208 (0.0%)      POSIX_ENSURE_GTE(en.size, cipher_suite->record_alg->cipher->io.aead.record_iv_size);
         .         
   699,052 (0.0%)      uint8_t aad_iv[S2N_TLS_MAX_IV_LEN] = { 0 };
 1,048,578 (0.0%)      struct s2n_blob iv = { 0 };
 2,796,208 (0.0%)      POSIX_GUARD(s2n_blob_init(&iv, aad_iv, sizeof(aad_iv)));
 1,398,104 (0.0%)      struct s2n_stuffer iv_stuffer = { 0 };
 2,446,682 (0.0%)      POSIX_GUARD(s2n_stuffer_init(&iv_stuffer, &iv));
         .         
 2,097,156 (0.0%)      if (cipher_suite->record_alg->flags & S2N_TLS12_AES_GCM_AEAD_NONCE) {
         .                 /* Partially explicit nonce. See RFC 5288 Section 3 */
         .                 POSIX_GUARD(s2n_stuffer_write_bytes(&iv_stuffer, implicit_iv, cipher_suite->record_alg->cipher->io.aead.fixed_iv_size));
         .                 POSIX_GUARD(s2n_stuffer_write_bytes(&iv_stuffer, en.data, cipher_suite->record_alg->cipher->io.aead.record_iv_size));
 3,145,734 (0.0%)      } else if (cipher_suite->record_alg->flags & S2N_TLS12_CHACHA_POLY_AEAD_NONCE || is_tls13_record) {
         .                 /* Fully implicit nonce.
         .                  * This is introduced with ChaChaPoly with RFC 7905 Section 2
         .                  * and also used for TLS 1.3 record protection (RFC 8446 Section 5.2).
         .                  *
         .                  * In these cipher modes, the sequence number (64 bits) is left padded by 4 bytes
         .                  * to align and xor-ed with the 96-bit IV.
         .                  **/
   349,526 (0.0%)          uint8_t four_zeroes[4] = { 0 };
 2,796,208 (0.0%)          POSIX_GUARD(s2n_stuffer_write_bytes(&iv_stuffer, four_zeroes, 4));
 2,796,208 (0.0%)          POSIX_GUARD(s2n_stuffer_write_bytes(&iv_stuffer, sequence_number, S2N_TLS_SEQUENCE_NUM_LEN));
36,700,230 (0.2%)          for (int i = 0; i < cipher_suite->record_alg->cipher->io.aead.fixed_iv_size; i++) {
         .                     S2N_INVARIANT(i <= cipher_suite->record_alg->cipher->io.aead.fixed_iv_size);
54,526,056 (0.3%)              aad_iv[i] = aad_iv[i] ^ implicit_iv[i];
         .                 }
         .             } else {
         .                 POSIX_BAIL(S2N_ERR_INVALID_NONCE_TYPE);
         .             }
         .         
         .             /* Set the IV size to the amount of data written */
 1,398,104 (0.0%)      iv.size = s2n_stuffer_data_available(&iv_stuffer);
         .         
   699,052 (0.0%)      uint16_t payload_length = encrypted_length;
         .             /* remove the AEAD overhead from the record size */
 4,893,364 (0.0%)      POSIX_ENSURE_GTE(payload_length, cipher_suite->record_alg->cipher->io.aead.record_iv_size + cipher_suite->record_alg->cipher->io.aead.tag_size);
 2,097,156 (0.0%)      payload_length -= cipher_suite->record_alg->cipher->io.aead.record_iv_size;
 2,097,156 (0.0%)      payload_length -= cipher_suite->record_alg->cipher->io.aead.tag_size;
         .         
   699,052 (0.0%)      if (is_tls13_record) {
 5,242,890 (0.0%)          POSIX_GUARD_RESULT(s2n_tls13_aead_aad_init(payload_length, cipher_suite->record_alg->cipher->io.aead.tag_size, &aad));
         .             } else {
         .                 POSIX_GUARD_RESULT(s2n_aead_aad_init(conn, sequence_number, content_type, payload_length, &aad));
         .             }
         .         
         .             /* Decrypt stuff! */
         .             /* Skip explicit IV for decryption */
 2,796,208 (0.0%)      en.size -= cipher_suite->record_alg->cipher->io.aead.record_iv_size;
 2,796,208 (0.0%)      en.data += cipher_suite->record_alg->cipher->io.aead.record_iv_size;
         .         
         .             /* Check that we have some data to decrypt */
 1,048,578 (0.0%)      POSIX_ENSURE_NE(en.size, 0);
         .         
 4,893,364 (0.0%)      POSIX_GUARD(cipher_suite->record_alg->cipher->io.aead.decrypt(session_key, &iv, &aad, &en, &en));
 1,048,578 (0.0%)      struct s2n_blob seq = { 0 };
 2,796,208 (0.0%)      POSIX_GUARD(s2n_blob_init(&seq, sequence_number, S2N_TLS_SEQUENCE_NUM_LEN));
 1,747,630 (0.0%)      POSIX_GUARD(s2n_increment_sequence_number(&seq));
         .         
         .             /* O.k., we've successfully read and decrypted the record, now we need to align the stuffer
         .              * for reading the plaintext data.
         .              */
 2,097,156 (0.0%)      POSIX_GUARD(s2n_stuffer_reread(&conn->in));
 2,097,156 (0.0%)      POSIX_GUARD(s2n_stuffer_reread(&conn->header_in));
         .         
         .             /* Skip the IV, if any */
 1,398,104 (0.0%)      if (conn->actual_protocol_version >= S2N_TLS12) {
 4,194,312 (0.0%)          POSIX_GUARD(s2n_stuffer_skip_read(&conn->in, cipher_suite->record_alg->cipher->io.aead.record_iv_size));
         .             }
         .         
         .             /* Truncate and wipe the MAC and any padding */
 4,893,364 (0.0%)      POSIX_GUARD(s2n_stuffer_wipe_n(&conn->in, s2n_stuffer_data_available(&conn->in) - payload_length));
   699,052 (0.0%)      conn->in_status = PLAINTEXT;
         .         
   349,526 (0.0%)      return 0;
 2,097,156 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_record_write.c
--------------------------------------------------------------------------------
Ir_______________ 

-- line 34 ----------------------------------------
         .         
         .         /* In TLS1.3 the record type is obfuscated as APPLICATION_DATA once the handshake begins to be encrypted.
         .          * The real record type is encrypted and written in the final byte of the record.
         .          * In TLS1.2 the record type is always cleartext. */
         .         #define RECORD_TYPE(is_tls13_record, content_type) (is_tls13_record ? TLS_APPLICATION_DATA : content_type)
         .         
         .         /* How much overhead does the IV, MAC, TAG and padding bytes introduce ? */
         .         static S2N_RESULT s2n_tls_record_overhead(struct s2n_connection *conn, uint16_t *out)
 3,495,260 (0.0%)  {
   699,052 (0.0%)      RESULT_ENSURE_REF(conn);
   699,052 (0.0%)      RESULT_ENSURE_MUT(out);
 1,048,578 (0.0%)      struct s2n_crypto_parameters *active = conn->server;
         .         
 1,398,104 (0.0%)      if (conn->mode == S2N_CLIENT) {
         .                 active = conn->client;
         .             }
         .         
   349,526 (0.0%)      uint8_t extra = 0;
 3,495,260 (0.0%)      RESULT_GUARD_POSIX(s2n_hmac_digest_size(active->cipher_suite->record_alg->hmac_alg, &extra));
         .         
 2,446,682 (0.0%)      if (active->cipher_suite->record_alg->cipher->type == S2N_CBC) {
         .                 /* Subtract one for the padding length byte */
         .                 extra += 1;
         .         
         .                 if (conn->actual_protocol_version > S2N_TLS10) {
         .                     extra += active->cipher_suite->record_alg->cipher->io.cbc.record_iv_size;
         .                 }
 2,446,682 (0.0%)      } else if (active->cipher_suite->record_alg->cipher->type == S2N_AEAD) {
 2,796,208 (0.0%)          extra += active->cipher_suite->record_alg->cipher->io.aead.tag_size;
 3,145,734 (0.0%)          extra += active->cipher_suite->record_alg->cipher->io.aead.record_iv_size;
         .             } else if (active->cipher_suite->record_alg->cipher->type == S2N_COMPOSITE && conn->actual_protocol_version > S2N_TLS10) {
         .                 extra += active->cipher_suite->record_alg->cipher->io.comp.record_iv_size;
         .             }
         .         
 1,398,104 (0.0%)      *out = extra;
         .         
   349,526 (0.0%)      return S2N_RESULT_OK;
 2,097,156 (0.0%)  }
         .         
         .         /* This function returns maximum size of plaintext data to write for the payload.
         .          * Record overheads are not included here.
         .          */
         .         S2N_RESULT s2n_record_max_write_payload_size(struct s2n_connection *conn, uint16_t *max_fragment_size)
 6,990,520 (0.0%)  {
 1,398,104 (0.0%)      RESULT_ENSURE_REF(conn);
 2,796,208 (0.0%)      RESULT_ENSURE_REF(conn->config);
 1,398,104 (0.0%)      RESULT_ENSURE_MUT(max_fragment_size);
 2,796,208 (0.0%)      RESULT_ENSURE(conn->max_outgoing_fragment_length > 0, S2N_ERR_FRAGMENT_LENGTH_TOO_SMALL);
         .         
 4,893,364 (0.0%)      *max_fragment_size = MIN(conn->max_outgoing_fragment_length, S2N_TLS_MAXIMUM_FRAGMENT_LENGTH);
         .         
         .             /* If a custom send buffer is configured, ensure it will be large enough for the payload.
         .              * That may mean we need a smaller fragment size.
         .              */
 2,796,208 (0.0%)      uint32_t send_buffer_override = conn->config->send_buffer_size_override;
 1,398,104 (0.0%)      if (send_buffer_override) {
         .                 uint16_t max_record_size = 0;
         .                 RESULT_GUARD(s2n_record_max_write_size(conn, *max_fragment_size, &max_record_size));
         .                 if (send_buffer_override < max_record_size) {
         .                     size_t overhead = (max_record_size - *max_fragment_size);
         .                     RESULT_ENSURE_GT(send_buffer_override, overhead);
         .                     *max_fragment_size = send_buffer_override - overhead;
         .                 }
         .             }
         .         
   699,052 (0.0%)      return S2N_RESULT_OK;
 4,194,312 (0.0%)  }
         .         
         .         S2N_RESULT s2n_record_max_write_size(struct s2n_connection *conn, uint16_t max_fragment_size, uint16_t *max_record_size)
         .         {
         .             RESULT_ENSURE_REF(conn);
         .             RESULT_ENSURE_MUT(max_record_size);
         .         
         .             if (!IS_NEGOTIATED(conn)) {
         .                 *max_record_size = S2N_TLS_MAX_RECORD_LEN_FOR(max_fragment_size);
-- line 108 ----------------------------------------
-- line 156 ----------------------------------------
         .             RESULT_ENSURE(size <= ETH_MTU, S2N_ERR_FRAGMENT_LENGTH_TOO_LARGE);
         .         
         .             *payload_size = size;
         .         
         .             return S2N_RESULT_OK;
         .         }
         .         
         .         int s2n_record_write_protocol_version(struct s2n_connection *conn, uint8_t record_type, struct s2n_stuffer *out)
 3,844,786 (0.0%)  {
 1,048,578 (0.0%)      uint8_t record_protocol_version = conn->actual_protocol_version;
         .         
         .             /**
         .              *= https://www.rfc-editor.org/rfc/rfc8446#section-5.1
         .              *# This version value is historical, deriving from the use of 0x0301 for
         .              *# TLS 1.0 and 0x0300 for SSL 3.0.  In order to maximize backward
         .              *# compatibility, a record containing an initial ClientHello SHOULD have
         .              *# version 0x0301 (reflecting TLS 1.0)
         .              *
-- line 173 ----------------------------------------
-- line 175 ----------------------------------------
         .              * use that assumed value here in case we are talking to a legacy
         .              * server that expects TLS1.0.
         .              *
         .              * Both TLS 1.3 early data and a deserialized connection will
         .              * send data without the server_protocol_version being known. However,
         .              * the record type would be set to APPLICATION_DATA in their cases
         .              * so this check is avoided.
         .              **/
 2,097,156 (0.0%)      if (conn->server_protocol_version == s2n_unknown_protocol_version
         .                     && record_type == TLS_HANDSHAKE) {
         .                 record_protocol_version = MIN(record_protocol_version, S2N_TLS10);
         .             }
         .         
         .             /**
         .              *= https://www.rfc-editor.org/rfc/rfc8446#section-5.1
         .              *# legacy_record_version:  MUST be set to 0x0303 for all records
         .              *#    generated by a TLS 1.3 implementation other than an initial
         .              *#    ClientHello (i.e., one not generated after a HelloRetryRequest),
         .              *#    where it MAY also be 0x0301 for compatibility purposes.
         .              **/
 1,747,630 (0.0%)      record_protocol_version = MIN(record_protocol_version, S2N_TLS12);
         .         
         .             /* Never send an empty protocol version.
         .              * If the protocol version is unknown, default to TLS1.0 like we do for initial ClientHellos.
         .              */
 1,398,104 (0.0%)      if (record_protocol_version == s2n_unknown_protocol_version) {
         .                 record_protocol_version = S2N_TLS10;
         .             }
         .         
         .             uint8_t protocol_version[S2N_TLS_PROTOCOL_VERSION_LEN];
 2,097,156 (0.0%)      protocol_version[0] = record_protocol_version / 10;
 4,893,364 (0.0%)      protocol_version[1] = record_protocol_version % 10;
         .         
 2,796,208 (0.0%)      POSIX_GUARD(s2n_stuffer_write_bytes(out, protocol_version, S2N_TLS_PROTOCOL_VERSION_LEN));
         .         
   349,526 (0.0%)      return 0;
 1,747,630 (0.0%)  }
         .         
         .         static inline int s2n_record_encrypt(
         .                 struct s2n_connection *conn,
         .                 const struct s2n_cipher_suite *cipher_suite,
         .                 struct s2n_session_key *session_key,
         .                 struct s2n_blob *iv,
         .                 struct s2n_blob *aad,
         .                 struct s2n_blob *en,
         .                 uint8_t *implicit_iv, uint16_t block_size)
 4,194,312 (0.0%)  {
 1,398,104 (0.0%)      POSIX_ENSURE_REF(en->data);
         .         
 3,495,260 (0.0%)      switch (cipher_suite->record_alg->cipher->type) {
         .                 case S2N_STREAM:
         .                     POSIX_GUARD(cipher_suite->record_alg->cipher->io.stream.encrypt(session_key, en, en));
         .                     break;
         .                 case S2N_CBC:
         .                     POSIX_GUARD(cipher_suite->record_alg->cipher->io.cbc.encrypt(session_key, iv, en, en));
         .         
         .                     /* Copy the last encrypted block to be the next IV */
         .                     if (conn->actual_protocol_version < S2N_TLS11) {
         .                         POSIX_ENSURE_GTE(en->size, block_size);
         .                         POSIX_CHECKED_MEMCPY(implicit_iv, en->data + en->size - block_size, block_size);
         .                     }
         .                     break;
         .                 case S2N_AEAD:
 4,893,364 (0.0%)              POSIX_GUARD(cipher_suite->record_alg->cipher->io.aead.encrypt(session_key, iv, aad, en, en));
   699,052 (0.0%)              break;
         .                 case S2N_COMPOSITE:
         .                     /* This will: compute mac, append padding, append padding length, and encrypt */
         .                     POSIX_GUARD(cipher_suite->record_alg->cipher->io.comp.encrypt(session_key, iv, en, en));
         .         
         .                     /* Copy the last encrypted block to be the next IV */
         .                     POSIX_ENSURE_GTE(en->size, block_size);
         .                     POSIX_CHECKED_MEMCPY(implicit_iv, en->data + en->size - block_size, block_size);
         .                     break;
         .                 default:
         .                     POSIX_BAIL(S2N_ERR_CIPHER_TYPE);
         .                     break;
         .             }
         .         
   349,526 (0.0%)      return 0;
 1,048,578 (0.0%)  }
         .         
         .         static S2N_RESULT s2n_record_write_mac(struct s2n_connection *conn, struct s2n_blob *record_header,
         .                 struct s2n_blob *plaintext, struct s2n_stuffer *out, uint32_t *bytes_written)
 4,543,838 (0.0%)  {
   699,052 (0.0%)      RESULT_ENSURE_REF(conn);
 1,398,104 (0.0%)      RESULT_ENSURE_REF(conn->server);
 1,398,104 (0.0%)      RESULT_ENSURE_REF(conn->client);
   699,052 (0.0%)      RESULT_ENSURE_REF(record_header);
   699,052 (0.0%)      RESULT_ENSURE_REF(plaintext);
   699,052 (0.0%)      RESULT_ENSURE_REF(out);
   699,052 (0.0%)      RESULT_ENSURE_REF(bytes_written);
   699,052 (0.0%)      *bytes_written = 0;
         .         
 1,398,104 (0.0%)      struct s2n_hmac_state *mac = &conn->server->server_record_mac;
 1,398,104 (0.0%)      const struct s2n_cipher_suite *cipher_suite = conn->server->cipher_suite;
 1,398,104 (0.0%)      uint8_t *sequence_number = conn->server->server_sequence_number;
         .         
 1,398,104 (0.0%)      if (conn->mode == S2N_CLIENT) {
         .                 mac = &conn->client->client_record_mac;
         .                 cipher_suite = conn->client->cipher_suite;
         .                 sequence_number = conn->client->client_sequence_number;
         .             }
         .         
   699,052 (0.0%)      RESULT_ENSURE_REF(cipher_suite);
 1,398,104 (0.0%)      RESULT_ENSURE_REF(cipher_suite->record_alg);
         .         
 1,747,630 (0.0%)      if (cipher_suite->record_alg->hmac_alg == S2N_HMAC_NONE) {
         .                 /* If the S2N_HMAC_NONE algorithm is specified, a MAC should not be explicitly written.
         .                  * This is the case for AEAD and Composite cipher types, where the MAC is written as part
         .                  * of encryption. This is also the case for plaintext handshake records, where the null
         .                  * stream cipher is used.
         .                  */
   699,052 (0.0%)          return S2N_RESULT_OK;
         .             }
         .         
         .             /**
         .              *= https://www.rfc-editor.org/rfc/rfc5246#section-6.2.3.1
         .              *# The MAC is generated as:
         .              *#
         .              *#    MAC(MAC_write_key, seq_num +
         .              */
-- line 295 ----------------------------------------
-- line 346 ----------------------------------------
         .             uint8_t *digest = s2n_stuffer_raw_write(out, mac_digest_size);
         .             RESULT_ENSURE_REF(digest);
         .             RESULT_GUARD_POSIX(s2n_hmac_digest(mac, digest, mac_digest_size));
         .             *bytes_written = mac_digest_size;
         .         
         .             RESULT_GUARD_POSIX(s2n_hmac_reset(mac));
         .         
         .             return S2N_RESULT_OK;
 2,097,156 (0.0%)  }
         .         
         .         int s2n_record_writev(struct s2n_connection *conn, uint8_t content_type, const struct iovec *in, int in_count, size_t offs, size_t to_write)
 5,242,890 (0.0%)  {
 1,747,630 (0.0%)      if (conn->ktls_send_enabled) {
         .                 return s2n_ktls_record_writev(conn, content_type, in, in_count, offs, to_write);
         .             }
         .         
 1,048,578 (0.0%)      struct s2n_blob iv = { 0 };
   349,526 (0.0%)      uint8_t padding = 0;
   349,526 (0.0%)      uint16_t block_size = 0;
   699,052 (0.0%)      uint8_t aad_iv[S2N_TLS_MAX_IV_LEN] = { 0 };
         .         
         .             /* In TLS 1.3, handle CCS message as unprotected records */
 1,048,578 (0.0%)      struct s2n_crypto_parameters *current_client_crypto = conn->client;
 1,048,578 (0.0%)      struct s2n_crypto_parameters *current_server_crypto = conn->server;
 2,097,156 (0.0%)      if (conn->actual_protocol_version == S2N_TLS13 && content_type == TLS_CHANGE_CIPHER_SPEC) {
         .                 POSIX_ENSURE_REF(conn->initial);
         .                 conn->client = conn->initial;
         .                 conn->server = conn->initial;
         .             }
         .         
 1,398,104 (0.0%)      uint8_t *sequence_number = conn->server->server_sequence_number;
 1,398,104 (0.0%)      struct s2n_session_key *session_key = &conn->server->server_key;
 1,398,104 (0.0%)      const struct s2n_cipher_suite *cipher_suite = conn->server->cipher_suite;
 1,398,104 (0.0%)      uint8_t *implicit_iv = conn->server->server_implicit_iv;
         .         
 1,398,104 (0.0%)      if (conn->mode == S2N_CLIENT) {
         .                 sequence_number = conn->client->client_sequence_number;
         .                 session_key = &conn->client->client_key;
         .                 cipher_suite = conn->client->cipher_suite;
         .                 implicit_iv = conn->client->client_implicit_iv;
         .             }
         .         
         .             /* The NULL stream cipher MUST NEVER be used for ApplicationData.
         .              * Writing ApplicationData unencrypted defeats the purpose of TLS. */
 2,097,156 (0.0%)      if (cipher_suite->record_alg->cipher == &s2n_null_cipher) {
         .                 POSIX_ENSURE(content_type != TLS_APPLICATION_DATA, S2N_ERR_ENCRYPT);
         .             }
         .         
 1,747,630 (0.0%)      const int is_tls13_record = cipher_suite->record_alg->flags & S2N_TLS13_RECORD_AEAD_NONCE;
 7,340,046 (0.0%)      s2n_stack_blob(aad, is_tls13_record ? S2N_TLS13_AAD_LEN : S2N_TLS_MAX_AAD_LEN, S2N_TLS_MAX_AAD_LEN);
         .         
         .             /* If we aren't buffering multiple records, then the output stuffer should be empty. */
 1,747,630 (0.0%)      if (!conn->multirecord_send) {
 2,097,156 (0.0%)          POSIX_ENSURE(s2n_stuffer_data_available(&conn->out) == 0, S2N_ERR_RECORD_STUFFER_NEEDS_DRAINING);
         .             }
         .         
         .             /* Before we do anything, we need to figure out what the length of the
         .              * fragment is going to be.
         .              */
   349,526 (0.0%)      uint16_t max_write_payload_size = 0;
 3,495,260 (0.0%)      POSIX_GUARD_RESULT(s2n_record_max_write_payload_size(conn, &max_write_payload_size));
 2,097,156 (0.0%)      const uint16_t data_bytes_to_take = MIN(to_write, max_write_payload_size);
         .         
   349,526 (0.0%)      uint16_t extra = 0;
 3,495,260 (0.0%)      POSIX_GUARD_RESULT(s2n_tls_record_overhead(conn, &extra));
         .         
         .             /* If we have padding to worry about, figure that out too */
 2,097,156 (0.0%)      if (cipher_suite->record_alg->cipher->type == S2N_CBC) {
         .                 block_size = cipher_suite->record_alg->cipher->io.cbc.block_size;
         .                 if (((data_bytes_to_take + extra) % block_size)) {
         .                     padding = block_size - ((data_bytes_to_take + extra) % block_size);
         .                 }
 2,097,156 (0.0%)      } else if (cipher_suite->record_alg->cipher->type == S2N_COMPOSITE) {
         .                 block_size = cipher_suite->record_alg->cipher->io.comp.block_size;
         .             }
         .         
 1,398,104 (0.0%)      if (s2n_stuffer_is_freed(&conn->out)) {
         .                 /* If the output buffer has not been allocated yet, allocate
         .                  * at least enough memory to hold a record with the local maximum fragment length.
         .                  *
         .                  * The local maximum fragment length is:
         .                  * 1) The local default configured for new connections
         .                  * 2) The local value set by the user via s2n_connection_prefer_throughput()
         .                  *    or s2n_connection_prefer_low_latency()
         .                  * 3) On the server, the minimum of the local value and the value negotiated with the
-- line 430 ----------------------------------------
-- line 438 ----------------------------------------
         .         
         .                 uint32_t buffer_size = MAX(conn->config->send_buffer_size_override, max_wire_record_size);
         .                 POSIX_GUARD(s2n_stuffer_growable_alloc(&conn->out, buffer_size));
         .             }
         .         
         .             /* A record only local stuffer used to avoid tainting the conn->out stuffer or overwriting
         .              * previous records. It should be used to add an individual record to the out stuffer.
         .              */
 1,048,578 (0.0%)      struct s2n_blob record_blob = { 0 };
 1,398,104 (0.0%)      struct s2n_stuffer record_stuffer = { 0 };
 5,941,942 (0.0%)      POSIX_GUARD(s2n_blob_init(&record_blob,
         .                     conn->out.blob.data + conn->out.write_cursor,
         .                     s2n_stuffer_space_remaining(&conn->out)));
 2,446,682 (0.0%)      POSIX_GUARD(s2n_stuffer_init(&record_stuffer, &record_blob));
         .         
         .             /* Now that we know the length, start writing the record */
 1,398,104 (0.0%)      uint8_t record_type = RECORD_TYPE(is_tls13_record, content_type);
 2,446,682 (0.0%)      POSIX_GUARD(s2n_stuffer_write_uint8(&record_stuffer, record_type));
 2,796,208 (0.0%)      POSIX_GUARD(s2n_record_write_protocol_version(conn, record_type, &record_stuffer));
         .         
         .             /* Compute non-payload parts of the MAC(seq num, type, proto vers, fragment length) for composite ciphers.
         .              * Composite "encrypt" will MAC the payload data and fill in padding.
         .              */
 2,097,156 (0.0%)      if (cipher_suite->record_alg->cipher->type == S2N_COMPOSITE) {
         .                 /* Only fragment length is needed for MAC, but the EVP ctrl function needs fragment length + eiv len. */
         .                 uint16_t payload_and_eiv_len = data_bytes_to_take;
         .                 if (conn->actual_protocol_version > S2N_TLS10) {
         .                     payload_and_eiv_len += block_size;
         .                 }
         .         
         .                 /* Outputs number of extra bytes required for MAC and padding */
         .                 int pad_and_mac_len = 0;
         .                 POSIX_GUARD(cipher_suite->record_alg->cipher->io.comp.initial_hmac(session_key, sequence_number, content_type, conn->actual_protocol_version,
         .                         payload_and_eiv_len, &pad_and_mac_len));
         .                 extra += pad_and_mac_len;
         .             }
         .         
         .             /* TLS 1.3 protected record occupies one extra byte for content type */
   699,052 (0.0%)      if (is_tls13_record) {
 1,048,578 (0.0%)          extra += S2N_TLS_CONTENT_TYPE_LENGTH;
         .             }
         .         
         .             /* Rewrite the length to be the actual fragment length */
 2,097,156 (0.0%)      const uint16_t actual_fragment_length = data_bytes_to_take + padding + extra;
         .             /* ensure actual_fragment_length + S2N_TLS_RECORD_HEADER_LENGTH <= max record length */
 1,747,630 (0.0%)      const uint16_t max_record_length = is_tls13_record ? S2N_TLS13_MAXIMUM_RECORD_LENGTH : S2N_TLS_MAXIMUM_RECORD_LENGTH;
 1,747,630 (0.0%)      S2N_ERROR_IF(actual_fragment_length + S2N_TLS_RECORD_HEADER_LENGTH > max_record_length, S2N_ERR_RECORD_LENGTH_TOO_LARGE);
 2,446,682 (0.0%)      POSIX_GUARD(s2n_stuffer_write_uint16(&record_stuffer, actual_fragment_length));
         .         
         .             /* If we're AEAD, write the sequence number as an IV, and generate the AAD */
 2,097,156 (0.0%)      if (cipher_suite->record_alg->cipher->type == S2N_AEAD) {
 1,398,104 (0.0%)          struct s2n_stuffer iv_stuffer = { 0 };
 2,796,208 (0.0%)          POSIX_GUARD(s2n_blob_init(&iv, aad_iv, sizeof(aad_iv)));
 2,446,682 (0.0%)          POSIX_GUARD(s2n_stuffer_init(&iv_stuffer, &iv));
         .         
 2,097,156 (0.0%)          if (cipher_suite->record_alg->flags & S2N_TLS12_AES_GCM_AEAD_NONCE) {
         .                     /* Partially explicit nonce. See RFC 5288 Section 3 */
         .                     POSIX_GUARD(s2n_stuffer_write_bytes(&record_stuffer, sequence_number, S2N_TLS_SEQUENCE_NUM_LEN));
         .                     POSIX_GUARD(s2n_stuffer_write_bytes(&iv_stuffer, implicit_iv, cipher_suite->record_alg->cipher->io.aead.fixed_iv_size));
         .                     POSIX_GUARD(s2n_stuffer_write_bytes(&iv_stuffer, sequence_number, S2N_TLS_SEQUENCE_NUM_LEN));
 3,145,734 (0.0%)          } else if (cipher_suite->record_alg->flags & S2N_TLS12_CHACHA_POLY_AEAD_NONCE || is_tls13_record) {
         .                     /* Fully implicit nonce. See RFC7905 Section 2 */
   349,526 (0.0%)              uint8_t four_zeroes[4] = { 0 };
 2,796,208 (0.0%)              POSIX_GUARD(s2n_stuffer_write_bytes(&iv_stuffer, four_zeroes, 4));
 2,796,208 (0.0%)              POSIX_GUARD(s2n_stuffer_write_bytes(&iv_stuffer, sequence_number, S2N_TLS_SEQUENCE_NUM_LEN));
36,700,230 (0.2%)              for (int i = 0; i < cipher_suite->record_alg->cipher->io.aead.fixed_iv_size; i++) {
54,526,056 (0.3%)                  aad_iv[i] = aad_iv[i] ^ implicit_iv[i];
         .                     }
         .                 } else {
         .                     POSIX_BAIL(S2N_ERR_INVALID_NONCE_TYPE);
         .                 }
         .         
         .                 /* Set the IV size to the amount of data written */
 1,398,104 (0.0%)          iv.size = s2n_stuffer_data_available(&iv_stuffer);
   699,052 (0.0%)          if (is_tls13_record) {
 5,941,942 (0.0%)              POSIX_GUARD_RESULT(s2n_tls13_aead_aad_init(data_bytes_to_take + S2N_TLS_CONTENT_TYPE_LENGTH, cipher_suite->record_alg->cipher->io.aead.tag_size, &aad));
         .                 } else {
         .                     POSIX_GUARD_RESULT(s2n_aead_aad_init(conn, sequence_number, content_type, data_bytes_to_take, &aad));
         .                 }
         .             } else if (cipher_suite->record_alg->cipher->type == S2N_CBC || cipher_suite->record_alg->cipher->type == S2N_COMPOSITE) {
         .                 POSIX_GUARD(s2n_blob_init(&iv, implicit_iv, block_size));
         .         
         .                 /* For TLS1.1/1.2; write the IV with random data */
         .                 if (conn->actual_protocol_version > S2N_TLS10) {
-- line 521 ----------------------------------------
-- line 544 ----------------------------------------
         .                          * s2n starts AES *after* the explicit IV.
         .                          */
         .                         POSIX_GUARD(s2n_stuffer_write(&record_stuffer, &iv));
         .                     }
         .                 }
         .             }
         .         
         .             /* Write the plaintext data */
 4,543,838 (0.0%)      POSIX_GUARD(s2n_stuffer_writev_bytes(&record_stuffer, in, in_count, offs, data_bytes_to_take));
 2,446,682 (0.0%)      void *orig_write_ptr = record_stuffer.blob.data + record_stuffer.write_cursor - data_bytes_to_take;
         .         
         .             /* Write the MAC */
 1,048,578 (0.0%)      struct s2n_blob header_blob = { 0 };
 2,796,208 (0.0%)      POSIX_GUARD(s2n_blob_slice(&record_blob, &header_blob, 0, S2N_TLS_RECORD_HEADER_LENGTH));
 1,048,578 (0.0%)      struct s2n_blob plaintext_blob = { 0 };
 2,796,208 (0.0%)      POSIX_GUARD(s2n_blob_init(&plaintext_blob, orig_write_ptr, data_bytes_to_take));
   349,526 (0.0%)      uint32_t mac_digest_size = 0;
 4,543,838 (0.0%)      POSIX_GUARD_RESULT(s2n_record_write_mac(conn, &header_blob, &plaintext_blob, &record_stuffer, &mac_digest_size));
         .         
         .             /* We are done with this sequence number, so we can increment it */
 1,048,578 (0.0%)      struct s2n_blob seq = { 0 };
 2,796,208 (0.0%)      POSIX_GUARD(s2n_blob_init(&seq, sequence_number, S2N_TLS_SEQUENCE_NUM_LEN));
 1,747,630 (0.0%)      POSIX_GUARD(s2n_increment_sequence_number(&seq));
         .         
         .             /* Write content type for TLS 1.3 record (RFC 8446 Section 5.2) */
   699,052 (0.0%)      if (is_tls13_record) {
 2,446,682 (0.0%)          POSIX_GUARD(s2n_stuffer_write_uint8(&record_stuffer, content_type));
         .             }
         .         
 2,097,156 (0.0%)      if (cipher_suite->record_alg->cipher->type == S2N_CBC) {
         .                 /* Include padding bytes, each with the value 'p', and
         .                  * include an extra padding length byte, also with the value 'p'.
         .                  */
         .                 for (int i = 0; i <= padding; i++) {
         .                     POSIX_GUARD(s2n_stuffer_write_uint8(&record_stuffer, padding));
         .                 }
         .             }
         .         
         .             /* Rewind to rewrite/encrypt the packet */
 1,747,630 (0.0%)      POSIX_GUARD(s2n_stuffer_rewrite(&record_stuffer));
         .         
         .             /* Skip the header */
 2,097,156 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(&record_stuffer, S2N_TLS_RECORD_HEADER_LENGTH));
         .         
 1,747,630 (0.0%)      uint16_t encrypted_length = data_bytes_to_take + mac_digest_size;
 4,194,312 (0.0%)      switch (cipher_suite->record_alg->cipher->type) {
         .                 case S2N_AEAD:
 3,844,786 (0.0%)              POSIX_GUARD(s2n_stuffer_skip_write(&record_stuffer, cipher_suite->record_alg->cipher->io.aead.record_iv_size));
 2,097,156 (0.0%)              encrypted_length += cipher_suite->record_alg->cipher->io.aead.tag_size;
   699,052 (0.0%)              if (is_tls13_record) {
         .                         /* one extra byte for content type */
   349,526 (0.0%)                  encrypted_length += S2N_TLS_CONTENT_TYPE_LENGTH;
         .                     }
   699,052 (0.0%)              break;
         .                 case S2N_CBC:
         .                     if (conn->actual_protocol_version > S2N_TLS10) {
         .                         /* Leave the IV alone and unencrypted */
         .                         POSIX_GUARD(s2n_stuffer_skip_write(&record_stuffer, iv.size));
         .                     }
         .                     /* Encrypt the padding and the padding length byte too */
         .                     encrypted_length += padding + 1;
         .                     break;
-- line 605 ----------------------------------------
-- line 609 ----------------------------------------
         .                 */
         .                     encrypted_length += extra;
         .                     break;
         .                 default:
         .                     break;
         .             }
         .         
         .             /* Check that stuffer have enough space to write encrypted record, because raw_write cannot expand tainted stuffer */
 2,097,156 (0.0%)      S2N_ERROR_IF(s2n_stuffer_space_remaining(&record_stuffer) < encrypted_length, S2N_ERR_RECORD_STUFFER_SIZE);
         .         
         .             /* Do the encryption */
 3,844,786 (0.0%)      struct s2n_blob en = { .size = encrypted_length, .data = s2n_stuffer_raw_write(&record_stuffer, encrypted_length) };
 4,893,364 (0.0%)      POSIX_GUARD(s2n_record_encrypt(conn, cipher_suite, session_key, &iv, &aad, &en, implicit_iv, block_size));
         .         
         .             /* Sync the out stuffer write cursor with the record stuffer. */
 3,495,260 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(&conn->out, s2n_stuffer_data_available(&record_stuffer)));
         .         
 2,097,156 (0.0%)      if (conn->actual_protocol_version == S2N_TLS13 && content_type == TLS_CHANGE_CIPHER_SPEC) {
         .                 conn->client = current_client_crypto;
         .                 conn->server = current_server_crypto;
         .             }
         .         
   349,526 (0.0%)      return data_bytes_to_take;
 2,097,156 (0.0%)  }
         .         
         .         S2N_RESULT s2n_record_write(struct s2n_connection *conn, uint8_t content_type, struct s2n_blob *in)
         .         {
         .             struct iovec iov;
         .             iov.iov_base = in->data;
         .             iov.iov_len = in->size;
         .             int written = s2n_record_writev(conn, content_type, &iov, 1, 0, in->size);
         .             RESULT_GUARD_POSIX(written);
-- line 640 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_recv.c
--------------------------------------------------------------------------------
Ir_______________ 

-- line 32 ----------------------------------------
         .         #include "tls/s2n_resume.h"
         .         #include "tls/s2n_tls.h"
         .         #include "utils/s2n_blob.h"
         .         #include "utils/s2n_io.h"
         .         #include "utils/s2n_safety.h"
         .         #include "utils/s2n_socket.h"
         .         
         .         S2N_RESULT s2n_recv_in_init(struct s2n_connection *conn, uint32_t written, uint32_t total)
 2,796,208 (0.0%)  {
   699,052 (0.0%)      RESULT_ENSURE_REF(conn);
         .         
         .             /* If we're going to initialize conn->in to point to more memory than
         .              * is actually readable, make sure that the additional memory exists.
         .              */
 1,048,578 (0.0%)      RESULT_ENSURE_LTE(written, total);
 1,048,578 (0.0%)      uint32_t remaining = total - written;
 2,446,682 (0.0%)      RESULT_ENSURE_LTE(remaining, s2n_stuffer_space_remaining(&conn->buffer_in));
         .         
 2,446,682 (0.0%)      uint8_t *data = s2n_stuffer_raw_read(&conn->buffer_in, written);
   699,052 (0.0%)      RESULT_ENSURE_REF(data);
 2,097,156 (0.0%)      RESULT_GUARD_POSIX(s2n_stuffer_free(&conn->in));
 3,145,734 (0.0%)      RESULT_GUARD_POSIX(s2n_blob_init(&conn->in.blob, data, total));
 2,796,208 (0.0%)      RESULT_GUARD_POSIX(s2n_stuffer_skip_write(&conn->in, written));
   349,526 (0.0%)      return S2N_RESULT_OK;
 1,048,578 (0.0%)  }
         .         
         .         S2N_RESULT s2n_read_in_bytes(struct s2n_connection *conn, struct s2n_stuffer *output, uint32_t length)
 4,893,364 (0.0%)  {
10,485,780 (0.1%)      while (s2n_stuffer_data_available(output) < length) {
 5,592,416 (0.0%)          uint32_t remaining = length - s2n_stuffer_data_available(output);
 3,495,260 (0.0%)          if (conn->recv_buffering) {
         .                     remaining = MAX(remaining, s2n_stuffer_space_remaining(output));
         .                 }
 1,398,104 (0.0%)          errno = 0;
 4,893,364 (0.0%)          int r = s2n_connection_recv_stuffer(output, conn, remaining);
 1,398,104 (0.0%)          if (r == 0) {
         .                     s2n_atomic_flag_set(&conn->read_closed);
         .                 }
 6,291,468 (0.0%)          RESULT_GUARD(s2n_io_check_read_result(r));
 4,893,364 (0.0%)          conn->wire_bytes_in += r;
         .             }
         .         
   699,052 (0.0%)      return S2N_RESULT_OK;
 1,398,104 (0.0%)  }
         .         
         .         static S2N_RESULT s2n_recv_buffer_in(struct s2n_connection *conn, size_t min_size)
 4,194,312 (0.0%)  {
 4,893,364 (0.0%)      RESULT_GUARD_POSIX(s2n_stuffer_resize_if_empty(&conn->buffer_in, S2N_LARGE_FRAGMENT_LENGTH));
 4,194,312 (0.0%)      uint32_t buffer_in_available = s2n_stuffer_data_available(&conn->buffer_in);
 2,097,156 (0.0%)      if (buffer_in_available < min_size) {
 2,097,156 (0.0%)          uint32_t remaining = min_size - buffer_in_available;
 4,893,364 (0.0%)          if (s2n_stuffer_space_remaining(&conn->buffer_in) < remaining) {
         .                     RESULT_GUARD_POSIX(s2n_stuffer_shift(&conn->buffer_in));
         .                 }
 9,087,676 (0.1%)          RESULT_GUARD(s2n_read_in_bytes(conn, &conn->buffer_in, min_size));
         .             }
   699,052 (0.0%)      return S2N_RESULT_OK;
 1,398,104 (0.0%)  }
         .         
         .         int s2n_read_full_record(struct s2n_connection *conn, uint8_t *record_type, int *isSSLv2)
 4,194,312 (0.0%)  {
   699,052 (0.0%)      *isSSLv2 = 0;
         .         
 1,747,630 (0.0%)      if (conn->ktls_recv_enabled) {
         .                 return s2n_ktls_read_full_record(conn, record_type);
         .             }
         .         
         .             /* If the record has already been decrypted, then leave it alone */
 1,398,104 (0.0%)      if (conn->in_status == PLAINTEXT) {
         .                 /* Only application data packets count as plaintext */
         .                 *record_type = TLS_APPLICATION_DATA;
         .                 return S2N_SUCCESS;
         .             }
         .         
         .             /* Read the record until we at least have a header */
 2,097,156 (0.0%)      POSIX_GUARD(s2n_stuffer_reread(&conn->header_in));
 2,097,156 (0.0%)      uint32_t header_available = s2n_stuffer_data_available(&conn->header_in);
   699,052 (0.0%)      if (header_available < S2N_TLS_RECORD_HEADER_LENGTH) {
 1,048,578 (0.0%)          uint32_t header_remaining = S2N_TLS_RECORD_HEADER_LENGTH - header_available;
 2,097,156 (0.0%)          s2n_result ret = s2n_recv_buffer_in(conn, header_remaining);
 3,495,260 (0.0%)          uint32_t header_read = MIN(header_remaining, s2n_stuffer_data_available(&conn->buffer_in));
 3,495,260 (0.0%)          POSIX_GUARD(s2n_stuffer_copy(&conn->buffer_in, &conn->header_in, header_read));
 2,097,156 (0.0%)          POSIX_GUARD_RESULT(ret);
         .             }
         .         
   349,526 (0.0%)      uint16_t fragment_length = 0;
         .         
         .             /* If the first bit is set then this is an SSLv2 record */
 1,747,630 (0.0%)      if (conn->header_in.blob.data[0] & S2N_TLS_SSLV2_HEADER_FLAG) {
         .                 *isSSLv2 = 1;
         .                 WITH_ERROR_BLINDING(conn, POSIX_GUARD(s2n_sslv2_record_header_parse(conn, record_type, &conn->client_protocol_version, &fragment_length)));
         .             } else {
 6,990,520 (0.0%)          WITH_ERROR_BLINDING(conn, POSIX_GUARD(s2n_record_header_parse(conn, record_type, &fragment_length)));
         .             }
         .         
         .             /* Read enough to have the whole record */
 2,097,156 (0.0%)      uint32_t fragment_available = s2n_stuffer_data_available(&conn->in);
 1,398,104 (0.0%)      if (fragment_available < fragment_length || fragment_length == 0) {
 2,796,208 (0.0%)          POSIX_GUARD(s2n_stuffer_rewind_read(&conn->buffer_in, fragment_available));
 2,446,682 (0.0%)          s2n_result ret = s2n_recv_buffer_in(conn, fragment_length);
 3,495,260 (0.0%)          uint32_t fragment_read = MIN(fragment_length, s2n_stuffer_data_available(&conn->buffer_in));
 4,194,312 (0.0%)          POSIX_GUARD_RESULT(s2n_recv_in_init(conn, fragment_read, fragment_length));
 2,097,156 (0.0%)          POSIX_GUARD_RESULT(ret);
         .             }
         .         
 1,398,104 (0.0%)      if (*isSSLv2) {
         .                 return 0;
         .             }
         .         
         .             /* Decrypt and parse the record */
 3,145,734 (0.0%)      if (s2n_early_data_is_trial_decryption_allowed(conn, *record_type)) {
         .                 POSIX_ENSURE(s2n_record_parse(conn) >= S2N_SUCCESS, S2N_ERR_EARLY_DATA_TRIAL_DECRYPT);
         .             } else {
 5,941,942 (0.0%)          WITH_ERROR_BLINDING(conn, POSIX_GUARD(s2n_record_parse(conn)));
         .             }
         .         
         .             /* In TLS 1.3, encrypted handshake records would appear to be of record type
         .             * TLS_APPLICATION_DATA. The actual record content type is found after the encrypted
         .             * is decrypted.
         .             */
 2,796,208 (0.0%)      if (conn->actual_protocol_version == S2N_TLS13 && *record_type == TLS_APPLICATION_DATA) {
 2,796,208 (0.0%)          POSIX_GUARD(s2n_tls13_parse_record_type(&conn->in, record_type));
         .             }
         .         
   349,526 (0.0%)      return 0;
 3,145,734 (0.0%)  }
         .         
         .         ssize_t s2n_recv_impl(struct s2n_connection *conn, void *buf, ssize_t size_signed, s2n_blocked_status *blocked)
 4,543,838 (0.0%)  {
   699,052 (0.0%)      POSIX_ENSURE_GTE(size_signed, 0);
   699,052 (0.0%)      size_t size = size_signed;
   349,526 (0.0%)      ssize_t bytes_read = 0;
 1,048,578 (0.0%)      struct s2n_blob out = { 0 };
 2,796,208 (0.0%)      POSIX_GUARD(s2n_blob_init(&out, (uint8_t *) buf, 0));
         .         
         .             /*
         .              * Set the `blocked` status to BLOCKED_ON_READ by default
         .              *
         .              * The only case in which it should be updated is on a successful read into the provided buffer.
         .              *
         .              * Unfortunately, the current `blocked` behavior has become ossified by buggy applications that ignore
         .              * error types and only read `blocked`. As such, it's very important to avoid changing how this value is updated
         .              * as it could break applications.
         .              */
   699,052 (0.0%)      *blocked = S2N_BLOCKED_ON_READ;
         .         
 2,446,682 (0.0%)      if (!s2n_connection_check_io_status(conn, S2N_IO_READABLE)) {
         .                 /*
         .                  *= https://www.rfc-editor.org/rfc/rfc8446#6.1
         .                  *# If a transport-level close
         .                  *# is received prior to a "close_notify", the receiver cannot know that
         .                  *# all the data that was sent has been received.
         .                  *
         .                  *= https://www.rfc-editor.org/rfc/rfc8446#6.1
         .                  *# If the application protocol using TLS provides that any data may be
-- line 186 ----------------------------------------
-- line 188 ----------------------------------------
         .                  *# closed, the TLS implementation MUST receive a "close_notify" alert
         .                  *# before indicating end-of-data to the application layer.
         .                  */
         .                 POSIX_ENSURE(s2n_atomic_flag_test(&conn->close_notify_received), S2N_ERR_CLOSED);
         .                 *blocked = S2N_NOT_BLOCKED;
         .                 return 0;
         .             }
         .         
 1,747,630 (0.0%)      POSIX_ENSURE(!s2n_connection_is_quic_enabled(conn), S2N_ERR_UNSUPPORTED_WITH_QUIC);
 2,796,208 (0.0%)      POSIX_GUARD_RESULT(s2n_early_data_validate_recv(conn));
         .         
 2,796,208 (0.0%)      while (size && s2n_connection_check_io_status(conn, S2N_IO_READABLE)) {
   349,526 (0.0%)          int isSSLv2 = 0;
   349,526 (0.0%)          uint8_t record_type = 0;
 2,446,682 (0.0%)          int r = s2n_read_full_record(conn, &record_type, &isSSLv2);
   699,052 (0.0%)          if (r < 0) {
         .                     /* Don't propagate the error if we already read some bytes. */
         .                     if (bytes_read && (s2n_errno == S2N_ERR_CLOSED || s2n_errno == S2N_ERR_IO_BLOCKED)) {
         .                         break;
         .                     }
         .         
         .                     /* If we get here, it's an error condition */
         .                     if (s2n_errno != S2N_ERR_IO_BLOCKED && s2n_allowed_to_cache_connection(conn) && conn->session_id_len) {
         .                         conn->config->cache_delete(conn, conn->config->cache_delete_data, conn->session_id, conn->session_id_len);
         .                     }
         .         
         .                     S2N_ERROR_PRESERVE_ERRNO();
         .                 }
         .         
 1,048,578 (0.0%)          S2N_ERROR_IF(isSSLv2, S2N_ERR_BAD_MESSAGE);
         .         
 1,048,578 (0.0%)          if (record_type != TLS_HANDSHAKE) {
         .                     /*
         .                      *= https://www.rfc-editor.org/rfc/rfc8446#section-5.1
         .                      *#    -  Handshake messages MUST NOT be interleaved with other record
         .                      *#       types.  That is, if a handshake message is split over two or more
         .                      *#       records, there MUST NOT be any other records between them.
         .                      */
 1,398,104 (0.0%)              POSIX_ENSURE(s2n_stuffer_is_wiped(&conn->post_handshake.in), S2N_ERR_BAD_MESSAGE);
         .         
         .                     /* If not handling a handshake message, free the post-handshake memory.
         .                      * Post-handshake messages are infrequent enough that we don't want to
         .                      * keep a potentially large buffer around unnecessarily.
         .                      */
 1,398,104 (0.0%)              if (!s2n_stuffer_is_freed(&conn->post_handshake.in)) {
         .                         POSIX_GUARD(s2n_stuffer_free(&conn->post_handshake.in));
         .                     }
         .                 }
         .         
 1,048,578 (0.0%)          if (record_type != TLS_APPLICATION_DATA) {
         .                     switch (record_type) {
         .                         case TLS_ALERT:
         .                             POSIX_GUARD(s2n_process_alert_fragment(conn));
         .                             break;
         .                         case TLS_HANDSHAKE: {
         .                             s2n_result result = s2n_post_handshake_recv(conn);
         .                             /* Ignore any errors due to insufficient input data from io.
         .                              * The next iteration of this loop will attempt to read more input data.
-- line 245 ----------------------------------------
-- line 249 ----------------------------------------
         .                             }
         .                             break;
         .                         }
         .                     }
         .                     POSIX_GUARD_RESULT(s2n_record_wipe(conn));
         .                     continue;
         .                 }
         .         
 3,495,260 (0.0%)          out.size = MIN(size, s2n_stuffer_data_available(&conn->in));
         .         
 2,796,208 (0.0%)          POSIX_GUARD(s2n_stuffer_erase_and_read(&conn->in, &out));
 1,048,578 (0.0%)          bytes_read += out.size;
         .         
 1,747,630 (0.0%)          out.data += out.size;
 1,048,578 (0.0%)          size -= out.size;
         .         
         .                 /* Are we ready for more encrypted data? */
 2,097,156 (0.0%)          if (s2n_stuffer_data_available(&conn->in) == 0) {
 2,796,208 (0.0%)              POSIX_GUARD_RESULT(s2n_record_wipe(conn));
         .                 }
         .         
         .                 /* If we've read some data, return it in legacy mode */
 2,796,208 (0.0%)          if (bytes_read && !conn->config->recv_multi_record) {
   349,526 (0.0%)              break;
         .                 }
         .             }
         .         
         .             /* Due to the history of this API, some applications depend on the blocked status to know if
         .              * the connection's `in` stuffer was completely cleared. This behavior needs to be preserved.
         .              *
         .              * Moving forward, applications should instead use `s2n_peek`, which accomplishes the same thing
         .              * without conflating being blocked on reading from the OS socket vs blocked on the application's
         .              * buffer size.
         .              */
 2,097,156 (0.0%)      if (s2n_stuffer_data_available(&conn->in) == 0) {
   699,052 (0.0%)          *blocked = S2N_NOT_BLOCKED;
         .             }
         .         
   699,052 (0.0%)      return bytes_read;
 3,145,734 (0.0%)  }
         .         
         .         ssize_t s2n_recv(struct s2n_connection *conn, void *buf, ssize_t size, s2n_blocked_status *blocked)
 3,145,734 (0.0%)  {
 1,398,104 (0.0%)      POSIX_ENSURE(!conn->recv_in_use, S2N_ERR_REENTRANCY);
   699,052 (0.0%)      conn->recv_in_use = true;
         .         
 2,446,682 (0.0%)      ssize_t result = s2n_recv_impl(conn, buf, size, blocked);
 3,495,260 (0.0%)      POSIX_GUARD_RESULT(s2n_early_data_record_bytes(conn, result));
         .         
         .             /* finish the recv call */
 2,796,208 (0.0%)      POSIX_GUARD_RESULT(s2n_connection_dynamic_free_in_buffer(conn));
         .         
   699,052 (0.0%)      conn->recv_in_use = false;
   349,526 (0.0%)      return result;
 1,048,578 (0.0%)  }
         .         
         .         uint32_t s2n_peek(struct s2n_connection *conn)
         .         {
         .             if (conn == NULL) {
         .                 return 0;
         .             }
         .         
         .             /* If we have partially buffered an encrypted record,
-- line 311 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_send.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 37 ----------------------------------------
        .          *
        .          * We only buffer multiple records when sending application data, NOT when
        .          * sending handshake messages or alerts. If the next record is a post-handshake message
        .          * or an alert, then the send buffer will be flushed regardless of the result of this method.
        .          * Therefore we don't need to consider the size of any potential KeyUpdate messages,
        .          * NewSessionTicket messages, or Alerts.
        .          */
        .         bool s2n_should_flush(struct s2n_connection *conn, ssize_t total_message_size)
3,145,734 (0.0%)  {
        .             /* Always flush if not buffering multiple records. */
1,747,630 (0.0%)      if (!conn->multirecord_send) {
  699,052 (0.0%)          return true;
        .             }
        .         
        .             /* Flush if all data has been sent. */
        .             ssize_t remaining_payload_size = total_message_size - conn->current_user_data_consumed;
        .             if (remaining_payload_size <= 0) {
        .                 return true;
        .             }
        .         
-- line 56 ----------------------------------------
-- line 73 ----------------------------------------
        .              * hasn't been allocated, assume it will have enough space.
        .              */
        .             uint32_t available_space = s2n_stuffer_space_remaining(&conn->out);
        .             if (available_space < max_write_size && !s2n_stuffer_is_freed(&conn->out)) {
        .                 return true;
        .             }
        .         
        .             return false;
1,747,630 (0.0%)  }
        .         
        .         int s2n_flush(struct s2n_connection *conn, s2n_blocked_status *blocked)
4,194,312 (0.0%)  {
1,398,104 (0.0%)      *blocked = S2N_BLOCKED_ON_WRITE;
        .         
        .             /* Write any data that's already pending */
6,990,520 (0.0%)      while (s2n_stuffer_data_available(&conn->out)) {
  699,052 (0.0%)          errno = 0;
4,194,312 (0.0%)          int w = s2n_connection_send_stuffer(&conn->out, conn, s2n_stuffer_data_available(&conn->out));
3,145,734 (0.0%)          POSIX_GUARD_RESULT(s2n_io_check_write_result(w));
2,446,682 (0.0%)          conn->wire_bytes_out += w;
        .             }
4,194,312 (0.0%)      POSIX_GUARD(s2n_stuffer_rewrite(&conn->out));
        .         
2,796,208 (0.0%)      if (conn->reader_warning_out) {
        .                 POSIX_GUARD_RESULT(s2n_alerts_write_warning(conn));
        .                 conn->reader_warning_out = 0;
        .                 POSIX_GUARD(s2n_flush(conn, blocked));
        .             }
        .         
1,398,104 (0.0%)      *blocked = S2N_NOT_BLOCKED;
  699,052 (0.0%)      return 0;
1,398,104 (0.0%)  }
        .         
        .         S2N_RESULT s2n_sendv_with_offset_total_size(const struct iovec *bufs, ssize_t count,
        .                 ssize_t offs, ssize_t *total_size_out)
3,145,734 (0.0%)  {
  699,052 (0.0%)      RESULT_ENSURE_REF(total_size_out);
  699,052 (0.0%)      if (count > 0) {
  699,052 (0.0%)          RESULT_ENSURE_REF(bufs);
        .             }
        .         
  349,526 (0.0%)      size_t total_size = 0;
3,145,734 (0.0%)      for (ssize_t i = 0; i < count; i++) {
2,446,682 (0.0%)          size_t iov_len = bufs[i].iov_len;
        .                 /* Account for any offset */
  699,052 (0.0%)          if (offs > 0) {
        .                     size_t offs_consumed = MIN((size_t) offs, iov_len);
        .                     iov_len -= offs_consumed;
        .                     offs -= offs_consumed;
        .                 }
1,398,104 (0.0%)          RESULT_ENSURE(S2N_ADD_IS_OVERFLOW_SAFE(total_size, iov_len, SIZE_MAX),
        .                         S2N_ERR_INVALID_ARGUMENT);
  699,052 (0.0%)          total_size += iov_len;
        .             }
        .         
        .             /* We must have fully accounted for the offset, or else the offset is larger
        .              * than the available data and our inputs are invalid.
        .              */
  699,052 (0.0%)      RESULT_ENSURE(offs == 0, S2N_ERR_INVALID_ARGUMENT);
        .         
1,048,578 (0.0%)      RESULT_ENSURE(total_size <= SSIZE_MAX, S2N_ERR_INVALID_ARGUMENT);
1,048,578 (0.0%)      *total_size_out = total_size;
  349,526 (0.0%)      return S2N_RESULT_OK;
1,048,578 (0.0%)  }
        .         
        .         ssize_t s2n_sendv_with_offset_impl(struct s2n_connection *conn, const struct iovec *bufs,
        .                 ssize_t count, ssize_t offs, s2n_blocked_status *blocked)
4,543,838 (0.0%)  {
  699,052 (0.0%)      ssize_t user_data_sent = 0, total_size = 0;
        .         
2,446,682 (0.0%)      POSIX_ENSURE(s2n_connection_check_io_status(conn, S2N_IO_WRITABLE), S2N_ERR_CLOSED);
1,747,630 (0.0%)      POSIX_ENSURE(!s2n_connection_is_quic_enabled(conn), S2N_ERR_UNSUPPORTED_WITH_QUIC);
        .         
        .             /* Flush any pending I/O */
2,446,682 (0.0%)      POSIX_GUARD(s2n_flush(conn, blocked));
        .         
1,747,630 (0.0%)      if (conn->ktls_send_enabled) {
        .                 return s2n_ktls_sendv_with_offset(conn, bufs, count, offs, blocked);
        .             }
        .         
        .             /* Acknowledge consumed and flushed user data as sent */
1,048,578 (0.0%)      user_data_sent = conn->current_user_data_consumed;
        .         
  699,052 (0.0%)      *blocked = S2N_BLOCKED_ON_WRITE;
        .         
  349,526 (0.0%)      uint16_t max_payload_size = 0;
3,495,260 (0.0%)      POSIX_GUARD_RESULT(s2n_record_max_write_payload_size(conn, &max_payload_size));
        .         
        .             /* TLS 1.0 and SSLv3 are vulnerable to the so-called Beast attack. Work
        .              * around this by splitting messages into one byte records, and then
        .              * the remainder can follow as usual.
        .              */
  349,526 (0.0%)      int cbcHackUsed = 0;
        .         
1,048,578 (0.0%)      struct s2n_crypto_parameters *writer = conn->server;
1,398,104 (0.0%)      if (conn->mode == S2N_CLIENT) {
        .                 writer = conn->client;
        .             }
        .         
3,844,786 (0.0%)      POSIX_GUARD_RESULT(s2n_sendv_with_offset_total_size(bufs, count, offs, &total_size));
        .             /* Defensive check against an invalid retry */
1,747,630 (0.0%)      POSIX_ENSURE(conn->current_user_data_consumed <= total_size, S2N_ERR_SEND_SIZE);
3,844,786 (0.0%)      POSIX_GUARD_RESULT(s2n_early_data_validate_send(conn, total_size));
        .         
1,398,104 (0.0%)      if (conn->dynamic_record_timeout_threshold > 0) {
        .                 uint64_t elapsed = 0;
        .                 POSIX_GUARD_RESULT(s2n_timer_elapsed(conn->config, &conn->write_timer, &elapsed));
        .                 /* Reset record size back to a single segment after threshold seconds of inactivity */
        .                 if (elapsed - conn->last_write_elapsed > (uint64_t) conn->dynamic_record_timeout_threshold * 1000000000) {
        .                     conn->active_application_bytes_consumed = 0;
        .                 }
        .                 conn->last_write_elapsed = elapsed;
        .             }
        .         
        .             /* Now write the data we were asked to send this round */
3,495,260 (0.0%)      while (total_size - conn->current_user_data_consumed) {
3,495,260 (0.0%)          ssize_t to_write = MIN(total_size - conn->current_user_data_consumed, max_payload_size);
        .         
        .                 /* If dynamic record size is enabled,
        .                  * use small TLS records that fit into a single TCP segment for the threshold bytes of data
        .                  */
2,446,682 (0.0%)          if (conn->active_application_bytes_consumed < (uint64_t) conn->dynamic_record_resize_threshold) {
        .                     uint16_t min_payload_size = 0;
        .                     POSIX_GUARD_RESULT(s2n_record_min_write_payload_size(conn, &min_payload_size));
        .                     to_write = MIN(min_payload_size, to_write);
        .                 }
        .         
        .                 /* Don't split messages in server mode for interoperability with naive clients.
        .                  * Some clients may have expectations based on the amount of content in the first record.
        .                  */
1,398,104 (0.0%)          if (conn->actual_protocol_version < S2N_TLS11
        .                         && writer->cipher_suite->record_alg->cipher->type == S2N_CBC && conn->mode != S2N_SERVER) {
        .                     if (to_write > 1 && cbcHackUsed == 0) {
        .                         to_write = 1;
        .                         cbcHackUsed = 1;
        .                     }
        .                 }
        .         
2,446,682 (0.0%)          POSIX_GUARD(s2n_post_handshake_send(conn, blocked));
        .         
        .                 /* Write and encrypt the record */
4,543,838 (0.0%)          int written_to_record = s2n_record_writev(conn, TLS_APPLICATION_DATA, bufs, count,
1,398,104 (0.0%)                  conn->current_user_data_consumed + offs, to_write);
  699,052 (0.0%)          POSIX_GUARD(written_to_record);
2,446,682 (0.0%)          conn->current_user_data_consumed += written_to_record;
2,446,682 (0.0%)          conn->active_application_bytes_consumed += written_to_record;
        .         
        .                 /* Send it, unless we're waiting for more records */
2,446,682 (0.0%)          if (s2n_should_flush(conn, total_size)) {
2,446,682 (0.0%)              if (s2n_flush(conn, blocked) < 0) {
        .                         if (s2n_errno == S2N_ERR_IO_BLOCKED && user_data_sent > 0) {
        .                             /* We successfully sent >0 user bytes on the wire, but not the full requested payload
        .                              * because we became blocked on I/O. Acknowledge the data sent. */
        .         
        .                             conn->current_user_data_consumed -= user_data_sent;
        .                             return user_data_sent;
        .                         } else {
        .                             S2N_ERROR_PRESERVE_ERRNO();
        .                         }
        .                     }
        .         
        .                     /* Acknowledge consumed and flushed user data as sent */
1,048,578 (0.0%)              user_data_sent = conn->current_user_data_consumed;
        .                 }
        .             }
        .         
        .             /* If everything has been written, then there's no user data pending */
  699,052 (0.0%)      conn->current_user_data_consumed = 0;
        .         
  699,052 (0.0%)      *blocked = S2N_NOT_BLOCKED;
  349,526 (0.0%)      return total_size;
2,097,156 (0.0%)  }
        .         
        .         ssize_t s2n_sendv_with_offset(struct s2n_connection *conn, const struct iovec *bufs, ssize_t count,
        .                 ssize_t offs, s2n_blocked_status *blocked)
3,495,260 (0.0%)  {
1,398,104 (0.0%)      POSIX_ENSURE(!conn->send_in_use, S2N_ERR_REENTRANCY);
  699,052 (0.0%)      conn->send_in_use = true;
        .         
3,145,734 (0.0%)      ssize_t result = s2n_sendv_with_offset_impl(conn, bufs, count, offs, blocked);
3,495,260 (0.0%)      POSIX_GUARD_RESULT(s2n_early_data_record_bytes(conn, result));
        .         
2,796,208 (0.0%)      POSIX_GUARD_RESULT(s2n_connection_dynamic_free_out_buffer(conn));
        .         
  699,052 (0.0%)      conn->send_in_use = false;
  349,526 (0.0%)      return result;
1,048,578 (0.0%)  }
        .         
        .         ssize_t s2n_sendv(struct s2n_connection *conn, const struct iovec *bufs, ssize_t count, s2n_blocked_status *blocked)
        .         {
        .             return s2n_sendv_with_offset(conn, bufs, count, 0, blocked);
        .         }
        .         
        .         ssize_t s2n_send(struct s2n_connection *conn, const void *buf, ssize_t size, s2n_blocked_status *blocked)
3,844,786 (0.0%)  {
        .             struct iovec iov;
  699,052 (0.0%)      iov.iov_base = (void *) (uintptr_t) buf;
  699,052 (0.0%)      iov.iov_len = size;
2,796,208 (0.0%)      return s2n_sendv_with_offset(conn, &iov, 1, 0, blocked);
1,747,630 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_atomic.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 44 ----------------------------------------
        .         #if S2N_ATOMIC_SUPPORTED && S2N_THREAD_SANITIZER
        .             __atomic_store(&var->val, &clear_val, __ATOMIC_RELAXED);
        .         #else
        .             var->val = clear_val;
        .         #endif
        .         }
        .         
        .         bool s2n_atomic_flag_test(s2n_atomic_flag *var)
9,786,728 (0.1%)  {
        .         #if S2N_ATOMIC_SUPPORTED && S2N_THREAD_SANITIZER
        .             sig_atomic_t result = 0;
        .             __atomic_load(&var->val, &result, __ATOMIC_RELAXED);
        .             return result;
        .         #else
9,786,728 (0.1%)      return var->val;
        .         #endif
4,893,364 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c
--------------------------------------------------------------------------------
Ir________________ 

-- line 19 ----------------------------------------
          .         #include <string.h>
          .         #include <sys/param.h>
          .         
          .         #include "api/s2n.h"
          .         #include "error/s2n_errno.h"
          .         #include "utils/s2n_safety.h"
          .         
          .         S2N_RESULT s2n_blob_validate(const struct s2n_blob *b)
346,030,740 (2.1%)  {
115,343,580 (0.7%)      RESULT_ENSURE_REF(b);
415,935,940 (2.6%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->data == NULL, b->size == 0), S2N_ERR_SAFETY);
415,935,940 (2.6%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->data == NULL, b->allocated == 0), S2N_ERR_SAFETY);
789,229,708 (4.8%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->growable == 0, b->allocated == 0), S2N_ERR_SAFETY);
558,892,074 (3.4%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->growable != 0, b->size <= b->allocated), S2N_ERR_SAFETY);
479,549,672 (2.9%)      RESULT_DEBUG_ENSURE(S2N_MEM_IS_READABLE(b->data, b->allocated), S2N_ERR_SAFETY);
792,724,968 (4.9%)      RESULT_DEBUG_ENSURE(S2N_MEM_IS_READABLE(b->data, b->size), S2N_ERR_SAFETY);
 57,671,790 (0.4%)      return S2N_RESULT_OK;
173,015,370 (1.1%)  }
          .         
          .         int s2n_blob_init(struct s2n_blob *b, uint8_t *data, uint32_t size)
 33,554,496 (0.2%)  {
  8,388,624 (0.1%)      POSIX_ENSURE_REF(b);
 16,078,196 (0.1%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_SAFETY);
 50,331,744 (0.3%)      *b = (struct s2n_blob){ .data = data, .size = size, .allocated = 0, .growable = 0 };
 62,914,680 (0.4%)      POSIX_POSTCONDITION(s2n_blob_validate(b));
  4,194,312 (0.0%)      return S2N_SUCCESS;
 12,582,936 (0.1%)  }
          .         
          .         int s2n_blob_zero(struct s2n_blob *b)
          .         {
          .             POSIX_PRECONDITION(s2n_blob_validate(b));
          .             POSIX_CHECKED_MEMSET(b->data, 0, MAX(b->allocated, b->size));
          .             POSIX_POSTCONDITION(s2n_blob_validate(b));
          .             return S2N_SUCCESS;
          .         }
          .         
          .         int s2n_blob_slice(const struct s2n_blob *b, struct s2n_blob *slice, uint32_t offset, uint32_t size)
  4,194,312 (0.0%)  {
  5,242,890 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(b));
  5,242,890 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(slice));
          .         
    349,526 (0.0%)      uint32_t slice_size = 0;
  2,796,208 (0.0%)      POSIX_GUARD(s2n_add_overflow(offset, size, &slice_size));
  1,747,630 (0.0%)      POSIX_ENSURE(b->size >= slice_size, S2N_ERR_SIZE_MISMATCH);
  3,844,786 (0.0%)      slice->data = (b->data) ? (b->data + offset) : NULL;
  1,048,578 (0.0%)      slice->size = size;
  1,398,104 (0.0%)      slice->growable = 0;
    699,052 (0.0%)      slice->allocated = 0;
          .         
  5,242,890 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(slice));
    349,526 (0.0%)      return S2N_SUCCESS;
  2,097,156 (0.0%)  }
          .         
          .         int s2n_blob_char_to_lower(struct s2n_blob *b)
          .         {
          .             POSIX_PRECONDITION(s2n_blob_validate(b));
          .             for (size_t i = 0; i < b->size; i++) {
          .                 b->data[i] = tolower(b->data[i]);
          .             }
          .             POSIX_POSTCONDITION(s2n_blob_validate(b));
-- line 78 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_ensure.c
--------------------------------------------------------------------------------
Ir_______________ 

-- line 11 ----------------------------------------
         .          * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
         .          * express or implied. See the License for the specific language governing
         .          * permissions and limitations under the License.
         .          */
         .         
         .         #include "utils/s2n_safety.h"
         .         
         .         void *s2n_ensure_memmove_trace(void *to, const void *from, size_t size)
47,535,536 (0.3%)  {
11,883,884 (0.1%)      PTR_ENSURE_REF(to);
11,883,884 (0.1%)      PTR_ENSURE_REF(from);
         .         
         .             /* use memmove instead of memcpy since it'll handle overlapping regions and not result in UB */
41,593,594 (0.3%)      void *result = memmove(to, from, size);
11,883,884 (0.1%)      PTR_ENSURE_REF(result);
 5,941,942 (0.0%)      return result;
17,825,826 (0.1%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c
--------------------------------------------------------------------------------
Ir________________ 

-- line 79 ----------------------------------------
          .         #include "utils/s2n_result.h"
          .         
          .         #include <stdbool.h>
          .         
          .         #include "api/s2n.h"
          .         
          .         /* returns true when the result is S2N_RESULT_OK */
          .         inline bool s2n_result_is_ok(s2n_result result)
706,042,520 (4.3%)  {
529,531,890 (3.3%)      return result.__error_signal == S2N_SUCCESS;
353,021,260 (2.2%)  }
          .         
          .         /* returns true when the result is S2N_RESULT_ERROR */
          .         inline bool s2n_result_is_error(s2n_result result)
          .         {
          .             return result.__error_signal == S2N_FAILURE;
          .         }
          .         
          .         /* ignores the returned result of a function */
-- line 97 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls/src/error.rs
--------------------------------------------------------------------------------
Ir______________ 

1,398,104 (0.0%)  <unknown (line 0)>

-- line 71 ----------------------------------------
        .                     Err(Error::capture())
        .                 }
        .             }
        .         }
        .         
        .         impl Fallible for isize {
        .             type Output = usize;
        .         
4,893,364 (0.0%)      fn into_result(self) -> Result<Self::Output, Error> {
        .                 // Negative values can't be converted to a real size
        .                 // and instead indicate an error.
3,495,260 (0.0%)          self.try_into().map_err(|_| Error::capture())
1,398,104 (0.0%)      }
        .         }
        .         
        .         impl Fallible for u64 {
        .             type Output = Self;
        .         
        .             /// Converts a u64 to a Result by checking for u64::MAX.
        .             ///
        .             /// If a method that returns an unsigned int is fallible,
-- line 91 ----------------------------------------
-- line 134 ----------------------------------------
        .             type Output;
        .         
        .             fn into_poll(self) -> Poll<Result<Self::Output, Error>>;
        .         }
        .         
        .         impl<T: Fallible> Pollable for T {
        .             type Output = T::Output;
        .         
2,796,208 (0.0%)      fn into_poll(self) -> Poll<Result<Self::Output, Error>> {
6,990,520 (0.0%)          match self.into_result() {
6,990,520 (0.0%)              Ok(r) => Ok(r).into(),
        .                     Err(err) if err.is_retryable() => Poll::Pending,
        .                     Err(err) => Err(err).into(),
        .                 }
2,097,156 (0.0%)      }
        .         }
        .         
        .         impl Error {
        .             pub(crate) const INVALID_INPUT: Error = Self(Context::InvalidInput);
        .             pub(crate) const MISSING_WAKER: Error = Self(Context::MissingWaker);
        .         
        .             /// Converts an io::Error into an s2n-tls Error
        .             pub fn io_error(err: std::io::Error) -> Error {
-- line 156 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls/src/testing.rs
--------------------------------------------------------------------------------
Ir_______________ 

 6,640,994 (0.0%)  <unknown (line 0)>

-- line 273 ----------------------------------------
         .                         (_, Poll::Ready(Err(e))) => return Err(e),
         .                         // or an error on the client, then return the error
         .                         (Poll::Ready(Err(e)), _) => return Err(e),
         .                         _ => { /* not ready, poll again */ }
         .                     }
         .                 }
         .             }
         .         
 2,796,208 (0.0%)      unsafe extern "C" fn send_cb(context: *mut c_void, data: *const u8, len: u32) -> c_int {
   349,526 (0.0%)          let context = &*(context as *const LocalDataBuffer);
 3,844,786 (0.0%)          let data = core::slice::from_raw_parts(data, len as _);
 6,640,994 (0.0%)          let bytes_written = context.borrow_mut().write(data).unwrap();
         .                 bytes_written as c_int
   699,052 (0.0%)      }
         .         
         .             // Note: this callback will be invoked multiple times in the event that
         .             // the byte-slices of the VecDeque are not contiguous (wrap around).
 5,592,416 (0.0%)      unsafe extern "C" fn recv_cb(context: *mut c_void, data: *mut u8, len: u32) -> c_int {
   699,052 (0.0%)          let context = &*(context as *const LocalDataBuffer);
 7,689,572 (0.0%)          let data = core::slice::from_raw_parts_mut(data, len as _);
13,281,988 (0.1%)          match context.borrow_mut().read(data) {
 2,097,156 (0.0%)              Ok(len) => {
 2,796,208 (0.0%)                  if len == 0 {
         .                             // returning a length of 0 indicates a channel close (e.g. a
         .                             // TCP Close) which would not be correct here. To just communicate
         .                             // that there is no more data, we instead set the errno to
         .                             // WouldBlock and return -1.
         .                             errno::set_errno(errno::Errno(libc::EWOULDBLOCK));
         .                             -1
         .                         } else {
   699,052 (0.0%)                      len as c_int
         .                         }
         .                     }
         .                     Err(err) => {
         .                         // VecDeque IO Operations should never fail
         .                         panic!("{err:?}");
         .                     }
         .                 }
 3,495,260 (0.0%)      }
         .         }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/tests/regression/src/bin/data_transfer.rs
--------------------------------------------------------------------------------
Ir______________ 

5,242,890 (0.0%)  <unknown (line 0)>

        .         use crabgrind as cg;
        .         use s2n_tls::security;
        .         use s2n_tls::testing::TestPair;
        .         
        .         const DATA_CHUNK: &[u8] = &[3, 1, 4]; // The data chunk to be sent
        .         const ONE_MB: usize = 1_048_576; // 1 MB in bytes
        .         
        1 (0.0%)  fn main() -> Result<(), Box<dyn std::error::Error>> {
        1 (0.0%)      cg::cachegrind::stop_instrumentation();
        .             
        .             let config = s2n_tls::testing::build_config(&security::DEFAULT_TLS13).expect("Failed to build config");
        .             
        .             // Create a pair (client + server) which uses that config
        .             let mut pair = TestPair::from_config(&config);
        .             
        .             // Assert a successful handshake
        .             assert!(pair.handshake().is_ok());
        .             
        .             // We can also do IO using the poll_* functions
        .             // This data is sent using the shared data buffers owned by the harness
        1 (0.0%)      cg::cachegrind::start_instrumentation();
        .             
        1 (0.0%)      let mut total_bytes_sent = 0;
        7 (0.0%)      let mut buffer = vec![0u8; DATA_CHUNK.len()]; // Buffer to receive data
        .         
  699,054 (0.0%)      while total_bytes_sent < ONE_MB {
        .                 // Send data chunk
4,893,364 (0.0%)          while !pair.server.poll_send(DATA_CHUNK).is_ready() {
        .                     // Polling until the send is ready
        .                 }
2,446,682 (0.0%)          total_bytes_sent += DATA_CHUNK.len();
        .         
        .                 // Receive data chunk
6,640,994 (0.0%)          while !pair.client.poll_recv(&mut buffer).is_ready() {
        .                     // Polling until the receive is ready
        .                 }
        .         
        .                 // Verify that the received data matches the sent data
8,738,150 (0.1%)          assert_eq!(DATA_CHUNK, &buffer[..DATA_CHUNK.len()]);
        .             }
        .         
        1 (0.0%)      cg::cachegrind::stop_instrumentation();
        .             
        .             println!("Transferred {} bytes successfully.", total_bytes_sent);
        .             
        .             Ok(())
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/alloc/src/collections/vec_deque/drain.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/alloc/src/collections/vec_deque/drain.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/alloc/src/collections/vec_deque/mod.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/alloc/src/collections/vec_deque/mod.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/cell.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/cell.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/cmp.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/cmp.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/intrinsics.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/intrinsics.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/num/uint_macros.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/num/uint_macros.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/ptr/const_ptr.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/ptr/const_ptr.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/result.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/result.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/slice/index.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/slice/index.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/slice/mod.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/slice/mod.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/slice/raw.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/slice/raw.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/ub_checks.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/core/src/ub_checks.rs

--------------------------------------------------------------------------------
-- Annotated source file: /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/std/src/io/impls.rs
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /rustc/129f3b9964af4d4a709d1383930ade12dfe7c081/library/std/src/io/impls.rs

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir____________________ 

14,367,337,489 (88.3%)    annotated: files known & above threshold & readable, line numbers known
    13,281,988  (0.1%)    annotated: files known & above threshold & readable, line numbers unknown
             0          unannotated: files known & above threshold & two or more non-identical
 1,511,352,020  (9.3%)  unannotated: files known & above threshold & unreadable 
   360,820,220  (2.2%)  unannotated: files known & below threshold
    27,263,861  (0.2%)  unannotated: files unknown

