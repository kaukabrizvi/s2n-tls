--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate cleanup_connection
Command:          target/debug/cleanup_connection
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir______________ 

656,189 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir____________________  file:function

< 103,123 (15.7%, 15.7%)  ./elf/./elf/dl-lookup.c:
   66,754 (10.2%)           do_lookup_x
   21,732  (3.3%)           _dl_lookup_symbol_x
   14,637  (2.2%)           check_match

<  73,154 (11.1%, 26.9%)  ./elf/../sysdeps/x86_64/dl-machine.h:
   73,088 (11.1%)           _dl_relocate_object

<  61,723  (9.4%, 36.3%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms

<  50,288  (7.7%, 43.9%)  ./elf/./elf/do-rel.h:
   50,232  (7.7%)           _dl_relocate_object

<  48,846  (7.4%, 51.4%)  ./stdio-common/./stdio-common/vfscanf-internal.c:__vfscanf_internal

<  25,774  (3.9%, 55.3%)  ./malloc/./malloc/malloc.c:
   10,644  (1.6%)           _int_free
    5,551  (0.8%)           malloc_consolidate
    4,284  (0.7%)           free
    1,785  (0.3%)           _int_malloc
    1,179  (0.2%)           unlink_chunk.isra.0
      771  (0.1%)           ptmalloc_init.part.0
      677  (0.1%)           malloc

<  23,542  (3.6%, 58.9%)  ./stdlib/../stdlib/strtol_l.c:____strtoul_l_internal

<  23,175  (3.5%, 62.4%)  ./elf/./elf/dl-tunables.c:
   22,033  (3.4%)           __GI___tunables_init
      862  (0.1%)           __tunable_get_val

<  22,238  (3.4%, 65.8%)  ./elf/./elf/dl-reloc.c:_dl_relocate_object

<  20,372  (3.1%, 68.9%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c:
   16,936  (2.6%)           s2n_tls_hmac_init
    1,040  (0.2%)           s2n_hmac_init
      700  (0.1%)           s2n_hmac_reset

<  20,015  (3.1%, 72.0%)  ./string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S:
   19,983  (3.0%)           strcmp

<  18,874  (2.9%, 74.8%)  ./elf/../sysdeps/generic/dl-new-hash.h:_dl_lookup_symbol_x

<  18,416  (2.8%, 77.7%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c:
   15,548  (2.4%)           s2n_blob_validate
    2,868  (0.4%)           s2n_blob_zero

<   9,833  (1.5%, 79.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c:
    5,877  (0.9%)           aws_lc_0_19_0_asn1_item_combine_free
    1,860  (0.3%)           aws_lc_0_19_0_ASN1_template_free
    1,751  (0.3%)           aws_lc_0_19_0_ASN1_primitive_free

<   9,296  (1.4%, 80.6%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c:
    1,728  (0.3%)           s2n_hash_init
    1,546  (0.2%)           s2n_low_level_hash_init
    1,032  (0.2%)           s2n_hash_state_validate
      720  (0.1%)           s2n_hash_set_impl
      704  (0.1%)           s2n_hash_update
      672  (0.1%)           s2n_low_level_hash_update

<   9,277  (1.4%, 82.0%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c:
    5,720  (0.9%)           aws_lc_0_19_0_OPENSSL_free
    2,100  (0.3%)           aws_lc_0_19_0_OPENSSL_cleanse
    1,120  (0.2%)           __asan_unpoison_memory_region

<   8,126  (1.2%, 83.2%)  ./elf/./elf/dl-version.c:
    8,041  (1.2%)           _dl_check_map_versions

<   8,007  (1.2%, 84.4%)  ./libio/./libio/genops.c:
    3,960  (0.6%)           _IO_sputbackc
    1,368  (0.2%)           _IO_setb
    1,111  (0.2%)           _IO_no_init
    1,060  (0.2%)           _IO_old_init

<   6,120  (0.9%, 85.4%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c:s2n_result_is_ok

<   5,041  (0.8%, 86.1%)  ./elf/./elf/dl-load.c:
    2,339  (0.4%)           _dl_map_object_from_fd
    1,053  (0.2%)           _dl_map_object

<   4,988  (0.8%, 86.9%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c:
    3,210  (0.5%)           s2n_stuffer_validate
    1,008  (0.2%)           s2n_stuffer_wipe

<   4,294  (0.7%, 87.6%)  ./elf/../sysdeps/x86/dl-cacheinfo.h:
    3,322  (0.5%)           intel_check_word.constprop.0

<   4,092  (0.6%, 88.2%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_crypto.c:s2n_crypto_parameters_wipe

<   3,986  (0.6%, 88.8%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_mem.c:
    1,512  (0.2%)           s2n_free_without_wipe
    1,116  (0.2%)           s2n_blob_is_growable

<   3,809  (0.6%, 89.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c:
    1,083  (0.2%)           aws_lc_0_19_0_asn1_get_field_ptr
      896  (0.1%)           aws_lc_0_19_0_asn1_do_adb

<   3,449  (0.5%, 89.9%)  ./libio/./libio/iogetdelim.c:getdelim

<   2,614  (0.4%, 90.3%)  ./elf/./elf/dl-tunables.h:
    2,589  (0.4%)           __GI___tunables_init

<   2,385  (0.4%, 90.7%)  ./elf/./elf/dl-cache.c:
    1,707  (0.3%)           _dl_cache_libcmp
      665  (0.1%)           _dl_load_cache_lookup

<   2,320  (0.4%, 91.0%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h:OPENSSL_memset

<   2,268  (0.3%, 91.4%)  ./elf/../bits/stdlib-bsearch.h:intel_check_word.constprop.0

<   2,141  (0.3%, 91.7%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:
    1,599  (0.2%)           __memcpy_avx_unaligned_erms

<   2,026  (0.3%, 92.0%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_connection.c:
    1,083  (0.2%)           s2n_connection_wipe

<   1,800  (0.3%, 92.3%)  ./libio/./libio/strops.c:_IO_str_init_static_internal

<   1,783  (0.3%, 92.5%)  ./elf/../sysdeps/generic/ldsodefs.h:
    1,050  (0.2%)           do_lookup_x
      727  (0.1%)           _dl_relocate_object

<   1,771  (0.3%, 92.8%)  ./string/../sysdeps/x86_64/multiarch/memchr-avx2.S:__memchr_avx2

<   1,710  (0.3%, 93.1%)  ./stdio-common/./stdio-common/isoc23_sscanf.c:__isoc23_sscanf

<   1,670  (0.3%, 93.3%)  ./elf/./elf/rtld.c:
    1,239  (0.2%)           dl_main

<   1,586  (0.2%, 93.6%)  ./elf/./elf/dl-deps.c:
    1,454  (0.2%)           _dl_map_object_deps

<   1,449  (0.2%, 93.8%)  ./string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2

<   1,337  (0.2%, 94.0%)  ./elf/./elf/dl-misc.c:
    1,292  (0.2%)           _dl_name_match_p

<   1,249  (0.2%, 94.2%)  ./nptl/./nptl/pthread_getattr_np.c:pthread_getattr_np@@GLIBC_2.32

<   1,238  (0.2%, 94.4%)  ???:
      842  (0.1%)           ???

<   1,033  (0.2%, 94.5%)  ./elf/./elf/dl-minimal-malloc.c:
      928  (0.1%)           __minimal_malloc

<   1,006  (0.2%, 94.7%)  ./elf/./elf/get-dynamic-info.h:_dl_map_object_from_fd

<     990  (0.2%, 94.8%)  ./stdio-common/../include/scratch_buffer.h:__vfscanf_internal

<     935  (0.1%, 95.0%)  ./elf/./elf/dl-object.c:
      752  (0.1%)           _dl_new_object

<     900  (0.1%, 95.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_object.c:aws_lc_0_19_0_ASN1_OBJECT_free

<     850  (0.1%, 95.2%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_ensure.c:s2n_ensure_memmove_trace

<     840  (0.1%, 95.4%)  ./elf/../sysdeps/generic/dl-protected.h:do_lookup_x

<     675  (0.1%, 95.5%)  ./stdio-common/../libio/strfile.h:__isoc23_sscanf

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir____________________  function:file

> 146,285 (22.3%, 22.3%)  _dl_relocate_object:
   73,088 (11.1%)           ./elf/../sysdeps/x86_64/dl-machine.h
   50,232  (7.7%)           ./elf/./elf/do-rel.h
   22,238  (3.4%)           ./elf/./elf/dl-reloc.c
      727  (0.1%)           ./elf/../sysdeps/generic/ldsodefs.h

>  68,644 (10.5%, 32.8%)  do_lookup_x:
   66,754 (10.2%)           ./elf/./elf/dl-lookup.c
    1,050  (0.2%)           ./elf/../sysdeps/generic/ldsodefs.h
      840  (0.1%)           ./elf/../sysdeps/generic/dl-protected.h

>  61,723  (9.4%, 42.2%)  __memset_avx2_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

>  50,421  (7.7%, 49.8%)  __vfscanf_internal:
   48,846  (7.4%)           ./stdio-common/./stdio-common/vfscanf-internal.c
      990  (0.2%)           ./stdio-common/../include/scratch_buffer.h

>  40,606  (6.2%, 56.0%)  _dl_lookup_symbol_x:
   21,732  (3.3%)           ./elf/./elf/dl-lookup.c
   18,874  (2.9%)           ./elf/../sysdeps/generic/dl-new-hash.h

>  24,622  (3.8%, 59.8%)  __GI___tunables_init:
   22,033  (3.4%)           ./elf/./elf/dl-tunables.c
    2,589  (0.4%)           ./elf/./elf/dl-tunables.h

>  23,542  (3.6%, 63.4%)  ____strtoul_l_internal:./stdlib/../stdlib/strtol_l.c

>  20,027  (3.1%, 66.4%)  strcmp:
   19,983  (3.0%)           ./string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S

>  16,936  (2.6%, 69.0%)  s2n_tls_hmac_init:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c

>  15,548  (2.4%, 71.4%)  s2n_blob_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c

>  14,637  (2.2%, 73.6%)  check_match:./elf/./elf/dl-lookup.c

>  10,644  (1.6%, 75.2%)  _int_free:./malloc/./malloc/malloc.c

>   8,071  (1.2%, 76.5%)  _dl_check_map_versions:
    8,041  (1.2%)           ./elf/./elf/dl-version.c

>   6,120  (0.9%, 77.4%)  s2n_result_is_ok:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c

>   5,877  (0.9%, 78.3%)  aws_lc_0_19_0_asn1_item_combine_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c

>   5,720  (0.9%, 79.2%)  aws_lc_0_19_0_OPENSSL_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>   5,590  (0.9%, 80.0%)  intel_check_word.constprop.0:
    3,322  (0.5%)           ./elf/../sysdeps/x86/dl-cacheinfo.h
    2,268  (0.3%)           ./elf/../bits/stdlib-bsearch.h

>   5,551  (0.8%, 80.9%)  malloc_consolidate:./malloc/./malloc/malloc.c

>   4,743  (0.7%, 81.6%)  free:
    4,284  (0.7%)           ./malloc/./malloc/malloc.c

>   4,092  (0.6%, 82.2%)  s2n_crypto_parameters_wipe:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_crypto.c

>   3,960  (0.6%, 82.8%)  _IO_sputbackc:./libio/./libio/genops.c

>   3,878  (0.6%, 83.4%)  _dl_map_object_from_fd:
    2,339  (0.4%)           ./elf/./elf/dl-load.c
    1,006  (0.2%)           ./elf/./elf/get-dynamic-info.h

>   3,825  (0.6%, 84.0%)  getdelim:
    3,449  (0.5%)           ./libio/./libio/iogetdelim.c

>   3,210  (0.5%, 84.5%)  s2n_stuffer_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>   2,868  (0.4%, 84.9%)  s2n_blob_zero:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c

>   2,560  (0.4%, 85.3%)  OPENSSL_memset:
    2,320  (0.4%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h

>   2,385  (0.4%, 85.7%)  __isoc23_sscanf:
    1,710  (0.3%)           ./stdio-common/./stdio-common/isoc23_sscanf.c
      675  (0.1%)           ./stdio-common/../libio/strfile.h

>   2,100  (0.3%, 86.0%)  aws_lc_0_19_0_OPENSSL_cleanse:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>   1,860  (0.3%, 86.3%)  aws_lc_0_19_0_ASN1_template_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c

>   1,800  (0.3%, 86.5%)  _IO_str_init_static_internal:./libio/./libio/strops.c

>   1,785  (0.3%, 86.8%)  _int_malloc:./malloc/./malloc/malloc.c

>   1,771  (0.3%, 87.1%)  __memchr_avx2:./string/../sysdeps/x86_64/multiarch/memchr-avx2.S

>   1,751  (0.3%, 87.3%)  aws_lc_0_19_0_ASN1_primitive_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c

>   1,748  (0.3%, 87.6%)  dl_main:
    1,239  (0.2%)           ./elf/./elf/rtld.c

>   1,728  (0.3%, 87.9%)  s2n_hash_init:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>   1,707  (0.3%, 88.1%)  _dl_cache_libcmp:./elf/./elf/dl-cache.c

>   1,599  (0.2%, 88.4%)  __memcpy_avx_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

>   1,546  (0.2%, 88.6%)  s2n_low_level_hash_init:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>   1,512  (0.2%, 88.8%)  s2n_free_without_wipe:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_mem.c

>   1,480  (0.2%, 89.1%)  _dl_map_object_deps:
    1,454  (0.2%)           ./elf/./elf/dl-deps.c

>   1,449  (0.2%, 89.3%)  __strlen_avx2:./string/../sysdeps/x86_64/multiarch/strlen-avx2.S

>   1,368  (0.2%, 89.5%)  _IO_setb:./libio/./libio/genops.c

>   1,292  (0.2%, 89.7%)  _dl_name_match_p:./elf/./elf/dl-misc.c

>   1,251  (0.2%, 89.9%)  pthread_getattr_np@@GLIBC_2.32:
    1,249  (0.2%)           ./nptl/./nptl/pthread_getattr_np.c

>   1,179  (0.2%, 90.1%)  unlink_chunk.isra.0:./malloc/./malloc/malloc.c

>   1,120  (0.2%, 90.2%)  __asan_unpoison_memory_region:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>   1,116  (0.2%, 90.4%)  s2n_blob_is_growable:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_mem.c

>   1,111  (0.2%, 90.6%)  _IO_no_init:./libio/./libio/genops.c

>   1,083  (0.2%, 90.7%)  s2n_connection_wipe:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_connection.c

>   1,083  (0.2%, 90.9%)  aws_lc_0_19_0_asn1_get_field_ptr:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c

>   1,060  (0.2%, 91.1%)  _IO_old_init:./libio/./libio/genops.c

>   1,053  (0.2%, 91.2%)  _dl_map_object:./elf/./elf/dl-load.c

>   1,040  (0.2%, 91.4%)  s2n_hmac_init:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c

>   1,032  (0.2%, 91.5%)  s2n_hash_state_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>   1,008  (0.2%, 91.7%)  s2n_stuffer_wipe:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>     928  (0.1%, 91.8%)  __minimal_malloc:./elf/./elf/dl-minimal-malloc.c

>     900  (0.1%, 92.0%)  aws_lc_0_19_0_ASN1_OBJECT_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_object.c

>     896  (0.1%, 92.1%)  aws_lc_0_19_0_asn1_do_adb:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c

>     862  (0.1%, 92.2%)  __tunable_get_val:./elf/./elf/dl-tunables.c

>     850  (0.1%, 92.4%)  s2n_ensure_memmove_trace:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_ensure.c

>     849  (0.1%, 92.5%)  ptmalloc_init.part.0:
      771  (0.1%)           ./malloc/./malloc/malloc.c

>     842  (0.1%, 92.6%)  ???:???

>     773  (0.1%, 92.8%)  _dl_new_object:
      752  (0.1%)           ./elf/./elf/dl-object.c

>     720  (0.1%, 92.9%)  s2n_hash_set_impl:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>     704  (0.1%, 93.0%)  s2n_hash_update:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>     703  (0.1%, 93.1%)  _dl_load_cache_lookup:
      665  (0.1%)           ./elf/./elf/dl-cache.c

>     700  (0.1%, 93.2%)  s2n_hmac_reset:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c

>     694  (0.1%, 93.3%)  malloc:
      677  (0.1%)           ./malloc/./malloc/malloc.c

>     672  (0.1%, 93.4%)  s2n_low_level_hash_update:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/../bits/stdlib-bsearch.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/../bits/stdlib-bsearch.h

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/../sysdeps/generic/dl-new-hash.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/../sysdeps/generic/dl-new-hash.h

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/../sysdeps/generic/dl-protected.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/../sysdeps/generic/dl-protected.h

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/../sysdeps/generic/ldsodefs.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/../sysdeps/generic/ldsodefs.h

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/../sysdeps/x86/dl-cacheinfo.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/../sysdeps/x86/dl-cacheinfo.h

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/../sysdeps/x86_64/dl-machine.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/../sysdeps/x86_64/dl-machine.h

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-cache.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-cache.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-deps.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-deps.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-load.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-load.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-lookup.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-lookup.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-minimal-malloc.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-minimal-malloc.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-misc.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-misc.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-object.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-object.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-reloc.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-reloc.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-tunables.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-tunables.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-tunables.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-tunables.h

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-version.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-version.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/do-rel.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/do-rel.h

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/get-dynamic-info.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/get-dynamic-info.h

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/rtld.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/rtld.c

--------------------------------------------------------------------------------
-- Annotated source file: ./libio/./libio/genops.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./libio/./libio/genops.c

--------------------------------------------------------------------------------
-- Annotated source file: ./libio/./libio/iogetdelim.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./libio/./libio/iogetdelim.c

--------------------------------------------------------------------------------
-- Annotated source file: ./libio/./libio/strops.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./libio/./libio/strops.c

--------------------------------------------------------------------------------
-- Annotated source file: ./malloc/./malloc/malloc.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./malloc/./malloc/malloc.c

--------------------------------------------------------------------------------
-- Annotated source file: ./nptl/./nptl/pthread_getattr_np.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./nptl/./nptl/pthread_getattr_np.c

--------------------------------------------------------------------------------
-- Annotated source file: ./stdio-common/../include/scratch_buffer.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdio-common/../include/scratch_buffer.h

--------------------------------------------------------------------------------
-- Annotated source file: ./stdio-common/../libio/strfile.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdio-common/../libio/strfile.h

--------------------------------------------------------------------------------
-- Annotated source file: ./stdio-common/./stdio-common/isoc23_sscanf.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdio-common/./stdio-common/isoc23_sscanf.c

--------------------------------------------------------------------------------
-- Annotated source file: ./stdio-common/./stdio-common/vfscanf-internal.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdio-common/./stdio-common/vfscanf-internal.c

--------------------------------------------------------------------------------
-- Annotated source file: ./stdlib/../stdlib/strtol_l.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdlib/../stdlib/strtol_l.c

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memchr-avx2.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memchr-avx2.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/strlen-avx2.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/strlen-avx2.S

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_object.c
--------------------------------------------------------------------------------
Ir________ 

-- line 187 ----------------------------------------
  .           ret = (ASN1_OBJECT *)OPENSSL_zalloc(sizeof(ASN1_OBJECT));
  .           if (ret == NULL) {
  .             return NULL;
  .           }
  .           ret->flags = ASN1_OBJECT_FLAG_DYNAMIC;
  .           return ret;
  .         }
  .         
 90 (0.0%)  void ASN1_OBJECT_free(ASN1_OBJECT *a) {
 36 (0.0%)    if (a == NULL) {
  .             return;
  .           }
 90 (0.0%)    if (a->flags & ASN1_OBJECT_FLAG_DYNAMIC_STRINGS) {
 72 (0.0%)      OPENSSL_free((void *)a->sn);
 72 (0.0%)      OPENSSL_free((void *)a->ln);
108 (0.0%)      a->sn = a->ln = NULL;
  .           }
 90 (0.0%)    if (a->flags & ASN1_OBJECT_FLAG_DYNAMIC_DATA) {
 72 (0.0%)      OPENSSL_free((void *)a->data);
 36 (0.0%)      a->data = NULL;
 36 (0.0%)      a->length = 0;
  .           }
 90 (0.0%)    if (a->flags & ASN1_OBJECT_FLAG_DYNAMIC) {
 72 (0.0%)      OPENSSL_free(a);
  .           }
 36 (0.0%)  }
  .         
  .         ASN1_OBJECT *ASN1_OBJECT_create(int nid, const unsigned char *data, size_t len,
  .                                         const char *sn, const char *ln) {
  .           if (len > INT_MAX) {
  .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_STRING_TOO_LONG);
  .             return NULL;
  .           }
  .         
-- line 220 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c
--------------------------------------------------------------------------------
Ir________ 

-- line 60 ----------------------------------------
  .         
  .         #include <openssl/asn1t.h>
  .         #include <openssl/mem.h>
  .         
  .         #include "internal.h"
  .         
  .         // Free up an ASN1 structure
  .         
114 (0.0%)  void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it) {
114 (0.0%)    asn1_item_combine_free(&val, it, 0);
 57 (0.0%)  }
  .         
 24 (0.0%)  void ASN1_item_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 24 (0.0%)    asn1_item_combine_free(pval, it, 0);
 12 (0.0%)  }
  .         
  .         void asn1_item_combine_free(ASN1_VALUE **pval, const ASN1_ITEM *it,
553 (0.1%)                              int combine) {
 79 (0.0%)    const ASN1_TEMPLATE *tt = NULL, *seqtt;
  .           const ASN1_EXTERN_FUNCS *ef;
  .           int i;
316 (0.0%)    if (pval == NULL || it == NULL) {
  .             return;
  .           }
488 (0.1%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) {
  6 (0.0%)      return;
  .           }
  .         
988 (0.2%)    switch (it->itype) {
  .             case ASN1_ITYPE_PRIMITIVE:
144 (0.0%)        if (it->templates) {
 12 (0.0%)          ASN1_template_free(pval, it->templates);
  .               } else {
170 (0.0%)          ASN1_primitive_free(pval, it);
  .               }
 36 (0.0%)        break;
  .         
  .             case ASN1_ITYPE_MSTRING:
 70 (0.0%)        ASN1_primitive_free(pval, it);
 14 (0.0%)        break;
  .         
  .             case ASN1_ITYPE_CHOICE: {
  3 (0.0%)        const ASN1_AUX *aux = it->funcs;
  4 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
  2 (0.0%)        if (asn1_cb) {
  .                 i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
  .                 if (i == 2) {
  .                   return;
  .                 }
  .               }
  6 (0.0%)        i = asn1_get_choice_selector(pval, it);
  8 (0.0%)        if ((i >= 0) && (i < it->tcount)) {
  .                 ASN1_VALUE **pchval;
  7 (0.0%)          tt = it->templates + i;
  6 (0.0%)          pchval = asn1_get_field_ptr(pval, tt);
  5 (0.0%)          ASN1_template_free(pchval, tt);
  .               }
  2 (0.0%)        if (asn1_cb) {
  .                 asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);
  .               }
  2 (0.0%)        if (!combine) {
  4 (0.0%)          OPENSSL_free(*pval);
  2 (0.0%)          *pval = NULL;
  .               }
  3 (0.0%)        break;
  .             }
  .         
  .             case ASN1_ITYPE_EXTERN:
  6 (0.0%)        ef = it->funcs;
 12 (0.0%)        if (ef && ef->asn1_ex_free) {
 14 (0.0%)          ef->asn1_ex_free(pval, it);
  .               }
  6 (0.0%)        break;
  .         
  .             case ASN1_ITYPE_SEQUENCE: {
161 (0.0%)        if (!asn1_refcount_dec_and_test_zero(pval, it)) {
  2 (0.0%)          return;
  .               }
 66 (0.0%)        const ASN1_AUX *aux = it->funcs;
 94 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
 44 (0.0%)        if (asn1_cb) {
 16 (0.0%)          i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
  4 (0.0%)          if (i == 2) {
  .                   return;
  .                 }
  .               }
110 (0.0%)        asn1_enc_free(pval, it);
  .               // If we free up as normal we will invalidate any ANY DEFINED BY
  .               // field and we wont be able to determine the type of the field it
  .               // defines. So free up in reverse order.
176 (0.0%)        tt = it->templates + it->tcount - 1;
624 (0.1%)        for (i = 0; i < it->tcount; tt--, i++) {
  .                 ASN1_VALUE **pseqval;
392 (0.1%)          seqtt = asn1_do_adb(pval, tt, 0);
112 (0.0%)          if (!seqtt) {
  .                   continue;
  .                 }
336 (0.1%)          pseqval = asn1_get_field_ptr(pval, seqtt);
336 (0.1%)          ASN1_template_free(pseqval, seqtt);
  .               }
 44 (0.0%)        if (asn1_cb) {
 14 (0.0%)          asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);
  .               }
 44 (0.0%)        if (!combine) {
 88 (0.0%)          OPENSSL_free(*pval);
 44 (0.0%)          *pval = NULL;
  .               }
 44 (0.0%)        break;
  .             }
  .           }
158 (0.0%)  }
  .         
531 (0.1%)  void ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
295 (0.0%)    if (tt->flags & ASN1_TFLG_SK_MASK) {
  9 (0.0%)      STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;
 45 (0.0%)      for (size_t i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
 24 (0.0%)        ASN1_VALUE *vtmp = sk_ASN1_VALUE_value(sk, i);
 24 (0.0%)        ASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item));
  .             }
  9 (0.0%)      sk_ASN1_VALUE_free(sk);
  6 (0.0%)      *pval = NULL;
  .           } else {
448 (0.1%)      asn1_item_combine_free(pval, ASN1_ITEM_ptr(tt->item),
112 (0.0%)                             tt->flags & ASN1_TFLG_COMBINE);
  .           }
357 (0.1%)  }
  .         
288 (0.0%)  void ASN1_primitive_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
  .           // Historically, |it->funcs| for primitive types contained an
  .           // |ASN1_PRIMITIVE_FUNCS| table of calbacks.
192 (0.0%)    assert(it->funcs == NULL);
  .         
356 (0.1%)    int utype = it->itype == ASN1_ITYPE_MSTRING ? -1 : it->utype;
405 (0.1%)    switch (utype) {
  .             case V_ASN1_OBJECT:
 72 (0.0%)        ASN1_OBJECT_free((ASN1_OBJECT *)*pval);
 18 (0.0%)        break;
  .         
  .             case V_ASN1_BOOLEAN:
  6 (0.0%)        if (it) {
 15 (0.0%)          *(ASN1_BOOLEAN *)pval = (ASN1_BOOLEAN)it->size;
  .               } else {
  .                 *(ASN1_BOOLEAN *)pval = ASN1_BOOLEAN_NONE;
  .               }
  3 (0.0%)        return;
  .         
  .             case V_ASN1_NULL:
  .               break;
  .         
  .             case V_ASN1_ANY:
 12 (0.0%)        if (*pval != NULL) {
 12 (0.0%)          asn1_type_cleanup((ASN1_TYPE *)*pval);
 12 (0.0%)          OPENSSL_free(*pval);
  .               }
  6 (0.0%)        break;
  .         
  .             default:
 96 (0.0%)        ASN1_STRING_free((ASN1_STRING *)*pval);
 48 (0.0%)        *pval = NULL;
 24 (0.0%)        break;
  .           }
 90 (0.0%)    *pval = NULL;
 96 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c
--------------------------------------------------------------------------------
Ir________ 

-- line 70 ----------------------------------------
  .         
  .         
  .         // Utility functions for manipulating fields and offsets
  .         
  .         // Add 'offset' to 'addr'
  .         #define offset2ptr(addr, offset) (void *)(((char *)(addr)) + (offset))
  .         
  .         // Given an ASN1_ITEM CHOICE type return the selector value
  5 (0.0%)  int asn1_get_choice_selector(ASN1_VALUE **pval, const ASN1_ITEM *it) {
  7 (0.0%)    int *sel = offset2ptr(*pval, it->utype);
  2 (0.0%)    return *sel;
  2 (0.0%)  }
  .         
  .         // Given an ASN1_ITEM CHOICE type set the selector value, return old value.
  .         int asn1_set_choice_selector(ASN1_VALUE **pval, int value,
  .                                      const ASN1_ITEM *it) {
  .           int *sel, ret;
  .           sel = offset2ptr(*pval, it->utype);
  .           ret = *sel;
  .           *sel = value;
  .           return ret;
  .         }
  .         
  .         static CRYPTO_refcount_t *asn1_get_references(ASN1_VALUE **pval,
115 (0.0%)                                                const ASN1_ITEM *it) {
 92 (0.0%)    if (it->itype != ASN1_ITYPE_SEQUENCE) {
  .             return NULL;
  .           }
 69 (0.0%)    const ASN1_AUX *aux = it->funcs;
 66 (0.0%)    if (!aux || !(aux->flags & ASN1_AFLG_REFCOUNT)) {
 42 (0.0%)      return NULL;
  .           }
 12 (0.0%)    return offset2ptr(*pval, aux->ref_offset);
 46 (0.0%)  }
  .         
  .         void asn1_refcount_set_one(ASN1_VALUE **pval, const ASN1_ITEM *it) {
  .           CRYPTO_refcount_t *references = asn1_get_references(pval, it);
  .           if (references != NULL) {
  .             *references = 1;
  .           }
  .         }
  .         
138 (0.0%)  int asn1_refcount_dec_and_test_zero(ASN1_VALUE **pval, const ASN1_ITEM *it) {
138 (0.0%)    CRYPTO_refcount_t *references = asn1_get_references(pval, it);
 46 (0.0%)    if (references != NULL) {
  8 (0.0%)      return CRYPTO_refcount_dec_and_test_zero(references);
  .           }
 21 (0.0%)    return 1;
 46 (0.0%)  }
  .         
132 (0.0%)  static ASN1_ENCODING *asn1_get_enc_ptr(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 88 (0.0%)    assert(it->itype == ASN1_ITYPE_SEQUENCE);
  .           const ASN1_AUX *aux;
132 (0.0%)    if (!pval || !*pval) {
  .             return NULL;
  .           }
 66 (0.0%)    aux = it->funcs;
 59 (0.0%)    if (!aux || !(aux->flags & ASN1_AFLG_ENCODING)) {
 42 (0.0%)      return NULL;
  .           }
  6 (0.0%)    return offset2ptr(*pval, aux->enc_offset);
 44 (0.0%)  }
  .         
  .         void asn1_enc_init(ASN1_VALUE **pval, const ASN1_ITEM *it) {
  .           ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
  .           if (enc) {
  .             enc->enc = NULL;
  .             enc->len = 0;
  .             enc->alias_only = 0;
  .             enc->alias_only_on_next_parse = 0;
  .           }
  .         }
  .         
132 (0.0%)  void asn1_enc_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
132 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
 44 (0.0%)    if (enc) {
  3 (0.0%)      asn1_encoding_clear(enc);
  .           }
 66 (0.0%)  }
  .         
  .         int asn1_enc_save(ASN1_VALUE **pval, const unsigned char *in, int inlen,
  .                           const ASN1_ITEM *it) {
  .           ASN1_ENCODING *enc;
  .           enc = asn1_get_enc_ptr(pval, it);
  .           if (!enc) {
  .             return 1;
  .           }
-- line 156 ----------------------------------------
-- line 170 ----------------------------------------
  .               return 0;
  .             }
  .           }
  .         
  .           enc->len = inlen;
  .           return 1;
  .         }
  .         
  5 (0.0%)  void asn1_encoding_clear(ASN1_ENCODING *enc) {
  5 (0.0%)    if (!enc->alias_only) {
  4 (0.0%)      OPENSSL_free(enc->enc);
  .           }
  2 (0.0%)    enc->enc = NULL;
  2 (0.0%)    enc->len = 0;
  4 (0.0%)    enc->alias_only = 0;
  4 (0.0%)    enc->alias_only_on_next_parse = 0;
  3 (0.0%)  }
  .         
  .         int asn1_enc_restore(int *len, unsigned char **out, ASN1_VALUE **pval,
  .                              const ASN1_ITEM *it) {
  .           ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
  .           if (!enc || enc->len == 0) {
  .             return 0;
  .           }
  .           if (out) {
-- line 194 ----------------------------------------
-- line 197 ----------------------------------------
  .           }
  .           if (len) {
  .             *len = enc->len;
  .           }
  .           return 1;
  .         }
  .         
  .         // Given an ASN1_TEMPLATE get a pointer to a field
285 (0.0%)  ASN1_VALUE **asn1_get_field_ptr(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
  .           ASN1_VALUE **pvaltmp;
285 (0.0%)    if (tt->flags & ASN1_TFLG_COMBINE) {
  .             return pval;
  .           }
342 (0.1%)    pvaltmp = offset2ptr(*pval, tt->offset);
  .           // NOTE for BOOLEAN types the field is just a plain int so we can't return
  .           // int **, so settle for (int *).
 57 (0.0%)    return pvaltmp;
114 (0.0%)  }
  .         
  .         // Handle ANY DEFINED BY template, find the selector, look up the relevant
  .         // ASN1_TEMPLATE in the table and return it.
  .         const ASN1_TEMPLATE *asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt,
392 (0.1%)                                   int nullerr) {
  .           const ASN1_ADB *adb;
  .           const ASN1_ADB_TABLE *atbl;
  .           ASN1_VALUE **sfld;
  .           int i;
280 (0.0%)    if (!(tt->flags & ASN1_TFLG_ADB_MASK)) {
112 (0.0%)      return tt;
  .           }
  .         
  .           // Else ANY DEFINED BY ... get the table
  .           adb = ASN1_ADB_ptr(tt->item);
  .         
  .           // Get the selector field
  .           sfld = offset2ptr(*pval, adb->offset);
  .         
-- line 233 ----------------------------------------
-- line 265 ----------------------------------------
  .           return adb->default_tt;
  .         
  .         err:
  .           // FIXME: should log the value or OID of unsupported type
  .           if (nullerr) {
  .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);
  .           }
  .           return NULL;
112 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h
--------------------------------------------------------------------------------
Ir________ 

-- line 882 ----------------------------------------
  .         static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
  .           if (n == 0) {
  .             return dst;
  .           }
  .         
  .           return memmove(dst, src, n);
  .         }
  .         
870 (0.1%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
290 (0.0%)    if (n == 0) {
  .             return dst;
  .           }
  .         
870 (0.1%)    return memset(dst, c, n);
290 (0.0%)  }
  .         
  .         
  .         // Loads and stores.
  .         //
  .         // The following functions load and store sized integers with the specified
  .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
  .         // requirements on the input and output pointers.
  .         
-- line 904 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 77 ----------------------------------------
    .         #define OPENSSL_MALLOC_PREFIX 8
    .         OPENSSL_STATIC_ASSERT(OPENSSL_MALLOC_PREFIX >= sizeof(size_t),
    .                               size_t_too_large)
    .         
    .         #if defined(OPENSSL_ASAN)
    .         void __asan_poison_memory_region(const volatile void *addr, size_t size);
    .         void __asan_unpoison_memory_region(const volatile void *addr, size_t size);
    .         #else
   40 (0.0%)  static void __asan_poison_memory_region(const void *addr, size_t size) {}
1,120 (0.2%)  static void __asan_unpoison_memory_region(const void *addr, size_t size) {}
    .         #endif
    .         
    .         // Windows doesn't really support weak symbols as of May 2019, and Clang on
    .         // Windows will emit strong symbols instead. See
    .         // https://bugs.llvm.org/show_bug.cgi?id=37598
    .         #if defined(__ELF__) && defined(__GNUC__)
    .         #define WEAK_SYMBOL_FUNC(rettype, name, args) \
    .           rettype name args __attribute__((weak));
-- line 94 ----------------------------------------
-- line 157 ----------------------------------------
    .             return 0;
    .           }
    .           malloc_impl = m;
    .           realloc_impl = r;
    .           free_impl = f;
    .           return 1;
    .         }
    .         
   25 (0.0%)  void *OPENSSL_malloc(size_t size) {
   15 (0.0%)    if (malloc_impl != NULL) {
    .             assert(OPENSSL_memory_alloc == NULL);
    .             assert(OPENSSL_memory_realloc == NULL);
    .             assert(OPENSSL_memory_free == NULL);
    .             assert(OPENSSL_memory_get_size == NULL);
    .             assert(realloc_impl != NULL);
    .             assert(free_impl != NULL);
    .             return malloc_impl(size, AWSLC_FILE, AWSLC_LINE);
    .           }
   15 (0.0%)    if (OPENSSL_memory_alloc != NULL) {
    .             assert(OPENSSL_memory_free != NULL);
    .             assert(OPENSSL_memory_get_size != NULL);
    .             void *ptr = OPENSSL_memory_alloc(size);
    .             if (ptr == NULL && size != 0) {
    .               goto err;
    .             }
    .             return ptr;
    .           }
    .         
   10 (0.0%)    if (size + OPENSSL_MALLOC_PREFIX < size) {
    .             goto err;
    .           }
    .         
   25 (0.0%)    void *ptr = malloc(size + OPENSSL_MALLOC_PREFIX);
   10 (0.0%)    if (ptr == NULL) {
    .             goto err;
    .           }
    .         
   15 (0.0%)    *(size_t *)ptr = size;
    .         
   20 (0.0%)    __asan_poison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
   15 (0.0%)    return ((uint8_t *)ptr) + OPENSSL_MALLOC_PREFIX;
    .         
    .          err:
    .           // This only works because ERR does not call OPENSSL_malloc.
    .           OPENSSL_PUT_ERROR(CRYPTO, ERR_R_MALLOC_FAILURE);
    .           return NULL;
   10 (0.0%)  }
    .         
   25 (0.0%)  void *OPENSSL_zalloc(size_t size) {
   20 (0.0%)    void *ret = OPENSSL_malloc(size);
   10 (0.0%)    if (ret != NULL) {
   25 (0.0%)      OPENSSL_memset(ret, 0, size);
    .           }
    5 (0.0%)    return ret;
   10 (0.0%)  }
    .         
   12 (0.0%)  void *OPENSSL_calloc(size_t num, size_t size) {
   18 (0.0%)    if (size != 0 && num > SIZE_MAX / size) {
    .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
    .             return NULL;
    .           }
    .         
    8 (0.0%)    return OPENSSL_zalloc(num * size);
    4 (0.0%)  }
    .         
  900 (0.1%)  void OPENSSL_free(void *orig_ptr) {
  360 (0.1%)    if (orig_ptr == NULL) {
   40 (0.0%)      return;
    .           }
  420 (0.1%)    if (free_impl != NULL) {
    .             assert(OPENSSL_memory_alloc == NULL);
    .             assert(OPENSSL_memory_realloc == NULL);
    .             assert(OPENSSL_memory_free == NULL);
    .             assert(OPENSSL_memory_get_size == NULL);
    .             assert(malloc_impl != NULL);
    .             assert(realloc_impl != NULL);
    .             free_impl(orig_ptr, AWSLC_FILE, AWSLC_LINE);
    .             return;
    .           }
    .         
  420 (0.1%)    if (OPENSSL_memory_free != NULL) {
    .             OPENSSL_memory_free(orig_ptr);
    .             return;
    .           }
    .         
  420 (0.1%)    void *ptr = ((uint8_t *)orig_ptr) - OPENSSL_MALLOC_PREFIX;
  560 (0.1%)    __asan_unpoison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
    .         
  420 (0.1%)    size_t size = *(size_t *)ptr;
  840 (0.1%)    OPENSSL_cleanse(ptr, size + OPENSSL_MALLOC_PREFIX);
    .         
    .         // ASan knows to intercept malloc and free, but not sdallocx.
    .         #if defined(OPENSSL_ASAN)
    .           (void)sdallocx;
    .           free(ptr);
    .           (void) sdallocx;
    .         #else
  420 (0.1%)    if (sdallocx) {
    .             sdallocx(ptr, size + OPENSSL_MALLOC_PREFIX, 0 /* flags */);
    .           } else {
  560 (0.1%)      free(ptr);
    .           }
    .         #endif
  360 (0.1%)  }
    .         
    .         void *OPENSSL_realloc(void *orig_ptr, size_t new_size) {
    .           if (orig_ptr == NULL) {
    .             return OPENSSL_malloc(new_size);
    .           }
    .           if (realloc_impl != NULL) {
    .             assert(OPENSSL_memory_alloc == NULL);
    .             assert(OPENSSL_memory_realloc == NULL);
-- line 268 ----------------------------------------
-- line 299 ----------------------------------------
    .           }
    .         
    .           memcpy(ret, orig_ptr, to_copy);
    .           OPENSSL_free(orig_ptr);
    .         
    .           return ret;
    .         }
    .         
  840 (0.1%)  void OPENSSL_cleanse(void *ptr, size_t len) {
    .         #if defined(OPENSSL_WINDOWS)
    .           SecureZeroMemory(ptr, len);
    .         #else
  700 (0.1%)    OPENSSL_memset(ptr, 0, len);
    .         
    .         #if !defined(OPENSSL_NO_ASM)
    .           /* As best as we can tell, this is sufficient to break any optimisations that
    .              might try to eliminate "superfluous" memsets. If there's an easy way to
    .              detect memset_s, it would be better to use that. */
  140 (0.0%)    __asm__ __volatile__("" : : "r"(ptr) : "memory");
    .         #endif
    .         #endif  // !OPENSSL_NO_ASM
  420 (0.1%)  }
    .         
    .         void OPENSSL_clear_free(void *ptr, size_t unused) { OPENSSL_free(ptr); }
    .         
    .         int CRYPTO_secure_malloc_init(size_t size, size_t min_size) { return 0; }
    .         
    .         int CRYPTO_secure_malloc_initialized(void) { return 0; }
    .         
    .         size_t CRYPTO_secure_used(void) { return 0; }
-- line 328 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c
--------------------------------------------------------------------------------
Ir________ 

-- line 26 ----------------------------------------
  .         #if defined(S2N_LIBCRYPTO_SUPPORTS_EVP_MD5_SHA1_HASH)
  .             return false;
  .         #else
  .             return true;
  .         #endif
  .         }
  .         
  .         static bool s2n_use_evp_impl()
144 (0.0%)  {
 48 (0.0%)      return s2n_is_in_fips_mode();
 96 (0.0%)  }
  .         
  .         bool s2n_hash_evp_fully_supported()
  .         {
  .             return s2n_use_evp_impl() && !s2n_use_custom_md5_sha1();
  .         }
  .         
  .         const EVP_MD *s2n_hash_alg_to_evp_md(s2n_hash_algorithm alg)
  .         {
-- line 44 ----------------------------------------
-- line 60 ----------------------------------------
  .                     return EVP_md5_sha1();
  .         #endif
  .                 default:
  .                     return NULL;
  .             }
  .         }
  .         
  .         int s2n_hash_digest_size(s2n_hash_algorithm alg, uint8_t *out)
 56 (0.0%)  {
 16 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(out, sizeof(*out)), S2N_ERR_PRECONDITION_VIOLATION);
  .             /* clang-format off */
 80 (0.0%)      switch (alg) {
 24 (0.0%)          case S2N_HASH_NONE:     *out = 0;                    break;
  .                 case S2N_HASH_MD5:      *out = MD5_DIGEST_LENGTH;    break;
  .                 case S2N_HASH_SHA1:     *out = SHA_DIGEST_LENGTH;    break;
  .                 case S2N_HASH_SHA224:   *out = SHA224_DIGEST_LENGTH; break;
  .                 case S2N_HASH_SHA256:   *out = SHA256_DIGEST_LENGTH; break;
  .                 case S2N_HASH_SHA384:   *out = SHA384_DIGEST_LENGTH; break;
  .                 case S2N_HASH_SHA512:   *out = SHA512_DIGEST_LENGTH; break;
  .                 case S2N_HASH_MD5_SHA1: *out = MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH; break;
  .                 default:
  .                     POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
  .             }
  .             /* clang-format on */
  8 (0.0%)      return S2N_SUCCESS;
 24 (0.0%)  }
  .         
  .         /* NOTE: s2n_hash_const_time_get_currently_in_hash_block takes advantage of the fact that
  .          * hash_block_size is a power of 2. This is true for all hashes we currently support
  .          * If this ever becomes untrue, this would require fixing*/
  .         int s2n_hash_block_size(s2n_hash_algorithm alg, uint64_t *block_size)
  .         {
  .             POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(block_size, sizeof(*block_size)), S2N_ERR_PRECONDITION_VIOLATION);
  .             /* clang-format off */
-- line 93 ----------------------------------------
-- line 104 ----------------------------------------
  .                         POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
  .             }
  .             /* clang-format on */
  .             return S2N_SUCCESS;
  .         }
  .         
  .         /* Return true if hash algorithm is available, false otherwise. */
  .         bool s2n_hash_is_available(s2n_hash_algorithm alg)
160 (0.0%)  {
320 (0.0%)      switch (alg) {
  .                 case S2N_HASH_MD5:
  .                 case S2N_HASH_MD5_SHA1:
  .                     /* return false if in FIPS mode, as MD5 algs are not available in FIPS mode. */
  .                     return !s2n_is_in_fips_mode();
  .                 case S2N_HASH_NONE:
  .                 case S2N_HASH_SHA1:
  .                 case S2N_HASH_SHA224:
  .                 case S2N_HASH_SHA256:
  .                 case S2N_HASH_SHA384:
  .                 case S2N_HASH_SHA512:
 64 (0.0%)              return true;
  .                 case S2N_HASH_SENTINEL:
  .                     return false;
  .             }
  .             return false;
 64 (0.0%)  }
  .         
  .         int s2n_hash_is_ready_for_input(struct s2n_hash_state *state)
  .         {
  .             POSIX_PRECONDITION(s2n_hash_state_validate(state));
  .             return state->is_ready_for_input;
  .         }
  .         
  .         static int s2n_low_level_hash_new(struct s2n_hash_state *state)
-- line 137 ----------------------------------------
-- line 140 ----------------------------------------
  .              * being used. For the s2n_low_level_hash implementation, new is a no-op.
  .              */
  .         
  .             *state = (struct s2n_hash_state){ 0 };
  .             return S2N_SUCCESS;
  .         }
  .         
  .         static int s2n_low_level_hash_init(struct s2n_hash_state *state, s2n_hash_algorithm alg)
336 (0.1%)  {
480 (0.1%)      switch (alg) {
  .                 case S2N_HASH_NONE:
 64 (0.0%)              break;
  .                 case S2N_HASH_MD5:
 12 (0.0%)              POSIX_GUARD_OSSL(MD5_Init(&state->digest.low_level.md5), S2N_ERR_HASH_INIT_FAILED);
  4 (0.0%)              break;
  .                 case S2N_HASH_SHA1:
 12 (0.0%)              POSIX_GUARD_OSSL(SHA1_Init(&state->digest.low_level.sha1), S2N_ERR_HASH_INIT_FAILED);
  4 (0.0%)              break;
  .                 case S2N_HASH_SHA224:
 12 (0.0%)              POSIX_GUARD_OSSL(SHA224_Init(&state->digest.low_level.sha224), S2N_ERR_HASH_INIT_FAILED);
  4 (0.0%)              break;
  .                 case S2N_HASH_SHA256:
 24 (0.0%)              POSIX_GUARD_OSSL(SHA256_Init(&state->digest.low_level.sha256), S2N_ERR_HASH_INIT_FAILED);
  8 (0.0%)              break;
  .                 case S2N_HASH_SHA384:
 12 (0.0%)              POSIX_GUARD_OSSL(SHA384_Init(&state->digest.low_level.sha384), S2N_ERR_HASH_INIT_FAILED);
  4 (0.0%)              break;
  .                 case S2N_HASH_SHA512:
 12 (0.0%)              POSIX_GUARD_OSSL(SHA512_Init(&state->digest.low_level.sha512), S2N_ERR_HASH_INIT_FAILED);
  4 (0.0%)              break;
  .                 case S2N_HASH_MD5_SHA1:
 12 (0.0%)              POSIX_GUARD_OSSL(SHA1_Init(&state->digest.low_level.md5_sha1.sha1), S2N_ERR_HASH_INIT_FAILED);
 12 (0.0%)              POSIX_GUARD_OSSL(MD5_Init(&state->digest.low_level.md5_sha1.md5), S2N_ERR_HASH_INIT_FAILED);
  2 (0.0%)              break;
  .         
  .                 default:
  .                     POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
  .             }
  .         
144 (0.0%)      state->alg = alg;
 96 (0.0%)      state->is_ready_for_input = 1;
 96 (0.0%)      state->currently_in_hash = 0;
  .         
 48 (0.0%)      return 0;
144 (0.0%)  }
  .         
  .         static int s2n_low_level_hash_update(struct s2n_hash_state *state, const void *data, uint32_t size)
128 (0.0%)  {
 64 (0.0%)      POSIX_ENSURE(state->is_ready_for_input, S2N_ERR_HASH_NOT_READY);
  .         
192 (0.0%)      switch (state->alg) {
  .                 case S2N_HASH_NONE:
 32 (0.0%)              break;
  .                 case S2N_HASH_MD5:
  .                     POSIX_GUARD_OSSL(MD5_Update(&state->digest.low_level.md5, data, size), S2N_ERR_HASH_UPDATE_FAILED);
  .                     break;
  .                 case S2N_HASH_SHA1:
  .                     POSIX_GUARD_OSSL(SHA1_Update(&state->digest.low_level.sha1, data, size), S2N_ERR_HASH_UPDATE_FAILED);
  .                     break;
  .                 case S2N_HASH_SHA224:
  .                     POSIX_GUARD_OSSL(SHA224_Update(&state->digest.low_level.sha224, data, size), S2N_ERR_HASH_UPDATE_FAILED);
-- line 200 ----------------------------------------
-- line 211 ----------------------------------------
  .                 case S2N_HASH_MD5_SHA1:
  .                     POSIX_GUARD_OSSL(SHA1_Update(&state->digest.low_level.md5_sha1.sha1, data, size), S2N_ERR_HASH_UPDATE_FAILED);
  .                     POSIX_GUARD_OSSL(MD5_Update(&state->digest.low_level.md5_sha1.md5, data, size), S2N_ERR_HASH_UPDATE_FAILED);
  .                     break;
  .                 default:
  .                     POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
  .             }
  .         
 96 (0.0%)      POSIX_ENSURE(size <= (UINT64_MAX - state->currently_in_hash), S2N_ERR_INTEGER_OVERFLOW);
 96 (0.0%)      state->currently_in_hash += size;
  .         
 16 (0.0%)      return S2N_SUCCESS;
 48 (0.0%)  }
  .         
  .         static int s2n_low_level_hash_digest(struct s2n_hash_state *state, void *out, uint32_t size)
  .         {
  .             POSIX_ENSURE(state->is_ready_for_input, S2N_ERR_HASH_NOT_READY);
  .         
  .             switch (state->alg) {
  .                 case S2N_HASH_NONE:
  .                     break;
-- line 231 ----------------------------------------
-- line 263 ----------------------------------------
  .             }
  .         
  .             state->currently_in_hash = 0;
  .             state->is_ready_for_input = 0;
  .             return 0;
  .         }
  .         
  .         static int s2n_low_level_hash_copy(struct s2n_hash_state *to, struct s2n_hash_state *from)
 70 (0.0%)  {
150 (0.0%)      POSIX_CHECKED_MEMCPY(to, from, sizeof(struct s2n_hash_state));
 10 (0.0%)      return 0;
 30 (0.0%)  }
  .         
  .         static int s2n_low_level_hash_reset(struct s2n_hash_state *state)
 80 (0.0%)  {
  .             /* hash_init resets the ready_for_input and currently_in_hash fields. */
 96 (0.0%)      return s2n_low_level_hash_init(state, state->alg);
 32 (0.0%)  }
  .         
  .         static int s2n_low_level_hash_free(struct s2n_hash_state *state)
  .         {
  .             /* s2n_hash_free will always call the corresponding implementation of the s2n_hash
  .              * being used. For the s2n_low_level_hash implementation, free is a no-op.
  .              */
  .             state->is_ready_for_input = 0;
  .             return S2N_SUCCESS;
-- line 288 ----------------------------------------
-- line 481 ----------------------------------------
  .             .update = &s2n_evp_hash_update,
  .             .digest = &s2n_evp_hash_digest,
  .             .copy = &s2n_evp_hash_copy,
  .             .reset = &s2n_evp_hash_reset,
  .             .free = &s2n_evp_hash_free,
  .         };
  .         
  .         static int s2n_hash_set_impl(struct s2n_hash_state *state)
240 (0.0%)  {
144 (0.0%)      state->hash_impl = &s2n_low_level_hash;
192 (0.0%)      if (s2n_use_evp_impl()) {
  .                 state->hash_impl = &s2n_evp_hash;
  .             }
 48 (0.0%)      return S2N_SUCCESS;
 96 (0.0%)  }
  .         
  .         int s2n_hash_new(struct s2n_hash_state *state)
  .         {
  .             POSIX_ENSURE_REF(state);
  .             /* Set hash_impl on initial hash creation.
  .              * When in FIPS mode, the EVP API's must be used for hashes.
  .              */
  .             POSIX_GUARD(s2n_hash_set_impl(state));
-- line 503 ----------------------------------------
-- line 504 ----------------------------------------
  .         
  .             POSIX_ENSURE_REF(state->hash_impl->alloc);
  .         
  .             POSIX_GUARD(state->hash_impl->alloc(state));
  .             return S2N_SUCCESS;
  .         }
  .         
  .         S2N_RESULT s2n_hash_state_validate(struct s2n_hash_state *state)
516 (0.1%)  {
172 (0.0%)      RESULT_ENSURE_REF(state);
 86 (0.0%)      return S2N_RESULT_OK;
258 (0.0%)  }
  .         
  .         int s2n_hash_allow_md5_for_fips(struct s2n_hash_state *state)
  .         {
  .             POSIX_ENSURE_REF(state);
  .             /* Ensure that hash_impl is set, as it may have been reset for s2n_hash_state on s2n_connection_wipe.
  .              * When in FIPS mode, the EVP API's must be used for hashes.
  .              */
  .             POSIX_GUARD(s2n_hash_set_impl(state));
  .         
  .             POSIX_ENSURE_REF(state->hash_impl->allow_md5_for_fips);
  .         
  .             return state->hash_impl->allow_md5_for_fips(state);
  .         }
  .         
  .         int s2n_hash_init(struct s2n_hash_state *state, s2n_hash_algorithm alg)
320 (0.0%)  {
 64 (0.0%)      POSIX_ENSURE_REF(state);
  .             /* Ensure that hash_impl is set, as it may have been reset for s2n_hash_state on s2n_connection_wipe.
  .              * When in FIPS mode, the EVP API's must be used for hashes.
  .              */
160 (0.0%)      POSIX_GUARD(s2n_hash_set_impl(state));
  .         
 32 (0.0%)      bool is_md5_allowed_for_fips = false;
352 (0.1%)      POSIX_GUARD_RESULT(s2n_digest_is_md5_allowed_for_fips(&state->digest.high_level.evp, &is_md5_allowed_for_fips));
  .         
160 (0.0%)      if (s2n_hash_is_available(alg) || ((alg == S2N_HASH_MD5 || alg == S2N_HASH_MD5_SHA1) && is_md5_allowed_for_fips)) {
  .                 /* s2n will continue to initialize an "unavailable" hash when s2n is in FIPS mode and
  .                  * FIPS is forcing the hash to be made available.
  .                  */
160 (0.0%)          POSIX_ENSURE_REF(state->hash_impl->init);
  .         
288 (0.0%)          return state->hash_impl->init(state, alg);
  .             } else {
  .                 POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
  .             }
192 (0.0%)  }
  .         
  .         int s2n_hash_update(struct s2n_hash_state *state, const void *data, uint32_t size)
128 (0.0%)  {
240 (0.0%)      POSIX_PRECONDITION(s2n_hash_state_validate(state));
 64 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_PRECONDITION_VIOLATION);
 80 (0.0%)      POSIX_ENSURE_REF(state->hash_impl->update);
  .         
144 (0.0%)      return state->hash_impl->update(state, data, size);
 48 (0.0%)  }
  .         
  .         int s2n_hash_digest(struct s2n_hash_state *state, void *out, uint32_t size)
  .         {
  .             POSIX_PRECONDITION(s2n_hash_state_validate(state));
  .             POSIX_ENSURE(S2N_MEM_IS_READABLE(out, size), S2N_ERR_PRECONDITION_VIOLATION);
  .             POSIX_ENSURE_REF(state->hash_impl->digest);
  .         
  .             return state->hash_impl->digest(state, out, size);
  .         }
  .         
  .         int s2n_hash_copy(struct s2n_hash_state *to, struct s2n_hash_state *from)
 70 (0.0%)  {
150 (0.0%)      POSIX_PRECONDITION(s2n_hash_state_validate(to));
150 (0.0%)      POSIX_PRECONDITION(s2n_hash_state_validate(from));
 50 (0.0%)      POSIX_ENSURE_REF(from->hash_impl->copy);
  .         
 80 (0.0%)      return from->hash_impl->copy(to, from);
 30 (0.0%)  }
  .         
  .         int s2n_hash_reset(struct s2n_hash_state *state)
 96 (0.0%)  {
 32 (0.0%)      POSIX_ENSURE_REF(state);
  .             /* Ensure that hash_impl is set, as it may have been reset for s2n_hash_state on s2n_connection_wipe.
  .              * When in FIPS mode, the EVP API's must be used for hashes.
  .              */
 80 (0.0%)      POSIX_GUARD(s2n_hash_set_impl(state));
  .         
 80 (0.0%)      POSIX_ENSURE_REF(state->hash_impl->reset);
  .         
 96 (0.0%)      return state->hash_impl->reset(state);
 48 (0.0%)  }
  .         
  .         int s2n_hash_free(struct s2n_hash_state *state)
  .         {
  .             if (state == NULL) {
  .                 return S2N_SUCCESS;
  .             }
  .             /* Ensure that hash_impl is set, as it may have been reset for s2n_hash_state on s2n_connection_wipe.
  .              * When in FIPS mode, the EVP API's must be used for hashes.
-- line 599 ----------------------------------------
-- line 601 ----------------------------------------
  .             POSIX_GUARD(s2n_hash_set_impl(state));
  .         
  .             POSIX_ENSURE_REF(state->hash_impl->free);
  .         
  .             return state->hash_impl->free(state);
  .         }
  .         
  .         int s2n_hash_get_currently_in_hash_total(struct s2n_hash_state *state, uint64_t *out)
 70 (0.0%)  {
150 (0.0%)      POSIX_PRECONDITION(s2n_hash_state_validate(state));
 20 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(out, sizeof(*out)), S2N_ERR_PRECONDITION_VIOLATION);
 40 (0.0%)      POSIX_ENSURE(state->is_ready_for_input, S2N_ERR_HASH_NOT_READY);
  .         
 40 (0.0%)      *out = state->currently_in_hash;
 10 (0.0%)      return S2N_SUCCESS;
 30 (0.0%)  }
  .         
  .         /* Calculate, in constant time, the number of bytes currently in the hash_block */
  .         int s2n_hash_const_time_get_currently_in_hash_block(struct s2n_hash_state *state, uint64_t *out)
  .         {
  .             POSIX_PRECONDITION(s2n_hash_state_validate(state));
  .             POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(out, sizeof(*out)), S2N_ERR_PRECONDITION_VIOLATION);
  .             POSIX_ENSURE(state->is_ready_for_input, S2N_ERR_HASH_NOT_READY);
  .             uint64_t hash_block_size = 0;
-- line 624 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 44 ----------------------------------------
    .             case S2N_HASH_MD5_SHA1:   /* Fall through ... */
    .             default:
    .                 POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
    .             }
    .             return S2N_SUCCESS;
    .         }
    .         
    .         int s2n_hmac_hash_alg(s2n_hmac_algorithm hmac_alg, s2n_hash_algorithm *out)
  112 (0.0%)  {
   32 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(out, sizeof(*out)), S2N_ERR_PRECONDITION_VIOLATION);
  160 (0.0%)      switch(hmac_alg) {
   48 (0.0%)      case S2N_HMAC_NONE:       *out = S2N_HASH_NONE;   break;
    .             case S2N_HMAC_MD5:        *out = S2N_HASH_MD5;    break;
    .             case S2N_HMAC_SHA1:       *out = S2N_HASH_SHA1;   break;
    .             case S2N_HMAC_SHA224:     *out = S2N_HASH_SHA224; break;
    .             case S2N_HMAC_SHA256:     *out = S2N_HASH_SHA256; break;
    .             case S2N_HMAC_SHA384:     *out = S2N_HASH_SHA384; break;
    .             case S2N_HMAC_SHA512:     *out = S2N_HASH_SHA512; break;
    .             case S2N_HMAC_SSLv3_MD5:  *out = S2N_HASH_MD5;    break;
    .             case S2N_HMAC_SSLv3_SHA1: *out = S2N_HASH_SHA1;   break;
    .             default:
    .                 POSIX_BAIL(S2N_ERR_HMAC_INVALID_ALGORITHM);
    .             }
   16 (0.0%)      return S2N_SUCCESS;
   48 (0.0%)  }
    .         
    .         int s2n_hmac_digest_size(s2n_hmac_algorithm hmac_alg, uint8_t *out)
   72 (0.0%)  {
    .             s2n_hash_algorithm hash_alg;
   56 (0.0%)      POSIX_GUARD(s2n_hmac_hash_alg(hmac_alg, &hash_alg));
   56 (0.0%)      POSIX_GUARD(s2n_hash_digest_size(hash_alg, out));
    8 (0.0%)      return S2N_SUCCESS;
   40 (0.0%)  }
    .         
    .         /* Return 1 if hmac algorithm is available, 0 otherwise. */
    .         bool s2n_hmac_is_available(s2n_hmac_algorithm hmac_alg)
   40 (0.0%)  {
   80 (0.0%)      switch(hmac_alg) {
    .             case S2N_HMAC_MD5:
    .             case S2N_HMAC_SSLv3_MD5:
    .             case S2N_HMAC_SSLv3_SHA1:
    .                 /* Some libcryptos, such as OpenSSL, disable MD5 by default when in FIPS mode, which is
    .                  * required in order to negotiate SSLv3. However, this is supported in AWS-LC.
    .                  */
    .                 return !s2n_is_in_fips_mode() || s2n_libcrypto_is_awslc();
    .             case S2N_HMAC_NONE:
    .             case S2N_HMAC_SHA1:
    .             case S2N_HMAC_SHA224:
    .             case S2N_HMAC_SHA256:
    .             case S2N_HMAC_SHA384:
    .             case S2N_HMAC_SHA512:
   16 (0.0%)          return true;
    .             }
    .             return false;
   16 (0.0%)  }
    .         
    .         static int s2n_sslv3_mac_init(struct s2n_hmac_state *state, s2n_hmac_algorithm alg, const void *key, uint32_t klen)
    .         {
    .             for (int i = 0; i < state->xor_pad_size; i++) {
    .                 state->xor_pad[i] = 0x36;
    .             }
    .         
    .             POSIX_GUARD(s2n_hash_update(&state->inner_just_key, key, klen));
-- line 106 ----------------------------------------
-- line 112 ----------------------------------------
    .         
    .             POSIX_GUARD(s2n_hash_update(&state->outer_just_key, key, klen));
    .             POSIX_GUARD(s2n_hash_update(&state->outer_just_key, state->xor_pad, state->xor_pad_size));
    .         
    .             return S2N_SUCCESS;
    .         }
    .         
    .         static int s2n_tls_hmac_init(struct s2n_hmac_state *state, s2n_hmac_algorithm alg, const void *key, uint32_t klen)
   72 (0.0%)  {
   48 (0.0%)      memset(&state->xor_pad, 0, sizeof(state->xor_pad));
    .         
   40 (0.0%)      if (klen > state->xor_pad_size) {
    .                 POSIX_GUARD(s2n_hash_update(&state->outer, key, klen));
    .                 POSIX_GUARD(s2n_hash_digest(&state->outer, state->digest_pad, state->digest_size));
    .                 POSIX_CHECKED_MEMCPY(state->xor_pad, state->digest_pad, state->digest_size);
    .             } else {
   56 (0.0%)          POSIX_CHECKED_MEMCPY(state->xor_pad, key, klen);
    .             }
    .         
3,128 (0.5%)      for (int i = 0; i < state->xor_pad_size; i++) {
5,120 (0.8%)          state->xor_pad[i] ^= 0x36;
    .             }
    .         
   96 (0.0%)      POSIX_GUARD(s2n_hash_update(&state->inner_just_key, state->xor_pad, state->xor_pad_size));
    .         
    .             /* 0x36 xor 0x5c == 0x6a */
3,128 (0.5%)      for (int i = 0; i < state->xor_pad_size; i++) {
5,120 (0.8%)          state->xor_pad[i] ^= 0x6a;
    .             }
    .         
   96 (0.0%)      POSIX_GUARD(s2n_hash_update(&state->outer_just_key, state->xor_pad, state->xor_pad_size));
    8 (0.0%)      return S2N_SUCCESS;
   24 (0.0%)  }
    .         
    .         int s2n_hmac_xor_pad_size(s2n_hmac_algorithm hmac_alg, uint16_t *xor_pad_size)
   56 (0.0%)  {
   16 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(xor_pad_size, sizeof(*xor_pad_size)), S2N_ERR_PRECONDITION_VIOLATION);
   80 (0.0%)      switch(hmac_alg) {
   24 (0.0%)      case S2N_HMAC_NONE:       *xor_pad_size = 64;   break;
    .             case S2N_HMAC_MD5:        *xor_pad_size = 64;   break;
    .             case S2N_HMAC_SHA1:       *xor_pad_size = 64;   break;
    .             case S2N_HMAC_SHA224:     *xor_pad_size = 64;   break;
    .             case S2N_HMAC_SHA256:     *xor_pad_size = 64;   break;
    .             case S2N_HMAC_SHA384:     *xor_pad_size = 128;  break;
    .             case S2N_HMAC_SHA512:     *xor_pad_size = 128;  break;
    .             case S2N_HMAC_SSLv3_MD5:  *xor_pad_size = 48;   break;
    .             case S2N_HMAC_SSLv3_SHA1: *xor_pad_size = 40;   break;
    .             default:
    .                 POSIX_BAIL(S2N_ERR_HMAC_INVALID_ALGORITHM);
    .             }
    8 (0.0%)      return S2N_SUCCESS;
   24 (0.0%)  }
    .         
    .         int s2n_hmac_hash_block_size(s2n_hmac_algorithm hmac_alg, uint16_t *block_size)
   56 (0.0%)  {
   16 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(block_size, sizeof(*block_size)), S2N_ERR_PRECONDITION_VIOLATION);
   80 (0.0%)      switch(hmac_alg) {
   24 (0.0%)      case S2N_HMAC_NONE:       *block_size = 64;   break;
    .             case S2N_HMAC_MD5:        *block_size = 64;   break;
    .             case S2N_HMAC_SHA1:       *block_size = 64;   break;
    .             case S2N_HMAC_SHA224:     *block_size = 64;   break;
    .             case S2N_HMAC_SHA256:     *block_size = 64;   break;
    .             case S2N_HMAC_SHA384:     *block_size = 128;  break;
    .             case S2N_HMAC_SHA512:     *block_size = 128;  break;
    .             case S2N_HMAC_SSLv3_MD5:  *block_size = 64;   break;
    .             case S2N_HMAC_SSLv3_SHA1: *block_size = 64;   break;
    .             default:
    .                 POSIX_BAIL(S2N_ERR_HMAC_INVALID_ALGORITHM);
    .             }
    8 (0.0%)      return S2N_SUCCESS;
   24 (0.0%)  }
    .         
    .         int s2n_hmac_new(struct s2n_hmac_state *state)
    .         {
    .             POSIX_ENSURE_REF(state);
    .             POSIX_GUARD(s2n_hash_new(&state->inner));
    .             POSIX_GUARD(s2n_hash_new(&state->inner_just_key));
    .             POSIX_GUARD(s2n_hash_new(&state->outer));
    .             POSIX_GUARD(s2n_hash_new(&state->outer_just_key));
    .             POSIX_POSTCONDITION(s2n_hmac_state_validate(state));
    .             return S2N_SUCCESS;
    .         }
    .         
    .         S2N_RESULT s2n_hmac_state_validate(struct s2n_hmac_state *state)
   60 (0.0%)  {
   20 (0.0%)      RESULT_ENSURE_REF(state);
   90 (0.0%)      RESULT_GUARD(s2n_hash_state_validate(&state->inner));
   90 (0.0%)      RESULT_GUARD(s2n_hash_state_validate(&state->inner_just_key));
   90 (0.0%)      RESULT_GUARD(s2n_hash_state_validate(&state->outer));
   90 (0.0%)      RESULT_GUARD(s2n_hash_state_validate(&state->outer_just_key));
   10 (0.0%)      return S2N_RESULT_OK;
   30 (0.0%)  }
    .         
    .         int s2n_hmac_init(struct s2n_hmac_state *state, s2n_hmac_algorithm alg, const void *key, uint32_t klen)
   96 (0.0%)  {
   16 (0.0%)      POSIX_ENSURE_REF(state);
   48 (0.0%)      if (!s2n_hmac_is_available(alg)) {
    .                 /* Prevent hmacs from being used if they are not available. */
    .                 POSIX_BAIL(S2N_ERR_HMAC_INVALID_ALGORITHM);
    .             }
    .         
   24 (0.0%)      state->alg = alg;
   64 (0.0%)      POSIX_GUARD(s2n_hmac_hash_block_size(alg, &state->hash_block_size));
   16 (0.0%)      state->currently_in_hash_block = 0;
   64 (0.0%)      POSIX_GUARD(s2n_hmac_xor_pad_size(alg, &state->xor_pad_size));
   64 (0.0%)      POSIX_GUARD(s2n_hmac_digest_size(alg, &state->digest_size));
    .         
   32 (0.0%)      POSIX_ENSURE_GTE(sizeof(state->xor_pad), state->xor_pad_size);
   32 (0.0%)      POSIX_ENSURE_GTE(sizeof(state->digest_pad), state->digest_size);
    .             /* key needs to be as large as the biggest block size */
   32 (0.0%)      POSIX_ENSURE_GTE(sizeof(state->xor_pad), state->hash_block_size);
    .         
    .             s2n_hash_algorithm hash_alg;
   56 (0.0%)      POSIX_GUARD(s2n_hmac_hash_alg(alg, &hash_alg));
    .         
   64 (0.0%)      POSIX_GUARD(s2n_hash_init(&state->inner, hash_alg));
   64 (0.0%)      POSIX_GUARD(s2n_hash_init(&state->inner_just_key, hash_alg));
   64 (0.0%)      POSIX_GUARD(s2n_hash_init(&state->outer, hash_alg));
   64 (0.0%)      POSIX_GUARD(s2n_hash_init(&state->outer_just_key, hash_alg));
    .         
   32 (0.0%)      if (alg == S2N_HMAC_SSLv3_SHA1 || alg == S2N_HMAC_SSLv3_MD5) {
    .                 POSIX_GUARD(s2n_sslv3_mac_init(state, alg, key, klen));
    .             } else {
   64 (0.0%)          POSIX_GUARD(s2n_tls_hmac_init(state, alg, key, klen));
    .             }
    .         
    .             /* Once we have produced inner_just_key and outer_just_key, don't need the key material in xor_pad, so wipe it.
    .              * Since xor_pad is used as a source of bytes in s2n_hmac_digest_two_compression_rounds,
    .              * this also prevents uninitilized bytes being used.
    .              */
   48 (0.0%)      memset(&state->xor_pad, 0, sizeof(state->xor_pad));
   40 (0.0%)      POSIX_GUARD(s2n_hmac_reset(state));
    .         
    8 (0.0%)      return S2N_SUCCESS;
   48 (0.0%)  }
    .         
    .         int s2n_hmac_update(struct s2n_hmac_state *state, const void *in, uint32_t size)
    .         {
    .             POSIX_PRECONDITION(s2n_hmac_state_validate(state));
    .             POSIX_ENSURE(state->hash_block_size != 0, S2N_ERR_PRECONDITION_VIOLATION);
    .             /* Keep track of how much of the current hash block is full
    .              *
    .              * Why the 4294949760 constant in this code? 4294949760 is the highest 32-bit
-- line 254 ----------------------------------------
-- line 322 ----------------------------------------
    .                 POSIX_GUARD(s2n_hash_free(&state->outer));
    .                 POSIX_GUARD(s2n_hash_free(&state->outer_just_key));
    .             }
    .         
    .             return S2N_SUCCESS;
    .         }
    .         
    .         int s2n_hmac_reset(struct s2n_hmac_state *state)
   90 (0.0%)  {
  150 (0.0%)      POSIX_PRECONDITION(s2n_hmac_state_validate(state));
   40 (0.0%)      POSIX_ENSURE(state->hash_block_size != 0, S2N_ERR_PRECONDITION_VIOLATION);
   90 (0.0%)      POSIX_GUARD(s2n_hash_copy(&state->inner, &state->inner_just_key));
    .         
   10 (0.0%)      uint64_t bytes_in_hash = 0;
   80 (0.0%)      POSIX_GUARD(s2n_hash_get_currently_in_hash_total(&state->inner, &bytes_in_hash));
   90 (0.0%)      bytes_in_hash %= state->hash_block_size;
   40 (0.0%)      POSIX_ENSURE(bytes_in_hash <= UINT32_MAX, S2N_ERR_INTEGER_OVERFLOW);
    .             /* The length of the key is not private, so don't need to do tricky math here */
   40 (0.0%)      state->currently_in_hash_block = bytes_in_hash;
   10 (0.0%)      return S2N_SUCCESS;
   60 (0.0%)  }
    .         
    .         int s2n_hmac_digest_verify(const void *a, const void *b, uint32_t len)
    .         {
    .             return S2N_SUCCESS - !s2n_constant_time_equals(a, b, len);
    .         }
    .         
    .         int s2n_hmac_copy(struct s2n_hmac_state *to, struct s2n_hmac_state *from)
    .         {
-- line 350 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c
--------------------------------------------------------------------------------
Ir________ 

-- line 18 ----------------------------------------
  .         #include <sys/param.h>
  .         
  .         #include "error/s2n_errno.h"
  .         #include "utils/s2n_blob.h"
  .         #include "utils/s2n_mem.h"
  .         #include "utils/s2n_safety.h"
  .         
  .         S2N_RESULT s2n_stuffer_validate(const struct s2n_stuffer *stuffer)
324 (0.0%)  {
  .             /**
  .              * Note that we do not assert any properties on the tainted field,
  .              * as any boolean value in that field is valid.
  .              */
108 (0.0%)      RESULT_ENSURE_REF(stuffer);
432 (0.1%)      RESULT_GUARD(s2n_blob_validate(&stuffer->blob));
672 (0.1%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(stuffer->growable, stuffer->alloced), S2N_ERR_SAFETY);
  .         
  .             /* <= is valid because we can have a fully written/read stuffer */
486 (0.1%)      RESULT_DEBUG_ENSURE(stuffer->high_water_mark <= stuffer->blob.size, S2N_ERR_SAFETY);
486 (0.1%)      RESULT_DEBUG_ENSURE(stuffer->write_cursor <= stuffer->high_water_mark, S2N_ERR_SAFETY);
486 (0.1%)      RESULT_DEBUG_ENSURE(stuffer->read_cursor <= stuffer->write_cursor, S2N_ERR_SAFETY);
 54 (0.0%)      return S2N_RESULT_OK;
162 (0.0%)  }
  .         
  .         S2N_RESULT s2n_stuffer_reservation_validate(const struct s2n_stuffer_reservation *reservation)
  .         {
  .             /**
  .              * Note that we need two dereferences here to decrease proof complexity
  .              * for CBMC (see https://github.com/awslabs/s2n/issues/2290). We can roll back
  .              * this change once CBMC can handle common subexpression elimination.
  .              */
-- line 48 ----------------------------------------
-- line 56 ----------------------------------------
  .             /* The entire reservation must fit between the stuffer read and write cursors */
  .             RESULT_ENSURE_LTE(reserve_obj.write_cursor + reserve_obj.length, stuffer_obj.write_cursor);
  .             RESULT_ENSURE_GTE(reserve_obj.write_cursor, stuffer_obj.read_cursor);
  .         
  .             return S2N_RESULT_OK;
  .         }
  .         
  .         int s2n_stuffer_init(struct s2n_stuffer *stuffer, struct s2n_blob *in)
 14 (0.0%)  {
  4 (0.0%)      POSIX_ENSURE_MUT(stuffer);
 30 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(in));
 16 (0.0%)      stuffer->blob = *in;
  4 (0.0%)      stuffer->read_cursor = 0;
  4 (0.0%)      stuffer->write_cursor = 0;
  4 (0.0%)      stuffer->high_water_mark = 0;
  8 (0.0%)      stuffer->alloced = 0;
  8 (0.0%)      stuffer->growable = 0;
  8 (0.0%)      stuffer->tainted = 0;
 30 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  2 (0.0%)      return S2N_SUCCESS;
  6 (0.0%)  }
  .         
  .         int s2n_stuffer_init_written(struct s2n_stuffer *stuffer, struct s2n_blob *in)
  .         {
  .             POSIX_ENSURE_REF(in);
  .             POSIX_GUARD(s2n_stuffer_init(stuffer, in));
  .             POSIX_GUARD(s2n_stuffer_skip_write(stuffer, in->size));
  .             return S2N_SUCCESS;
  .         }
  .         
  .         int s2n_stuffer_alloc(struct s2n_stuffer *stuffer, const uint32_t size)
 14 (0.0%)  {
  4 (0.0%)      POSIX_ENSURE_REF(stuffer);
 10 (0.0%)      *stuffer = (struct s2n_stuffer){ 0 };
 14 (0.0%)      POSIX_GUARD(s2n_alloc(&stuffer->blob, size));
 14 (0.0%)      POSIX_GUARD(s2n_stuffer_init(stuffer, &stuffer->blob));
  .         
  8 (0.0%)      stuffer->alloced = 1;
  .         
 30 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  2 (0.0%)      return S2N_SUCCESS;
  6 (0.0%)  }
  .         
  .         int s2n_stuffer_growable_alloc(struct s2n_stuffer *stuffer, const uint32_t size)
 12 (0.0%)  {
 14 (0.0%)      POSIX_GUARD(s2n_stuffer_alloc(stuffer, size));
  .         
  8 (0.0%)      stuffer->growable = 1;
  .         
 30 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  2 (0.0%)      return S2N_SUCCESS;
  4 (0.0%)  }
  .         
  .         int s2n_stuffer_free(struct s2n_stuffer *stuffer)
 20 (0.0%)  {
 60 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 20 (0.0%)      if (stuffer->alloced) {
  .                 POSIX_GUARD(s2n_free(&stuffer->blob));
  .             }
 20 (0.0%)      *stuffer = (struct s2n_stuffer){ 0 };
  4 (0.0%)      return S2N_SUCCESS;
  8 (0.0%)  }
  .         
  .         int s2n_stuffer_free_without_wipe(struct s2n_stuffer *stuffer)
  .         {
  .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
  .             if (stuffer->alloced) {
  .                 POSIX_GUARD(s2n_free_without_wipe(&stuffer->blob));
  .             }
  .             *stuffer = (struct s2n_stuffer){ 0 };
  .             return S2N_SUCCESS;
  .         }
  .         
  .         int s2n_stuffer_resize(struct s2n_stuffer *stuffer, const uint32_t size)
 42 (0.0%)  {
 90 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 30 (0.0%)      POSIX_ENSURE(!stuffer->tainted, S2N_ERR_RESIZE_TAINTED_STUFFER);
 30 (0.0%)      POSIX_ENSURE(stuffer->growable, S2N_ERR_RESIZE_STATIC_STUFFER);
  .         
 24 (0.0%)      if (size == stuffer->blob.size) {
  .                 return S2N_SUCCESS;
  .             }
  .         
 12 (0.0%)      if (size == 0) {
 12 (0.0%)          s2n_stuffer_wipe(stuffer);
 16 (0.0%)          return s2n_free(&stuffer->blob);
  .             }
  .         
  8 (0.0%)      if (size < stuffer->blob.size) {
  .                 POSIX_CHECKED_MEMSET(stuffer->blob.data + size, S2N_WIPE_PATTERN, (stuffer->blob.size - size));
  .                 if (stuffer->read_cursor > size) {
  .                     stuffer->read_cursor = size;
  .                 }
  .                 if (stuffer->write_cursor > size) {
  .                     stuffer->write_cursor = size;
  .                 }
  .                 if (stuffer->high_water_mark > size) {
  .                     stuffer->high_water_mark = size;
  .                 }
  .                 stuffer->blob.size = size;
  .                 POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  .                 return S2N_SUCCESS;
  .             }
  .         
 14 (0.0%)      POSIX_GUARD(s2n_realloc(&stuffer->blob, size));
 30 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  2 (0.0%)      return S2N_SUCCESS;
 18 (0.0%)  }
  .         
  .         int s2n_stuffer_resize_if_empty(struct s2n_stuffer *stuffer, const uint32_t size)
  .         {
  .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
  .             if (stuffer->blob.data == NULL) {
  .                 POSIX_ENSURE(!stuffer->tainted, S2N_ERR_RESIZE_TAINTED_STUFFER);
  .                 POSIX_ENSURE(stuffer->growable, S2N_ERR_RESIZE_STATIC_STUFFER);
  .                 POSIX_GUARD(s2n_realloc(&stuffer->blob, size));
-- line 171 ----------------------------------------
-- line 213 ----------------------------------------
  .         }
  .         
  .         bool s2n_stuffer_is_consumed(struct s2n_stuffer *stuffer)
  .         {
  .             return stuffer && (stuffer->read_cursor == stuffer->write_cursor) && !stuffer->tainted;
  .         }
  .         
  .         int s2n_stuffer_wipe(struct s2n_stuffer *stuffer)
108 (0.0%)  {
270 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 72 (0.0%)      if (!s2n_stuffer_is_wiped(stuffer)) {
 36 (0.0%)          POSIX_CHECKED_MEMSET(stuffer->blob.data, S2N_WIPE_PATTERN, stuffer->high_water_mark);
  .             }
  .         
 72 (0.0%)      stuffer->tainted = 0;
 36 (0.0%)      stuffer->write_cursor = 0;
 36 (0.0%)      stuffer->read_cursor = 0;
 36 (0.0%)      stuffer->high_water_mark = 0;
270 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
 18 (0.0%)      return S2N_SUCCESS;
 54 (0.0%)  }
  .         
  .         int s2n_stuffer_skip_read(struct s2n_stuffer *stuffer, uint32_t n)
  .         {
  .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
  .             POSIX_ENSURE(s2n_stuffer_data_available(stuffer) >= n, S2N_ERR_STUFFER_OUT_OF_DATA);
  .         
  .             stuffer->read_cursor += n;
  .             return S2N_SUCCESS;
-- line 241 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_connection.c
--------------------------------------------------------------------------------
Ir_______ 

-- line 112 ----------------------------------------
 .              * reset/reuse the connection. Calling it last ensures that s2n_connection_wipe is
 .              * implemented correctly and safe.
 .              */
 .             PTR_GUARD_POSIX(s2n_connection_wipe(conn));
 .             return conn;
 .         }
 .         
 .         static int s2n_connection_zero(struct s2n_connection *conn, int mode, struct s2n_config *config)
16 (0.0%)  {
 .             /* Zero the whole connection structure */
30 (0.0%)      POSIX_CHECKED_MEMSET(conn, 0, sizeof(struct s2n_connection));
 .         
 6 (0.0%)      conn->mode = mode;
 4 (0.0%)      conn->max_outgoing_fragment_length = S2N_DEFAULT_FRAGMENT_LENGTH;
 4 (0.0%)      conn->handshake.end_of_messages = APPLICATION_DATA;
10 (0.0%)      s2n_connection_set_config(conn, config);
 .         
 2 (0.0%)      return 0;
 6 (0.0%)  }
 .         
 .         S2N_RESULT s2n_connection_wipe_all_keyshares(struct s2n_connection *conn)
12 (0.0%)  {
 4 (0.0%)      RESULT_ENSURE_REF(conn);
 .         
12 (0.0%)      RESULT_GUARD_POSIX(s2n_ecc_evp_params_free(&conn->kex_params.server_ecc_evp_params));
12 (0.0%)      RESULT_GUARD_POSIX(s2n_ecc_evp_params_free(&conn->kex_params.client_ecc_evp_params));
 .         
12 (0.0%)      RESULT_GUARD_POSIX(s2n_kem_group_free(&conn->kex_params.server_kem_group_params));
12 (0.0%)      RESULT_GUARD_POSIX(s2n_kem_group_free(&conn->kex_params.client_kem_group_params));
 .         
 2 (0.0%)      return S2N_RESULT_OK;
 6 (0.0%)  }
 .         
 .         static int s2n_connection_wipe_keys(struct s2n_connection *conn)
10 (0.0%)  {
 .             /* Free any server key received (we may not have completed a
 .              * handshake, so this may not have been free'd yet) */
12 (0.0%)      POSIX_GUARD(s2n_pkey_free(&conn->handshake_params.server_public_key));
12 (0.0%)      POSIX_GUARD(s2n_pkey_zero_init(&conn->handshake_params.server_public_key));
12 (0.0%)      POSIX_GUARD(s2n_pkey_free(&conn->handshake_params.client_public_key));
12 (0.0%)      POSIX_GUARD(s2n_pkey_zero_init(&conn->handshake_params.client_public_key));
 8 (0.0%)      s2n_x509_validator_wipe(&conn->x509_validator);
12 (0.0%)      POSIX_GUARD(s2n_dh_params_free(&conn->kex_params.server_dh_params));
16 (0.0%)      POSIX_GUARD_RESULT(s2n_connection_wipe_all_keyshares(conn));
12 (0.0%)      POSIX_GUARD(s2n_kem_free(&conn->kex_params.kem_params));
12 (0.0%)      POSIX_GUARD(s2n_free(&conn->handshake_params.client_cert_chain));
12 (0.0%)      POSIX_GUARD(s2n_free(&conn->ct_response));
 .         
 2 (0.0%)      return 0;
 4 (0.0%)  }
 .         
 .         static int s2n_connection_free_managed_recv_io(struct s2n_connection *conn)
12 (0.0%)  {
 4 (0.0%)      POSIX_ENSURE_REF(conn);
 .         
10 (0.0%)      if (conn->managed_recv_io) {
 .                 POSIX_GUARD(s2n_free_object((uint8_t **) &conn->recv_io_context, sizeof(struct s2n_socket_read_io_context)));
 .                 conn->managed_recv_io = false;
 .                 conn->recv = NULL;
 .             }
 2 (0.0%)      return S2N_SUCCESS;
 6 (0.0%)  }
 .         
 .         static int s2n_connection_free_managed_send_io(struct s2n_connection *conn)
12 (0.0%)  {
 4 (0.0%)      POSIX_ENSURE_REF(conn);
 .         
10 (0.0%)      if (conn->managed_send_io) {
 .                 POSIX_GUARD(s2n_free_object((uint8_t **) &conn->send_io_context, sizeof(struct s2n_socket_write_io_context)));
 .                 conn->managed_send_io = false;
 .                 conn->send = NULL;
 .             }
 2 (0.0%)      return S2N_SUCCESS;
 6 (0.0%)  }
 .         
 .         static int s2n_connection_free_managed_io(struct s2n_connection *conn)
10 (0.0%)  {
10 (0.0%)      POSIX_GUARD(s2n_connection_free_managed_recv_io(conn));
10 (0.0%)      POSIX_GUARD(s2n_connection_free_managed_send_io(conn));
 2 (0.0%)      return S2N_SUCCESS;
 4 (0.0%)  }
 .         
 .         static int s2n_connection_wipe_io(struct s2n_connection *conn)
10 (0.0%)  {
10 (0.0%)      if (s2n_connection_is_managed_corked(conn) && conn->recv) {
 .                 POSIX_GUARD(s2n_socket_read_restore(conn));
 .             }
10 (0.0%)      if (s2n_connection_is_managed_corked(conn) && conn->send) {
 .                 POSIX_GUARD(s2n_socket_write_restore(conn));
 .             }
 .         
 .             /* Remove all I/O-related members */
10 (0.0%)      POSIX_GUARD(s2n_connection_free_managed_io(conn));
 .         
 2 (0.0%)      return 0;
 4 (0.0%)  }
 .         
 .         static uint8_t s2n_default_verify_host(const char *host_name, size_t len, void *data)
 .         {
 .             /* if present, match server_name of the connection using rules
 .              * outlined in RFC6125 6.4. */
 .         
 .             struct s2n_connection *conn = data;
 .         
-- line 215 ----------------------------------------
-- line 274 ----------------------------------------
 .             POSIX_GUARD_RESULT(s2n_crypto_parameters_free(&conn->initial));
 .             POSIX_GUARD_RESULT(s2n_crypto_parameters_free(&conn->secure));
 .             POSIX_GUARD(s2n_free_object((uint8_t **) &conn, sizeof(struct s2n_connection)));
 .         
 .             return 0;
 .         }
 .         
 .         int s2n_connection_set_config(struct s2n_connection *conn, struct s2n_config *config)
20 (0.0%)  {
 4 (0.0%)      POSIX_ENSURE_REF(conn);
 4 (0.0%)      POSIX_ENSURE_REF(config);
 .         
 8 (0.0%)      if (conn->config == config) {
 .                 return 0;
 .             }
 .         
 .             /* s2n_config invariant: any s2n_config is always in a state that respects the
 .              * config->security_policy certificate preferences. Therefore we only need to
 .              * validate certificates here if the connection is using a security policy override.
 .              */
 6 (0.0%)      const struct s2n_security_policy *security_policy_override = conn->security_policy_override;
 4 (0.0%)      if (security_policy_override) {
 .                 POSIX_GUARD_RESULT(s2n_config_validate_loaded_certificates(config, security_policy_override));
 .             }
 .         
 .             /* We only support one client certificate */
10 (0.0%)      if (s2n_config_get_num_default_certs(config) > 1 && conn->mode == S2N_CLIENT) {
 .                 POSIX_BAIL(S2N_ERR_TOO_MANY_CERTIFICATES);
 .             }
 .         
 8 (0.0%)      s2n_x509_validator_wipe(&conn->x509_validator);
 .         
 2 (0.0%)      s2n_cert_auth_type auth_type = S2N_CERT_AUTH_NONE;
22 (0.0%)      POSIX_GUARD_RESULT(s2n_connection_and_config_get_client_auth_type(conn, config, &auth_type));
 .         
16 (0.0%)      int8_t dont_need_x509_validation = (conn->mode == S2N_SERVER) && (auth_type == S2N_CERT_AUTH_NONE);
 .         
14 (0.0%)      if (config->disable_x509_validation || dont_need_x509_validation) {
 6 (0.0%)          POSIX_GUARD(s2n_x509_validator_init_no_x509_validation(&conn->x509_validator));
 .             } else {
14 (0.0%)          POSIX_GUARD(s2n_x509_validator_init(&conn->x509_validator, &config->trust_store, config->check_ocsp));
 4 (0.0%)          if (!conn->verify_host_fn_overridden) {
 4 (0.0%)              if (config->verify_host_fn != NULL) {
 4 (0.0%)                  conn->verify_host_fn = config->verify_host_fn;
 5 (0.0%)                  conn->data_for_verify_host = config->data_for_verify_host;
 .                     } else {
 .                         conn->verify_host_fn = s2n_default_verify_host;
 .                         conn->data_for_verify_host = conn;
 .                     }
 .                 }
 .         
 5 (0.0%)          if (config->max_verify_cert_chain_depth_set) {
 .                     POSIX_GUARD(s2n_x509_validator_set_max_chain_depth(&conn->x509_validator, config->max_verify_cert_chain_depth));
 .                 }
 .             }
10 (0.0%)      conn->tickets_to_send = config->initial_tickets_to_send;
 .         
18 (0.0%)      if (conn->psk_params.psk_list.len == 0 && !conn->psk_mode_overridden) {
16 (0.0%)          POSIX_GUARD(s2n_connection_set_psk_mode(conn, config->psk_mode));
 8 (0.0%)          conn->psk_mode_overridden = false;
 .             }
 .         
 .             /* If at least one certificate does not have a private key configured,
 .              * the config must provide an async pkey callback.
 .              * The handshake could still fail if the callback doesn't offload the
 .              * signature, but this at least catches configuration mistakes.
 .              */
10 (0.0%)      if (config->no_signing_key) {
 .                 POSIX_ENSURE(config->async_pkey_cb, S2N_ERR_NO_PRIVATE_KEY);
 .             }
 .         
10 (0.0%)      if (config->quic_enabled) {
 .                 /* If QUIC is ever enabled for a connection via the config,
 .                  * we should enforce that it can never be disabled by
 .                  * changing the config.
 .                  *
 .                  * Enabling QUIC indicates that the connection is being used by
 .                  * a QUIC implementation, which never changes. Disabling QUIC
 .                  * partially through a connection could also potentially be
 .                  * dangerous, as QUIC handles encryption.
 .                  */
 .                 POSIX_GUARD(s2n_connection_enable_quic(conn));
 .             }
 .         
 8 (0.0%)      if (config->send_buffer_size_override) {
 .                 conn->multirecord_send = true;
 .             }
 .         
 .             /* Historically, calling s2n_config_set_verification_ca_location enabled OCSP stapling
 .              * regardless of the value set by an application calling s2n_config_set_status_request_type.
 .              * We maintain this behavior for backwards compatibility.
 .              *
 .              * However, the s2n_config_set_verification_ca_location behavior predates client authentication
 .              * support for OCSP stapling, so could only affect whether clients requested OCSP stapling. We
 .              * therefore only have to maintain the legacy behavior for clients, not servers.
 .              * 
 .              * Note: The Rust bindings do not maintain the legacy behavior.
 .              */
24 (0.0%)      conn->request_ocsp_status = config->ocsp_status_requested_by_user;
10 (0.0%)      if (config->ocsp_status_requested_by_s2n && conn->mode == S2N_CLIENT) {
 .                 conn->request_ocsp_status = true;
 .             }
 .         
 6 (0.0%)      conn->config = config;
 2 (0.0%)      return S2N_SUCCESS;
12 (0.0%)  }
 .         
 .         int s2n_connection_server_name_extension_used(struct s2n_connection *conn)
 .         {
 .             POSIX_ENSURE_REF(conn);
 .             POSIX_ENSURE(conn->mode == S2N_SERVER, S2N_ERR_INVALID_STATE);
 .             POSIX_ENSURE(!(conn->handshake.client_hello_received), S2N_ERR_INVALID_STATE);
 .         
 .             conn->server_name_used = 1;
 .             return S2N_SUCCESS;
 .         }
 .         
 .         int s2n_connection_set_ctx(struct s2n_connection *conn, void *ctx)
14 (0.0%)  {
 4 (0.0%)      POSIX_ENSURE_REF(conn);
 .         
 6 (0.0%)      conn->context = ctx;
 2 (0.0%)      return S2N_SUCCESS;
 6 (0.0%)  }
 .         
 .         void *s2n_connection_get_ctx(struct s2n_connection *conn)
24 (0.0%)  {
12 (0.0%)      return conn->context;
12 (0.0%)  }
 .         
 .         int s2n_connection_release_buffers(struct s2n_connection *conn)
 .         {
 .             POSIX_ENSURE_REF(conn);
 .             POSIX_PRECONDITION(s2n_stuffer_validate(&conn->out));
 .             POSIX_PRECONDITION(s2n_stuffer_validate(&conn->in));
 .         
 .             POSIX_ENSURE(s2n_stuffer_is_consumed(&conn->out), S2N_ERR_STUFFER_HAS_UNPROCESSED_DATA);
-- line 410 ----------------------------------------
-- line 457 ----------------------------------------
 .         
 .         /* An idempotent operation which initializes values on the connection.
 .          *
 .          * Called in order to reuse a connection structure for a new connection. Should wipe
 .          * any persistent memory, free any temporary memory, and set all fields back to their
 .          * defaults.
 .          */
 .         int s2n_connection_wipe(struct s2n_connection *conn)
18 (0.0%)  {
 .             /* First make a copy of everything we'd like to save, which isn't very much. */
 6 (0.0%)      int mode = conn->mode;
 6 (0.0%)      struct s2n_config *config = conn->config;
 8 (0.0%)      struct s2n_stuffer alert_in = { 0 };
 8 (0.0%)      struct s2n_stuffer client_ticket_to_decrypt = { 0 };
 8 (0.0%)      struct s2n_stuffer handshake_io = { 0 };
 8 (0.0%)      struct s2n_stuffer header_in = { 0 };
 8 (0.0%)      struct s2n_stuffer buffer_in = { 0 };
 8 (0.0%)      struct s2n_stuffer out = { 0 };
 .         
 .             /* Some required structures might have been freed to conserve memory between handshakes.
 .              * Restore them.
 .              */
 8 (0.0%)      if (!conn->handshake.hashes) {
 .                 POSIX_GUARD_RESULT(s2n_handshake_hashes_new(&conn->handshake.hashes));
 .             }
18 (0.0%)      POSIX_GUARD_RESULT(s2n_handshake_hashes_wipe(conn->handshake.hashes));
 6 (0.0%)      struct s2n_handshake_hashes *handshake_hashes = conn->handshake.hashes;
 8 (0.0%)      if (!conn->prf_space) {
 .                 POSIX_GUARD_RESULT(s2n_prf_new(conn));
 .             }
16 (0.0%)      POSIX_GUARD_RESULT(s2n_prf_wipe(conn));
 6 (0.0%)      struct s2n_prf_working_space *prf_workspace = conn->prf_space;
 8 (0.0%)      if (!conn->initial) {
 .                 POSIX_GUARD_RESULT(s2n_crypto_parameters_new(&conn->initial));
 .             } else {
18 (0.0%)          POSIX_GUARD_RESULT(s2n_crypto_parameters_wipe(conn->initial));
 .             }
 6 (0.0%)      struct s2n_crypto_parameters *initial = conn->initial;
 8 (0.0%)      if (!conn->secure) {
 .                 POSIX_GUARD_RESULT(s2n_crypto_parameters_new(&conn->secure));
 .             } else {
18 (0.0%)          POSIX_GUARD_RESULT(s2n_crypto_parameters_wipe(conn->secure));
 .             }
 6 (0.0%)      struct s2n_crypto_parameters *secure = conn->secure;
 .         
 .             /* Wipe all of the sensitive stuff */
10 (0.0%)      POSIX_GUARD(s2n_connection_wipe_keys(conn));
12 (0.0%)      POSIX_GUARD(s2n_stuffer_wipe(&conn->alert_in));
12 (0.0%)      POSIX_GUARD(s2n_stuffer_wipe(&conn->client_ticket_to_decrypt));
12 (0.0%)      POSIX_GUARD(s2n_stuffer_wipe(&conn->handshake.io));
12 (0.0%)      POSIX_GUARD(s2n_stuffer_wipe(&conn->post_handshake.in));
12 (0.0%)      POSIX_GUARD(s2n_blob_zero(&conn->client_hello.raw_message));
12 (0.0%)      POSIX_GUARD(s2n_stuffer_wipe(&conn->header_in));
12 (0.0%)      POSIX_GUARD(s2n_stuffer_wipe(&conn->buffer_in));
12 (0.0%)      POSIX_GUARD(s2n_stuffer_wipe(&conn->out));
 .         
 .             /* Free stuffers we plan to just recreate */
12 (0.0%)      POSIX_GUARD(s2n_stuffer_free(&conn->post_handshake.in));
12 (0.0%)      POSIX_GUARD(s2n_stuffer_free(&conn->in));
 .         
18 (0.0%)      POSIX_GUARD_RESULT(s2n_psk_parameters_wipe(&conn->psk_params));
 .         
 .             /* Wipe the I/O-related info and restore the original socket if necessary */
10 (0.0%)      POSIX_GUARD(s2n_connection_wipe_io(conn));
 .         
12 (0.0%)      POSIX_GUARD(s2n_free(&conn->client_ticket));
12 (0.0%)      POSIX_GUARD(s2n_free(&conn->status_response));
12 (0.0%)      POSIX_GUARD(s2n_free(&conn->application_protocols_overridden));
12 (0.0%)      POSIX_GUARD(s2n_free(&conn->our_quic_transport_parameters));
12 (0.0%)      POSIX_GUARD(s2n_free(&conn->peer_quic_transport_parameters));
12 (0.0%)      POSIX_GUARD(s2n_free(&conn->server_early_data_context));
12 (0.0%)      POSIX_GUARD(s2n_free(&conn->tls13_ticket_fields.session_secret));
12 (0.0%)      POSIX_GUARD(s2n_free(&conn->cookie));
 .         
 .             /* Allocate memory for handling handshakes */
14 (0.0%)      POSIX_GUARD(s2n_stuffer_resize(&conn->handshake.io, S2N_LARGE_RECORD_LENGTH));
 .         
 .             /* Truncate the message buffers to save memory, we will dynamically resize it as needed */
12 (0.0%)      POSIX_GUARD(s2n_free(&conn->client_hello.raw_message));
14 (0.0%)      POSIX_GUARD(s2n_stuffer_resize(&conn->buffer_in, 0));
14 (0.0%)      POSIX_GUARD(s2n_stuffer_resize(&conn->out, 0));
 .         
 .             /* Remove context associated with connection */
 4 (0.0%)      conn->context = NULL;
 4 (0.0%)      conn->verify_host_fn_overridden = 0;
 4 (0.0%)      conn->verify_host_fn = NULL;
 4 (0.0%)      conn->data_for_verify_host = NULL;
 .         
 .             /* Clone the stuffers */
 .             /* ignore address warnings because dest is allocated on the stack */
 .         #ifdef S2N_DIAGNOSTICS_PUSH_SUPPORTED
 .             #pragma GCC diagnostic push
 .             #pragma GCC diagnostic ignored "-Waddress"
 .         #endif
32 (0.0%)      POSIX_CHECKED_MEMCPY(&alert_in, &conn->alert_in, sizeof(struct s2n_stuffer));
32 (0.0%)      POSIX_CHECKED_MEMCPY(&client_ticket_to_decrypt, &conn->client_ticket_to_decrypt, sizeof(struct s2n_stuffer));
32 (0.0%)      POSIX_CHECKED_MEMCPY(&handshake_io, &conn->handshake.io, sizeof(struct s2n_stuffer));
32 (0.0%)      POSIX_CHECKED_MEMCPY(&header_in, &conn->header_in, sizeof(struct s2n_stuffer));
32 (0.0%)      POSIX_CHECKED_MEMCPY(&buffer_in, &conn->buffer_in, sizeof(struct s2n_stuffer));
32 (0.0%)      POSIX_CHECKED_MEMCPY(&out, &conn->out, sizeof(struct s2n_stuffer));
 .         #ifdef S2N_DIAGNOSTICS_POP_SUPPORTED
 .             #pragma GCC diagnostic pop
 .         #endif
 .         
16 (0.0%)      POSIX_GUARD(s2n_connection_zero(conn, mode, config));
 .         
32 (0.0%)      POSIX_CHECKED_MEMCPY(&conn->alert_in, &alert_in, sizeof(struct s2n_stuffer));
32 (0.0%)      POSIX_CHECKED_MEMCPY(&conn->client_ticket_to_decrypt, &client_ticket_to_decrypt, sizeof(struct s2n_stuffer));
32 (0.0%)      POSIX_CHECKED_MEMCPY(&conn->handshake.io, &handshake_io, sizeof(struct s2n_stuffer));
32 (0.0%)      POSIX_CHECKED_MEMCPY(&conn->header_in, &header_in, sizeof(struct s2n_stuffer));
32 (0.0%)      POSIX_CHECKED_MEMCPY(&conn->buffer_in, &buffer_in, sizeof(struct s2n_stuffer));
32 (0.0%)      POSIX_CHECKED_MEMCPY(&conn->out, &out, sizeof(struct s2n_stuffer));
 .         
 .             /* conn->in will eventually point to part of conn->buffer_in, but we initialize
 .              * it as growable and allocated to support legacy tests.
 .              */
14 (0.0%)      POSIX_GUARD(s2n_stuffer_growable_alloc(&conn->in, 0));
 .         
 6 (0.0%)      conn->handshake.hashes = handshake_hashes;
 6 (0.0%)      conn->prf_space = prf_workspace;
 6 (0.0%)      conn->initial = initial;
 6 (0.0%)      conn->secure = secure;
 8 (0.0%)      conn->client = conn->initial;
 8 (0.0%)      conn->server = conn->initial;
 6 (0.0%)      conn->handshake_params.client_cert_sig_scheme = &s2n_null_sig_scheme;
 6 (0.0%)      conn->handshake_params.server_cert_sig_scheme = &s2n_null_sig_scheme;
 .         
18 (0.0%)      POSIX_GUARD_RESULT(s2n_psk_parameters_init(&conn->psk_params));
 4 (0.0%)      conn->server_keying_material_lifetime = ONE_WEEK_IN_SEC;
 .         
 .             /* Require all handshakes hashes. This set can be reduced as the handshake progresses. */
12 (0.0%)      POSIX_GUARD(s2n_handshake_require_all_hashes(&conn->handshake));
 .         
 8 (0.0%)      if (conn->mode == S2N_SERVER) {
 .                 /* Start with the highest protocol version so that the highest common protocol version can be selected */
 .                 /* during handshake. */
 4 (0.0%)          conn->server_protocol_version = s2n_highest_protocol_version;
 4 (0.0%)          conn->client_protocol_version = s2n_unknown_protocol_version;
 5 (0.0%)          conn->actual_protocol_version = s2n_unknown_protocol_version;
 .             } else {
 .                 /* For clients, also set actual_protocol_version.  Record generation uses that value for the initial */
 .                 /* ClientHello record version. Not all servers ignore the record version in ClientHello. */
 4 (0.0%)          conn->server_protocol_version = s2n_unknown_protocol_version;
 4 (0.0%)          conn->client_protocol_version = s2n_highest_protocol_version;
 4 (0.0%)          conn->actual_protocol_version = s2n_highest_protocol_version;
 .             }
 .         
 .             /* Initialize remaining values */
 4 (0.0%)      conn->blinding = S2N_BUILT_IN_BLINDING;
 4 (0.0%)      conn->session_ticket_status = S2N_NO_TICKET;
 .         
 2 (0.0%)      return 0;
12 (0.0%)  }
 .         
 .         int s2n_connection_set_recv_ctx(struct s2n_connection *conn, void *ctx)
 .         {
 .             POSIX_ENSURE_REF(conn);
 .             POSIX_GUARD(s2n_connection_free_managed_recv_io(conn));
 .             conn->recv_io_context = ctx;
 .             return S2N_SUCCESS;
 .         }
-- line 617 ----------------------------------------
-- line 757 ----------------------------------------
 .             }
 .         
 .             POSIX_ENSURE_REF(*protocol_preferences);
 .             return 0;
 .         }
 .         
 .         static S2N_RESULT s2n_connection_and_config_get_client_auth_type(const struct s2n_connection *conn,
 .                 const struct s2n_config *config, s2n_cert_auth_type *client_cert_auth_type)
16 (0.0%)  {
 4 (0.0%)      RESULT_ENSURE_REF(conn);
 4 (0.0%)      RESULT_ENSURE_REF(config);
 4 (0.0%)      RESULT_ENSURE_REF(client_cert_auth_type);
 .         
 8 (0.0%)      if (conn->client_cert_auth_type_overridden) {
 .                 *client_cert_auth_type = conn->client_cert_auth_type;
 8 (0.0%)      } else if (config->client_cert_auth_type_overridden) {
 .                 *client_cert_auth_type = config->client_cert_auth_type;
 8 (0.0%)      } else if (conn->mode == S2N_CLIENT) {
 .                 /* Clients should default to "Optional" so that they handle any
 .                  * CertificateRequests sent by the server.
 .                  */
 3 (0.0%)          *client_cert_auth_type = S2N_CERT_AUTH_OPTIONAL;
 .             } else {
 .                 /* Servers should default to "None" so that they send no CertificateRequests. */
 2 (0.0%)          *client_cert_auth_type = S2N_CERT_AUTH_NONE;
 .             }
 .         
 2 (0.0%)      return S2N_RESULT_OK;
 6 (0.0%)  }
 .         
 .         int s2n_connection_get_client_auth_type(struct s2n_connection *conn,
 .                 s2n_cert_auth_type *client_cert_auth_type)
 .         {
 .             POSIX_ENSURE_REF(conn);
 .             POSIX_GUARD_RESULT(s2n_connection_and_config_get_client_auth_type(
 .                     conn, conn->config, client_cert_auth_type));
 .             return S2N_SUCCESS;
-- line 793 ----------------------------------------
-- line 1427 ----------------------------------------
 .             }
 .             POSIX_ENSURE(w >= 0, S2N_ERR_SEND_STUFFER_TO_CONN);
 .         
 .             POSIX_GUARD(s2n_stuffer_skip_read(stuffer, w));
 .             return w;
 .         }
 .         
 .         int s2n_connection_is_managed_corked(const struct s2n_connection *s2n_connection)
24 (0.0%)  {
 8 (0.0%)      POSIX_ENSURE_REF(s2n_connection);
 .         
24 (0.0%)      return (s2n_connection->managed_send_io && s2n_connection->corked_io);
12 (0.0%)  }
 .         
 .         const uint8_t *s2n_connection_get_sct_list(struct s2n_connection *conn, uint32_t *length)
 .         {
 .             if (!length) {
 .                 return NULL;
 .             }
 .         
 .             *length = conn->ct_response.size;
-- line 1447 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/tls/s2n_crypto.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 45 ----------------------------------------
    .             RESULT_GUARD(s2n_crypto_parameters_wipe(params));
    .         
    .             *new_params = params;
    .             ZERO_TO_DISABLE_DEFER_CLEANUP(params);
    .             return S2N_RESULT_OK;
    .         }
    .         
    .         S2N_RESULT s2n_crypto_parameters_wipe(struct s2n_crypto_parameters *params)
   36 (0.0%)  {
    8 (0.0%)      RESULT_ENSURE_REF(params);
    .         
    .             /* Wipe the hmacs for reuse */
  612 (0.1%)      struct s2n_hmac_state client_state = params->client_record_mac;
  612 (0.1%)      struct s2n_hmac_state server_state = params->server_record_mac;
   32 (0.0%)      RESULT_GUARD_POSIX(s2n_hmac_init(&client_state, S2N_HMAC_NONE, NULL, 0));
   32 (0.0%)      RESULT_GUARD_POSIX(s2n_hmac_init(&server_state, S2N_HMAC_NONE, NULL, 0));
    .         
    .             /* Wipe the keys for reuse */
   20 (0.0%)      struct s2n_session_key client_key = params->client_key;
   20 (0.0%)      struct s2n_session_key server_key = params->server_key;
   16 (0.0%)      if (params->cipher_suite
   20 (0.0%)              && params->cipher_suite->record_alg
   24 (0.0%)              && params->cipher_suite->record_alg->cipher
   28 (0.0%)              && params->cipher_suite->record_alg->cipher->destroy_key) {
   44 (0.0%)          RESULT_GUARD_POSIX(params->cipher_suite->record_alg->cipher->destroy_key(&params->client_key));
   44 (0.0%)          RESULT_GUARD_POSIX(params->cipher_suite->record_alg->cipher->destroy_key(&params->server_key));
    .             }
    .         
1,240 (0.2%)      *params = (struct s2n_crypto_parameters){ 0 };
    .         
  612 (0.1%)      params->client_record_mac = client_state;
  612 (0.1%)      params->server_record_mac = server_state;
   20 (0.0%)      params->client_key = client_key;
   20 (0.0%)      params->server_key = server_key;
   12 (0.0%)      params->cipher_suite = &s2n_null_cipher_suite;
    4 (0.0%)      return S2N_RESULT_OK;
   24 (0.0%)  }
    .         
    .         S2N_CLEANUP_RESULT s2n_crypto_parameters_free(struct s2n_crypto_parameters **params)
    .         {
    .             if (params == NULL || *params == NULL) {
    .                 return S2N_RESULT_OK;
    .             }
    .         
    .             /* Free HMAC states */
-- line 89 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 19 ----------------------------------------
    .         #include <string.h>
    .         #include <sys/param.h>
    .         
    .         #include "api/s2n.h"
    .         #include "error/s2n_errno.h"
    .         #include "utils/s2n_safety.h"
    .         
    .         S2N_RESULT s2n_blob_validate(const struct s2n_blob *b)
1,212 (0.2%)  {
  404 (0.1%)      RESULT_ENSURE_REF(b);
2,471 (0.4%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->data == NULL, b->size == 0), S2N_ERR_SAFETY);
2,471 (0.4%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->data == NULL, b->allocated == 0), S2N_ERR_SAFETY);
2,757 (0.4%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->growable == 0, b->allocated == 0), S2N_ERR_SAFETY);
1,967 (0.3%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->growable != 0, b->size <= b->allocated), S2N_ERR_SAFETY);
1,687 (0.3%)      RESULT_DEBUG_ENSURE(S2N_MEM_IS_READABLE(b->data, b->allocated), S2N_ERR_SAFETY);
1,771 (0.3%)      RESULT_DEBUG_ENSURE(S2N_MEM_IS_READABLE(b->data, b->size), S2N_ERR_SAFETY);
  202 (0.0%)      return S2N_RESULT_OK;
  606 (0.1%)  }
    .         
    .         int s2n_blob_init(struct s2n_blob *b, uint8_t *data, uint32_t size)
    .         {
    .             POSIX_ENSURE_REF(b);
    .             POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_SAFETY);
    .             *b = (struct s2n_blob){ .data = data, .size = size, .allocated = 0, .growable = 0 };
    .             POSIX_POSTCONDITION(s2n_blob_validate(b));
    .             return S2N_SUCCESS;
    .         }
    .         
    .         int s2n_blob_zero(struct s2n_blob *b)
  324 (0.0%)  {
  810 (0.1%)      POSIX_PRECONDITION(s2n_blob_validate(b));
  708 (0.1%)      POSIX_CHECKED_MEMSET(b->data, 0, MAX(b->allocated, b->size));
  810 (0.1%)      POSIX_POSTCONDITION(s2n_blob_validate(b));
   54 (0.0%)      return S2N_SUCCESS;
  162 (0.0%)  }
    .         
    .         int s2n_blob_slice(const struct s2n_blob *b, struct s2n_blob *slice, uint32_t offset, uint32_t size)
    .         {
    .             POSIX_PRECONDITION(s2n_blob_validate(b));
    .             POSIX_PRECONDITION(s2n_blob_validate(slice));
    .         
    .             uint32_t slice_size = 0;
    .             POSIX_GUARD(s2n_add_overflow(offset, size, &slice_size));
-- line 61 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_ensure.c
--------------------------------------------------------------------------------
Ir________ 

-- line 11 ----------------------------------------
  .          * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
  .          * express or implied. See the License for the specific language governing
  .          * permissions and limitations under the License.
  .          */
  .         
  .         #include "utils/s2n_safety.h"
  .         
  .         void *s2n_ensure_memmove_trace(void *to, const void *from, size_t size)
272 (0.0%)  {
 68 (0.0%)      PTR_ENSURE_REF(to);
 68 (0.0%)      PTR_ENSURE_REF(from);
  .         
  .             /* use memmove instead of memcpy since it'll handle overlapping regions and not result in UB */
238 (0.0%)      void *result = memmove(to, from, size);
 68 (0.0%)      PTR_ENSURE_REF(result);
 34 (0.0%)      return result;
102 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_mem.c
--------------------------------------------------------------------------------
Ir________ 

-- line 168 ----------------------------------------
  .             *mem_cleanup_callback = s2n_mem_cleanup_cb;
  .             *mem_malloc_callback = s2n_mem_malloc_cb;
  .             *mem_free_callback = s2n_mem_free_cb;
  .         
  .             return S2N_RESULT_OK;
  .         }
  .         
  .         int s2n_alloc(struct s2n_blob *b, uint32_t size)
 14 (0.0%)  {
  8 (0.0%)      POSIX_ENSURE(initialized, S2N_ERR_NOT_INITIALIZED);
  4 (0.0%)      POSIX_ENSURE_REF(b);
  6 (0.0%)      const struct s2n_blob temp = { 0 };
 14 (0.0%)      *b = temp;
 14 (0.0%)      POSIX_GUARD(s2n_realloc(b, size));
  2 (0.0%)      return S2N_SUCCESS;
  6 (0.0%)  }
  .         
  .         /* A blob is growable if it is either explicitly marked as such, or if it contains no data */
  .         bool s2n_blob_is_growable(const struct s2n_blob *b)
168 (0.0%)  {
864 (0.1%)      return b && (b->growable || (b->data == NULL && b->size == 0 && b->allocated == 0));
 84 (0.0%)  }
  .         
  .         /* Tries to realloc the requested bytes.
  .          * If successful, updates *b.
  .          * If failed, *b remains unchanged
  .          */
  .         int s2n_realloc(struct s2n_blob *b, uint32_t size)
 80 (0.0%)  {
 32 (0.0%)      POSIX_ENSURE(initialized, S2N_ERR_NOT_INITIALIZED);
 16 (0.0%)      POSIX_ENSURE_REF(b);
 48 (0.0%)      POSIX_ENSURE(s2n_blob_is_growable(b), S2N_ERR_RESIZE_STATIC_BLOB);
 16 (0.0%)      if (size == 0) {
 24 (0.0%)          return s2n_free(b);
  .             }
  .         
  .             /* blob already has space for the request */
  8 (0.0%)      if (size <= b->allocated) {
  .                 if (size < b->size) {
  .                     /* Zero the existing blob memory before the we release it */
  .                     struct s2n_blob slice = { 0 };
  .                     POSIX_GUARD(s2n_blob_slice(b, &slice, size, b->size - size));
  .                     POSIX_GUARD(s2n_blob_zero(&slice));
  .                 }
  .         
  .                 b->size = size;
  .                 return S2N_SUCCESS;
  .             }
  .         
 14 (0.0%)      struct s2n_blob new_memory = { .data = NULL, .size = size, .allocated = 0, .growable = 1 };
 20 (0.0%)      if (s2n_mem_malloc_cb((void **) &new_memory.data, new_memory.size, &new_memory.allocated) != 0) {
  .                 S2N_ERROR_PRESERVE_ERRNO();
  .             }
  .         
  8 (0.0%)      POSIX_ENSURE(new_memory.allocated >= new_memory.size, S2N_ERR_ALLOC);
  6 (0.0%)      POSIX_ENSURE(new_memory.data != NULL, S2N_ERR_ALLOC);
  .         
  8 (0.0%)      if (b->size) {
  .                 POSIX_CHECKED_MEMCPY(new_memory.data, b->data, b->size);
  .             }
  .         
  8 (0.0%)      if (b->allocated) {
  .                 POSIX_GUARD(s2n_free(b));
  .             }
  .         
 14 (0.0%)      *b = new_memory;
  2 (0.0%)      return S2N_SUCCESS;
 48 (0.0%)  }
  .         
  .         int s2n_free_object(uint8_t **p_data, uint32_t size)
  .         {
  .             POSIX_ENSURE_REF(p_data);
  .         
  .             if (*p_data == NULL) {
  .                 return S2N_SUCCESS;
  .             }
-- line 243 ----------------------------------------
-- line 294 ----------------------------------------
  .             POSIX_ENSURE(s2n_mem_cleanup_cb() >= S2N_SUCCESS, S2N_ERR_CANCELLED);
  .         
  .             initialized = false;
  .         
  .             return S2N_SUCCESS;
  .         }
  .         
  .         int s2n_free(struct s2n_blob *b)
170 (0.0%)  {
  .             /* To avoid memory leaks, don't exit the function until the memory
  .                has been freed */
136 (0.0%)      int zero_rc = s2n_blob_zero(b);
170 (0.0%)      POSIX_GUARD(s2n_free_without_wipe(b));
 34 (0.0%)      return zero_rc;
 68 (0.0%)  }
  .         
  .         int s2n_free_without_wipe(struct s2n_blob *b)
204 (0.0%)  {
510 (0.1%)      POSIX_PRECONDITION(s2n_blob_validate(b));
  .         
136 (0.0%)      POSIX_ENSURE(initialized, S2N_ERR_NOT_INITIALIZED);
204 (0.0%)      POSIX_ENSURE(s2n_blob_is_growable(b), S2N_ERR_FREE_STATIC_BLOB);
  .         
136 (0.0%)      if (b->data) {
 50 (0.0%)          POSIX_ENSURE(s2n_mem_free_cb(b->data, b->allocated) >= S2N_SUCCESS, S2N_ERR_CANCELLED);
  .             }
  .         
136 (0.0%)      *b = (struct s2n_blob){ 0 };
  .         
 34 (0.0%)      return S2N_SUCCESS;
102 (0.0%)  }
  .         
  .         int s2n_free_or_wipe(struct s2n_blob *b)
108 (0.0%)  {
 36 (0.0%)      POSIX_ENSURE_REF(b);
 72 (0.0%)      int zero_rc = s2n_blob_zero(b);
 72 (0.0%)      if (b->allocated) {
  .                 POSIX_GUARD(s2n_free_without_wipe(b));
  .             }
 18 (0.0%)      return zero_rc;
 54 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 79 ----------------------------------------
    .         #include "utils/s2n_result.h"
    .         
    .         #include <stdbool.h>
    .         
    .         #include "api/s2n.h"
    .         
    .         /* returns true when the result is S2N_RESULT_OK */
    .         inline bool s2n_result_is_ok(s2n_result result)
2,720 (0.4%)  {
2,040 (0.3%)      return result.__error_signal == S2N_SUCCESS;
1,360 (0.2%)  }
    .         
    .         /* returns true when the result is S2N_RESULT_ERROR */
    .         inline bool s2n_result_is_error(s2n_result result)
    .         {
    .             return result.__error_signal == S2N_FAILURE;
    .         }
    .         
    .         /* ignores the returned result of a function */
-- line 97 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir_____________ 

 96,285 (14.7%)    annotated: files known & above threshold & readable, line numbers known
      0            annotated: files known & above threshold & readable, line numbers unknown
      0          unannotated: files known & above threshold & two or more non-identical
528,911 (80.6%)  unannotated: files known & above threshold & unreadable 
 29,755  (4.5%)  unannotated: files known & below threshold
  1,238  (0.2%)  unannotated: files unknown

