--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate cachegrind.out.144312
Command:          target/debug/create_cert
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir__________________ 

154,967,248 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir_______________________  file:function

< 72,660,230 (46.9%, 46.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont5.S:
  55,770,284 (36.0%)           aws_lc_0_19_0_bn_sqr8x_internal
  15,699,024 (10.1%)           mul4x_internal
   1,114,840  (0.7%)           __bn_post4x_internal

< 28,964,663 (18.7%, 65.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h:
  11,547,690  (7.5%)           constant_time_select_w
   8,798,240  (5.7%)           value_barrier_w
   3,062,976  (2.0%)           constant_time_select_int
   1,626,305  (1.0%)           constant_time_lt_w
   1,340,850  (0.9%)           constant_time_is_zero_w
   1,340,080  (0.9%)           constant_time_msb_w
   1,052,293  (0.7%)           constant_time_eq_w

< 13,659,473  (8.8%, 74.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c:
   9,759,036  (6.3%)           aws_lc_0_19_0_bn_rshift1_words
   3,005,463  (1.9%)           aws_lc_0_19_0_bn_rshift_words
     303,186  (0.2%)           aws_lc_0_19_0_bn_is_bit_set_words
     233,220  (0.2%)           aws_lc_0_19_0_BN_is_bit_set
     225,498  (0.1%)           aws_lc_0_19_0_BN_rshift1

< 10,820,287  (7.0%, 81.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c:
   8,461,816  (5.5%)           aws_lc_0_19_0_bn_select_words
   1,298,663  (0.8%)           aws_lc_0_19_0_bn_fits_in_words
     486,225  (0.3%)           aws_lc_0_19_0_bn_minimal_width
     296,992  (0.2%)           aws_lc_0_19_0_bn_set_minimal_width
     266,503  (0.2%)           aws_lc_0_19_0_bn_wexpand

<  8,753,652  (5.6%, 87.0%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c:
   4,849,844  (3.1%)           aws_lc_0_19_0_bn_add_words
   3,149,314  (2.0%)           aws_lc_0_19_0_bn_sub_words
     514,080  (0.3%)           aws_lc_0_19_0_bn_mul_add_words
     182,364  (0.1%)           aws_lc_0_19_0_bn_mul_words

<  4,747,996  (3.1%, 90.1%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c:
   2,949,394  (1.9%)           s2n_stuffer_validate
     589,475  (0.4%)           s2n_stuffer_write_bytes
     520,020  (0.3%)           s2n_stuffer_skip_write
     468,018  (0.3%)           s2n_stuffer_reserve_space

<  4,490,372  (2.9%, 93.0%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/cmp.c:
   4,295,162  (2.8%)           bn_cmp_words_consttime

<  3,767,963  (2.4%, 95.4%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c:
   3,761,010  (2.4%)           s2n_blob_validate

<  1,424,466  (0.9%, 96.3%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c:s2n_result_is_ok

<  1,121,446  (0.7%, 97.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/div.c:
     776,197  (0.5%)           aws_lc_0_19_0_bn_div_consttime
     325,080  (0.2%)           aws_lc_0_19_0_bn_reduce_once_in_place

<    887,736  (0.6%, 97.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont.S:
     837,276  (0.5%)           bn_mul4x_mont

<    823,808  (0.5%, 98.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/add.c:
     458,140  (0.3%)           aws_lc_0_19_0_bn_uadd_consttime
     181,690  (0.1%)           aws_lc_0_19_0_bn_usub_consttime

<    323,127  (0.2%, 98.4%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_base64.c:
     217,557  (0.1%)           s2n_stuffer_read_base64

<    308,170  (0.2%, 98.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/gcd.c:
     308,090  (0.2%)           aws_lc_0_19_0_BN_mod_inverse_odd

<    290,169  (0.2%, 98.8%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_pem.c:
     288,970  (0.2%)           s2n_stuffer_pem_read_contents

<    216,900  (0.1%, 98.9%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_ensure.c:s2n_ensure_memmove_trace

<    169,627  (0.1%, 99.0%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:
     169,085  (0.1%)           __memcpy_avx_unaligned_erms

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir_______________________  function:file

> 55,770,284 (36.0%, 36.0%)  aws_lc_0_19_0_bn_sqr8x_internal:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont5.S

> 15,699,024 (10.1%, 46.1%)  mul4x_internal:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont5.S

> 11,547,690  (7.5%, 53.6%)  constant_time_select_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>  9,759,036  (6.3%, 59.9%)  aws_lc_0_19_0_bn_rshift1_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c

>  8,798,240  (5.7%, 65.5%)  value_barrier_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>  8,461,816  (5.5%, 71.0%)  aws_lc_0_19_0_bn_select_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c

>  4,849,844  (3.1%, 74.1%)  aws_lc_0_19_0_bn_add_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c

>  4,295,162  (2.8%, 76.9%)  bn_cmp_words_consttime:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/cmp.c

>  3,761,010  (2.4%, 79.3%)  s2n_blob_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c

>  3,149,314  (2.0%, 81.4%)  aws_lc_0_19_0_bn_sub_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c

>  3,062,976  (2.0%, 83.3%)  constant_time_select_int:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>  3,005,463  (1.9%, 85.3%)  aws_lc_0_19_0_bn_rshift_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c

>  2,949,394  (1.9%, 87.2%)  s2n_stuffer_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>  1,626,305  (1.0%, 88.2%)  constant_time_lt_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>  1,424,466  (0.9%, 89.2%)  s2n_result_is_ok:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c

>  1,340,850  (0.9%, 90.0%)  constant_time_is_zero_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>  1,340,080  (0.9%, 90.9%)  constant_time_msb_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>  1,298,663  (0.8%, 91.7%)  aws_lc_0_19_0_bn_fits_in_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c

>  1,114,840  (0.7%, 92.4%)  __bn_post4x_internal:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont5.S

>  1,052,293  (0.7%, 93.1%)  constant_time_eq_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    837,276  (0.5%, 93.7%)  bn_mul4x_mont:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont.S

>    776,197  (0.5%, 94.2%)  aws_lc_0_19_0_bn_div_consttime:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/div.c

>    589,475  (0.4%, 94.5%)  s2n_stuffer_write_bytes:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    520,020  (0.3%, 94.9%)  s2n_stuffer_skip_write:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    514,080  (0.3%, 95.2%)  aws_lc_0_19_0_bn_mul_add_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c

>    486,225  (0.3%, 95.5%)  aws_lc_0_19_0_bn_minimal_width:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c

>    468,018  (0.3%, 95.8%)  s2n_stuffer_reserve_space:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    458,140  (0.3%, 96.1%)  aws_lc_0_19_0_bn_uadd_consttime:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/add.c

>    325,080  (0.2%, 96.3%)  aws_lc_0_19_0_bn_reduce_once_in_place:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/div.c

>    308,090  (0.2%, 96.5%)  aws_lc_0_19_0_BN_mod_inverse_odd:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/gcd.c

>    303,186  (0.2%, 96.7%)  aws_lc_0_19_0_bn_is_bit_set_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c

>    296,992  (0.2%, 96.9%)  aws_lc_0_19_0_bn_set_minimal_width:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c

>    288,970  (0.2%, 97.1%)  s2n_stuffer_pem_read_contents:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_pem.c

>    266,503  (0.2%, 97.3%)  aws_lc_0_19_0_bn_wexpand:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c

>    233,220  (0.2%, 97.4%)  aws_lc_0_19_0_BN_is_bit_set:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c

>    225,498  (0.1%, 97.6%)  aws_lc_0_19_0_BN_rshift1:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c

>    217,557  (0.1%, 97.7%)  s2n_stuffer_read_base64:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_base64.c

>    216,900  (0.1%, 97.9%)  s2n_ensure_memmove_trace:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_ensure.c

>    182,364  (0.1%, 98.0%)  aws_lc_0_19_0_bn_mul_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c

>    181,690  (0.1%, 98.1%)  aws_lc_0_19_0_bn_usub_consttime:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/add.c

>    169,085  (0.1%, 98.2%)  __memcpy_avx_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h
--------------------------------------------------------------------------------
Ir______________ 

-- line 235 ----------------------------------------
        .         
        .         typedef uint8_t stack_align_type;
        .         OPENSSL_STATIC_ASSERT(sizeof(stack_align_type) == 1,
        .                               stack_align_type_is_not_8_bits_long)
        .         
        .         // align_pointer returns |ptr|, advanced to |alignment|. |alignment| must be a
        .         // power of two, and |ptr| must have at least |alignment - 1| bytes of scratch
        .         // space.
       10 (0.0%)  static inline void *align_pointer(void *ptr, size_t alignment) {
        .           // |alignment| must be a power of two.
       14 (0.0%)    assert(alignment != 0 && (alignment & (alignment - 1)) == 0);
        .           // Instead of aligning |ptr| as a |uintptr_t| and casting back, compute the
        .           // offset and advance in pointer space. C guarantees that casting from pointer
        .           // to |uintptr_t| and back gives the same pointer, but general
        .           // integer-to-pointer conversions are implementation-defined. GCC does define
        .           // it in the useful way, but this makes fewer assumptions.
       14 (0.0%)    uintptr_t offset = (0u - (uintptr_t)ptr) & (alignment - 1);
        4 (0.0%)    ptr = (char *)ptr + offset;
       12 (0.0%)    assert(((uintptr_t)ptr & (alignment - 1)) == 0);
        2 (0.0%)    return ptr;
        4 (0.0%)  }
        .         
        .         
        .         // Constant-time utility functions.
        .         //
        .         // The following methods return a bitmask of all ones (0xff...f) for true and 0
        .         // for false. This is useful for choosing a value based on the result of a
        .         // conditional in constant time. For example,
        .         //
-- line 263 ----------------------------------------
-- line 293 ----------------------------------------
        .         
        .         // value_barrier_w returns |a|, but prevents GCC and Clang from reasoning about
        .         // the returned value. This is used to mitigate compilers undoing constant-time
        .         // code, until we can express our requirements directly in the language.
        .         //
        .         // Note the compiler is aware that |value_barrier_w| has no side effects and
        .         // always has the same output for a given input. This allows it to eliminate
        .         // dead code, move computations across loops, and vectorize.
3,299,340 (2.1%)  static inline crypto_word_t value_barrier_w(crypto_word_t a) {
        .         #if defined(__GNUC__) || defined(__clang__)
2,199,560 (1.4%)    __asm__("" : "+r"(a) : /* no inputs */);
        .         #endif
1,099,780 (0.7%)    return a;
2,199,560 (1.4%)  }
        .         
        .         // value_barrier_u32 behaves like |value_barrier_w| but takes a |uint32_t|.
       12 (0.0%)  static inline uint32_t value_barrier_u32(uint32_t a) {
        .         #if defined(__GNUC__) || defined(__clang__)
        8 (0.0%)    __asm__("" : "+r"(a) : /* no inputs */);
        .         #endif
        4 (0.0%)    return a;
        8 (0.0%)  }
        .         
        .         // value_barrier_u64 behaves like |value_barrier_w| but takes a |uint64_t|.
        .         static inline uint64_t value_barrier_u64(uint64_t a) {
        .         #if defined(__GNUC__) || defined(__clang__)
        .           __asm__("" : "+r"(a) : /* no inputs */);
        .         #endif
        .           return a;
        .         }
        .         
        .         // constant_time_msb_w returns the given value with the MSB copied to all the
        .         // other bits.
  574,320 (0.4%)  static inline crypto_word_t constant_time_msb_w(crypto_word_t a) {
  382,880 (0.2%)    return 0u - (a >> (sizeof(a) * 8 - 1));
  382,880 (0.2%)  }
        .         
        .         // constant_time_lt_w returns 0xff..f if a < b and 0 otherwise.
        .         static inline crypto_word_t constant_time_lt_w(crypto_word_t a,
  478,325 (0.3%)                                                 crypto_word_t b) {
        .           // Consider the two cases of the problem:
        .           //   msb(a) == msb(b): a < b iff the MSB of a - b is set.
        .           //   msb(a) != msb(b): a < b iff the MSB of b is set.
        .           //
        .           // If msb(a) == msb(b) then the following evaluates as:
        .           //   msb(a^((a^b)|((a-b)^a))) ==
        .           //   msb(a^((a-b) ^ a))       ==   (because msb(a^b) == 0)
        .           //   msb(a^a^(a-b))           ==   (rearranging)
-- line 340 ----------------------------------------
-- line 355 ----------------------------------------
        .           // )
        .           //
        .           // (declare-fun a () (_ BitVec 32))
        .           // (declare-fun b () (_ BitVec 32))
        .           //
        .           // (assert (not (= (= #x00000001 (bvlshr (lt a b) #x0000001f)) (bvult a b))))
        .           // (check-sat)
        .           // (get-model)
  956,650 (0.6%)    return constant_time_msb_w(a^((a^b)|((a-b)^a)));
  191,330 (0.1%)  }
        .         
        .         // constant_time_lt_8 acts like |constant_time_lt_w| but returns an 8-bit
        .         // mask.
        .         static inline uint8_t constant_time_lt_8(crypto_word_t a, crypto_word_t b) {
        .           return (uint8_t)(constant_time_lt_w(a, b));
        .         }
        .         
        .         // constant_time_ge_w returns 0xff..f if a >= b and 0 otherwise.
-- line 372 ----------------------------------------
-- line 377 ----------------------------------------
        .         
        .         // constant_time_ge_8 acts like |constant_time_ge_w| but returns an 8-bit
        .         // mask.
        .         static inline uint8_t constant_time_ge_8(crypto_word_t a, crypto_word_t b) {
        .           return (uint8_t)(constant_time_ge_w(a, b));
        .         }
        .         
        .         // constant_time_is_zero returns 0xff..f if a == 0 and 0 otherwise.
  383,100 (0.2%)  static inline crypto_word_t constant_time_is_zero_w(crypto_word_t a) {
        .           // Here is an SMT-LIB verification of this formula:
        .           //
        .           // (define-fun is_zero ((a (_ BitVec 32))) (_ BitVec 32)
        .           //   (bvand (bvnot a) (bvsub a #x00000001))
        .           // )
        .           //
        .           // (declare-fun a () (_ BitVec 32))
        .           //
        .           // (assert (not (= (= #x00000001 (bvlshr (is_zero a) #x0000001f)) (= a #x00000000))))
        .           // (check-sat)
        .           // (get-model)
  766,200 (0.5%)    return constant_time_msb_w(~a & (a - 1));
  191,550 (0.1%)  }
        .         
        .         // constant_time_is_zero_8 acts like |constant_time_is_zero_w| but returns an
        .         // 8-bit mask.
        .         static inline uint8_t constant_time_is_zero_8(crypto_word_t a) {
        .           return (uint8_t)(constant_time_is_zero_w(a));
        .         }
        .         
        .         // constant_time_eq_w returns 0xff..f if a == b and 0 otherwise.
        .         static inline crypto_word_t constant_time_eq_w(crypto_word_t a,
  478,315 (0.3%)                                                 crypto_word_t b) {
  382,652 (0.2%)    return constant_time_is_zero_w(a ^ b);
  191,326 (0.1%)  }
        .         
        .         // constant_time_eq_8 acts like |constant_time_eq_w| but returns an 8-bit
        .         // mask.
        .         static inline uint8_t constant_time_eq_8(crypto_word_t a, crypto_word_t b) {
        .           return (uint8_t)(constant_time_eq_w(a, b));
        .         }
        .         
        .         // constant_time_eq_int acts like |constant_time_eq_w| but works on int
-- line 418 ----------------------------------------
-- line 427 ----------------------------------------
        .           return constant_time_eq_8((crypto_word_t)(a), (crypto_word_t)(b));
        .         }
        .         
        .         // constant_time_select_w returns (mask & a) | (~mask & b). When |mask| is all
        .         // 1s or all 0s (as returned by the methods above), the select methods return
        .         // either |a| (if |mask| is nonzero) or |b| (if |mask| is zero).
        .         static inline crypto_word_t constant_time_select_w(crypto_word_t mask,
        .                                                            crypto_word_t a,
3,849,230 (2.5%)                                                     crypto_word_t b) {
        .           // Clang recognizes this pattern as a select. While it usually transforms it
        .           // to a cmov, it sometimes further transforms it into a branch, which we do
        .           // not want.
        .           //
        .           // Adding barriers to both |mask| and |~mask| breaks the relationship between
        .           // the two, which makes the compiler stick with bitmasks.
6,048,790 (3.9%)    return (value_barrier_w(mask) & a) | (value_barrier_w(~mask) & b);
1,649,670 (1.1%)  }
        .         
        .         // constant_time_select_8 acts like |constant_time_select| but operates on
        .         // 8-bit values.
        .         static inline uint8_t constant_time_select_8(uint8_t mask, uint8_t a,
        .                                                      uint8_t b) {
        .           return (uint8_t)(constant_time_select_w(mask, a, b));
        .         }
        .         
        .         // constant_time_select_int acts like |constant_time_select| but operates on
        .         // ints.
1,148,616 (0.7%)  static inline int constant_time_select_int(crypto_word_t mask, int a, int b) {
1,531,488 (1.0%)    return (int)(constant_time_select_w(mask, (crypto_word_t)(a),
        .                                               (crypto_word_t)(b)));
  382,872 (0.2%)  }
        .         
        .         #if defined(BORINGSSL_CONSTANT_TIME_VALIDATION)
        .         
        .         // CONSTTIME_SECRET takes a pointer and a number of bytes and marks that region
        .         // of memory as secret. Secret data is tracked as it flows to registers and
        .         // other parts of a memory. If secret data is used as a condition for a branch,
        .         // or as a memory index, it will trigger warnings in valgrind.
        .         #define CONSTTIME_SECRET(ptr, len) VALGRIND_MAKE_MEM_UNDEFINED(ptr, len)
-- line 465 ----------------------------------------
-- line 487 ----------------------------------------
        .           // significantly impact optimizations.
        .           //
        .           // Thus, to be safe, stick a value barrier, in hopes of comparably inhibiting
        .           // compiler analysis.
        .           CONSTTIME_DECLASSIFY(&v, sizeof(v));
        .           return value_barrier_w(v);
        .         }
        .         
       16 (0.0%)  static inline int constant_time_declassify_int(int v) {
        .           OPENSSL_STATIC_ASSERT(sizeof(uint32_t) == sizeof(int),
        .                         int_is_not_the_same_size_as_uint32_t);
        .           // See comment above.
        .           CONSTTIME_DECLASSIFY(&v, sizeof(v));
       12 (0.0%)    return value_barrier_u32(v);
        8 (0.0%)  }
        .         
        .         
        .         // Thread-safe initialisation.
        .         
        .         #if !defined(OPENSSL_THREADS)
        .         typedef uint32_t CRYPTO_once_t;
        .         #define CRYPTO_ONCE_INIT 0
        .         #elif defined(OPENSSL_WINDOWS_THREADS)
-- line 509 ----------------------------------------
-- line 800 ----------------------------------------
        .         static inline uint64_t CRYPTO_bswap8(uint64_t x) {
        .           return _byteswap_uint64(x);
        .         }
        .         #else
        .         static inline uint16_t CRYPTO_bswap2(uint16_t x) {
        .           return (x >> 8) | (x << 8);
        .         }
        .         
    3,516 (0.0%)  static inline uint32_t CRYPTO_bswap4(uint32_t x) {
    1,172 (0.0%)    x = (x >> 16) | (x << 16);
   10,548 (0.0%)    x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);
    1,172 (0.0%)    return x;
    2,344 (0.0%)  }
        .         
    2,720 (0.0%)  static inline uint64_t CRYPTO_bswap8(uint64_t x) {
    5,984 (0.0%)    return CRYPTO_bswap4(x >> 32) | (((uint64_t)CRYPTO_bswap4(x)) << 32);
    1,632 (0.0%)  }
        .         #endif
        .         
        .         
        .         // Language bug workarounds.
        .         //
        .         // Most C standard library functions are undefined if passed NULL, even when the
        .         // corresponding length is zero. This gives them (and, in turn, all functions
        .         // which call them) surprising behavior on empty arrays. Some compilers will
-- line 824 ----------------------------------------
-- line 848 ----------------------------------------
        .           }
        .         
        .           return memchr(s, c, n);
        .         }
        .         
        .         }  // extern "C++"
        .         #else  // __cplusplus
        .         
        6 (0.0%)  static inline void *OPENSSL_memchr(const void *s, int c, size_t n) {
        2 (0.0%)    if (n == 0) {
        2 (0.0%)      return NULL;
        .           }
        .         
        .           return memchr(s, c, n);
        2 (0.0%)  }
        .         
        .         #endif  // __cplusplus
        .         
        .         static inline int OPENSSL_memcmp(const void *s1, const void *s2, size_t n) {
        .           if (n == 0) {
        .             return 0;
        .           }
        .         
        .           return memcmp(s1, s2, n);
        .         }
        .         
    9,252 (0.0%)  static inline void *OPENSSL_memcpy(void *dst, const void *src, size_t n) {
    3,084 (0.0%)    if (n == 0) {
       98 (0.0%)      return dst;
        .           }
        .         
    8,958 (0.0%)    return memcpy(dst, src, n);
    3,084 (0.0%)  }
        .         
       12 (0.0%)  static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
        4 (0.0%)    if (n == 0) {
        .             return dst;
        .           }
        .         
       12 (0.0%)    return memmove(dst, src, n);
        4 (0.0%)  }
        .         
   17,958 (0.0%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
    5,986 (0.0%)    if (n == 0) {
    5,876 (0.0%)      return dst;
        .           }
        .         
      330 (0.0%)    return memset(dst, c, n);
    5,986 (0.0%)  }
        .         
        .         
        .         // Loads and stores.
        .         //
        .         // The following functions load and store sized integers with the specified
        .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
        .         // requirements on the input and output pointers.
        .         
-- line 904 ----------------------------------------
-- line 949 ----------------------------------------
        .         static inline void CRYPTO_store_u32_le(void *out, uint32_t v) {
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           v = CRYPTO_bswap4(v);
        .         #endif
        .           OPENSSL_memcpy(out, &v, sizeof(v));
        .         
        .         }
        .         
      224 (0.0%)  static inline uint32_t CRYPTO_load_u32_be(const void *in) {
        .           uint32_t v;
      192 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           return v;
        .         #else
       96 (0.0%)    return CRYPTO_bswap4(v);
        .         #endif
      160 (0.0%)  }
        .         
      260 (0.0%)  static inline void CRYPTO_store_u32_be(void *out, uint32_t v) {
        .         
        .         #if !defined(OPENSSL_BIG_ENDIAN)
      208 (0.0%)    v = CRYPTO_bswap4(v);
        .         #endif
      312 (0.0%)    OPENSSL_memcpy(out, &v, sizeof(v));
        .         
      156 (0.0%)  }
        .         
        .         static inline uint64_t CRYPTO_load_u64_le(const void *in) {
        .           uint64_t v;
        .           OPENSSL_memcpy(&v, in, sizeof(v));
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           return CRYPTO_bswap8(v);
        .         #else
        .           return v;
-- line 982 ----------------------------------------
-- line 1026 ----------------------------------------
        .         
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           v = CRYPTO_bswap_word(v);
        .         #endif
        .           OPENSSL_memcpy(out, &v, sizeof(v));
        .         
        .         }
        .         
    3,808 (0.0%)  static inline crypto_word_t CRYPTO_load_word_be(const void *in) {
        .           crypto_word_t v;
    3,264 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           return v;
        .         #else
        .         #if defined(OPENSSL_64_BIT)
        .           assert(sizeof(v) == 8);
    1,632 (0.0%)    return CRYPTO_bswap8(v);
        .         #else
        .           assert(sizeof(v) == 4);
        .           return CRYPTO_bswap4(v);
        .         #endif
        .         #endif
    2,720 (0.0%)  }
        .         
        .         // Bit rotation functions.
        .         //
        .         // Note these functions use |(-shift) & 31|, etc., because shifting by the bit
        .         // width is undefined. Both Clang and GCC recognize this pattern as a rotation,
        .         // but MSVC does not. Instead, we call MSVC's built-in functions.
        .         
        .         static inline uint32_t CRYPTO_rotl_u32(uint32_t value, int shift) {
-- line 1056 ----------------------------------------
-- line 1122 ----------------------------------------
        .           assert(carry <= 1);
        .           uint64_t ret = carry;
        .           ret += (uint64_t)x + y;
        .           *out_carry = (uint32_t)(ret >> 32);
        .           return (uint32_t)ret;
        .         }
        .         
        .         static inline uint64_t CRYPTO_addc_u64(uint64_t x, uint64_t y, uint64_t carry,
   20,432 (0.0%)                                         uint64_t *out_carry) {
    5,108 (0.0%)    assert(carry <= 1);
        .         #if defined(BORINGSSL_HAS_UINT128)
    7,662 (0.0%)    uint128_t ret = carry;
   20,432 (0.0%)    ret += (uint128_t)x + y;
   17,878 (0.0%)    *out_carry = (uint64_t)(ret >> 64);
    2,554 (0.0%)    return (uint64_t)ret;
        .         #else
        .           x += carry;
        .           carry = x < carry;
        .           uint64_t ret = x + y;
        .           carry += ret < x;
        .           *out_carry = carry;
        .           return ret;
        .         #endif
    7,662 (0.0%)  }
        .         #endif
        .         
        .         // CRYPTO_subc_* returns |x - y - borrow|, and sets |*out_borrow| to the borrow
        .         // bit. |borrow| must be zero or one.
        .         #if OPENSSL_HAS_BUILTIN(__builtin_subc)
        .         
        .         #define CRYPTO_GENERIC_SUBC(x, y, borrow, out_borrow) \
        .           (_Generic((x),                                      \
-- line 1153 ----------------------------------------
-- line 1173 ----------------------------------------
        .                                                uint32_t *out_borrow) {
        .           assert(borrow <= 1);
        .           uint32_t ret = x - y - borrow;
        .           *out_borrow = (x < y) | ((x == y) & borrow);
        .           return ret;
        .         }
        .         
        .         static inline uint64_t CRYPTO_subc_u64(uint64_t x, uint64_t y, uint64_t borrow,
    2,898 (0.0%)                                         uint64_t *out_borrow) {
      828 (0.0%)    assert(borrow <= 1);
    1,656 (0.0%)    uint64_t ret = x - y - borrow;
    4,968 (0.0%)    *out_borrow = (x < y) | ((x == y) & borrow);
      414 (0.0%)    return ret;
      828 (0.0%)  }
        .         #endif
        .         
        .         #if defined(OPENSSL_64_BIT)
        .         #define CRYPTO_addc_w CRYPTO_addc_u64
        .         #define CRYPTO_subc_w CRYPTO_subc_u64
        .         #else
        .         #define CRYPTO_addc_w CRYPTO_addc_u32
        .         #define CRYPTO_subc_w CRYPTO_subc_u32
-- line 1194 ----------------------------------------
-- line 1235 ----------------------------------------
        .         // run in this address space. If not, it runs it and crashes the address space
        .         // if unsuccessful.
        .         void boringssl_ensure_ffdh_self_test(void);
        .         
        .         #else
        .         
        .         // Outside of FIPS mode, the lazy tests are no-ops.
        .         
        5 (0.0%)  OPENSSL_INLINE void boringssl_ensure_rsa_self_test(void) {}
        .         OPENSSL_INLINE void boringssl_ensure_ecc_self_test(void) {}
        .         OPENSSL_INLINE void boringssl_ensure_ffdh_self_test(void) {}
        .         
        .         #endif  // FIPS
        .         
        .         // boringssl_self_test_sha256 performs a SHA-256 KAT.
        .         int boringssl_self_test_sha256(void);
        .         
-- line 1251 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/add.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 95 ----------------------------------------
     .             return 1;
     .           }
     .         
     .           ret = BN_uadd(r, a, b);
     .           r->neg = a_neg;
     .           return ret;
     .         }
     .         
64,328 (0.0%)  int bn_uadd_consttime(BIGNUM *r, const BIGNUM *a, const BIGNUM *b) {
     .           // Widths are public, so we normalize to make |a| the larger one.
35,088 (0.0%)    if (a->width < b->width) {
   578 (0.0%)      const BIGNUM *tmp = a;
   578 (0.0%)      a = b;
   578 (0.0%)      b = tmp;
     .           }
     .         
17,544 (0.0%)    int max = a->width;
17,544 (0.0%)    int min = b->width;
52,632 (0.0%)    if (!bn_wexpand(r, max + 1)) {
     .             return 0;
     .           }
23,392 (0.0%)    r->width = max + 1;
     .         
64,328 (0.0%)    BN_ULONG carry = bn_add_words(r->d, a->d, b->d, min);
45,304 (0.0%)    for (int i = min; i < max; i++) {
48,526 (0.0%)      r->d[i] = CRYPTO_addc_w(a->d[i], 0, carry, &carry);
     .           }
     .         
46,784 (0.0%)    r->d[max] = carry;
 5,848 (0.0%)    return 1;
35,088 (0.0%)  }
     .         
40,929 (0.0%)  int BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b) {
46,776 (0.0%)    if (!bn_uadd_consttime(r, a, b)) {
     .             return 0;
     .           }
17,541 (0.0%)    bn_set_minimal_width(r);
 5,847 (0.0%)    return 1;
11,694 (0.0%)  }
     .         
     .         int BN_add_word(BIGNUM *a, BN_ULONG w) {
     .           BN_ULONG l;
     .           int i;
     .         
     .           // degenerate case: w is zero
     .           if (!w) {
     .             return 1;
-- line 141 ----------------------------------------
-- line 167 ----------------------------------------
     .             }
     .             a->width++;
     .             a->d[i] = w;
     .           }
     .         
     .           return 1;
     .         }
     .         
     7 (0.0%)  int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b) {
     2 (0.0%)    int add = 0, neg = 0;
     .           const BIGNUM *tmp;
     .         
     .           //  a -  b	a-b
     .           //  a - -b	a+b
     .           // -a -  b	-(a+b)
     .           // -a - -b	b-a
     4 (0.0%)    if (a->neg) {
     .             if (b->neg) {
     .               tmp = a;
     .               a = b;
     .               b = tmp;
     .             } else {
     .               add = 1;
     .               neg = 1;
     .             }
     .           } else {
     4 (0.0%)      if (b->neg) {
     .               add = 1;
     .               neg = 0;
     .             }
     .           }
     .         
     2 (0.0%)    if (add) {
     .             if (!BN_uadd(r, a, b)) {
     .               return 0;
     .             }
     .         
     .             r->neg = neg;
     .             return 1;
     .           }
     .         
     7 (0.0%)    if (BN_ucmp(a, b) < 0) {
     .             if (!BN_usub(r, b, a)) {
     .               return 0;
     .             }
     .             r->neg = 1;
     .           } else {
     8 (0.0%)      if (!BN_usub(r, a, b)) {
     .               return 0;
     .             }
     2 (0.0%)      r->neg = 0;
     .           }
     .         
     1 (0.0%)    return 1;
     2 (0.0%)  }
     .         
32,054 (0.0%)  int bn_usub_consttime(BIGNUM *r, const BIGNUM *a, const BIGNUM *b) {
     .           // |b| may have more words than |a| given non-minimal inputs, but all words
     .           // beyond |a->width| must then be zero.
 8,742 (0.0%)    int b_width = b->width;
11,656 (0.0%)    if (b_width > a->width) {
     .             if (!bn_fits_in_words(b, a->width)) {
     .               OPENSSL_PUT_ERROR(BN, BN_R_ARG2_LT_ARG3);
     .               return 0;
     .             }
     .             b_width = a->width;
     .           }
     .         
26,226 (0.0%)    if (!bn_wexpand(r, a->width)) {
     .             return 0;
     .           }
     .         
32,054 (0.0%)    BN_ULONG borrow = bn_sub_words(r->d, a->d, b->d, b_width);
21,218 (0.0%)    for (int i = b_width; i < a->width; i++) {
 3,116 (0.0%)      r->d[i] = CRYPTO_subc_w(a->d[i], 0, borrow, &borrow);
     .           }
     .         
 8,742 (0.0%)    if (borrow) {
     .             OPENSSL_PUT_ERROR(BN, BN_R_ARG2_LT_ARG3);
     .             return 0;
     .           }
     .         
11,656 (0.0%)    r->width = a->width;
 5,828 (0.0%)    r->neg = 0;
 2,914 (0.0%)    return 1;
17,484 (0.0%)  }
     .         
20,384 (0.0%)  int BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b) {
23,296 (0.0%)    if (!bn_usub_consttime(r, a, b)) {
     .             return 0;
     .           }
 8,736 (0.0%)    bn_set_minimal_width(r);
 2,912 (0.0%)    return 1;
 5,824 (0.0%)  }
     .         
     .         int BN_sub_word(BIGNUM *a, BN_ULONG w) {
     .           int i;
     .         
     .           // degenerate case: w is zero
     .           if (!w) {
     .             return 1;
     .           }
-- line 268 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 90 ----------------------------------------
        .                     : "cc");                                                       \
        .             (r) = (carry);                                                         \
        .             (carry) = high;                                                        \
        .           } while (0)
        .         #undef sqr
        .         #define sqr(r0, r1, a) __asm__("mulq %2" : "=a"(r0), "=d"(r1) : "a"(a) : "cc");
        .         
        .         BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, size_t num,
    3,744 (0.0%)                            BN_ULONG w) {
      416 (0.0%)    BN_ULONG c1 = 0;
        .         
      832 (0.0%)    if (num == 0) {
        .             return (c1);
        .           }
        .         
   11,584 (0.0%)    while (num & ~3) {
  123,648 (0.1%)      mul_add(rp[0], ap[0], w, c1);
  118,272 (0.1%)      mul_add(rp[1], ap[1], w, c1);
  118,272 (0.1%)      mul_add(rp[2], ap[2], w, c1);
  118,272 (0.1%)      mul_add(rp[3], ap[3], w, c1);
    5,376 (0.0%)      ap += 4;
    5,376 (0.0%)      rp += 4;
    5,376 (0.0%)      num -= 4;
        .           }
      832 (0.0%)    if (num) {
        .             mul_add(rp[0], ap[0], w, c1);
        .             if (--num == 0) {
        .               return c1;
        .             }
        .             mul_add(rp[1], ap[1], w, c1);
        .             if (--num == 0) {
        .               return c1;
        .             }
        .             mul_add(rp[2], ap[2], w, c1);
        .             return c1;
        .           }
        .         
      416 (0.0%)    return c1;
    1,664 (0.0%)  }
        .         
        .         BN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, size_t num,
    1,206 (0.0%)                        BN_ULONG w) {
      134 (0.0%)    BN_ULONG c1 = 0;
        .         
      268 (0.0%)    if (num == 0) {
        .             return c1;
        .           }
        .         
    4,524 (0.0%)    while (num & ~3) {
   38,304 (0.0%)      mul(rp[0], ap[0], w, c1);
   42,560 (0.0%)      mul(rp[1], ap[1], w, c1);
   42,560 (0.0%)      mul(rp[2], ap[2], w, c1);
   42,560 (0.0%)      mul(rp[3], ap[3], w, c1);
    2,128 (0.0%)      ap += 4;
    2,128 (0.0%)      rp += 4;
    2,128 (0.0%)      num -= 4;
        .           }
      268 (0.0%)    if (num) {
    2,394 (0.0%)      mul(rp[0], ap[0], w, c1);
      399 (0.0%)      if (--num == 0) {
      266 (0.0%)        return c1;
        .             }
        .             mul(rp[1], ap[1], w, c1);
        .             if (--num == 0) {
        .               return c1;
        .             }
        .             mul(rp[2], ap[2], w, c1);
        .           }
        1 (0.0%)    return c1;
      536 (0.0%)  }
        .         
        .         void bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, size_t n) {
        .           if (n == 0) {
        .             return;
        .           }
        .         
        .           while (n & ~3) {
        .             sqr(r[0], r[1], a[0]);
-- line 167 ----------------------------------------
-- line 181 ----------------------------------------
        .             if (--n == 0) {
        .               return;
        .             }
        .             sqr(r[4], r[5], a[2]);
        .           }
        .         }
        .         
        .         BN_ULONG bn_add_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,
  117,131 (0.1%)                        size_t n) {
        .           BN_ULONG ret;
   16,733 (0.0%)    size_t i = 0;
        .         
   33,466 (0.0%)    if (n == 0) {
        2 (0.0%)      return 0;
        .           }
        .         
4,615,582 (3.0%)    __asm__ volatile (
        .               "	subq	%0,%0		\n"  // clear carry
        .               "	jmp	1f		\n"
        .               ".p2align 4			\n"
        .               "1:"
        .               "	movq	(%4,%2,8),%0	\n"
        .               "	adcq	(%5,%2,8),%0	\n"
        .               "	movq	%0,(%3,%2,8)	\n"
        .               "	lea	1(%2),%2	\n"
        .               "	dec	%1		\n"
        .               "	jnz	1b		\n"
        .               "	sbbq	%0,%0		\n"
        .               : "=&r"(ret), "+c"(n), "+r"(i)
        .               : "r"(rp), "r"(ap), "r"(bp)
        .               : "cc", "memory");
        .         
   33,464 (0.0%)    return ret & 1;
   33,466 (0.0%)  }
        .         
        .         BN_ULONG bn_sub_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,
   97,888 (0.1%)                        size_t n) {
        .           BN_ULONG ret;
   13,984 (0.0%)    size_t i = 0;
        .         
   27,968 (0.0%)    if (n == 0) {
        4 (0.0%)      return 0;
        .           }
        .         
2,953,538 (1.9%)    __asm__ volatile (
        .               "	subq	%0,%0		\n"  // clear borrow
        .               "	jmp	1f		\n"
        .               ".p2align 4			\n"
        .               "1:"
        .               "	movq	(%4,%2,8),%0	\n"
        .               "	sbbq	(%5,%2,8),%0	\n"
        .               "	movq	%0,(%3,%2,8)	\n"
        .               "	lea	1(%2),%2	\n"
        .               "	dec	%1		\n"
        .               "	jnz	1b		\n"
        .               "	sbbq	%0,%0		\n"
        .               : "=&r"(ret), "+c"(n), "+r"(i)
        .               : "r"(rp), "r"(ap), "r"(bp)
        .               : "cc", "memory");
        .         
   27,964 (0.0%)    return ret & 1;
   27,968 (0.0%)  }
        .         
        .         // mul_add_c(a,b,c0,c1,c2)  -- c+=a*b for three word number c=(c2,c1,c0)
        .         // mul_add_c2(a,b,c0,c1,c2) -- c+=2*a*b for three word number c=(c2,c1,c0)
        .         // sqr_add_c(a,i,c0,c1,c2)  -- c+=a[i]^2 for three word number c=(c2,c1,c0)
        .         // sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0)
        .         
        .         // Keep in mind that carrying into high part of multiplication result can not
        .         // overflow, because it cannot be all-ones.
-- line 250 ----------------------------------------
-- line 279 ----------------------------------------
        .             __asm__("addq %3,%0; adcq %4,%1; adcq %5,%2"                     \
        .                     : "+r"(c0), "+r"(c1), "+r"(c2)                           \
        .                     : "r"(t1), "r"(t2), "g"(0)                               \
        .                     : "cc");                                                 \
        .           } while (0)
        .         
        .         #define sqr_add_c2(a, i, j, c0, c1, c2) mul_add_c2((a)[i], (a)[j], c0, c1, c2)
        .         
      315 (0.0%)  void bn_mul_comba8(BN_ULONG r[16], const BN_ULONG a[8], const BN_ULONG b[8]) {
        .           BN_ULONG c1, c2, c3;
        .         
       45 (0.0%)    c1 = 0;
       45 (0.0%)    c2 = 0;
       45 (0.0%)    c3 = 0;
      765 (0.0%)    mul_add_c(a[0], b[0], c1, c2, c3);
      135 (0.0%)    r[0] = c1;
       45 (0.0%)    c1 = 0;
      810 (0.0%)    mul_add_c(a[0], b[1], c2, c3, c1);
      810 (0.0%)    mul_add_c(a[1], b[0], c2, c3, c1);
      180 (0.0%)    r[1] = c2;
       45 (0.0%)    c2 = 0;
      810 (0.0%)    mul_add_c(a[2], b[0], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[1], b[1], c3, c1, c2);
      810 (0.0%)    mul_add_c(a[0], b[2], c3, c1, c2);
      180 (0.0%)    r[2] = c3;
       45 (0.0%)    c3 = 0;
      810 (0.0%)    mul_add_c(a[0], b[3], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[1], b[2], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[2], b[1], c1, c2, c3);
      810 (0.0%)    mul_add_c(a[3], b[0], c1, c2, c3);
      180 (0.0%)    r[3] = c1;
       45 (0.0%)    c1 = 0;
      810 (0.0%)    mul_add_c(a[4], b[0], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[3], b[1], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[2], b[2], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[1], b[3], c2, c3, c1);
      810 (0.0%)    mul_add_c(a[0], b[4], c2, c3, c1);
      180 (0.0%)    r[4] = c2;
       45 (0.0%)    c2 = 0;
      810 (0.0%)    mul_add_c(a[0], b[5], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[1], b[4], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[2], b[3], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[3], b[2], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[4], b[1], c3, c1, c2);
      810 (0.0%)    mul_add_c(a[5], b[0], c3, c1, c2);
      180 (0.0%)    r[5] = c3;
       45 (0.0%)    c3 = 0;
      810 (0.0%)    mul_add_c(a[6], b[0], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[5], b[1], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[4], b[2], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[3], b[3], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[2], b[4], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[1], b[5], c1, c2, c3);
      810 (0.0%)    mul_add_c(a[0], b[6], c1, c2, c3);
      180 (0.0%)    r[6] = c1;
       45 (0.0%)    c1 = 0;
      810 (0.0%)    mul_add_c(a[0], b[7], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[1], b[6], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[2], b[5], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[3], b[4], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[4], b[3], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[5], b[2], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[6], b[1], c2, c3, c1);
      810 (0.0%)    mul_add_c(a[7], b[0], c2, c3, c1);
      180 (0.0%)    r[7] = c2;
       45 (0.0%)    c2 = 0;
      855 (0.0%)    mul_add_c(a[7], b[1], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[6], b[2], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[5], b[3], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[4], b[4], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[3], b[5], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[2], b[6], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[1], b[7], c3, c1, c2);
      180 (0.0%)    r[8] = c3;
       45 (0.0%)    c3 = 0;
      855 (0.0%)    mul_add_c(a[2], b[7], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[3], b[6], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[4], b[5], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[5], b[4], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[6], b[3], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[7], b[2], c1, c2, c3);
      180 (0.0%)    r[9] = c1;
       45 (0.0%)    c1 = 0;
      855 (0.0%)    mul_add_c(a[7], b[3], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[6], b[4], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[5], b[5], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[4], b[6], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[3], b[7], c2, c3, c1);
      180 (0.0%)    r[10] = c2;
       45 (0.0%)    c2 = 0;
      855 (0.0%)    mul_add_c(a[4], b[7], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[5], b[6], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[6], b[5], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[7], b[4], c3, c1, c2);
      180 (0.0%)    r[11] = c3;
       45 (0.0%)    c3 = 0;
      855 (0.0%)    mul_add_c(a[7], b[5], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[6], b[6], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[5], b[7], c1, c2, c3);
      180 (0.0%)    r[12] = c1;
       45 (0.0%)    c1 = 0;
      855 (0.0%)    mul_add_c(a[6], b[7], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[7], b[6], c2, c3, c1);
      180 (0.0%)    r[13] = c2;
       45 (0.0%)    c2 = 0;
      855 (0.0%)    mul_add_c(a[7], b[7], c3, c1, c2);
      180 (0.0%)    r[14] = c3;
      180 (0.0%)    r[15] = c1;
      135 (0.0%)  }
        .         
        .         void bn_mul_comba4(BN_ULONG r[8], const BN_ULONG a[4], const BN_ULONG b[4]) {
        .           BN_ULONG c1, c2, c3;
        .         
        .           c1 = 0;
        .           c2 = 0;
        .           c3 = 0;
        .           mul_add_c(a[0], b[0], c1, c2, c3);
-- line 395 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 66 ----------------------------------------
        .         #include "../delocate.h"
        .         
        .         
        .         // BN_MAX_WORDS is the maximum number of words allowed in a |BIGNUM|. It is
        .         // sized so byte and bit counts of a |BIGNUM| always fit in |int|, with room to
        .         // spare.
        .         #define BN_MAX_WORDS (INT_MAX / (4 * BN_BITS2))
        .         
      132 (0.0%)  BIGNUM *BN_new(void) {
       99 (0.0%)    BIGNUM *bn = OPENSSL_zalloc(sizeof(BIGNUM));
        .         
       66 (0.0%)    if (bn == NULL) {
        .             return NULL;
        .           }
        .         
       66 (0.0%)    bn->flags = BN_FLG_MALLOCED;
        .         
       33 (0.0%)    return bn;
       66 (0.0%)  }
        .         
        .         BIGNUM *BN_secure_new(void) { return BN_new(); }
        .         
       75 (0.0%)  void BN_init(BIGNUM *bn) {
       75 (0.0%)    OPENSSL_memset(bn, 0, sizeof(BIGNUM));
       45 (0.0%)  }
        .         
      180 (0.0%)  void BN_free(BIGNUM *bn) {
       72 (0.0%)    if (bn == NULL) {
       10 (0.0%)      return;
        .           }
        .         
      130 (0.0%)    if ((bn->flags & BN_FLG_STATIC_DATA) == 0) {
      104 (0.0%)      OPENSSL_free(bn->d);
        .           }
        .         
      130 (0.0%)    if (bn->flags & BN_FLG_MALLOCED) {
       68 (0.0%)      OPENSSL_free(bn);
        .           } else {
       27 (0.0%)      bn->d = NULL;
        .           }
       72 (0.0%)  }
        .         
        .         void BN_clear_free(BIGNUM *bn) {
        .           BN_free(bn);
        .         }
        .         
       15 (0.0%)  BIGNUM *BN_dup(const BIGNUM *src) {
        .           BIGNUM *copy;
        .         
        6 (0.0%)    if (src == NULL) {
        .             return NULL;
        .           }
        .         
        6 (0.0%)    copy = BN_new();
        6 (0.0%)    if (copy == NULL) {
        .             return NULL;
        .           }
        .         
       21 (0.0%)    if (!BN_copy(copy, src)) {
        .             BN_free(copy);
        .             return NULL;
        .           }
        .         
        3 (0.0%)    return copy;
        6 (0.0%)  }
        .         
      180 (0.0%)  BIGNUM *BN_copy(BIGNUM *dest, const BIGNUM *src) {
       90 (0.0%)    if (src == dest) {
       10 (0.0%)      return dest;
        .           }
        .         
      225 (0.0%)    if (!bn_wexpand(dest, src->width)) {
        .             return NULL;
        .           }
        .         
      275 (0.0%)    OPENSSL_memcpy(dest->d, src->d, sizeof(src->d[0]) * src->width);
        .         
      100 (0.0%)    dest->width = src->width;
      100 (0.0%)    dest->neg = src->neg;
       25 (0.0%)    return dest;
       60 (0.0%)  }
        .         
        .         void BN_clear(BIGNUM *bn) {
        .           if (bn->d != NULL) {
        .             OPENSSL_memset(bn->d, 0, bn->dmax * sizeof(bn->d[0]));
        .           }
        .         
        .           bn->width = 0;
        .           bn->neg = 0;
        .         }
        .         
       90 (0.0%)  DEFINE_METHOD_FUNCTION(BIGNUM, BN_value_one) {
        .           static const BN_ULONG kOneLimbs[1] = { 1 };
        3 (0.0%)    out->d = (BN_ULONG*) kOneLimbs;
        2 (0.0%)    out->width = 1;
        2 (0.0%)    out->dmax = 1;
        2 (0.0%)    out->neg = 0;
        2 (0.0%)    out->flags = BN_FLG_STATIC_DATA;
        3 (0.0%)  }
        .         
        .         // BN_num_bits_word returns the minimum number of bits needed to represent the
        .         // value in |l|.
      140 (0.0%)  unsigned BN_num_bits_word(BN_ULONG l) {
        .           // |BN_num_bits| is often called on RSA prime factors. These have public bit
        .           // lengths, but all bits beyond the high bit are secret, so count bits in
        .           // constant time.
        .           BN_ULONG x, mask;
      140 (0.0%)    int bits = (l != 0);
        .         
        .         #if BN_BITS2 > 32
        .           // Look at the upper half of |x|. |x| is at most 64 bits long.
      105 (0.0%)    x = l >> 32;
        .           // Set |mask| to all ones if |x| (the top 32 bits of |l|) is non-zero and all
        .           // all zeros otherwise.
      105 (0.0%)    mask = 0u - x;
      105 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
        .           // If |x| is non-zero, the lower half is included in the bit count in full,
        .           // and we count the upper half. Otherwise, we count the lower half.
      210 (0.0%)    bits += 32 & mask;
      140 (0.0%)    l ^= (x ^ l) & mask;  // |l| is |x| if |mask| and remains |l| otherwise.
        .         #endif
        .         
        .           // The remaining blocks are analogous iterations at lower powers of two.
      105 (0.0%)    x = l >> 16;
      105 (0.0%)    mask = 0u - x;
      105 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
      210 (0.0%)    bits += 16 & mask;
      140 (0.0%)    l ^= (x ^ l) & mask;
        .         
      105 (0.0%)    x = l >> 8;
      105 (0.0%)    mask = 0u - x;
      105 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
      210 (0.0%)    bits += 8 & mask;
      140 (0.0%)    l ^= (x ^ l) & mask;
        .         
      105 (0.0%)    x = l >> 4;
      105 (0.0%)    mask = 0u - x;
      105 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
      210 (0.0%)    bits += 4 & mask;
      140 (0.0%)    l ^= (x ^ l) & mask;
        .         
      105 (0.0%)    x = l >> 2;
      105 (0.0%)    mask = 0u - x;
      105 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
      210 (0.0%)    bits += 2 & mask;
      140 (0.0%)    l ^= (x ^ l) & mask;
        .         
      105 (0.0%)    x = l >> 1;
      105 (0.0%)    mask = 0u - x;
      105 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
      210 (0.0%)    bits += 1 & mask;
        .         
       35 (0.0%)    return bits;
       70 (0.0%)  }
        .         
      192 (0.0%)  unsigned BN_num_bits(const BIGNUM *bn) {
      128 (0.0%)    const int width = bn_minimal_width(bn);
       64 (0.0%)    if (width == 0) {
        .             return 0;
        .           }
        .         
      480 (0.0%)    return (width - 1) * BN_BITS2 + BN_num_bits_word(bn->d[width - 1]);
       96 (0.0%)  }
        .         
       45 (0.0%)  unsigned BN_num_bytes(const BIGNUM *bn) {
       45 (0.0%)    return (BN_num_bits(bn) + 7) / 8;
       18 (0.0%)  }
        .         
      224 (0.0%)  void BN_zero(BIGNUM *bn) {
      336 (0.0%)    bn->width = bn->neg = 0;
      168 (0.0%)  }
        .         
        5 (0.0%)  int BN_one(BIGNUM *bn) {
        4 (0.0%)    return BN_set_word(bn, 1);
        2 (0.0%)  }
        .         
        6 (0.0%)  int BN_set_word(BIGNUM *bn, BN_ULONG value) {
        2 (0.0%)    if (value == 0) {
        .             BN_zero(bn);
        .             return 1;
        .           }
        .         
        6 (0.0%)    if (!bn_wexpand(bn, 1)) {
        .             return 0;
        .           }
        .         
        2 (0.0%)    bn->neg = 0;
        4 (0.0%)    bn->d[0] = value;
        2 (0.0%)    bn->width = 1;
        1 (0.0%)    return 1;
        2 (0.0%)  }
        .         
        .         int BN_set_u64(BIGNUM *bn, uint64_t value) {
        .         #if BN_BITS2 == 64
        .           return BN_set_word(bn, value);
        .         #elif BN_BITS2 == 32
        .           if (value <= BN_MASK2) {
        .             return BN_set_word(bn, (BN_ULONG)value);
        .           }
-- line 264 ----------------------------------------
-- line 296 ----------------------------------------
        .         
        .           assert(num <= BN_MAX_WORDS);
        .           bn->width = (int)num;
        .           bn->dmax = (int)num;
        .           bn->neg = 0;
        .           bn->flags |= BN_FLG_STATIC_DATA;
        .         }
        .         
   14,735 (0.0%)  int bn_fits_in_words(const BIGNUM *bn, size_t num) {
        .           // All words beyond |num| must be zero.
    2,947 (0.0%)    BN_ULONG mask = 0;
  597,116 (0.4%)    for (size_t i = num; i < (size_t)bn->width; i++) {
  669,130 (0.4%)      mask |= bn->d[i];
        .           }
    8,841 (0.0%)    return mask == 0;
    5,894 (0.0%)  }
        .         
        .         int bn_copy_words(BN_ULONG *out, size_t num, const BIGNUM *bn) {
        .           if (bn->neg) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_NEGATIVE_NUMBER);
        .             return 0;
        .           }
        .         
        .           size_t width = (size_t)bn->width;
-- line 319 ----------------------------------------
-- line 325 ----------------------------------------
        .             width = num;
        .           }
        .         
        .           OPENSSL_memset(out, 0, sizeof(BN_ULONG) * num);
        .           OPENSSL_memcpy(out, bn->d, sizeof(BN_ULONG) * width);
        .           return 1;
        .         }
        .         
      148 (0.0%)  int BN_is_negative(const BIGNUM *bn) {
      185 (0.0%)    return bn->neg != 0;
       74 (0.0%)  }
        .         
        .         void BN_set_negative(BIGNUM *bn, int sign) {
        .           if (sign && !BN_is_zero(bn)) {
        .             bn->neg = 1;
        .           } else {
        .             bn->neg = 0;
        .           }
        .         }
        .         
  105,894 (0.1%)  int bn_wexpand(BIGNUM *bn, size_t words) {
        .           BN_ULONG *a;
        .         
   88,245 (0.1%)    if (words <= (size_t)bn->dmax) {
   35,194 (0.0%)      return 1;
        .           }
        .         
      104 (0.0%)    if (words > BN_MAX_WORDS) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_BIGNUM_TOO_LONG);
        .             return 0;
        .           }
        .         
      260 (0.0%)    if (bn->flags & BN_FLG_STATIC_DATA) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);
        .             return 0;
        .           }
        .         
      260 (0.0%)    a = OPENSSL_calloc(words, sizeof(BN_ULONG));
      104 (0.0%)    if (a == NULL) {
        .             return 0;
        .           }
        .         
      520 (0.0%)    OPENSSL_memcpy(a, bn->d, sizeof(BN_ULONG) * bn->width);
        .         
      208 (0.0%)    OPENSSL_free(bn->d);
      156 (0.0%)    bn->d = a;
      208 (0.0%)    bn->dmax = (int)words;
        .         
       52 (0.0%)    return 1;
   35,298 (0.0%)  }
        .         
        .         int bn_expand(BIGNUM *bn, size_t bits) {
        .           if (bits + BN_BITS2 - 1 < bits) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_BIGNUM_TOO_LONG);
        .             return 0;
        .           }
        .           return bn_wexpand(bn, (bits+BN_BITS2-1)/BN_BITS2);
        .         }
        .         
      138 (0.0%)  int bn_resize_words(BIGNUM *bn, size_t words) {
        .         #if defined(OPENSSL_PPC64LE)
        .           // This is a workaround for a miscompilation bug in Clang 7.0.1 on POWER.
        .           // The unittests catch the miscompilation, if it occurs, and it manifests
        .           // as a crash in |bn_fits_in_words|.
        .           //
        .           // The bug only triggers if building in FIPS mode and with -O3. Clang 8.0.1
        .           // has the same bug but this workaround is not effective there---I've not
        .           // been able to find a workaround for 8.0.1.
-- line 392 ----------------------------------------
-- line 394 ----------------------------------------
        .           // At the time of writing (2019-08-08), Clang git does *not* have this bug
        .           // and does not need this workaroud. The current git version should go on to
        .           // be Clang 10 thus, once we can depend on that, this can be removed.
        .           if (value_barrier_w((size_t)bn->width == words)) {
        .             return 1;
        .           }
        .         #endif
        .         
      115 (0.0%)    if ((size_t)bn->width <= words) {
      147 (0.0%)      if (!bn_wexpand(bn, words)) {
        .               return 0;
        .             }
      231 (0.0%)      OPENSSL_memset(bn->d + bn->width, 0,
      105 (0.0%)                     (words - bn->width) * sizeof(BN_ULONG));
       84 (0.0%)      bn->width = (int)words;
       42 (0.0%)      return 1;
        .           }
        .         
        .           // All words beyond the new width must be zero.
       14 (0.0%)    if (!bn_fits_in_words(bn, words)) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_BIGNUM_TOO_LONG);
        .             return 0;
        .           }
        8 (0.0%)    bn->width = (int)words;
        2 (0.0%)    return 1;
       46 (0.0%)  }
        .         
        .         void bn_select_words(BN_ULONG *r, BN_ULONG mask, const BN_ULONG *a,
  108,940 (0.1%)                       const BN_ULONG *b, size_t num) {
1,488,198 (1.0%)    for (size_t i = 0; i < num; i++) {
        .             OPENSSL_STATIC_ASSERT(sizeof(BN_ULONG) <= sizeof(crypto_word_t),
        .                                   crypto_word_t_is_too_small)
6,810,208 (4.4%)      r[i] = constant_time_select_w(mask, a[i], b[i]);
        .           }
   54,470 (0.0%)  }
        .         
   70,032 (0.0%)  int bn_minimal_width(const BIGNUM *bn) {
   52,524 (0.0%)    int ret = bn->width;
  304,718 (0.2%)    while (ret > 0 && bn->d[ret - 1] == 0) {
    6,427 (0.0%)      ret--;
        .           }
   17,508 (0.0%)    return ret;
   35,016 (0.0%)  }
        .         
   87,350 (0.1%)  void bn_set_minimal_width(BIGNUM *bn) {
   87,350 (0.1%)    bn->width = bn_minimal_width(bn);
   69,880 (0.0%)    if (bn->width == 0) {
        2 (0.0%)      bn->neg = 0;
        .           }
   52,410 (0.0%)  }
        .         
        .         int BN_get_flags(const BIGNUM *bn, int flags) {
        .           return bn->flags & flags;
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/cmp.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 59 ----------------------------------------
        .         #include <openssl/mem.h>
        .         #include <openssl/type_check.h>
        .         
        .         #include "internal.h"
        .         #include "../../internal.h"
        .         
        .         
        .         static int bn_cmp_words_consttime(const BN_ULONG *a, size_t a_len,
   23,480 (0.0%)                                    const BN_ULONG *b, size_t b_len) {
        .           OPENSSL_STATIC_ASSERT(sizeof(BN_ULONG) <= sizeof(crypto_word_t),
        .                                 crypto_word_t_is_too_small)
    2,935 (0.0%)    int ret = 0;
        .           // Process the common words in little-endian order.
   14,675 (0.0%)    size_t min = a_len < b_len ? a_len : b_len;
  397,327 (0.3%)    for (size_t i = 0; i < min; i++) {
1,339,282 (0.9%)      crypto_word_t eq = constant_time_eq_w(a[i], b[i]);
1,339,282 (0.9%)      crypto_word_t lt = constant_time_lt_w(a[i], b[i]);
        .             ret =
1,147,956 (0.7%)          constant_time_select_int(eq, ret, constant_time_select_int(lt, -1, 1));
        .           }
        .         
        .           // If |a| or |b| has non-zero words beyond |min|, they take precedence.
    8,805 (0.0%)    if (a_len < b_len) {
       45 (0.0%)      crypto_word_t mask = 0;
      698 (0.0%)      for (size_t i = a_len; i < b_len; i++) {
      642 (0.0%)        mask |= b[i];
        .             }
      495 (0.0%)      ret = constant_time_select_int(constant_time_is_zero_w(mask), ret, -1);
    8,670 (0.0%)    } else if (b_len < a_len) {
       65 (0.0%)      crypto_word_t mask = 0;
      774 (0.0%)      for (size_t i = b_len; i < a_len; i++) {
      576 (0.0%)        mask |= a[i];
        .             }
      650 (0.0%)      ret = constant_time_select_int(constant_time_is_zero_w(mask), ret, 1);
        .           }
        .         
    2,935 (0.0%)    return ret;
    5,870 (0.0%)  }
        .         
   17,598 (0.0%)  int BN_ucmp(const BIGNUM *a, const BIGNUM *b) {
   35,196 (0.0%)    return bn_cmp_words_consttime(a->d, a->width, b->d, b->width);
    5,866 (0.0%)  }
        .         
       60 (0.0%)  int BN_cmp(const BIGNUM *a, const BIGNUM *b) {
       40 (0.0%)    if ((a == NULL) || (b == NULL)) {
        .             if (a != NULL) {
        .               return -1;
        .             } else if (b != NULL) {
        .               return 1;
        .             } else {
        .               return 0;
        .             }
        .           }
        .         
        .           // We do not attempt to process the sign bit in constant time. Negative
        .           // |BIGNUM|s should never occur in crypto, only calculators.
       60 (0.0%)    if (a->neg != b->neg) {
        .             if (a->neg) {
        .               return -1;
        .             }
        .             return 1;
        .           }
        .         
       60 (0.0%)    int ret = BN_ucmp(a, b);
       50 (0.0%)    return a->neg ? -ret : ret;
       20 (0.0%)  }
        .         
       14 (0.0%)  int bn_less_than_words(const BN_ULONG *a, const BN_ULONG *b, size_t len) {
       16 (0.0%)    return bn_cmp_words_consttime(a, len, b, len) < 0;
        4 (0.0%)  }
        .         
       15 (0.0%)  int BN_abs_is_word(const BIGNUM *bn, BN_ULONG w) {
       12 (0.0%)    if (bn->width == 0) {
        .             return w == 0;
        .           }
       15 (0.0%)    BN_ULONG mask = bn->d[0] ^ w;
      338 (0.0%)    for (int i = 1; i < bn->width; i++) {
      512 (0.0%)      mask |= bn->d[i];
        .           }
        9 (0.0%)    return mask == 0;
        6 (0.0%)  }
        .         
        .         int BN_cmp_word(const BIGNUM *a, BN_ULONG b) {
        .           BIGNUM b_bn;
        .           BN_init(&b_bn);
        .         
        .           b_bn.d = &b;
        .           b_bn.width = b > 0;
        .           b_bn.dmax = 1;
        .           b_bn.flags = BN_FLG_STATIC_DATA;
        .           return BN_cmp(a, &b_bn);
        .         }
        .         
   14,670 (0.0%)  int BN_is_zero(const BIGNUM *bn) {
   11,736 (0.0%)    return bn_fits_in_words(bn, 0);
    5,868 (0.0%)  }
        .         
       15 (0.0%)  int BN_is_one(const BIGNUM *bn) {
       36 (0.0%)    return bn->neg == 0 && BN_abs_is_word(bn, 1);
        6 (0.0%)  }
        .         
        .         int BN_is_word(const BIGNUM *bn, BN_ULONG w) {
        .           return BN_abs_is_word(bn, w) && (w == 0 || bn->neg == 0);
        .         }
        .         
   23,224 (0.0%)  int BN_is_odd(const BIGNUM *bn) {
   66,826 (0.0%)    return bn->width > 0 && (bn->d[0] & 1) == 1;
   11,612 (0.0%)  }
        .         
        .         int BN_is_pow2(const BIGNUM *bn) {
        .           int width = bn_minimal_width(bn);
        .           if (width == 0 || bn->neg) {
        .             return 0;
        .           }
        .         
        .           for (int i = 0; i < width - 1; i++) {
-- line 174 ----------------------------------------
-- line 175 ----------------------------------------
        .             if (bn->d[i] != 0) {
        .               return 0;
        .             }
        .           }
        .         
        .           return 0 == (bn->d[width-1] & (bn->d[width-1] - 1));
        .         }
        .         
        5 (0.0%)  int BN_equal_consttime(const BIGNUM *a, const BIGNUM *b) {
        1 (0.0%)    BN_ULONG mask = 0;
        .           // If |a| or |b| has more words than the other, all those words must be zero.
        8 (0.0%)    for (int i = a->width; i < b->width; i++) {
        .             mask |= b->d[i];
        .           }
        8 (0.0%)    for (int i = b->width; i < a->width; i++) {
        .             mask |= a->d[i];
        .           }
        .           // Common words must match.
        7 (0.0%)    int min = a->width < b->width ? a->width : b->width;
      261 (0.0%)    for (int i = 0; i < min; i++) {
    1,024 (0.0%)      mask |= (a->d[i] ^ b->d[i]);
        .           }
        .           // The sign bit must match.
        7 (0.0%)    mask |= (a->neg ^ b->neg);
        3 (0.0%)    return mask == 0;
        2 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/div.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 132 ----------------------------------------
      .             l = (l & BN_MASK2l) << BN_BITS4;
      .           }
      .         
      .           ret |= q;
      .           return ret;
      .         }
      .         
      .         static inline void bn_div_rem_words(BN_ULONG *quotient_out, BN_ULONG *rem_out,
    924 (0.0%)                                      BN_ULONG n0, BN_ULONG n1, BN_ULONG d0) {
      .           // GCC and Clang generate function calls to |__udivdi3| and |__umoddi3| when
      .           // the |BN_ULLONG|-based C code is used.
      .           //
      .           // GCC bugs:
      .           //   * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=14224
      .           //   * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43721
      .           //   * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54183
      .           //   * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58897
-- line 148 ----------------------------------------
-- line 155 ----------------------------------------
      .           // These issues aren't specific to x86 and x86_64, so it might be worthwhile
      .           // to add more assembly language implementations.
      .         #if defined(BN_CAN_USE_INLINE_ASM) && defined(OPENSSL_X86)
      .           __asm__ volatile("divl %4"
      .                            : "=a"(*quotient_out), "=d"(*rem_out)
      .                            : "a"(n1), "d"(n0), "rm"(d0)
      .                            : "cc");
      .         #elif defined(BN_CAN_USE_INLINE_ASM) && defined(OPENSSL_X86_64)
  1,056 (0.0%)    __asm__ volatile("divq %4"
      .                            : "=a"(*quotient_out), "=d"(*rem_out)
      .                            : "a"(n1), "d"(n0), "rm"(d0)
      .                            : "cc");
      .         #else
      .         #if defined(BN_CAN_DIVIDE_ULLONG)
      .           BN_ULLONG n = (((BN_ULLONG)n0) << BN_BITS2) | n1;
      .           *quotient_out = (BN_ULONG)(n / d0);
      .         #else
      .           *quotient_out = bn_div_words(n0, n1, d0);
      .         #endif
      .           *rem_out = n1 - (*quotient_out * d0);
      .         #endif
    396 (0.0%)  }
      .         
      .         // BN_div computes "quotient := numerator / divisor", rounding towards zero,
      .         // and sets up |rem| such that "quotient * divisor + rem = numerator" holds.
      .         //
      .         // Thus:
      .         //
      .         //     quotient->neg == numerator->neg ^ divisor->neg
      .         //        (unless the result is zero)
-- line 184 ----------------------------------------
-- line 187 ----------------------------------------
      .         //
      .         // If |quotient| or |rem| is NULL, the respective value is not returned.
      .         //
      .         // This was specifically designed to contain fewer branches that may leak
      .         // sensitive information; see "New Branch Prediction Vulnerabilities in OpenSSL
      .         // and Necessary Software Countermeasures" by Onur Acıçmez, Shay Gueron, and
      .         // Jean-Pierre Seifert.
      .         int BN_div(BIGNUM *quotient, BIGNUM *rem, const BIGNUM *numerator,
     26 (0.0%)             const BIGNUM *divisor, BN_CTX *ctx) {
      .           int norm_shift, loop;
      .           BIGNUM wnum;
      .           BN_ULONG *resp, *wnump;
      .           BN_ULONG d0, d1;
      .           int num_n, div_n;
      .         
      .           // This function relies on the historical minimal-width |BIGNUM| invariant.
      .           // It is already not constant-time (constant-time reductions should use
      .           // Montgomery logic), so we shrink all inputs and intermediate values to
      .           // retain the previous behavior.
      .         
      .           // Invalid zero-padding would have particularly bad consequences.
      8 (0.0%)    int numerator_width = bn_minimal_width(numerator);
      8 (0.0%)    int divisor_width = bn_minimal_width(divisor);
     28 (0.0%)    if ((numerator_width > 0 && numerator->d[numerator_width - 1] == 0) ||
     20 (0.0%)        (divisor_width > 0 && divisor->d[divisor_width - 1] == 0)) {
      .             OPENSSL_PUT_ERROR(BN, BN_R_NOT_INITIALIZED);
      .             return 0;
      .           }
      .         
     10 (0.0%)    if (BN_is_zero(divisor)) {
      .             OPENSSL_PUT_ERROR(BN, BN_R_DIV_BY_ZERO);
      .             return 0;
      .           }
      .         
      6 (0.0%)    BN_CTX_start(ctx);
      8 (0.0%)    BIGNUM *tmp = BN_CTX_get(ctx);
      8 (0.0%)    BIGNUM *snum = BN_CTX_get(ctx);
      8 (0.0%)    BIGNUM *sdiv = BN_CTX_get(ctx);
      2 (0.0%)    BIGNUM *res = NULL;
      4 (0.0%)    if (quotient == NULL) {
     10 (0.0%)      res = BN_CTX_get(ctx);
      .           } else {
      .             res = quotient;
      .           }
      8 (0.0%)    if (sdiv == NULL || res == NULL) {
      .             goto err;
      .           }
      .         
      .           // First we normalise the numbers
     16 (0.0%)    norm_shift = BN_BITS2 - (BN_num_bits(divisor) % BN_BITS2);
     16 (0.0%)    if (!BN_lshift(sdiv, divisor, norm_shift)) {
      .             goto err;
      .           }
      6 (0.0%)    bn_set_minimal_width(sdiv);
      4 (0.0%)    sdiv->neg = 0;
      2 (0.0%)    norm_shift += BN_BITS2;
     16 (0.0%)    if (!BN_lshift(snum, numerator, norm_shift)) {
      .             goto err;
      .           }
      6 (0.0%)    bn_set_minimal_width(snum);
      4 (0.0%)    snum->neg = 0;
      .         
      .           // Since we don't want to have special-case logic for the case where snum is
      .           // larger than sdiv, we pad snum with enough zeroes without changing its
      .           // value.
     14 (0.0%)    if (snum->width <= sdiv->width + 1) {
      .             if (!bn_wexpand(snum, sdiv->width + 2)) {
      .               goto err;
      .             }
      .             for (int i = snum->width; i < sdiv->width + 2; i++) {
      .               snum->d[i] = 0;
      .             }
      .             snum->width = sdiv->width + 2;
      .           } else {
     20 (0.0%)      if (!bn_wexpand(snum, snum->width + 1)) {
      .               goto err;
      .             }
     16 (0.0%)      snum->d[snum->width] = 0;
     10 (0.0%)      snum->width++;
      .           }
      .         
      6 (0.0%)    div_n = sdiv->width;
      6 (0.0%)    num_n = snum->width;
      6 (0.0%)    loop = num_n - div_n;
      .           // Lets setup a 'window' into snum
      .           // This is the part that corresponds to the current
      .           // 'area' being divided
      2 (0.0%)    wnum.neg = 0;
     14 (0.0%)    wnum.d = &(snum->d[loop]);
      4 (0.0%)    wnum.width = div_n;
      .           // only needed when BN_ucmp messes up the values between width and max
      8 (0.0%)    wnum.dmax = snum->dmax - loop;  // so we don't step out of bounds
      .         
      .           // Get the top 2 words of sdiv
      .           // div_n=sdiv->width;
     18 (0.0%)    d0 = sdiv->d[div_n - 1];
     24 (0.0%)    d1 = (div_n == 1) ? 0 : sdiv->d[div_n - 2];
      .         
      .           // pointer to the 'top' of snum
     16 (0.0%)    wnump = &(snum->d[num_n - 1]);
      .         
      .           // Setup |res|. |numerator| and |res| may alias, so we save |numerator->neg|
      .           // for later.
      6 (0.0%)    const int numerator_neg = numerator->neg;
     12 (0.0%)    res->neg = (numerator_neg ^ divisor->neg);
     18 (0.0%)    if (!bn_wexpand(res, loop + 1)) {
      .             goto err;
      .           }
      8 (0.0%)    res->width = loop - 1;
     16 (0.0%)    resp = &(res->d[loop - 1]);
      .         
      .           // space for temp
     18 (0.0%)    if (!bn_wexpand(tmp, div_n + 1)) {
      .             goto err;
      .           }
      .         
      .           // if res->width == 0 then clear the neg value otherwise decrease
      .           // the resp pointer
      8 (0.0%)    if (res->width == 0) {
      .             res->neg = 0;
      .           } else {
      2 (0.0%)      resp--;
      .           }
      .         
    936 (0.0%)    for (int i = 0; i < loop - 1; i++, wnump--, resp--) {
      .             BN_ULONG q, l0;
      .             // the first part of the loop uses the top two words of snum and sdiv to
      .             // calculate a BN_ULONG q such that | wnum - sdiv * q | < sdiv
    132 (0.0%)      BN_ULONG n0, n1, rm = 0;
      .         
    396 (0.0%)      n0 = wnump[0];
    396 (0.0%)      n1 = wnump[-1];
    396 (0.0%)      if (n0 == d0) {
      .               q = BN_MASK2;
      .             } else {
      .               // n0 < d0
  1,056 (0.0%)        bn_div_rem_words(&q, &rm, n0, n1, d0);
      .         
      .         #ifdef BN_ULLONG
  2,244 (0.0%)        BN_ULLONG t2 = (BN_ULLONG)d1 * q;
      .               for (;;) {
  2,418 (0.0%)          if (t2 <= ((((BN_ULLONG)rm) << BN_BITS2) | wnump[-2])) {
    212 (0.0%)            break;
      .                 }
    132 (0.0%)          q--;
    176 (0.0%)          rm += d0;
    132 (0.0%)          if (rm < d0) {
     26 (0.0%)            break;  // don't let rm overflow
      .                 }
     72 (0.0%)          t2 -= d1;
      .               }
      .         #else  // !BN_ULLONG
      .               BN_ULONG t2l, t2h;
      .               BN_UMULT_LOHI(t2l, t2h, d1, q);
      .               for (;;) {
      .                 if (t2h < rm ||
      .                     (t2h == rm && t2l <= wnump[-2])) {
      .                   break;
-- line 344 ----------------------------------------
-- line 351 ----------------------------------------
      .                 if (t2l < d1) {
      .                   t2h--;
      .                 }
      .                 t2l -= d1;
      .               }
      .         #endif  // !BN_ULLONG
      .             }
      .         
  1,320 (0.0%)      l0 = bn_mul_words(tmp->d, sdiv->d, div_n, q);
  1,056 (0.0%)      tmp->d[div_n] = l0;
    396 (0.0%)      wnum.d--;
      .             // ingore top values of the bignums just sub the two
      .             // BN_ULONG arrays with bn_sub_words
  1,452 (0.0%)      if (bn_sub_words(wnum.d, wnum.d, tmp->d, div_n + 1)) {
      .               // Note: As we have considered only the leading
      .               // two BN_ULONGs in the calculation of q, sdiv * q
      .               // might be greater than wnum (but then (q-1) * sdiv
      .               // is less or equal than wnum)
      .               q--;
      .               if (bn_add_words(wnum.d, wnum.d, sdiv->d, div_n)) {
      .                 // we can't have an overflow here (assuming
      .                 // that q != 0, but if q == 0 then tmp is
      .                 // zero anyway)
      .                 (*wnump)++;
      .               }
      .             }
      .             // store part of the result
    396 (0.0%)      *resp = q;
      .           }
      .         
      6 (0.0%)    bn_set_minimal_width(snum);
      .         
      4 (0.0%)    if (rem != NULL) {
     16 (0.0%)      if (!BN_rshift(rem, snum, norm_shift)) {
      .               goto err;
      .             }
     10 (0.0%)      if (!BN_is_zero(rem)) {
      6 (0.0%)        rem->neg = numerator_neg;
      .             }
      .           }
      .         
      6 (0.0%)    bn_set_minimal_width(res);
      6 (0.0%)    BN_CTX_end(ctx);
      4 (0.0%)    return 1;
      .         
      .         err:
      .           BN_CTX_end(ctx);
      .           return 0;
     12 (0.0%)  }
      .         
      .         int BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx) {
      .           if (!(BN_mod(r, m, d, ctx))) {
      .             return 0;
      .           }
      .           if (!r->neg) {
      .             return 1;
      .           }
      .         
      .           // now -|d| < r < 0, so we have to set r := r + |d|.
      .           return (d->neg ? BN_sub : BN_add)(r, r, d);
      .         }
      .         
      .         BN_ULONG bn_reduce_once(BN_ULONG *r, const BN_ULONG *a, BN_ULONG carry,
     81 (0.0%)                          const BN_ULONG *m, size_t num) {
     27 (0.0%)    assert(r != a);
      .           // |r| = |a| - |m|. |bn_sub_words| performs the bulk of the subtraction, and
      .           // then we apply the borrow to |carry|.
     63 (0.0%)    carry -= bn_sub_words(r, a, m, num);
      .           // We know 0 <= |a| < 2*|m|, so -|m| <= |r| < |m|.
      .           //
      .           // If 0 <= |r| < |m|, |r| fits in |num| words and |carry| is zero. We then
      .           // wish to select |r| as the answer. Otherwise -m <= r < 0 and we wish to
      .           // return |r| + |m|, or |a|. |carry| must then be -1 or all ones. In both
      .           // cases, |carry| is a suitable input to |bn_select_words|.
      .           //
      .           // Although |carry| may be one if it was one on input and |bn_sub_words|
      .           // returns zero, this would give |r| > |m|, violating our input assumptions.
     36 (0.0%)    assert(carry == 0 || carry == (BN_ULONG)-1);
     72 (0.0%)    bn_select_words(r, carry, a /* r < 0 */, r /* r >= 0 */, num);
      9 (0.0%)    return carry;
     18 (0.0%)  }
      .         
      .         BN_ULONG bn_reduce_once_in_place(BN_ULONG *r, BN_ULONG carry, const BN_ULONG *m,
 97,362 (0.1%)                                   BN_ULONG *tmp, size_t num) {
      .           // See |bn_reduce_once| for why this logic works.
 75,726 (0.0%)    carry -= bn_sub_words(tmp, r, m, num);
 32,994 (0.0%)    assert(carry == 0 || carry == (BN_ULONG)-1);
 86,544 (0.1%)    bn_select_words(r, carry, r /* tmp < 0 */, tmp /* tmp >= 0 */, num);
 10,818 (0.0%)    return carry;
 21,636 (0.0%)  }
      .         
      .         void bn_mod_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,
     10 (0.0%)                        const BN_ULONG *m, BN_ULONG *tmp, size_t num) {
      .           // r = a - b
      7 (0.0%)    BN_ULONG borrow = bn_sub_words(r, a, b, num);
      .           // tmp = a - b + m
      6 (0.0%)    bn_add_words(tmp, r, m, num);
     10 (0.0%)    bn_select_words(r, 0 - borrow, tmp /* r < 0 */, r /* r >= 0 */, num);
      3 (0.0%)  }
      .         
      .         void bn_mod_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,
    660 (0.0%)                        const BN_ULONG *m, BN_ULONG *tmp, size_t num) {
    462 (0.0%)    BN_ULONG carry = bn_add_words(r, a, b, num);
    528 (0.0%)    bn_reduce_once_in_place(r, carry, m, tmp, num);
    198 (0.0%)  }
      .         
      .         int bn_div_consttime(BIGNUM *quotient, BIGNUM *remainder,
      .                              const BIGNUM *numerator, const BIGNUM *divisor,
     50 (0.0%)                       unsigned divisor_min_bits, BN_CTX *ctx) {
     50 (0.0%)    if (BN_is_negative(numerator) || BN_is_negative(divisor)) {
      .             OPENSSL_PUT_ERROR(BN, BN_R_NEGATIVE_NUMBER);
      .             return 0;
      .           }
     25 (0.0%)    if (BN_is_zero(divisor)) {
      .             OPENSSL_PUT_ERROR(BN, BN_R_DIV_BY_ZERO);
      .             return 0;
      .           }
      .         
      .           // This function implements long division in binary. It is not very efficient,
      .           // but it is simple, easy to make constant-time, and performant enough for RSA
      .           // key generation.
      .         
      5 (0.0%)    int ret = 0;
     15 (0.0%)    BN_CTX_start(ctx);
     20 (0.0%)    BIGNUM *q = quotient, *r = remainder;
     10 (0.0%)    if (quotient == NULL || quotient == numerator || quotient == divisor) {
     20 (0.0%)      q = BN_CTX_get(ctx);
      .           }
     34 (0.0%)    if (remainder == NULL || remainder == numerator || remainder == divisor) {
      8 (0.0%)      r = BN_CTX_get(ctx);
      .           }
     20 (0.0%)    BIGNUM *tmp = BN_CTX_get(ctx);
     40 (0.0%)    if (q == NULL || r == NULL || tmp == NULL ||
     45 (0.0%)        !bn_wexpand(q, numerator->width) ||
     45 (0.0%)        !bn_wexpand(r, divisor->width) ||
     35 (0.0%)        !bn_wexpand(tmp, divisor->width)) {
      .             goto err;
      .           }
      .         
     45 (0.0%)    OPENSSL_memset(q->d, 0, numerator->width * sizeof(BN_ULONG));
     20 (0.0%)    q->width = numerator->width;
     10 (0.0%)    q->neg = 0;
      .         
     45 (0.0%)    OPENSSL_memset(r->d, 0, divisor->width * sizeof(BN_ULONG));
     20 (0.0%)    r->width = divisor->width;
     10 (0.0%)    r->neg = 0;
      .         
      .           // Incorporate |numerator| into |r|, one bit at a time, reducing after each
      .           // step. We maintain the invariant that |0 <= r < divisor| and
      .           // |q * divisor + r = n| where |n| is the portion of |numerator| incorporated
      .           // so far.
      .           //
      .           // First, we short-circuit the loop: if we know |divisor| has at least
      .           // |divisor_min_bits| bits, the top |divisor_min_bits - 1| can be incorporated
      .           // without reductions. This significantly speeds up |RSA_check_key|. For
      .           // simplicity, we round down to a whole number of words.
     25 (0.0%)    assert(divisor_min_bits <= BN_num_bits(divisor));
      5 (0.0%)    int initial_words = 0;
     10 (0.0%)    if (divisor_min_bits > 0) {
     20 (0.0%)      initial_words = (divisor_min_bits - 1) / BN_BITS2;
     20 (0.0%)      if (initial_words > numerator->width) {
      .               initial_words = numerator->width;
      .             }
     90 (0.0%)      OPENSSL_memcpy(r->d, numerator->d + numerator->width - initial_words,
      .                            initial_words * sizeof(BN_ULONG));
      .           }
      .         
    544 (0.0%)    for (int i = numerator->width - initial_words - 1; i >= 0; i--) {
 32,928 (0.0%)      for (int bit = BN_BITS2 - 1; bit >= 0; bit--) {
      .               // Incorporate the next bit of the numerator, by computing
      .               // r = 2*r or 2*r + 1. Note the result fits in one more word. We store the
      .               // extra word in |carry|.
129,024 (0.1%)        BN_ULONG carry = bn_add_words(r->d, r->d, r->d, divisor->width);
215,040 (0.1%)        r->d[0] |= (numerator->d[i] >> bit) & 1;
      .               // |r| was previously fully-reduced, so we know:
      .               //      2*0 <= r <= 2*(divisor-1) + 1
      .               //        0 <= r <= 2*divisor - 1 < 2*divisor.
      .               // Thus |r| satisfies the preconditions for |bn_reduce_once_in_place|.
129,024 (0.1%)        BN_ULONG subtracted = bn_reduce_once_in_place(r->d, carry, divisor->d,
 21,504 (0.0%)                                                      tmp->d, divisor->width);
      .               // The corresponding bit of the quotient is set iff we needed to subtract.
247,296 (0.2%)        q->d[i] |= (~subtracted & 1) << bit;
      .             }
      .           }
      .         
     20 (0.0%)    if ((quotient != NULL && !BN_copy(quotient, q)) ||
     35 (0.0%)        (remainder != NULL && !BN_copy(remainder, r))) {
      .             goto err;
      .           }
      .         
     10 (0.0%)    ret = 1;
      .         
      .         err:
     15 (0.0%)    BN_CTX_end(ctx);
      5 (0.0%)    return ret;
     10 (0.0%)  }
      .         
     18 (0.0%)  static BIGNUM *bn_scratch_space_from_ctx(size_t width, BN_CTX *ctx) {
     12 (0.0%)    BIGNUM *ret = BN_CTX_get(ctx);
     12 (0.0%)    if (ret == NULL ||
     15 (0.0%)        !bn_wexpand(ret, width)) {
      .             return NULL;
      .           }
      6 (0.0%)    ret->neg = 0;
     12 (0.0%)    ret->width = (int)width;
      3 (0.0%)    return ret;
      6 (0.0%)  }
      .         
      .         // bn_resized_from_ctx returns |bn| with width at least |width| or NULL on
      .         // error. This is so it may be used with low-level "words" functions. If
      .         // necessary, it allocates a new |BIGNUM| with a lifetime of the current scope
      .         // in |ctx|, so the caller does not need to explicitly free it. |bn| must fit in
      .         // |width| words.
      .         static const BIGNUM *bn_resized_from_ctx(const BIGNUM *bn, size_t width,
     14 (0.0%)                                           BN_CTX *ctx) {
     10 (0.0%)    if ((size_t)bn->width >= width) {
      .             // Any excess words must be zero.
     14 (0.0%)      assert(bn_fits_in_words(bn, width));
      4 (0.0%)      return bn;
      .           }
      .           BIGNUM *ret = bn_scratch_space_from_ctx(width, ctx);
      .           if (ret == NULL ||
      .               !BN_copy(ret, bn) ||
      .               !bn_resize_words(ret, width)) {
      .             return NULL;
      .           }
      .           return ret;
      4 (0.0%)  }
      .         
      .         int BN_mod_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,
      .                        BN_CTX *ctx) {
      .           if (!BN_add(r, a, b)) {
      .             return 0;
      .           }
      .           return BN_nnmod(r, r, m, ctx);
      .         }
-- line 586 ----------------------------------------
-- line 615 ----------------------------------------
      .                        BN_CTX *ctx) {
      .           if (!BN_sub(r, a, b)) {
      .             return 0;
      .           }
      .           return BN_nnmod(r, r, m, ctx);
      .         }
      .         
      .         int bn_mod_sub_consttime(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
      9 (0.0%)                           const BIGNUM *m, BN_CTX *ctx) {
      3 (0.0%)    BN_CTX_start(ctx);
      9 (0.0%)    a = bn_resized_from_ctx(a, m->width, ctx);
      9 (0.0%)    b = bn_resized_from_ctx(b, m->width, ctx);
      8 (0.0%)    BIGNUM *tmp = bn_scratch_space_from_ctx(m->width, ctx);
     11 (0.0%)    int ok = a != NULL && b != NULL && tmp != NULL &&
      7 (0.0%)             bn_wexpand(r, m->width);
      2 (0.0%)    if (ok) {
     17 (0.0%)      bn_mod_sub_words(r->d, a->d, b->d, m->d, tmp->d, m->width);
      4 (0.0%)      r->width = m->width;
      2 (0.0%)      r->neg = 0;
      .           }
      3 (0.0%)    BN_CTX_end(ctx);
      1 (0.0%)    return ok;
      2 (0.0%)  }
      .         
      .         int BN_mod_sub_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
      .                              const BIGNUM *m) {
      .           BN_CTX *ctx = BN_CTX_new();
      .           int ok = ctx != NULL &&
      .                    bn_mod_sub_consttime(r, a, b, m, ctx);
      .           BN_CTX_free(ctx);
      .           return ok;
-- line 645 ----------------------------------------
-- line 705 ----------------------------------------
      .         
      .           ret = bn_mod_lshift_consttime(r, r, n, (abs_m ? abs_m : m), ctx);
      .         
      .           BN_free(abs_m);
      .           return ret;
      .         }
      .         
      .         int bn_mod_lshift_consttime(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m,
     18 (0.0%)                              BN_CTX *ctx) {
     18 (0.0%)    if (!BN_copy(r, a) ||
     14 (0.0%)        !bn_resize_words(r, m->width)) {
      .             return 0;
      .           }
      .         
      6 (0.0%)    BN_CTX_start(ctx);
     16 (0.0%)    BIGNUM *tmp = bn_scratch_space_from_ctx(m->width, ctx);
      8 (0.0%)    int ok = tmp != NULL;
      4 (0.0%)    if (ok) {
    274 (0.0%)      for (int i = 0; i < n; i++) {
  1,122 (0.0%)        bn_mod_add_words(r->d, r->d, r->d, m->d, tmp->d, m->width);
      .             }
      4 (0.0%)      r->neg = 0;
      .           }
      6 (0.0%)    BN_CTX_end(ctx);
      2 (0.0%)    return ok;
      4 (0.0%)  }
      .         
      .         int BN_mod_lshift_quick(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m) {
      .           BN_CTX *ctx = BN_CTX_new();
      .           int ok = ctx != NULL &&
      .                    bn_mod_lshift_consttime(r, a, n, m, ctx);
      .           BN_CTX_free(ctx);
      .           return ok;
      .         }
-- line 738 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/gcd.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 109 ----------------------------------------
     .         #include <openssl/bn.h>
     .         
     .         #include <openssl/err.h>
     .         
     .         #include "internal.h"
     .         
     .         
     .         int BN_mod_inverse_odd(BIGNUM *out, int *out_no_inverse, const BIGNUM *a,
     9 (0.0%)                         const BIGNUM *n, BN_CTX *ctx) {
     2 (0.0%)    *out_no_inverse = 0;
     .         
     5 (0.0%)    if (!BN_is_odd(n)) {
     .             OPENSSL_PUT_ERROR(BN, BN_R_CALLED_WITH_EVEN_MODULUS);
     .             return 0;
     .           }
     .         
    12 (0.0%)    if (BN_is_negative(a) || BN_cmp(a, n) >= 0) {
     .             OPENSSL_PUT_ERROR(BN, BN_R_INPUT_NOT_REDUCED);
     .             return 0;
     .           }
     .         
     .           BIGNUM *A, *B, *X, *Y;
     1 (0.0%)    int ret = 0;
     .           int sign;
     .         
     3 (0.0%)    BN_CTX_start(ctx);
     4 (0.0%)    A = BN_CTX_get(ctx);
     4 (0.0%)    B = BN_CTX_get(ctx);
     4 (0.0%)    X = BN_CTX_get(ctx);
     4 (0.0%)    Y = BN_CTX_get(ctx);
     2 (0.0%)    if (Y == NULL) {
     .             goto err;
     .           }
     .         
     2 (0.0%)    BIGNUM *R = out;
     .         
     3 (0.0%)    BN_zero(Y);
    19 (0.0%)    if (!BN_one(X) || BN_copy(B, a) == NULL || BN_copy(A, n) == NULL) {
     .             goto err;
     .           }
     2 (0.0%)    A->neg = 0;
     1 (0.0%)    sign = -1;
     .           // From  B = a mod |n|,  A = |n|  it follows that
     .           //
     .           //      0 <= B < A,
     .           //     -sign*X*a  ==  B   (mod |n|),
     .           //      sign*Y*a  ==  A   (mod |n|).
     .         
     .           // Binary inversion algorithm; requires odd modulus. This is faster than the
     .           // general algorithm if the modulus is sufficiently small (about 400 .. 500
     .           // bits on 32-bit systems, but much more on 64-bit systems)
     .           int shift;
     .         
14,561 (0.0%)    while (!BN_is_zero(B)) {
     .             //      0 < B < |n|,
     .             //      0 < A <= |n|,
     .             // (1) -sign*X*a  ==  B   (mod |n|),
     .             // (2)  sign*Y*a  ==  A   (mod |n|)
     .         
     .             // Now divide  B  by the maximum possible power of two in the integers,
     .             // and divide  X  by the same value mod |n|.
     .             // When we're done, (1) still holds.
 2,911 (0.0%)      shift = 0;
43,938 (0.0%)      while (!BN_is_bit_set(B, shift)) {
     .               // note that 0 < B
 2,950 (0.0%)        shift++;
     .         
14,750 (0.0%)        if (BN_is_odd(X)) {
11,712 (0.0%)          if (!BN_uadd(X, X, n)) {
     .                   goto err;
     .                 }
     .               }
     .               // now X is even, so we can easily divide it by two
20,650 (0.0%)        if (!BN_rshift1(X, X)) {
     .                 goto err;
     .               }
     .             }
 5,822 (0.0%)      if (shift > 0) {
11,792 (0.0%)        if (!BN_rshift(B, B, shift)) {
     .                 goto err;
     .               }
     .             }
     .         
     .             // Same for A and Y. Afterwards, (2) still holds.
 2,911 (0.0%)      shift = 0;
43,112 (0.0%)      while (!BN_is_bit_set(A, shift)) {
     .               // note that 0 < A
 2,832 (0.0%)        shift++;
     .         
14,160 (0.0%)        if (BN_is_odd(Y)) {
11,776 (0.0%)          if (!BN_uadd(Y, Y, n)) {
     .                   goto err;
     .                 }
     .               }
     .               // now Y is even
19,824 (0.0%)        if (!BN_rshift1(Y, Y)) {
     .                 goto err;
     .               }
     .             }
 5,822 (0.0%)      if (shift > 0) {
11,496 (0.0%)        if (!BN_rshift(A, A, shift)) {
     .                 goto err;
     .               }
     .             }
     .         
     .             // We still have (1) and (2).
     .             // Both  A  and  B  are odd.
     .             // The following computations ensure that
     .             //
     .             //     0 <= B < |n|,
     .             //      0 < A < |n|,
     .             // (1) -sign*X*a  ==  B   (mod |n|),
     .             // (2)  sign*Y*a  ==  A   (mod |n|),
     .             //
     .             // and that either  A  or  B  is even in the next iteration.
20,377 (0.0%)      if (BN_ucmp(B, A) >= 0) {
     .               // -sign*(X + Y)*a == B - A  (mod |n|)
11,792 (0.0%)        if (!BN_uadd(X, X, Y)) {
     .                 goto err;
     .               }
     .               // NB: we could use BN_mod_add_quick(X, X, Y, n), but that
     .               // actually makes the algorithm slower
11,792 (0.0%)        if (!BN_usub(B, B, A)) {
     .                 goto err;
     .               }
     .             } else {
     .               //  sign*(X + Y)*a == A - B  (mod |n|)
11,496 (0.0%)        if (!BN_uadd(Y, Y, X)) {
     .                 goto err;
     .               }
     .               // as above, BN_mod_add_quick(Y, Y, X, n) would slow things down
11,496 (0.0%)        if (!BN_usub(A, A, B)) {
     .                 goto err;
     .               }
     .             }
     .           }
     .         
     5 (0.0%)    if (!BN_is_one(A)) {
     .             *out_no_inverse = 1;
     .             OPENSSL_PUT_ERROR(BN, BN_R_NO_INVERSE);
     .             goto err;
     .           }
     .         
     .           // The while loop (Euclid's algorithm) ends when
     .           //      A == gcd(a,n);
     .           // we have
     .           //       sign*Y*a  ==  A  (mod |n|),
     .           // where  Y  is non-negative.
     .         
     2 (0.0%)    if (sign < 0) {
     8 (0.0%)      if (!BN_sub(Y, n, Y)) {
     .               goto err;
     .             }
     .           }
     .           // Now  Y*a  ==  A  (mod |n|).
     .         
     .           // Y*a == 1  (mod |n|)
    11 (0.0%)    if (Y->neg || BN_ucmp(Y, n) >= 0) {
     .             if (!BN_nnmod(Y, Y, n, ctx)) {
     .               goto err;
     .             }
     .           }
     7 (0.0%)    if (!BN_copy(R, Y)) {
     .             goto err;
     .           }
     .         
     2 (0.0%)    ret = 1;
     .         
     .         err:
     3 (0.0%)    BN_CTX_end(ctx);
     1 (0.0%)    return ret;
     2 (0.0%)  }
     .         
     .         BIGNUM *BN_mod_inverse(BIGNUM *out, const BIGNUM *a, const BIGNUM *n,
     .                                BN_CTX *ctx) {
     .           BIGNUM *new_out = NULL;
     .           if (out == NULL) {
     .             new_out = BN_new();
     .             if (new_out == NULL) {
     .               return NULL;
-- line 288 ----------------------------------------
-- line 319 ----------------------------------------
     .             BN_free(new_out);
     .             out = NULL;
     .           }
     .           BN_free(a_reduced);
     .           return out;
     .         }
     .         
     .         int BN_mod_inverse_blinded(BIGNUM *out, int *out_no_inverse, const BIGNUM *a,
    12 (0.0%)                             const BN_MONT_CTX *mont, BN_CTX *ctx) {
     2 (0.0%)    *out_no_inverse = 0;
     .         
    13 (0.0%)    if (BN_is_negative(a) || BN_cmp(a, &mont->N) >= 0) {
     .             OPENSSL_PUT_ERROR(BN, BN_R_INPUT_NOT_REDUCED);
     .             return 0;
     .           }
     .         
     1 (0.0%)    int ret = 0;
     .           BIGNUM blinding_factor;
     3 (0.0%)    BN_init(&blinding_factor);
     .         
    10 (0.0%)    if (!BN_rand_range_ex(&blinding_factor, 1, &mont->N) ||
    10 (0.0%)        !BN_mod_mul_montgomery(out, &blinding_factor, a, mont, ctx) ||
    11 (0.0%)        !BN_mod_inverse_odd(out, out_no_inverse, out, &mont->N, ctx) ||
     8 (0.0%)        !BN_mod_mul_montgomery(out, &blinding_factor, out, mont, ctx)) {
     .             OPENSSL_PUT_ERROR(BN, ERR_R_BN_LIB);
     .             goto err;
     .           }
     .         
     1 (0.0%)    ret = 1;
     .         
     .         err:
     3 (0.0%)    BN_free(&blinding_factor);
     1 (0.0%)    return ret;
     5 (0.0%)  }
     .         
     .         int bn_mod_inverse_prime(BIGNUM *out, const BIGNUM *a, const BIGNUM *p,
     .                                  BN_CTX *ctx, const BN_MONT_CTX *mont_p) {
     .           BN_CTX_start(ctx);
     .           BIGNUM *p_minus_2 = BN_CTX_get(ctx);
     .           int ok = p_minus_2 != NULL &&
     .                    BN_copy(p_minus_2, p) &&
     .                    BN_sub_word(p_minus_2, 2) &&
-- line 360 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 59 ----------------------------------------
        .         #include <string.h>
        .         
        .         #include <openssl/err.h>
        .         #include <openssl/type_check.h>
        .         
        .         #include "internal.h"
        .         
        .         
       28 (0.0%)  int BN_lshift(BIGNUM *r, const BIGNUM *a, int n) {
        .           int i, nw, lb, rb;
        .           BN_ULONG *t, *f;
        .           BN_ULONG l;
        .         
        8 (0.0%)    if (n < 0) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_NEGATIVE_NUMBER);
        .             return 0;
        .           }
        .         
       16 (0.0%)    r->neg = a->neg;
       24 (0.0%)    nw = n / BN_BITS2;
       48 (0.0%)    if (!bn_wexpand(r, a->width + nw + 1)) {
        .             return 0;
        .           }
       32 (0.0%)    lb = n % BN_BITS2;
       12 (0.0%)    rb = BN_BITS2 - lb;
       12 (0.0%)    f = a->d;
       12 (0.0%)    t = r->d;
       36 (0.0%)    t[a->width + nw] = 0;
        8 (0.0%)    if (lb == 0) {
    1,190 (0.0%)      for (i = a->width - 1; i >= 0; i--) {
    5,404 (0.0%)        t[nw + i] = f[i];
        .             }
        .           } else {
        .             for (i = a->width - 1; i >= 0; i--) {
        .               l = f[i];
        .               t[nw + i + 1] |= l >> rb;
        .               t[nw + i] = l << lb;
        .             }
        .           }
       28 (0.0%)    OPENSSL_memset(t, 0, nw * sizeof(t[0]));
       28 (0.0%)    r->width = a->width + nw + 1;
       12 (0.0%)    bn_set_minimal_width(r);
        .         
        4 (0.0%)    return 1;
        8 (0.0%)  }
        .         
        .         int BN_lshift1(BIGNUM *r, const BIGNUM *a) {
        .           BN_ULONG *ap, *rp, t, c;
        .           int i;
        .         
        .           if (r != a) {
        .             r->neg = a->neg;
        .             if (!bn_wexpand(r, a->width + 1)) {
-- line 111 ----------------------------------------
-- line 129 ----------------------------------------
        .             *rp = 1;
        .             r->width++;
        .           }
        .         
        .           return 1;
        .         }
        .         
        .         void bn_rshift_words(BN_ULONG *r, const BN_ULONG *a, unsigned shift,
   23,304 (0.0%)                       size_t num) {
    8,739 (0.0%)    unsigned shift_bits = shift % BN_BITS2;
   11,652 (0.0%)    size_t shift_words = shift / BN_BITS2;
    8,739 (0.0%)    if (shift_words >= num) {
        .             OPENSSL_memset(r, 0, num * sizeof(BN_ULONG));
        .             return;
        .           }
    5,826 (0.0%)    if (shift_bits == 0) {
       24 (0.0%)      OPENSSL_memmove(r, a + shift_words, (num - shift_words) * sizeof(BN_ULONG));
        .           } else {
  478,822 (0.3%)      for (size_t i = shift_words; i < num - 1; i++) {
  550,134 (0.4%)        r[i - shift_words] =
1,833,780 (1.2%)            (a[i] >> shift_bits) | (a[i + 1] << (BN_BITS2 - shift_bits));
        .             }
   49,487 (0.0%)      r[num - 1 - shift_words] = a[num - 1] >> shift_bits;
        .           }
   29,130 (0.0%)    OPENSSL_memset(r + num - shift_words, 0, shift_words * sizeof(BN_ULONG));
    5,826 (0.0%)  }
        .         
   20,391 (0.0%)  int BN_rshift(BIGNUM *r, const BIGNUM *a, int n) {
    5,826 (0.0%)    if (n < 0) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_NEGATIVE_NUMBER);
        .             return 0;
        .           }
        .         
   26,217 (0.0%)    if (!bn_wexpand(r, a->width)) {
        .             return 0;
        .           }
   29,130 (0.0%)    bn_rshift_words(r->d, a->d, n, a->width);
   11,652 (0.0%)    r->neg = a->neg;
   11,652 (0.0%)    r->width = a->width;
    8,739 (0.0%)    bn_set_minimal_width(r);
    2,913 (0.0%)    return 1;
    5,826 (0.0%)  }
        .         
        .         int bn_rshift_secret_shift(BIGNUM *r, const BIGNUM *a, unsigned n,
        .                                    BN_CTX *ctx) {
        .           int ret = 0;
        .           BN_CTX_start(ctx);
        .           BIGNUM *tmp = BN_CTX_get(ctx);
        .           if (tmp == NULL ||
        .               !BN_copy(r, a) ||
-- line 178 ----------------------------------------
-- line 192 ----------------------------------------
        .         
        .           ret = 1;
        .         
        .         err:
        .           BN_CTX_end(ctx);
        .           return ret;
        .         }
        .         
   34,692 (0.0%)  void bn_rshift1_words(BN_ULONG *r, const BN_ULONG *a, size_t num) {
   11,564 (0.0%)    if (num == 0) {
        .             return;
        .           }
1,878,072 (1.2%)    for (size_t i = 0; i < num - 1; i++) {
7,742,196 (5.0%)      r[i] = (a[i] >> 1) | (a[i + 1] << (BN_BITS2 - 1));
        .           }
   80,948 (0.1%)    r[num - 1] = a[num - 1] >> 1;
   11,564 (0.0%)  }
        .         
   34,692 (0.0%)  int BN_rshift1(BIGNUM *r, const BIGNUM *a) {
   52,038 (0.0%)    if (!bn_wexpand(r, a->width)) {
        .             return 0;
        .           }
   57,820 (0.0%)    bn_rshift1_words(r->d, a->d, a->width);
   23,128 (0.0%)    r->width = a->width;
   23,128 (0.0%)    r->neg = a->neg;
   17,346 (0.0%)    bn_set_minimal_width(r);
    5,782 (0.0%)    return 1;
   11,564 (0.0%)  }
        .         
       24 (0.0%)  int BN_set_bit(BIGNUM *a, int n) {
        8 (0.0%)    if (n < 0) {
        .             return 0;
        .           }
        .         
       24 (0.0%)    int i = n / BN_BITS2;
       32 (0.0%)    int j = n % BN_BITS2;
       16 (0.0%)    if (a->width <= i) {
       36 (0.0%)      if (!bn_wexpand(a, i + 1)) {
        .               return 0;
        .             }
    1,316 (0.0%)      for (int k = a->width; k < i + 1; k++) {
    2,254 (0.0%)        a->d[k] = 0;
        .             }
       16 (0.0%)      a->width = i + 1;
        .           }
        .         
       76 (0.0%)    a->d[i] |= (((BN_ULONG)1) << j);
        .         
        4 (0.0%)    return 1;
        8 (0.0%)  }
        .         
        .         int BN_clear_bit(BIGNUM *a, int n) {
        .           int i, j;
        .         
        .           if (n < 0) {
        .             return 0;
        .           }
        .         
-- line 249 ----------------------------------------
-- line 253 ----------------------------------------
        .             return 0;
        .           }
        .         
        .           a->d[i] &= (~(((BN_ULONG)1) << j));
        .           bn_set_minimal_width(a);
        .           return 1;
        .         }
        .         
   69,966 (0.0%)  int bn_is_bit_set_words(const BN_ULONG *a, size_t num, size_t bit) {
   34,983 (0.0%)    size_t i = bit / BN_BITS2;
   34,983 (0.0%)    size_t j = bit % BN_BITS2;
   34,983 (0.0%)    if (i >= num) {
        .             return 0;
        .           }
  104,949 (0.1%)    return (a[i] >> j) & 1;
   23,322 (0.0%)  }
        .         
   69,966 (0.0%)  int BN_is_bit_set(const BIGNUM *a, int n) {
   23,322 (0.0%)    if (n < 0) {
        .             return 0;
        .           }
  116,610 (0.1%)    return bn_is_bit_set_words(a->d, a->width, n);
   23,322 (0.0%)  }
        .         
        .         int BN_mask_bits(BIGNUM *a, int n) {
        .           if (n < 0) {
        .             return 0;
        .           }
        .         
        .           int w = n / BN_BITS2;
        .           int b = n % BN_BITS2;
-- line 283 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont.S
--------------------------------------------------------------------------------
Ir___________ 

-- line 10 ----------------------------------------
     .         .hidden OPENSSL_ia32cap_P
     .         
     .         .globl	bn_mul_mont
     .         .hidden bn_mul_mont
     .         .type	bn_mul_mont,@function
     .         .align	16
     .         bn_mul_mont:
     .         .cfi_startproc	
   108 (0.0%)  	movl	%r9d,%r9d
   108 (0.0%)  	movq	%rsp,%rax
     .         .cfi_def_cfa_register	%rax
   108 (0.0%)  	testl	$3,%r9d
   108 (0.0%)  	jnz	.Lmul_enter
   108 (0.0%)  	cmpl	$8,%r9d
   108 (0.0%)  	jb	.Lmul_enter
   108 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r11
   108 (0.0%)  	movl	8(%r11),%r11d
   108 (0.0%)  	cmpq	%rsi,%rdx
   108 (0.0%)  	jne	.Lmul4x_enter
    90 (0.0%)  	testl	$7,%r9d
    90 (0.0%)  	jz	.Lsqr8x_enter
     .         	jmp	.Lmul4x_enter
     .         
     .         .align	16
     .         .Lmul_enter:
     .         	pushq	%rbx
     .         .cfi_offset	%rbx,-16
     .         	pushq	%rbp
     .         .cfi_offset	%rbp,-24
-- line 38 ----------------------------------------
-- line 267 ----------------------------------------
     .         .type	bn_mul4x_mont,@function
     .         .align	16
     .         bn_mul4x_mont:
     .         .cfi_startproc	
     .         	movl	%r9d,%r9d
     .         	movq	%rsp,%rax
     .         .cfi_def_cfa_register	%rax
     .         .Lmul4x_enter:
    18 (0.0%)  	andl	$0x80100,%r11d
    18 (0.0%)  	cmpl	$0x80100,%r11d
    18 (0.0%)  	je	.Lmulx4x_enter
    18 (0.0%)  	pushq	%rbx
     .         .cfi_offset	%rbx,-16
    18 (0.0%)  	pushq	%rbp
     .         .cfi_offset	%rbp,-24
    18 (0.0%)  	pushq	%r12
     .         .cfi_offset	%r12,-32
    18 (0.0%)  	pushq	%r13
     .         .cfi_offset	%r13,-40
    18 (0.0%)  	pushq	%r14
     .         .cfi_offset	%r14,-48
    18 (0.0%)  	pushq	%r15
     .         .cfi_offset	%r15,-56
     .         
    18 (0.0%)  	negq	%r9
    18 (0.0%)  	movq	%rsp,%r11
    18 (0.0%)  	leaq	-32(%rsp,%r9,8),%r10
    18 (0.0%)  	negq	%r9
    18 (0.0%)  	andq	$-1024,%r10
     .         
    18 (0.0%)  	subq	%r10,%r11
    18 (0.0%)  	andq	$-4096,%r11
    18 (0.0%)  	leaq	(%r10,%r11,1),%rsp
    18 (0.0%)  	movq	(%rsp),%r11
    18 (0.0%)  	cmpq	%r10,%rsp
    18 (0.0%)  	ja	.Lmul4x_page_walk
    18 (0.0%)  	jmp	.Lmul4x_page_walk_done
     .         
     .         .Lmul4x_page_walk:
     .         	leaq	-4096(%rsp),%rsp
     .         	movq	(%rsp),%r11
     .         	cmpq	%r10,%rsp
     .         	ja	.Lmul4x_page_walk
     .         .Lmul4x_page_walk_done:
     .         
    18 (0.0%)  	movq	%rax,8(%rsp,%r9,8)
     .         .cfi_escape	0x0f,0x0a,0x77,0x08,0x79,0x00,0x38,0x1e,0x22,0x06,0x23,0x08
     .         .Lmul4x_body:
    18 (0.0%)  	movq	%rdi,16(%rsp,%r9,8)
    18 (0.0%)  	movq	%rdx,%r12
    18 (0.0%)  	movq	(%r8),%r8
    18 (0.0%)  	movq	(%r12),%rbx
    18 (0.0%)  	movq	(%rsi),%rax
     .         
    18 (0.0%)  	xorq	%r14,%r14
    18 (0.0%)  	xorq	%r15,%r15
     .         
    18 (0.0%)  	movq	%r8,%rbp
    18 (0.0%)  	mulq	%rbx
    18 (0.0%)  	movq	%rax,%r10
    18 (0.0%)  	movq	(%rcx),%rax
     .         
    18 (0.0%)  	imulq	%r10,%rbp
    18 (0.0%)  	movq	%rdx,%r11
     .         
    18 (0.0%)  	mulq	%rbp
    18 (0.0%)  	addq	%rax,%r10
    18 (0.0%)  	movq	8(%rsi),%rax
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	movq	%rdx,%rdi
     .         
    18 (0.0%)  	mulq	%rbx
    18 (0.0%)  	addq	%rax,%r11
    18 (0.0%)  	movq	8(%rcx),%rax
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	movq	%rdx,%r10
     .         
    18 (0.0%)  	mulq	%rbp
    18 (0.0%)  	addq	%rax,%rdi
    18 (0.0%)  	movq	16(%rsi),%rax
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	addq	%r11,%rdi
    18 (0.0%)  	leaq	4(%r15),%r15
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	movq	%rdi,(%rsp)
    18 (0.0%)  	movq	%rdx,%r13
    18 (0.0%)  	jmp	.L1st4x
     .         .align	16
     .         .L1st4x:
   214 (0.0%)  	mulq	%rbx
   214 (0.0%)  	addq	%rax,%r10
   214 (0.0%)  	movq	-16(%rcx,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	movq	%rdx,%r11
     .         
   214 (0.0%)  	mulq	%rbp
   214 (0.0%)  	addq	%rax,%r13
   214 (0.0%)  	movq	-8(%rsi,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	addq	%r10,%r13
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	movq	%r13,-24(%rsp,%r15,8)
   214 (0.0%)  	movq	%rdx,%rdi
     .         
   214 (0.0%)  	mulq	%rbx
   214 (0.0%)  	addq	%rax,%r11
   214 (0.0%)  	movq	-8(%rcx,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	movq	%rdx,%r10
     .         
   214 (0.0%)  	mulq	%rbp
   214 (0.0%)  	addq	%rax,%rdi
   214 (0.0%)  	movq	(%rsi,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	addq	%r11,%rdi
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	movq	%rdi,-16(%rsp,%r15,8)
   214 (0.0%)  	movq	%rdx,%r13
     .         
   214 (0.0%)  	mulq	%rbx
   214 (0.0%)  	addq	%rax,%r10
   214 (0.0%)  	movq	(%rcx,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	movq	%rdx,%r11
     .         
   214 (0.0%)  	mulq	%rbp
   214 (0.0%)  	addq	%rax,%r13
   214 (0.0%)  	movq	8(%rsi,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	addq	%r10,%r13
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	movq	%r13,-8(%rsp,%r15,8)
   214 (0.0%)  	movq	%rdx,%rdi
     .         
   214 (0.0%)  	mulq	%rbx
   214 (0.0%)  	addq	%rax,%r11
   214 (0.0%)  	movq	8(%rcx,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	leaq	4(%r15),%r15
   214 (0.0%)  	movq	%rdx,%r10
     .         
   214 (0.0%)  	mulq	%rbp
   214 (0.0%)  	addq	%rax,%rdi
   214 (0.0%)  	movq	-16(%rsi,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	addq	%r11,%rdi
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	movq	%rdi,-32(%rsp,%r15,8)
   214 (0.0%)  	movq	%rdx,%r13
   214 (0.0%)  	cmpq	%r9,%r15
   214 (0.0%)  	jb	.L1st4x
     .         
    18 (0.0%)  	mulq	%rbx
    18 (0.0%)  	addq	%rax,%r10
    18 (0.0%)  	movq	-16(%rcx,%r15,8),%rax
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	movq	%rdx,%r11
     .         
    18 (0.0%)  	mulq	%rbp
    18 (0.0%)  	addq	%rax,%r13
    18 (0.0%)  	movq	-8(%rsi,%r15,8),%rax
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	addq	%r10,%r13
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	movq	%r13,-24(%rsp,%r15,8)
    18 (0.0%)  	movq	%rdx,%rdi
     .         
    18 (0.0%)  	mulq	%rbx
    18 (0.0%)  	addq	%rax,%r11
    18 (0.0%)  	movq	-8(%rcx,%r15,8),%rax
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	movq	%rdx,%r10
     .         
    18 (0.0%)  	mulq	%rbp
    18 (0.0%)  	addq	%rax,%rdi
    18 (0.0%)  	movq	(%rsi),%rax
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	addq	%r11,%rdi
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	movq	%rdi,-16(%rsp,%r15,8)
    18 (0.0%)  	movq	%rdx,%r13
     .         
    18 (0.0%)  	xorq	%rdi,%rdi
    18 (0.0%)  	addq	%r10,%r13
    18 (0.0%)  	adcq	$0,%rdi
    18 (0.0%)  	movq	%r13,-8(%rsp,%r15,8)
    18 (0.0%)  	movq	%rdi,(%rsp,%r15,8)
     .         
    18 (0.0%)  	leaq	1(%r14),%r14
     .         .align	4
     .         .Louter4x:
   910 (0.0%)  	movq	(%r12,%r14,8),%rbx
   910 (0.0%)  	xorq	%r15,%r15
   910 (0.0%)  	movq	(%rsp),%r10
   910 (0.0%)  	movq	%r8,%rbp
   910 (0.0%)  	mulq	%rbx
   910 (0.0%)  	addq	%rax,%r10
   910 (0.0%)  	movq	(%rcx),%rax
   910 (0.0%)  	adcq	$0,%rdx
     .         
   910 (0.0%)  	imulq	%r10,%rbp
   910 (0.0%)  	movq	%rdx,%r11
     .         
   910 (0.0%)  	mulq	%rbp
   910 (0.0%)  	addq	%rax,%r10
   910 (0.0%)  	movq	8(%rsi),%rax
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	movq	%rdx,%rdi
     .         
   910 (0.0%)  	mulq	%rbx
   910 (0.0%)  	addq	%rax,%r11
   910 (0.0%)  	movq	8(%rcx),%rax
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	addq	8(%rsp),%r11
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	movq	%rdx,%r10
     .         
   910 (0.0%)  	mulq	%rbp
   910 (0.0%)  	addq	%rax,%rdi
   910 (0.0%)  	movq	16(%rsi),%rax
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	addq	%r11,%rdi
   910 (0.0%)  	leaq	4(%r15),%r15
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	movq	%rdi,(%rsp)
   910 (0.0%)  	movq	%rdx,%r13
   910 (0.0%)  	jmp	.Linner4x
     .         .align	16
     .         .Linner4x:
11,914 (0.0%)  	mulq	%rbx
11,914 (0.0%)  	addq	%rax,%r10
11,914 (0.0%)  	movq	-16(%rcx,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	-16(%rsp,%r15,8),%r10
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	movq	%rdx,%r11
     .         
11,914 (0.0%)  	mulq	%rbp
11,914 (0.0%)  	addq	%rax,%r13
11,914 (0.0%)  	movq	-8(%rsi,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	%r10,%r13
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	movq	%r13,-24(%rsp,%r15,8)
11,914 (0.0%)  	movq	%rdx,%rdi
     .         
11,914 (0.0%)  	mulq	%rbx
11,914 (0.0%)  	addq	%rax,%r11
11,914 (0.0%)  	movq	-8(%rcx,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	-8(%rsp,%r15,8),%r11
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	movq	%rdx,%r10
     .         
11,914 (0.0%)  	mulq	%rbp
11,914 (0.0%)  	addq	%rax,%rdi
11,914 (0.0%)  	movq	(%rsi,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	%r11,%rdi
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	movq	%rdi,-16(%rsp,%r15,8)
11,914 (0.0%)  	movq	%rdx,%r13
     .         
11,914 (0.0%)  	mulq	%rbx
11,914 (0.0%)  	addq	%rax,%r10
11,914 (0.0%)  	movq	(%rcx,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	(%rsp,%r15,8),%r10
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	movq	%rdx,%r11
     .         
11,914 (0.0%)  	mulq	%rbp
11,914 (0.0%)  	addq	%rax,%r13
11,914 (0.0%)  	movq	8(%rsi,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	%r10,%r13
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	movq	%r13,-8(%rsp,%r15,8)
11,914 (0.0%)  	movq	%rdx,%rdi
     .         
11,914 (0.0%)  	mulq	%rbx
11,914 (0.0%)  	addq	%rax,%r11
11,914 (0.0%)  	movq	8(%rcx,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	8(%rsp,%r15,8),%r11
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	leaq	4(%r15),%r15
11,914 (0.0%)  	movq	%rdx,%r10
     .         
11,914 (0.0%)  	mulq	%rbp
11,914 (0.0%)  	addq	%rax,%rdi
11,914 (0.0%)  	movq	-16(%rsi,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	%r11,%rdi
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	movq	%rdi,-32(%rsp,%r15,8)
11,914 (0.0%)  	movq	%rdx,%r13
11,914 (0.0%)  	cmpq	%r9,%r15
11,914 (0.0%)  	jb	.Linner4x
     .         
   910 (0.0%)  	mulq	%rbx
   910 (0.0%)  	addq	%rax,%r10
   910 (0.0%)  	movq	-16(%rcx,%r15,8),%rax
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	addq	-16(%rsp,%r15,8),%r10
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	movq	%rdx,%r11
     .         
   910 (0.0%)  	mulq	%rbp
   910 (0.0%)  	addq	%rax,%r13
   910 (0.0%)  	movq	-8(%rsi,%r15,8),%rax
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	addq	%r10,%r13
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	movq	%r13,-24(%rsp,%r15,8)
   910 (0.0%)  	movq	%rdx,%rdi
     .         
   910 (0.0%)  	mulq	%rbx
   910 (0.0%)  	addq	%rax,%r11
   910 (0.0%)  	movq	-8(%rcx,%r15,8),%rax
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	addq	-8(%rsp,%r15,8),%r11
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	leaq	1(%r14),%r14
   910 (0.0%)  	movq	%rdx,%r10
     .         
   910 (0.0%)  	mulq	%rbp
   910 (0.0%)  	addq	%rax,%rdi
   910 (0.0%)  	movq	(%rsi),%rax
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	addq	%r11,%rdi
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	movq	%rdi,-16(%rsp,%r15,8)
   910 (0.0%)  	movq	%rdx,%r13
     .         
   910 (0.0%)  	xorq	%rdi,%rdi
   910 (0.0%)  	addq	%r10,%r13
   910 (0.0%)  	adcq	$0,%rdi
   910 (0.0%)  	addq	(%rsp,%r9,8),%r13
   910 (0.0%)  	adcq	$0,%rdi
   910 (0.0%)  	movq	%r13,-8(%rsp,%r15,8)
   910 (0.0%)  	movq	%rdi,(%rsp,%r15,8)
     .         
   910 (0.0%)  	cmpq	%r9,%r14
   910 (0.0%)  	jb	.Louter4x
    18 (0.0%)  	movq	16(%rsp,%r9,8),%rdi
    18 (0.0%)  	leaq	-4(%r9),%r15
    18 (0.0%)  	movq	0(%rsp),%rax
    18 (0.0%)  	movq	8(%rsp),%rdx
    18 (0.0%)  	shrq	$2,%r15
    18 (0.0%)  	leaq	(%rsp),%rsi
    18 (0.0%)  	xorq	%r14,%r14
     .         
    18 (0.0%)  	subq	0(%rcx),%rax
    18 (0.0%)  	movq	16(%rsi),%rbx
    18 (0.0%)  	movq	24(%rsi),%rbp
    18 (0.0%)  	sbbq	8(%rcx),%rdx
     .         
     .         .Lsub4x:
   214 (0.0%)  	movq	%rax,0(%rdi,%r14,8)
   214 (0.0%)  	movq	%rdx,8(%rdi,%r14,8)
   214 (0.0%)  	sbbq	16(%rcx,%r14,8),%rbx
   214 (0.0%)  	movq	32(%rsi,%r14,8),%rax
   214 (0.0%)  	movq	40(%rsi,%r14,8),%rdx
   214 (0.0%)  	sbbq	24(%rcx,%r14,8),%rbp
   214 (0.0%)  	movq	%rbx,16(%rdi,%r14,8)
   214 (0.0%)  	movq	%rbp,24(%rdi,%r14,8)
   214 (0.0%)  	sbbq	32(%rcx,%r14,8),%rax
   214 (0.0%)  	movq	48(%rsi,%r14,8),%rbx
   214 (0.0%)  	movq	56(%rsi,%r14,8),%rbp
   214 (0.0%)  	sbbq	40(%rcx,%r14,8),%rdx
   214 (0.0%)  	leaq	4(%r14),%r14
   214 (0.0%)  	decq	%r15
   214 (0.0%)  	jnz	.Lsub4x
     .         
    18 (0.0%)  	movq	%rax,0(%rdi,%r14,8)
    18 (0.0%)  	movq	32(%rsi,%r14,8),%rax
    18 (0.0%)  	sbbq	16(%rcx,%r14,8),%rbx
    18 (0.0%)  	movq	%rdx,8(%rdi,%r14,8)
    18 (0.0%)  	sbbq	24(%rcx,%r14,8),%rbp
    18 (0.0%)  	movq	%rbx,16(%rdi,%r14,8)
     .         
    18 (0.0%)  	sbbq	$0,%rax
    18 (0.0%)  	movq	%rbp,24(%rdi,%r14,8)
    36 (0.0%)  	pxor	%xmm0,%xmm0
     .         .byte	102,72,15,110,224
    18 (0.0%)  	pcmpeqd	%xmm5,%xmm5
    18 (0.0%)  	pshufd	$0,%xmm4,%xmm4
    18 (0.0%)  	movq	%r9,%r15
    18 (0.0%)  	pxor	%xmm4,%xmm5
    18 (0.0%)  	shrq	$2,%r15
    18 (0.0%)  	xorl	%eax,%eax
     .         
    18 (0.0%)  	jmp	.Lcopy4x
     .         .align	16
     .         .Lcopy4x:
   232 (0.0%)  	movdqa	(%rsp,%rax,1),%xmm1
   232 (0.0%)  	movdqu	(%rdi,%rax,1),%xmm2
   232 (0.0%)  	pand	%xmm4,%xmm1
   232 (0.0%)  	pand	%xmm5,%xmm2
   232 (0.0%)  	movdqa	16(%rsp,%rax,1),%xmm3
   232 (0.0%)  	movdqa	%xmm0,(%rsp,%rax,1)
   232 (0.0%)  	por	%xmm2,%xmm1
   232 (0.0%)  	movdqu	16(%rdi,%rax,1),%xmm2
   232 (0.0%)  	movdqu	%xmm1,(%rdi,%rax,1)
   232 (0.0%)  	pand	%xmm4,%xmm3
   232 (0.0%)  	pand	%xmm5,%xmm2
   232 (0.0%)  	movdqa	%xmm0,16(%rsp,%rax,1)
   232 (0.0%)  	por	%xmm2,%xmm3
   232 (0.0%)  	movdqu	%xmm3,16(%rdi,%rax,1)
   232 (0.0%)  	leaq	32(%rax),%rax
   232 (0.0%)  	decq	%r15
   232 (0.0%)  	jnz	.Lcopy4x
    18 (0.0%)  	movq	8(%rsp,%r9,8),%rsi
     .         .cfi_def_cfa	%rsi, 8
    18 (0.0%)  	movq	$1,%rax
    18 (0.0%)  	movq	-48(%rsi),%r15
     .         .cfi_restore	%r15
    18 (0.0%)  	movq	-40(%rsi),%r14
     .         .cfi_restore	%r14
    18 (0.0%)  	movq	-32(%rsi),%r13
     .         .cfi_restore	%r13
    18 (0.0%)  	movq	-24(%rsi),%r12
     .         .cfi_restore	%r12
    18 (0.0%)  	movq	-16(%rsi),%rbp
     .         .cfi_restore	%rbp
    18 (0.0%)  	movq	-8(%rsi),%rbx
     .         .cfi_restore	%rbx
    36 (0.0%)  	leaq	(%rsi),%rsp
     .         .cfi_def_cfa_register	%rsp
     .         .Lmul4x_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	bn_mul4x_mont,.-bn_mul4x_mont
     .         .extern	bn_sqrx8x_internal
     .         .hidden bn_sqrx8x_internal
     .         .extern	bn_sqr8x_internal
-- line 703 ----------------------------------------
-- line 705 ----------------------------------------
     .         
     .         .type	bn_sqr8x_mont,@function
     .         .align	32
     .         bn_sqr8x_mont:
     .         .cfi_startproc	
     .         	movq	%rsp,%rax
     .         .cfi_def_cfa_register	%rax
     .         .Lsqr8x_enter:
    90 (0.0%)  	pushq	%rbx
     .         .cfi_offset	%rbx,-16
    90 (0.0%)  	pushq	%rbp
     .         .cfi_offset	%rbp,-24
    90 (0.0%)  	pushq	%r12
     .         .cfi_offset	%r12,-32
    90 (0.0%)  	pushq	%r13
     .         .cfi_offset	%r13,-40
    90 (0.0%)  	pushq	%r14
     .         .cfi_offset	%r14,-48
    90 (0.0%)  	pushq	%r15
     .         .cfi_offset	%r15,-56
     .         .Lsqr8x_prologue:
     .         
    90 (0.0%)  	movl	%r9d,%r10d
    90 (0.0%)  	shll	$3,%r9d
    90 (0.0%)  	shlq	$3+2,%r10
    90 (0.0%)  	negq	%r9
     .         
     .         
     .         
     .         
     .         
     .         
    90 (0.0%)  	leaq	-64(%rsp,%r9,2),%r11
    90 (0.0%)  	movq	%rsp,%rbp
    90 (0.0%)  	movq	(%r8),%r8
    90 (0.0%)  	subq	%rsi,%r11
    90 (0.0%)  	andq	$4095,%r11
    90 (0.0%)  	cmpq	%r11,%r10
    90 (0.0%)  	jb	.Lsqr8x_sp_alt
    22 (0.0%)  	subq	%r11,%rbp
    22 (0.0%)  	leaq	-64(%rbp,%r9,2),%rbp
    22 (0.0%)  	jmp	.Lsqr8x_sp_done
     .         
     .         .align	32
     .         .Lsqr8x_sp_alt:
    68 (0.0%)  	leaq	4096-64(,%r9,2),%r10
    68 (0.0%)  	leaq	-64(%rbp,%r9,2),%rbp
    68 (0.0%)  	subq	%r10,%r11
    68 (0.0%)  	movq	$0,%r10
    68 (0.0%)  	cmovcq	%r10,%r11
    68 (0.0%)  	subq	%r11,%rbp
     .         .Lsqr8x_sp_done:
    90 (0.0%)  	andq	$-64,%rbp
    90 (0.0%)  	movq	%rsp,%r11
    90 (0.0%)  	subq	%rbp,%r11
    90 (0.0%)  	andq	$-4096,%r11
    90 (0.0%)  	leaq	(%r11,%rbp,1),%rsp
    90 (0.0%)  	movq	(%rsp),%r10
    90 (0.0%)  	cmpq	%rbp,%rsp
    90 (0.0%)  	ja	.Lsqr8x_page_walk
    90 (0.0%)  	jmp	.Lsqr8x_page_walk_done
     .         
     .         .align	16
     .         .Lsqr8x_page_walk:
     .         	leaq	-4096(%rsp),%rsp
     .         	movq	(%rsp),%r10
     .         	cmpq	%rbp,%rsp
     .         	ja	.Lsqr8x_page_walk
     .         .Lsqr8x_page_walk_done:
     .         
    90 (0.0%)  	movq	%r9,%r10
    90 (0.0%)  	negq	%r9
     .         
    90 (0.0%)  	movq	%r8,32(%rsp)
   180 (0.0%)  	movq	%rax,40(%rsp)
     .         .cfi_escape	0x0f,0x05,0x77,0x28,0x06,0x23,0x08
     .         .Lsqr8x_body:
     .         
     .         .byte	102,72,15,110,209
   270 (0.0%)  	pxor	%xmm0,%xmm0
     .         .byte	102,72,15,110,207
     .         .byte	102,73,15,110,218
    90 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rax
    90 (0.0%)  	movl	8(%rax),%eax
    90 (0.0%)  	andl	$0x80100,%eax
    90 (0.0%)  	cmpl	$0x80100,%eax
    90 (0.0%)  	jne	.Lsqr8x_nox
     .         
     .         	call	bn_sqrx8x_internal
     .         
     .         
     .         
     .         
     .         	leaq	(%r8,%rcx,1),%rbx
     .         	movq	%rcx,%r9
     .         	movq	%rcx,%rdx
     .         .byte	102,72,15,126,207
     .         	sarq	$3+2,%rcx
     .         	jmp	.Lsqr8x_sub
     .         
     .         .align	32
     .         .Lsqr8x_nox:
    90 (0.0%)  	call	bn_sqr8x_internal
     .         
     .         
     .         
     .         
    90 (0.0%)  	leaq	(%rdi,%r9,1),%rbx
    90 (0.0%)  	movq	%r9,%rcx
   180 (0.0%)  	movq	%r9,%rdx
     .         .byte	102,72,15,126,207
    90 (0.0%)  	sarq	$3+2,%rcx
    90 (0.0%)  	jmp	.Lsqr8x_sub
     .         
     .         .align	32
     .         .Lsqr8x_sub:
 1,104 (0.0%)  	movq	0(%rbx),%r12
 1,104 (0.0%)  	movq	8(%rbx),%r13
 1,104 (0.0%)  	movq	16(%rbx),%r14
 1,104 (0.0%)  	movq	24(%rbx),%r15
 1,104 (0.0%)  	leaq	32(%rbx),%rbx
 1,104 (0.0%)  	sbbq	0(%rbp),%r12
 1,104 (0.0%)  	sbbq	8(%rbp),%r13
 1,104 (0.0%)  	sbbq	16(%rbp),%r14
 1,104 (0.0%)  	sbbq	24(%rbp),%r15
 1,104 (0.0%)  	leaq	32(%rbp),%rbp
 1,104 (0.0%)  	movq	%r12,0(%rdi)
 1,104 (0.0%)  	movq	%r13,8(%rdi)
 1,104 (0.0%)  	movq	%r14,16(%rdi)
 1,104 (0.0%)  	movq	%r15,24(%rdi)
 1,104 (0.0%)  	leaq	32(%rdi),%rdi
 1,104 (0.0%)  	incq	%rcx
 1,104 (0.0%)  	jnz	.Lsqr8x_sub
     .         
    90 (0.0%)  	sbbq	$0,%rax
    90 (0.0%)  	leaq	(%rbx,%r9,1),%rbx
   180 (0.0%)  	leaq	(%rdi,%r9,1),%rdi
     .         
     .         .byte	102,72,15,110,200
    90 (0.0%)  	pxor	%xmm0,%xmm0
    90 (0.0%)  	pshufd	$0,%xmm1,%xmm1
    90 (0.0%)  	movq	40(%rsp),%rsi
     .         .cfi_def_cfa	%rsi,8
    90 (0.0%)  	jmp	.Lsqr8x_cond_copy
     .         
     .         .align	32
     .         .Lsqr8x_cond_copy:
 1,104 (0.0%)  	movdqa	0(%rbx),%xmm2
 1,104 (0.0%)  	movdqa	16(%rbx),%xmm3
 1,104 (0.0%)  	leaq	32(%rbx),%rbx
 1,104 (0.0%)  	movdqu	0(%rdi),%xmm4
 1,104 (0.0%)  	movdqu	16(%rdi),%xmm5
 1,104 (0.0%)  	leaq	32(%rdi),%rdi
 1,104 (0.0%)  	movdqa	%xmm0,-32(%rbx)
 1,104 (0.0%)  	movdqa	%xmm0,-16(%rbx)
 1,104 (0.0%)  	movdqa	%xmm0,-32(%rbx,%rdx,1)
 1,104 (0.0%)  	movdqa	%xmm0,-16(%rbx,%rdx,1)
 1,104 (0.0%)  	pcmpeqd	%xmm1,%xmm0
 1,104 (0.0%)  	pand	%xmm1,%xmm2
 1,104 (0.0%)  	pand	%xmm1,%xmm3
 1,104 (0.0%)  	pand	%xmm0,%xmm4
 1,104 (0.0%)  	pand	%xmm0,%xmm5
 1,104 (0.0%)  	pxor	%xmm0,%xmm0
 1,104 (0.0%)  	por	%xmm2,%xmm4
 1,104 (0.0%)  	por	%xmm3,%xmm5
 1,104 (0.0%)  	movdqu	%xmm4,-32(%rdi)
 1,104 (0.0%)  	movdqu	%xmm5,-16(%rdi)
 1,104 (0.0%)  	addq	$32,%r9
 1,104 (0.0%)  	jnz	.Lsqr8x_cond_copy
     .         
    90 (0.0%)  	movq	$1,%rax
    90 (0.0%)  	movq	-48(%rsi),%r15
     .         .cfi_restore	%r15
    90 (0.0%)  	movq	-40(%rsi),%r14
     .         .cfi_restore	%r14
    90 (0.0%)  	movq	-32(%rsi),%r13
     .         .cfi_restore	%r13
    90 (0.0%)  	movq	-24(%rsi),%r12
     .         .cfi_restore	%r12
    90 (0.0%)  	movq	-16(%rsi),%rbp
     .         .cfi_restore	%rbp
    90 (0.0%)  	movq	-8(%rsi),%rbx
     .         .cfi_restore	%rbx
   180 (0.0%)  	leaq	(%rsi),%rsp
     .         .cfi_def_cfa_register	%rsp
     .         .Lsqr8x_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	bn_sqr8x_mont,.-bn_sqr8x_mont
     .         .type	bn_mulx4x_mont,@function
     .         .align	32
     .         bn_mulx4x_mont:
-- line 896 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont5.S
--------------------------------------------------------------------------------
Ir____________ 

-- line 10 ----------------------------------------
      .         .hidden OPENSSL_ia32cap_P
      .         
      .         .globl	bn_mul_mont_gather5
      .         .hidden bn_mul_mont_gather5
      .         .type	bn_mul_mont_gather5,@function
      .         .align	64
      .         bn_mul_mont_gather5:
      .         .cfi_startproc	
     30 (0.0%)  	movl	%r9d,%r9d
     30 (0.0%)  	movq	%rsp,%rax
      .         .cfi_def_cfa_register	%rax
     30 (0.0%)  	testl	$7,%r9d
     30 (0.0%)  	jnz	.Lmul_enter
     30 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r11
     30 (0.0%)  	movl	8(%r11),%r11d
     30 (0.0%)  	jmp	.Lmul4x_enter
      .         
      .         .align	16
      .         .Lmul_enter:
      .         	movd	8(%rsp),%xmm5
      .         	pushq	%rbx
      .         .cfi_offset	%rbx,-16
      .         	pushq	%rbp
      .         .cfi_offset	%rbp,-24
-- line 33 ----------------------------------------
-- line 455 ----------------------------------------
      .         .type	bn_mul4x_mont_gather5,@function
      .         .align	32
      .         bn_mul4x_mont_gather5:
      .         .cfi_startproc	
      .         .byte	0x67
      .         	movq	%rsp,%rax
      .         .cfi_def_cfa_register	%rax
      .         .Lmul4x_enter:
     30 (0.0%)  	andl	$0x80108,%r11d
     30 (0.0%)  	cmpl	$0x80108,%r11d
     30 (0.0%)  	je	.Lmulx4x_enter
     30 (0.0%)  	pushq	%rbx
      .         .cfi_offset	%rbx,-16
     30 (0.0%)  	pushq	%rbp
      .         .cfi_offset	%rbp,-24
     30 (0.0%)  	pushq	%r12
      .         .cfi_offset	%r12,-32
     30 (0.0%)  	pushq	%r13
      .         .cfi_offset	%r13,-40
     30 (0.0%)  	pushq	%r14
      .         .cfi_offset	%r14,-48
     60 (0.0%)  	pushq	%r15
      .         .cfi_offset	%r15,-56
      .         .Lmul4x_prologue:
      .         
      .         .byte	0x67
      .         	shll	$3,%r9d
     30 (0.0%)  	leaq	(%r9,%r9,2),%r10
     30 (0.0%)  	negq	%r9
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
     30 (0.0%)  	leaq	-320(%rsp,%r9,2),%r11
     30 (0.0%)  	movq	%rsp,%rbp
     30 (0.0%)  	subq	%rdi,%r11
     30 (0.0%)  	andq	$4095,%r11
     30 (0.0%)  	cmpq	%r11,%r10
     30 (0.0%)  	jb	.Lmul4xsp_alt
      .         	subq	%r11,%rbp
      .         	leaq	-320(%rbp,%r9,2),%rbp
      .         	jmp	.Lmul4xsp_done
      .         
      .         .align	32
      .         .Lmul4xsp_alt:
     30 (0.0%)  	leaq	4096-320(,%r9,2),%r10
     30 (0.0%)  	leaq	-320(%rbp,%r9,2),%rbp
     30 (0.0%)  	subq	%r10,%r11
     30 (0.0%)  	movq	$0,%r10
     30 (0.0%)  	cmovcq	%r10,%r11
     30 (0.0%)  	subq	%r11,%rbp
      .         .Lmul4xsp_done:
     30 (0.0%)  	andq	$-64,%rbp
     30 (0.0%)  	movq	%rsp,%r11
     30 (0.0%)  	subq	%rbp,%r11
     30 (0.0%)  	andq	$-4096,%r11
     30 (0.0%)  	leaq	(%r11,%rbp,1),%rsp
     30 (0.0%)  	movq	(%rsp),%r10
     30 (0.0%)  	cmpq	%rbp,%rsp
     30 (0.0%)  	ja	.Lmul4x_page_walk
     30 (0.0%)  	jmp	.Lmul4x_page_walk_done
      .         
      .         .Lmul4x_page_walk:
      .         	leaq	-4096(%rsp),%rsp
      .         	movq	(%rsp),%r10
      .         	cmpq	%rbp,%rsp
      .         	ja	.Lmul4x_page_walk
      .         .Lmul4x_page_walk_done:
      .         
     30 (0.0%)  	negq	%r9
      .         
     30 (0.0%)  	movq	%rax,40(%rsp)
      .         .cfi_escape	0x0f,0x05,0x77,0x28,0x06,0x23,0x08
      .         .Lmul4x_body:
      .         
     30 (0.0%)  	call	mul4x_internal
      .         
     30 (0.0%)  	movq	40(%rsp),%rsi
      .         .cfi_def_cfa	%rsi,8
     30 (0.0%)  	movq	$1,%rax
      .         
     30 (0.0%)  	movq	-48(%rsi),%r15
      .         .cfi_restore	%r15
     30 (0.0%)  	movq	-40(%rsi),%r14
      .         .cfi_restore	%r14
     30 (0.0%)  	movq	-32(%rsi),%r13
      .         .cfi_restore	%r13
     30 (0.0%)  	movq	-24(%rsi),%r12
      .         .cfi_restore	%r12
     30 (0.0%)  	movq	-16(%rsi),%rbp
      .         .cfi_restore	%rbp
     30 (0.0%)  	movq	-8(%rsi),%rbx
      .         .cfi_restore	%rbx
     60 (0.0%)  	leaq	(%rsi),%rsp
      .         .cfi_def_cfa_register	%rsp
      .         .Lmul4x_epilogue:
      .         	.byte	0xf3,0xc3
      .         .cfi_endproc	
      .         .size	bn_mul4x_mont_gather5,.-bn_mul4x_mont_gather5
      .         
      .         .type	mul4x_internal,@function
      .         .align	32
      .         mul4x_internal:
      .         .cfi_startproc	
    848 (0.0%)  	shlq	$5,%r9
    848 (0.0%)  	movd	8(%rax),%xmm5
    848 (0.0%)  	leaq	.Linc(%rip),%rax
    848 (0.0%)  	leaq	128(%rdx,%r9,1),%r13
    848 (0.0%)  	shrq	$5,%r9
    848 (0.0%)  	movdqa	0(%rax),%xmm0
    848 (0.0%)  	movdqa	16(%rax),%xmm1
    848 (0.0%)  	leaq	88-112(%rsp,%r9,1),%r10
    848 (0.0%)  	leaq	128(%rdx),%r12
      .         
    848 (0.0%)  	pshufd	$0,%xmm5,%xmm5
  1,696 (0.0%)  	movdqa	%xmm1,%xmm4
      .         .byte	0x67,0x67
      .         	movdqa	%xmm1,%xmm2
    848 (0.0%)  	paddd	%xmm0,%xmm1
  1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm0
      .         .byte	0x67
      .         	movdqa	%xmm4,%xmm3
    848 (0.0%)  	paddd	%xmm1,%xmm2
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm1
    848 (0.0%)  	movdqa	%xmm0,112(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm0
      .         
    848 (0.0%)  	paddd	%xmm2,%xmm3
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm2
    848 (0.0%)  	movdqa	%xmm1,128(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm1
      .         
    848 (0.0%)  	paddd	%xmm3,%xmm0
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm3
    848 (0.0%)  	movdqa	%xmm2,144(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm2
      .         
    848 (0.0%)  	paddd	%xmm0,%xmm1
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm0
    848 (0.0%)  	movdqa	%xmm3,160(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm3
    848 (0.0%)  	paddd	%xmm1,%xmm2
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm1
    848 (0.0%)  	movdqa	%xmm0,176(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm0
      .         
    848 (0.0%)  	paddd	%xmm2,%xmm3
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm2
    848 (0.0%)  	movdqa	%xmm1,192(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm1
      .         
    848 (0.0%)  	paddd	%xmm3,%xmm0
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm3
    848 (0.0%)  	movdqa	%xmm2,208(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm2
      .         
    848 (0.0%)  	paddd	%xmm0,%xmm1
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm0
    848 (0.0%)  	movdqa	%xmm3,224(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm3
    848 (0.0%)  	paddd	%xmm1,%xmm2
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm1
    848 (0.0%)  	movdqa	%xmm0,240(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm0
      .         
    848 (0.0%)  	paddd	%xmm2,%xmm3
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm2
    848 (0.0%)  	movdqa	%xmm1,256(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm1
      .         
    848 (0.0%)  	paddd	%xmm3,%xmm0
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm3
    848 (0.0%)  	movdqa	%xmm2,272(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm2
      .         
    848 (0.0%)  	paddd	%xmm0,%xmm1
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm0
    848 (0.0%)  	movdqa	%xmm3,288(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm3
    848 (0.0%)  	paddd	%xmm1,%xmm2
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm1
    848 (0.0%)  	movdqa	%xmm0,304(%r10)
      .         
  1,696 (0.0%)  	paddd	%xmm2,%xmm3
      .         .byte	0x67
      .         	pcmpeqd	%xmm5,%xmm2
    848 (0.0%)  	movdqa	%xmm1,320(%r10)
      .         
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm3
    848 (0.0%)  	movdqa	%xmm2,336(%r10)
    848 (0.0%)  	pand	64(%r12),%xmm0
      .         
    848 (0.0%)  	pand	80(%r12),%xmm1
    848 (0.0%)  	pand	96(%r12),%xmm2
    848 (0.0%)  	movdqa	%xmm3,352(%r10)
    848 (0.0%)  	pand	112(%r12),%xmm3
    848 (0.0%)  	por	%xmm2,%xmm0
    848 (0.0%)  	por	%xmm3,%xmm1
    848 (0.0%)  	movdqa	-128(%r12),%xmm4
    848 (0.0%)  	movdqa	-112(%r12),%xmm5
    848 (0.0%)  	movdqa	-96(%r12),%xmm2
    848 (0.0%)  	pand	112(%r10),%xmm4
    848 (0.0%)  	movdqa	-80(%r12),%xmm3
    848 (0.0%)  	pand	128(%r10),%xmm5
    848 (0.0%)  	por	%xmm4,%xmm0
    848 (0.0%)  	pand	144(%r10),%xmm2
    848 (0.0%)  	por	%xmm5,%xmm1
    848 (0.0%)  	pand	160(%r10),%xmm3
    848 (0.0%)  	por	%xmm2,%xmm0
    848 (0.0%)  	por	%xmm3,%xmm1
    848 (0.0%)  	movdqa	-64(%r12),%xmm4
    848 (0.0%)  	movdqa	-48(%r12),%xmm5
    848 (0.0%)  	movdqa	-32(%r12),%xmm2
    848 (0.0%)  	pand	176(%r10),%xmm4
    848 (0.0%)  	movdqa	-16(%r12),%xmm3
    848 (0.0%)  	pand	192(%r10),%xmm5
    848 (0.0%)  	por	%xmm4,%xmm0
    848 (0.0%)  	pand	208(%r10),%xmm2
    848 (0.0%)  	por	%xmm5,%xmm1
    848 (0.0%)  	pand	224(%r10),%xmm3
    848 (0.0%)  	por	%xmm2,%xmm0
    848 (0.0%)  	por	%xmm3,%xmm1
    848 (0.0%)  	movdqa	0(%r12),%xmm4
    848 (0.0%)  	movdqa	16(%r12),%xmm5
    848 (0.0%)  	movdqa	32(%r12),%xmm2
    848 (0.0%)  	pand	240(%r10),%xmm4
    848 (0.0%)  	movdqa	48(%r12),%xmm3
    848 (0.0%)  	pand	256(%r10),%xmm5
    848 (0.0%)  	por	%xmm4,%xmm0
    848 (0.0%)  	pand	272(%r10),%xmm2
    848 (0.0%)  	por	%xmm5,%xmm1
    848 (0.0%)  	pand	288(%r10),%xmm3
    848 (0.0%)  	por	%xmm2,%xmm0
    848 (0.0%)  	por	%xmm3,%xmm1
    848 (0.0%)  	por	%xmm1,%xmm0
      .         
    848 (0.0%)  	pshufd	$0x4e,%xmm0,%xmm1
    848 (0.0%)  	por	%xmm1,%xmm0
  1,696 (0.0%)  	leaq	256(%r12),%r12
      .         .byte	102,72,15,126,195
      .         
    848 (0.0%)  	movq	%r13,16+8(%rsp)
    848 (0.0%)  	movq	%rdi,56+8(%rsp)
      .         
    848 (0.0%)  	movq	(%r8),%r8
    848 (0.0%)  	movq	(%rsi),%rax
    848 (0.0%)  	leaq	(%rsi,%r9,1),%rsi
    848 (0.0%)  	negq	%r9
      .         
    848 (0.0%)  	movq	%r8,%rbp
    848 (0.0%)  	mulq	%rbx
    848 (0.0%)  	movq	%rax,%r10
    848 (0.0%)  	movq	(%rcx),%rax
      .         
    848 (0.0%)  	imulq	%r10,%rbp
    848 (0.0%)  	leaq	64+8(%rsp),%r14
    848 (0.0%)  	movq	%rdx,%r11
      .         
    848 (0.0%)  	mulq	%rbp
    848 (0.0%)  	addq	%rax,%r10
    848 (0.0%)  	movq	8(%rsi,%r9,1),%rax
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	movq	%rdx,%rdi
      .         
    848 (0.0%)  	mulq	%rbx
    848 (0.0%)  	addq	%rax,%r11
    848 (0.0%)  	movq	8(%rcx),%rax
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	movq	%rdx,%r10
      .         
    848 (0.0%)  	mulq	%rbp
    848 (0.0%)  	addq	%rax,%rdi
    848 (0.0%)  	movq	16(%rsi,%r9,1),%rax
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	addq	%r11,%rdi
    848 (0.0%)  	leaq	32(%r9),%r15
    848 (0.0%)  	leaq	32(%rcx),%rcx
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	movq	%rdi,(%r14)
    848 (0.0%)  	movq	%rdx,%r13
    848 (0.0%)  	jmp	.L1st4x
      .         
      .         .align	32
      .         .L1st4x:
  5,936 (0.0%)  	mulq	%rbx
  5,936 (0.0%)  	addq	%rax,%r10
  5,936 (0.0%)  	movq	-16(%rcx),%rax
  5,936 (0.0%)  	leaq	32(%r14),%r14
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%rdx,%r11
      .         
  5,936 (0.0%)  	mulq	%rbp
  5,936 (0.0%)  	addq	%rax,%r13
  5,936 (0.0%)  	movq	-8(%rsi,%r15,1),%rax
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	addq	%r10,%r13
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%r13,-24(%r14)
  5,936 (0.0%)  	movq	%rdx,%rdi
      .         
  5,936 (0.0%)  	mulq	%rbx
  5,936 (0.0%)  	addq	%rax,%r11
  5,936 (0.0%)  	movq	-8(%rcx),%rax
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%rdx,%r10
      .         
  5,936 (0.0%)  	mulq	%rbp
  5,936 (0.0%)  	addq	%rax,%rdi
  5,936 (0.0%)  	movq	(%rsi,%r15,1),%rax
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	addq	%r11,%rdi
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%rdi,-16(%r14)
  5,936 (0.0%)  	movq	%rdx,%r13
      .         
  5,936 (0.0%)  	mulq	%rbx
  5,936 (0.0%)  	addq	%rax,%r10
  5,936 (0.0%)  	movq	0(%rcx),%rax
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%rdx,%r11
      .         
  5,936 (0.0%)  	mulq	%rbp
  5,936 (0.0%)  	addq	%rax,%r13
  5,936 (0.0%)  	movq	8(%rsi,%r15,1),%rax
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	addq	%r10,%r13
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%r13,-8(%r14)
  5,936 (0.0%)  	movq	%rdx,%rdi
      .         
  5,936 (0.0%)  	mulq	%rbx
  5,936 (0.0%)  	addq	%rax,%r11
  5,936 (0.0%)  	movq	8(%rcx),%rax
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%rdx,%r10
      .         
  5,936 (0.0%)  	mulq	%rbp
  5,936 (0.0%)  	addq	%rax,%rdi
  5,936 (0.0%)  	movq	16(%rsi,%r15,1),%rax
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	addq	%r11,%rdi
  5,936 (0.0%)  	leaq	32(%rcx),%rcx
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%rdi,(%r14)
  5,936 (0.0%)  	movq	%rdx,%r13
      .         
  5,936 (0.0%)  	addq	$32,%r15
  5,936 (0.0%)  	jnz	.L1st4x
      .         
    848 (0.0%)  	mulq	%rbx
    848 (0.0%)  	addq	%rax,%r10
    848 (0.0%)  	movq	-16(%rcx),%rax
    848 (0.0%)  	leaq	32(%r14),%r14
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	movq	%rdx,%r11
      .         
    848 (0.0%)  	mulq	%rbp
    848 (0.0%)  	addq	%rax,%r13
    848 (0.0%)  	movq	-8(%rsi),%rax
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	addq	%r10,%r13
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	movq	%r13,-24(%r14)
    848 (0.0%)  	movq	%rdx,%rdi
      .         
    848 (0.0%)  	mulq	%rbx
    848 (0.0%)  	addq	%rax,%r11
    848 (0.0%)  	movq	-8(%rcx),%rax
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	movq	%rdx,%r10
      .         
    848 (0.0%)  	mulq	%rbp
    848 (0.0%)  	addq	%rax,%rdi
    848 (0.0%)  	movq	(%rsi,%r9,1),%rax
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	addq	%r11,%rdi
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	movq	%rdi,-16(%r14)
    848 (0.0%)  	movq	%rdx,%r13
      .         
    848 (0.0%)  	leaq	(%rcx,%r9,1),%rcx
      .         
    848 (0.0%)  	xorq	%rdi,%rdi
    848 (0.0%)  	addq	%r10,%r13
    848 (0.0%)  	adcq	$0,%rdi
    848 (0.0%)  	movq	%r13,-8(%r14)
      .         
    848 (0.0%)  	jmp	.Louter4x
      .         
      .         .align	32
      .         .Louter4x:
 26,288 (0.0%)  	leaq	16+128(%r14),%rdx
 26,288 (0.0%)  	pxor	%xmm4,%xmm4
 26,288 (0.0%)  	pxor	%xmm5,%xmm5
 26,288 (0.0%)  	movdqa	-128(%r12),%xmm0
 26,288 (0.0%)  	movdqa	-112(%r12),%xmm1
 26,288 (0.0%)  	movdqa	-96(%r12),%xmm2
 26,288 (0.0%)  	movdqa	-80(%r12),%xmm3
 26,288 (0.0%)  	pand	-128(%rdx),%xmm0
 26,288 (0.0%)  	pand	-112(%rdx),%xmm1
 26,288 (0.0%)  	por	%xmm0,%xmm4
 26,288 (0.0%)  	pand	-96(%rdx),%xmm2
 26,288 (0.0%)  	por	%xmm1,%xmm5
 26,288 (0.0%)  	pand	-80(%rdx),%xmm3
 26,288 (0.0%)  	por	%xmm2,%xmm4
 26,288 (0.0%)  	por	%xmm3,%xmm5
 26,288 (0.0%)  	movdqa	-64(%r12),%xmm0
 26,288 (0.0%)  	movdqa	-48(%r12),%xmm1
 26,288 (0.0%)  	movdqa	-32(%r12),%xmm2
 26,288 (0.0%)  	movdqa	-16(%r12),%xmm3
 26,288 (0.0%)  	pand	-64(%rdx),%xmm0
 26,288 (0.0%)  	pand	-48(%rdx),%xmm1
 26,288 (0.0%)  	por	%xmm0,%xmm4
 26,288 (0.0%)  	pand	-32(%rdx),%xmm2
 26,288 (0.0%)  	por	%xmm1,%xmm5
 26,288 (0.0%)  	pand	-16(%rdx),%xmm3
 26,288 (0.0%)  	por	%xmm2,%xmm4
 26,288 (0.0%)  	por	%xmm3,%xmm5
 26,288 (0.0%)  	movdqa	0(%r12),%xmm0
 26,288 (0.0%)  	movdqa	16(%r12),%xmm1
 26,288 (0.0%)  	movdqa	32(%r12),%xmm2
 26,288 (0.0%)  	movdqa	48(%r12),%xmm3
 26,288 (0.0%)  	pand	0(%rdx),%xmm0
 26,288 (0.0%)  	pand	16(%rdx),%xmm1
 26,288 (0.0%)  	por	%xmm0,%xmm4
 26,288 (0.0%)  	pand	32(%rdx),%xmm2
 26,288 (0.0%)  	por	%xmm1,%xmm5
 26,288 (0.0%)  	pand	48(%rdx),%xmm3
 26,288 (0.0%)  	por	%xmm2,%xmm4
 26,288 (0.0%)  	por	%xmm3,%xmm5
 26,288 (0.0%)  	movdqa	64(%r12),%xmm0
 26,288 (0.0%)  	movdqa	80(%r12),%xmm1
 26,288 (0.0%)  	movdqa	96(%r12),%xmm2
 26,288 (0.0%)  	movdqa	112(%r12),%xmm3
 26,288 (0.0%)  	pand	64(%rdx),%xmm0
 26,288 (0.0%)  	pand	80(%rdx),%xmm1
 26,288 (0.0%)  	por	%xmm0,%xmm4
 26,288 (0.0%)  	pand	96(%rdx),%xmm2
 26,288 (0.0%)  	por	%xmm1,%xmm5
 26,288 (0.0%)  	pand	112(%rdx),%xmm3
 26,288 (0.0%)  	por	%xmm2,%xmm4
 26,288 (0.0%)  	por	%xmm3,%xmm5
 26,288 (0.0%)  	por	%xmm5,%xmm4
      .         
 26,288 (0.0%)  	pshufd	$0x4e,%xmm4,%xmm0
 26,288 (0.0%)  	por	%xmm4,%xmm0
 52,576 (0.0%)  	leaq	256(%r12),%r12
      .         .byte	102,72,15,126,195
      .         
 26,288 (0.0%)  	movq	(%r14,%r9,1),%r10
 26,288 (0.0%)  	movq	%r8,%rbp
 26,288 (0.0%)  	mulq	%rbx
 26,288 (0.0%)  	addq	%rax,%r10
 26,288 (0.0%)  	movq	(%rcx),%rax
 26,288 (0.0%)  	adcq	$0,%rdx
      .         
 26,288 (0.0%)  	imulq	%r10,%rbp
 26,288 (0.0%)  	movq	%rdx,%r11
 26,288 (0.0%)  	movq	%rdi,(%r14)
      .         
 26,288 (0.0%)  	leaq	(%r14,%r9,1),%r14
      .         
 26,288 (0.0%)  	mulq	%rbp
 26,288 (0.0%)  	addq	%rax,%r10
 26,288 (0.0%)  	movq	8(%rsi,%r9,1),%rax
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	movq	%rdx,%rdi
      .         
 26,288 (0.0%)  	mulq	%rbx
 26,288 (0.0%)  	addq	%rax,%r11
 26,288 (0.0%)  	movq	8(%rcx),%rax
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	addq	8(%r14),%r11
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	movq	%rdx,%r10
      .         
 26,288 (0.0%)  	mulq	%rbp
 26,288 (0.0%)  	addq	%rax,%rdi
 26,288 (0.0%)  	movq	16(%rsi,%r9,1),%rax
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	addq	%r11,%rdi
 26,288 (0.0%)  	leaq	32(%r9),%r15
 26,288 (0.0%)  	leaq	32(%rcx),%rcx
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	movq	%rdx,%r13
 26,288 (0.0%)  	jmp	.Linner4x
      .         
      .         .align	32
      .         .Linner4x:
184,016 (0.1%)  	mulq	%rbx
184,016 (0.1%)  	addq	%rax,%r10
184,016 (0.1%)  	movq	-16(%rcx),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	16(%r14),%r10
184,016 (0.1%)  	leaq	32(%r14),%r14
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%rdx,%r11
      .         
184,016 (0.1%)  	mulq	%rbp
184,016 (0.1%)  	addq	%rax,%r13
184,016 (0.1%)  	movq	-8(%rsi,%r15,1),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	%r10,%r13
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%rdi,-32(%r14)
184,016 (0.1%)  	movq	%rdx,%rdi
      .         
184,016 (0.1%)  	mulq	%rbx
184,016 (0.1%)  	addq	%rax,%r11
184,016 (0.1%)  	movq	-8(%rcx),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	-8(%r14),%r11
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%rdx,%r10
      .         
184,016 (0.1%)  	mulq	%rbp
184,016 (0.1%)  	addq	%rax,%rdi
184,016 (0.1%)  	movq	(%rsi,%r15,1),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	%r11,%rdi
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%r13,-24(%r14)
184,016 (0.1%)  	movq	%rdx,%r13
      .         
184,016 (0.1%)  	mulq	%rbx
184,016 (0.1%)  	addq	%rax,%r10
184,016 (0.1%)  	movq	0(%rcx),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	(%r14),%r10
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%rdx,%r11
      .         
184,016 (0.1%)  	mulq	%rbp
184,016 (0.1%)  	addq	%rax,%r13
184,016 (0.1%)  	movq	8(%rsi,%r15,1),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	%r10,%r13
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%rdi,-16(%r14)
184,016 (0.1%)  	movq	%rdx,%rdi
      .         
184,016 (0.1%)  	mulq	%rbx
184,016 (0.1%)  	addq	%rax,%r11
184,016 (0.1%)  	movq	8(%rcx),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	8(%r14),%r11
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%rdx,%r10
      .         
184,016 (0.1%)  	mulq	%rbp
184,016 (0.1%)  	addq	%rax,%rdi
184,016 (0.1%)  	movq	16(%rsi,%r15,1),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	%r11,%rdi
184,016 (0.1%)  	leaq	32(%rcx),%rcx
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%r13,-8(%r14)
184,016 (0.1%)  	movq	%rdx,%r13
      .         
184,016 (0.1%)  	addq	$32,%r15
184,016 (0.1%)  	jnz	.Linner4x
      .         
 26,288 (0.0%)  	mulq	%rbx
 26,288 (0.0%)  	addq	%rax,%r10
 26,288 (0.0%)  	movq	-16(%rcx),%rax
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	addq	16(%r14),%r10
 26,288 (0.0%)  	leaq	32(%r14),%r14
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	movq	%rdx,%r11
      .         
 26,288 (0.0%)  	mulq	%rbp
 26,288 (0.0%)  	addq	%rax,%r13
 26,288 (0.0%)  	movq	-8(%rsi),%rax
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	addq	%r10,%r13
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	movq	%rdi,-32(%r14)
 26,288 (0.0%)  	movq	%rdx,%rdi
      .         
 26,288 (0.0%)  	mulq	%rbx
 26,288 (0.0%)  	addq	%rax,%r11
 26,288 (0.0%)  	movq	%rbp,%rax
 26,288 (0.0%)  	movq	-8(%rcx),%rbp
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	addq	-8(%r14),%r11
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	movq	%rdx,%r10
      .         
 26,288 (0.0%)  	mulq	%rbp
 26,288 (0.0%)  	addq	%rax,%rdi
 26,288 (0.0%)  	movq	(%rsi,%r9,1),%rax
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	addq	%r11,%rdi
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	movq	%r13,-24(%r14)
 26,288 (0.0%)  	movq	%rdx,%r13
      .         
 26,288 (0.0%)  	movq	%rdi,-16(%r14)
 26,288 (0.0%)  	leaq	(%rcx,%r9,1),%rcx
      .         
 26,288 (0.0%)  	xorq	%rdi,%rdi
 26,288 (0.0%)  	addq	%r10,%r13
 26,288 (0.0%)  	adcq	$0,%rdi
 26,288 (0.0%)  	addq	(%r14),%r13
 26,288 (0.0%)  	adcq	$0,%rdi
 26,288 (0.0%)  	movq	%r13,-8(%r14)
      .         
 26,288 (0.0%)  	cmpq	16+8(%rsp),%r12
 26,288 (0.0%)  	jb	.Louter4x
    848 (0.0%)  	xorq	%rax,%rax
    848 (0.0%)  	subq	%r13,%rbp
    848 (0.0%)  	adcq	%r15,%r15
    848 (0.0%)  	orq	%r15,%rdi
    848 (0.0%)  	subq	%rdi,%rax
    848 (0.0%)  	leaq	(%r14,%r9,1),%rbx
    848 (0.0%)  	movq	(%rcx),%r12
    848 (0.0%)  	leaq	(%rcx),%rbp
    848 (0.0%)  	movq	%r9,%rcx
    848 (0.0%)  	sarq	$3+2,%rcx
    848 (0.0%)  	movq	56+8(%rsp),%rdi
    848 (0.0%)  	decq	%r12
    848 (0.0%)  	xorq	%r10,%r10
    848 (0.0%)  	movq	8(%rbp),%r13
    848 (0.0%)  	movq	16(%rbp),%r14
    848 (0.0%)  	movq	24(%rbp),%r15
    848 (0.0%)  	jmp	.Lsqr4x_sub_entry
      .         .cfi_endproc	
      .         .size	mul4x_internal,.-mul4x_internal
      .         .globl	bn_power5
      .         .hidden bn_power5
      .         .type	bn_power5,@function
      .         .align	32
      .         bn_power5:
      .         .cfi_startproc	
    818 (0.0%)  	movq	%rsp,%rax
      .         .cfi_def_cfa_register	%rax
    818 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r11
    818 (0.0%)  	movl	8(%r11),%r11d
    818 (0.0%)  	andl	$0x80108,%r11d
    818 (0.0%)  	cmpl	$0x80108,%r11d
    818 (0.0%)  	je	.Lpowerx5_enter
    818 (0.0%)  	pushq	%rbx
      .         .cfi_offset	%rbx,-16
    818 (0.0%)  	pushq	%rbp
      .         .cfi_offset	%rbp,-24
    818 (0.0%)  	pushq	%r12
      .         .cfi_offset	%r12,-32
    818 (0.0%)  	pushq	%r13
      .         .cfi_offset	%r13,-40
    818 (0.0%)  	pushq	%r14
      .         .cfi_offset	%r14,-48
    818 (0.0%)  	pushq	%r15
      .         .cfi_offset	%r15,-56
      .         .Lpower5_prologue:
      .         
    818 (0.0%)  	shll	$3,%r9d
    818 (0.0%)  	leal	(%r9,%r9,2),%r10d
    818 (0.0%)  	negq	%r9
    818 (0.0%)  	movq	(%r8),%r8
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
    818 (0.0%)  	leaq	-320(%rsp,%r9,2),%r11
    818 (0.0%)  	movq	%rsp,%rbp
    818 (0.0%)  	subq	%rdi,%r11
    818 (0.0%)  	andq	$4095,%r11
    818 (0.0%)  	cmpq	%r11,%r10
    818 (0.0%)  	jb	.Lpwr_sp_alt
      .         	subq	%r11,%rbp
      .         	leaq	-320(%rbp,%r9,2),%rbp
      .         	jmp	.Lpwr_sp_done
      .         
      .         .align	32
      .         .Lpwr_sp_alt:
    818 (0.0%)  	leaq	4096-320(,%r9,2),%r10
    818 (0.0%)  	leaq	-320(%rbp,%r9,2),%rbp
    818 (0.0%)  	subq	%r10,%r11
    818 (0.0%)  	movq	$0,%r10
    818 (0.0%)  	cmovcq	%r10,%r11
    818 (0.0%)  	subq	%r11,%rbp
      .         .Lpwr_sp_done:
    818 (0.0%)  	andq	$-64,%rbp
    818 (0.0%)  	movq	%rsp,%r11
    818 (0.0%)  	subq	%rbp,%r11
    818 (0.0%)  	andq	$-4096,%r11
    818 (0.0%)  	leaq	(%r11,%rbp,1),%rsp
    818 (0.0%)  	movq	(%rsp),%r10
    818 (0.0%)  	cmpq	%rbp,%rsp
    818 (0.0%)  	ja	.Lpwr_page_walk
    818 (0.0%)  	jmp	.Lpwr_page_walk_done
      .         
      .         .Lpwr_page_walk:
      .         	leaq	-4096(%rsp),%rsp
      .         	movq	(%rsp),%r10
      .         	cmpq	%rbp,%rsp
      .         	ja	.Lpwr_page_walk
      .         .Lpwr_page_walk_done:
      .         
    818 (0.0%)  	movq	%r9,%r10
    818 (0.0%)  	negq	%r9
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
    818 (0.0%)  	movq	%r8,32(%rsp)
  4,090 (0.0%)  	movq	%rax,40(%rsp)
      .         .cfi_escape	0x0f,0x05,0x77,0x28,0x06,0x23,0x08
      .         .Lpower5_body:
      .         .byte	102,72,15,110,207
      .         .byte	102,72,15,110,209
      .         .byte	102,73,15,110,218
      .         .byte	102,72,15,110,226
      .         
    818 (0.0%)  	call	__bn_sqr8x_internal
    818 (0.0%)  	call	__bn_post4x_internal
    818 (0.0%)  	call	__bn_sqr8x_internal
    818 (0.0%)  	call	__bn_post4x_internal
    818 (0.0%)  	call	__bn_sqr8x_internal
    818 (0.0%)  	call	__bn_post4x_internal
    818 (0.0%)  	call	__bn_sqr8x_internal
    818 (0.0%)  	call	__bn_post4x_internal
    818 (0.0%)  	call	__bn_sqr8x_internal
  2,454 (0.0%)  	call	__bn_post4x_internal
      .         
      .         .byte	102,72,15,126,209
      .         .byte	102,72,15,126,226
    818 (0.0%)  	movq	%rsi,%rdi
    818 (0.0%)  	movq	40(%rsp),%rax
    818 (0.0%)  	leaq	32(%rsp),%r8
      .         
    818 (0.0%)  	call	mul4x_internal
      .         
    818 (0.0%)  	movq	40(%rsp),%rsi
      .         .cfi_def_cfa	%rsi,8
    818 (0.0%)  	movq	$1,%rax
    818 (0.0%)  	movq	-48(%rsi),%r15
      .         .cfi_restore	%r15
    818 (0.0%)  	movq	-40(%rsi),%r14
      .         .cfi_restore	%r14
    818 (0.0%)  	movq	-32(%rsi),%r13
      .         .cfi_restore	%r13
    818 (0.0%)  	movq	-24(%rsi),%r12
      .         .cfi_restore	%r12
    818 (0.0%)  	movq	-16(%rsi),%rbp
      .         .cfi_restore	%rbp
    818 (0.0%)  	movq	-8(%rsi),%rbx
      .         .cfi_restore	%rbx
  1,636 (0.0%)  	leaq	(%rsi),%rsp
      .         .cfi_def_cfa_register	%rsp
      .         .Lpower5_epilogue:
      .         	.byte	0xf3,0xc3
      .         .cfi_endproc	
      .         .size	bn_power5,.-bn_power5
      .         
      .         .globl	bn_sqr8x_internal
      .         .hidden bn_sqr8x_internal
-- line 1228 ----------------------------------------
-- line 1300 ----------------------------------------
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
  4,180 (0.0%)  	leaq	32(%r10),%rbp
  4,180 (0.0%)  	leaq	(%rsi,%r9,1),%rsi
      .         
  4,180 (0.0%)  	movq	%r9,%rcx
      .         
      .         
  4,180 (0.0%)  	movq	-32(%rsi,%rbp,1),%r14
  4,180 (0.0%)  	leaq	48+8(%rsp,%r9,2),%rdi
  4,180 (0.0%)  	movq	-24(%rsi,%rbp,1),%rax
  4,180 (0.0%)  	leaq	-32(%rdi,%rbp,1),%rdi
  4,180 (0.0%)  	movq	-16(%rsi,%rbp,1),%rbx
  4,180 (0.0%)  	movq	%rax,%r15
      .         
  4,180 (0.0%)  	mulq	%r14
  4,180 (0.0%)  	movq	%rax,%r10
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	movq	%rdx,%r11
  4,180 (0.0%)  	movq	%r10,-24(%rdi,%rbp,1)
      .         
  4,180 (0.0%)  	mulq	%r14
  4,180 (0.0%)  	addq	%rax,%r11
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	adcq	$0,%rdx
  4,180 (0.0%)  	movq	%r11,-16(%rdi,%rbp,1)
  4,180 (0.0%)  	movq	%rdx,%r10
      .         
      .         
  4,180 (0.0%)  	movq	-8(%rsi,%rbp,1),%rbx
  4,180 (0.0%)  	mulq	%r15
  4,180 (0.0%)  	movq	%rax,%r12
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	movq	%rdx,%r13
      .         
  4,180 (0.0%)  	leaq	(%rbp),%rcx
  4,180 (0.0%)  	mulq	%r14
  4,180 (0.0%)  	addq	%rax,%r10
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	movq	%rdx,%r11
  4,180 (0.0%)  	adcq	$0,%r11
  4,180 (0.0%)  	addq	%r12,%r10
  4,180 (0.0%)  	adcq	$0,%r11
  4,180 (0.0%)  	movq	%r10,-8(%rdi,%rcx,1)
  4,180 (0.0%)  	jmp	.Lsqr4x_1st
      .         
      .         .align	32
      .         .Lsqr4x_1st:
 29,644 (0.0%)  	movq	(%rsi,%rcx,1),%rbx
 29,644 (0.0%)  	mulq	%r15
 29,644 (0.0%)  	addq	%rax,%r13
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	%rdx,%r12
 29,644 (0.0%)  	adcq	$0,%r12
      .         
 29,644 (0.0%)  	mulq	%r14
 29,644 (0.0%)  	addq	%rax,%r11
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	8(%rsi,%rcx,1),%rbx
 29,644 (0.0%)  	movq	%rdx,%r10
 29,644 (0.0%)  	adcq	$0,%r10
 29,644 (0.0%)  	addq	%r13,%r11
 29,644 (0.0%)  	adcq	$0,%r10
      .         
      .         
 29,644 (0.0%)  	mulq	%r15
 29,644 (0.0%)  	addq	%rax,%r12
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	%r11,(%rdi,%rcx,1)
 29,644 (0.0%)  	movq	%rdx,%r13
 29,644 (0.0%)  	adcq	$0,%r13
      .         
 29,644 (0.0%)  	mulq	%r14
 29,644 (0.0%)  	addq	%rax,%r10
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	16(%rsi,%rcx,1),%rbx
 29,644 (0.0%)  	movq	%rdx,%r11
 29,644 (0.0%)  	adcq	$0,%r11
 29,644 (0.0%)  	addq	%r12,%r10
 29,644 (0.0%)  	adcq	$0,%r11
      .         
 29,644 (0.0%)  	mulq	%r15
 29,644 (0.0%)  	addq	%rax,%r13
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	%r10,8(%rdi,%rcx,1)
 29,644 (0.0%)  	movq	%rdx,%r12
 29,644 (0.0%)  	adcq	$0,%r12
      .         
 29,644 (0.0%)  	mulq	%r14
 29,644 (0.0%)  	addq	%rax,%r11
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	24(%rsi,%rcx,1),%rbx
 29,644 (0.0%)  	movq	%rdx,%r10
 29,644 (0.0%)  	adcq	$0,%r10
 29,644 (0.0%)  	addq	%r13,%r11
 29,644 (0.0%)  	adcq	$0,%r10
      .         
      .         
 29,644 (0.0%)  	mulq	%r15
 29,644 (0.0%)  	addq	%rax,%r12
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	%r11,16(%rdi,%rcx,1)
 29,644 (0.0%)  	movq	%rdx,%r13
 29,644 (0.0%)  	adcq	$0,%r13
 29,644 (0.0%)  	leaq	32(%rcx),%rcx
      .         
 29,644 (0.0%)  	mulq	%r14
 29,644 (0.0%)  	addq	%rax,%r10
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	%rdx,%r11
 29,644 (0.0%)  	adcq	$0,%r11
 29,644 (0.0%)  	addq	%r12,%r10
 29,644 (0.0%)  	adcq	$0,%r11
 29,644 (0.0%)  	movq	%r10,-8(%rdi,%rcx,1)
      .         
 29,644 (0.0%)  	cmpq	$0,%rcx
 29,644 (0.0%)  	jne	.Lsqr4x_1st
      .         
  4,180 (0.0%)  	mulq	%r15
  4,180 (0.0%)  	addq	%rax,%r13
  4,180 (0.0%)  	leaq	16(%rbp),%rbp
  4,180 (0.0%)  	adcq	$0,%rdx
  4,180 (0.0%)  	addq	%r11,%r13
  4,180 (0.0%)  	adcq	$0,%rdx
      .         
  4,180 (0.0%)  	movq	%r13,(%rdi)
  4,180 (0.0%)  	movq	%rdx,%r12
  4,180 (0.0%)  	movq	%rdx,8(%rdi)
  4,180 (0.0%)  	jmp	.Lsqr4x_outer
      .         
      .         .align	32
      .         .Lsqr4x_outer:
 55,108 (0.0%)  	movq	-32(%rsi,%rbp,1),%r14
 55,108 (0.0%)  	leaq	48+8(%rsp,%r9,2),%rdi
 55,108 (0.0%)  	movq	-24(%rsi,%rbp,1),%rax
 55,108 (0.0%)  	leaq	-32(%rdi,%rbp,1),%rdi
 55,108 (0.0%)  	movq	-16(%rsi,%rbp,1),%rbx
 55,108 (0.0%)  	movq	%rax,%r15
      .         
 55,108 (0.0%)  	mulq	%r14
 55,108 (0.0%)  	movq	-24(%rdi,%rbp,1),%r10
 55,108 (0.0%)  	addq	%rax,%r10
 55,108 (0.0%)  	movq	%rbx,%rax
 55,108 (0.0%)  	adcq	$0,%rdx
 55,108 (0.0%)  	movq	%r10,-24(%rdi,%rbp,1)
 55,108 (0.0%)  	movq	%rdx,%r11
      .         
 55,108 (0.0%)  	mulq	%r14
 55,108 (0.0%)  	addq	%rax,%r11
 55,108 (0.0%)  	movq	%rbx,%rax
 55,108 (0.0%)  	adcq	$0,%rdx
 55,108 (0.0%)  	addq	-16(%rdi,%rbp,1),%r11
 55,108 (0.0%)  	movq	%rdx,%r10
 55,108 (0.0%)  	adcq	$0,%r10
 55,108 (0.0%)  	movq	%r11,-16(%rdi,%rbp,1)
      .         
 55,108 (0.0%)  	xorq	%r12,%r12
      .         
 55,108 (0.0%)  	movq	-8(%rsi,%rbp,1),%rbx
 55,108 (0.0%)  	mulq	%r15
 55,108 (0.0%)  	addq	%rax,%r12
 55,108 (0.0%)  	movq	%rbx,%rax
 55,108 (0.0%)  	adcq	$0,%rdx
 55,108 (0.0%)  	addq	-8(%rdi,%rbp,1),%r12
 55,108 (0.0%)  	movq	%rdx,%r13
 55,108 (0.0%)  	adcq	$0,%r13
      .         
 55,108 (0.0%)  	mulq	%r14
 55,108 (0.0%)  	addq	%rax,%r10
 55,108 (0.0%)  	movq	%rbx,%rax
 55,108 (0.0%)  	adcq	$0,%rdx
 55,108 (0.0%)  	addq	%r12,%r10
 55,108 (0.0%)  	movq	%rdx,%r11
 55,108 (0.0%)  	adcq	$0,%r11
 55,108 (0.0%)  	movq	%r10,-8(%rdi,%rbp,1)
      .         
 55,108 (0.0%)  	leaq	(%rbp),%rcx
 55,108 (0.0%)  	jmp	.Lsqr4x_inner
      .         
      .         .align	32
      .         .Lsqr4x_inner:
396,892 (0.3%)  	movq	(%rsi,%rcx,1),%rbx
396,892 (0.3%)  	mulq	%r15
396,892 (0.3%)  	addq	%rax,%r13
396,892 (0.3%)  	movq	%rbx,%rax
396,892 (0.3%)  	movq	%rdx,%r12
396,892 (0.3%)  	adcq	$0,%r12
396,892 (0.3%)  	addq	(%rdi,%rcx,1),%r13
793,784 (0.5%)  	adcq	$0,%r12
      .         
      .         .byte	0x67
      .         	mulq	%r14
396,892 (0.3%)  	addq	%rax,%r11
396,892 (0.3%)  	movq	%rbx,%rax
396,892 (0.3%)  	movq	8(%rsi,%rcx,1),%rbx
396,892 (0.3%)  	movq	%rdx,%r10
396,892 (0.3%)  	adcq	$0,%r10
396,892 (0.3%)  	addq	%r13,%r11
396,892 (0.3%)  	adcq	$0,%r10
      .         
396,892 (0.3%)  	mulq	%r15
396,892 (0.3%)  	addq	%rax,%r12
396,892 (0.3%)  	movq	%r11,(%rdi,%rcx,1)
396,892 (0.3%)  	movq	%rbx,%rax
396,892 (0.3%)  	movq	%rdx,%r13
396,892 (0.3%)  	adcq	$0,%r13
396,892 (0.3%)  	addq	8(%rdi,%rcx,1),%r12
396,892 (0.3%)  	leaq	16(%rcx),%rcx
396,892 (0.3%)  	adcq	$0,%r13
      .         
396,892 (0.3%)  	mulq	%r14
396,892 (0.3%)  	addq	%rax,%r10
396,892 (0.3%)  	movq	%rbx,%rax
396,892 (0.3%)  	adcq	$0,%rdx
396,892 (0.3%)  	addq	%r12,%r10
396,892 (0.3%)  	movq	%rdx,%r11
396,892 (0.3%)  	adcq	$0,%r11
396,892 (0.3%)  	movq	%r10,-8(%rdi,%rcx,1)
      .         
396,892 (0.3%)  	cmpq	$0,%rcx
452,000 (0.3%)  	jne	.Lsqr4x_inner
      .         
      .         .byte	0x67
      .         	mulq	%r15
 55,108 (0.0%)  	addq	%rax,%r13
 55,108 (0.0%)  	adcq	$0,%rdx
 55,108 (0.0%)  	addq	%r11,%r13
 55,108 (0.0%)  	adcq	$0,%rdx
      .         
 55,108 (0.0%)  	movq	%r13,(%rdi)
 55,108 (0.0%)  	movq	%rdx,%r12
 55,108 (0.0%)  	movq	%rdx,8(%rdi)
      .         
 55,108 (0.0%)  	addq	$16,%rbp
 55,108 (0.0%)  	jnz	.Lsqr4x_outer
      .         
      .         
  4,180 (0.0%)  	movq	-32(%rsi),%r14
  4,180 (0.0%)  	leaq	48+8(%rsp,%r9,2),%rdi
  4,180 (0.0%)  	movq	-24(%rsi),%rax
  4,180 (0.0%)  	leaq	-32(%rdi,%rbp,1),%rdi
  4,180 (0.0%)  	movq	-16(%rsi),%rbx
  4,180 (0.0%)  	movq	%rax,%r15
      .         
  4,180 (0.0%)  	mulq	%r14
  4,180 (0.0%)  	addq	%rax,%r10
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	movq	%rdx,%r11
  4,180 (0.0%)  	adcq	$0,%r11
      .         
  4,180 (0.0%)  	mulq	%r14
  4,180 (0.0%)  	addq	%rax,%r11
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	movq	%r10,-24(%rdi)
  4,180 (0.0%)  	movq	%rdx,%r10
  4,180 (0.0%)  	adcq	$0,%r10
  4,180 (0.0%)  	addq	%r13,%r11
  4,180 (0.0%)  	movq	-8(%rsi),%rbx
  4,180 (0.0%)  	adcq	$0,%r10
      .         
  4,180 (0.0%)  	mulq	%r15
  4,180 (0.0%)  	addq	%rax,%r12
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	movq	%r11,-16(%rdi)
  4,180 (0.0%)  	movq	%rdx,%r13
  4,180 (0.0%)  	adcq	$0,%r13
      .         
  4,180 (0.0%)  	mulq	%r14
  4,180 (0.0%)  	addq	%rax,%r10
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	movq	%rdx,%r11
  4,180 (0.0%)  	adcq	$0,%r11
  4,180 (0.0%)  	addq	%r12,%r10
  4,180 (0.0%)  	adcq	$0,%r11
  4,180 (0.0%)  	movq	%r10,-8(%rdi)
      .         
  4,180 (0.0%)  	mulq	%r15
  4,180 (0.0%)  	addq	%rax,%r13
  4,180 (0.0%)  	movq	-16(%rsi),%rax
  4,180 (0.0%)  	adcq	$0,%rdx
  4,180 (0.0%)  	addq	%r11,%r13
  4,180 (0.0%)  	adcq	$0,%rdx
      .         
  4,180 (0.0%)  	movq	%r13,(%rdi)
  4,180 (0.0%)  	movq	%rdx,%r12
  4,180 (0.0%)  	movq	%rdx,8(%rdi)
      .         
  4,180 (0.0%)  	mulq	%rbx
  4,180 (0.0%)  	addq	$16,%rbp
  4,180 (0.0%)  	xorq	%r14,%r14
  4,180 (0.0%)  	subq	%r9,%rbp
  4,180 (0.0%)  	xorq	%r15,%r15
      .         
  4,180 (0.0%)  	addq	%r12,%rax
  4,180 (0.0%)  	adcq	$0,%rdx
  4,180 (0.0%)  	movq	%rax,8(%rdi)
  4,180 (0.0%)  	movq	%rdx,16(%rdi)
  4,180 (0.0%)  	movq	%r15,24(%rdi)
      .         
  4,180 (0.0%)  	movq	-16(%rsi,%rbp,1),%rax
  4,180 (0.0%)  	leaq	48+8(%rsp),%rdi
  4,180 (0.0%)  	xorq	%r10,%r10
  4,180 (0.0%)  	movq	8(%rdi),%r11
      .         
  4,180 (0.0%)  	leaq	(%r14,%r10,2),%r12
  4,180 (0.0%)  	shrq	$63,%r10
  4,180 (0.0%)  	leaq	(%rcx,%r11,2),%r13
  4,180 (0.0%)  	shrq	$63,%r11
  4,180 (0.0%)  	orq	%r10,%r13
  4,180 (0.0%)  	movq	16(%rdi),%r10
  4,180 (0.0%)  	movq	%r11,%r14
  4,180 (0.0%)  	mulq	%rax
  4,180 (0.0%)  	negq	%r15
  4,180 (0.0%)  	movq	24(%rdi),%r11
  4,180 (0.0%)  	adcq	%rax,%r12
  4,180 (0.0%)  	movq	-8(%rsi,%rbp,1),%rax
  4,180 (0.0%)  	movq	%r12,(%rdi)
  4,180 (0.0%)  	adcq	%rdx,%r13
      .         
  4,180 (0.0%)  	leaq	(%r14,%r10,2),%rbx
  4,180 (0.0%)  	movq	%r13,8(%rdi)
  4,180 (0.0%)  	sbbq	%r15,%r15
  4,180 (0.0%)  	shrq	$63,%r10
  4,180 (0.0%)  	leaq	(%rcx,%r11,2),%r8
  4,180 (0.0%)  	shrq	$63,%r11
  4,180 (0.0%)  	orq	%r10,%r8
  4,180 (0.0%)  	movq	32(%rdi),%r10
  4,180 (0.0%)  	movq	%r11,%r14
  4,180 (0.0%)  	mulq	%rax
  4,180 (0.0%)  	negq	%r15
  4,180 (0.0%)  	movq	40(%rdi),%r11
  4,180 (0.0%)  	adcq	%rax,%rbx
  4,180 (0.0%)  	movq	0(%rsi,%rbp,1),%rax
  4,180 (0.0%)  	movq	%rbx,16(%rdi)
  4,180 (0.0%)  	adcq	%rdx,%r8
  4,180 (0.0%)  	leaq	16(%rbp),%rbp
  4,180 (0.0%)  	movq	%r8,24(%rdi)
  4,180 (0.0%)  	sbbq	%r15,%r15
  4,180 (0.0%)  	leaq	64(%rdi),%rdi
  4,180 (0.0%)  	jmp	.Lsqr4x_shift_n_add
      .         
      .         .align	32
      .         .Lsqr4x_shift_n_add:
 29,644 (0.0%)  	leaq	(%r14,%r10,2),%r12
 29,644 (0.0%)  	shrq	$63,%r10
 29,644 (0.0%)  	leaq	(%rcx,%r11,2),%r13
 29,644 (0.0%)  	shrq	$63,%r11
 29,644 (0.0%)  	orq	%r10,%r13
 29,644 (0.0%)  	movq	-16(%rdi),%r10
 29,644 (0.0%)  	movq	%r11,%r14
 29,644 (0.0%)  	mulq	%rax
 29,644 (0.0%)  	negq	%r15
 29,644 (0.0%)  	movq	-8(%rdi),%r11
 29,644 (0.0%)  	adcq	%rax,%r12
 29,644 (0.0%)  	movq	-8(%rsi,%rbp,1),%rax
 29,644 (0.0%)  	movq	%r12,-32(%rdi)
 29,644 (0.0%)  	adcq	%rdx,%r13
      .         
 29,644 (0.0%)  	leaq	(%r14,%r10,2),%rbx
 29,644 (0.0%)  	movq	%r13,-24(%rdi)
 29,644 (0.0%)  	sbbq	%r15,%r15
 29,644 (0.0%)  	shrq	$63,%r10
 29,644 (0.0%)  	leaq	(%rcx,%r11,2),%r8
 29,644 (0.0%)  	shrq	$63,%r11
 29,644 (0.0%)  	orq	%r10,%r8
 29,644 (0.0%)  	movq	0(%rdi),%r10
 29,644 (0.0%)  	movq	%r11,%r14
 29,644 (0.0%)  	mulq	%rax
 29,644 (0.0%)  	negq	%r15
 29,644 (0.0%)  	movq	8(%rdi),%r11
 29,644 (0.0%)  	adcq	%rax,%rbx
 29,644 (0.0%)  	movq	0(%rsi,%rbp,1),%rax
 29,644 (0.0%)  	movq	%rbx,-16(%rdi)
 29,644 (0.0%)  	adcq	%rdx,%r8
      .         
 29,644 (0.0%)  	leaq	(%r14,%r10,2),%r12
 29,644 (0.0%)  	movq	%r8,-8(%rdi)
 29,644 (0.0%)  	sbbq	%r15,%r15
 29,644 (0.0%)  	shrq	$63,%r10
 29,644 (0.0%)  	leaq	(%rcx,%r11,2),%r13
 29,644 (0.0%)  	shrq	$63,%r11
 29,644 (0.0%)  	orq	%r10,%r13
 29,644 (0.0%)  	movq	16(%rdi),%r10
 29,644 (0.0%)  	movq	%r11,%r14
 29,644 (0.0%)  	mulq	%rax
 29,644 (0.0%)  	negq	%r15
 29,644 (0.0%)  	movq	24(%rdi),%r11
 29,644 (0.0%)  	adcq	%rax,%r12
 29,644 (0.0%)  	movq	8(%rsi,%rbp,1),%rax
 29,644 (0.0%)  	movq	%r12,0(%rdi)
 29,644 (0.0%)  	adcq	%rdx,%r13
      .         
 29,644 (0.0%)  	leaq	(%r14,%r10,2),%rbx
 29,644 (0.0%)  	movq	%r13,8(%rdi)
 29,644 (0.0%)  	sbbq	%r15,%r15
 29,644 (0.0%)  	shrq	$63,%r10
 29,644 (0.0%)  	leaq	(%rcx,%r11,2),%r8
 29,644 (0.0%)  	shrq	$63,%r11
 29,644 (0.0%)  	orq	%r10,%r8
 29,644 (0.0%)  	movq	32(%rdi),%r10
 29,644 (0.0%)  	movq	%r11,%r14
 29,644 (0.0%)  	mulq	%rax
 29,644 (0.0%)  	negq	%r15
 29,644 (0.0%)  	movq	40(%rdi),%r11
 29,644 (0.0%)  	adcq	%rax,%rbx
 29,644 (0.0%)  	movq	16(%rsi,%rbp,1),%rax
 29,644 (0.0%)  	movq	%rbx,16(%rdi)
 29,644 (0.0%)  	adcq	%rdx,%r8
 29,644 (0.0%)  	movq	%r8,24(%rdi)
 29,644 (0.0%)  	sbbq	%r15,%r15
 29,644 (0.0%)  	leaq	64(%rdi),%rdi
 29,644 (0.0%)  	addq	$32,%rbp
 29,644 (0.0%)  	jnz	.Lsqr4x_shift_n_add
      .         
  8,360 (0.0%)  	leaq	(%r14,%r10,2),%r12
      .         .byte	0x67
      .         	shrq	$63,%r10
  4,180 (0.0%)  	leaq	(%rcx,%r11,2),%r13
  4,180 (0.0%)  	shrq	$63,%r11
  4,180 (0.0%)  	orq	%r10,%r13
  4,180 (0.0%)  	movq	-16(%rdi),%r10
  4,180 (0.0%)  	movq	%r11,%r14
  4,180 (0.0%)  	mulq	%rax
  4,180 (0.0%)  	negq	%r15
  4,180 (0.0%)  	movq	-8(%rdi),%r11
  4,180 (0.0%)  	adcq	%rax,%r12
  4,180 (0.0%)  	movq	-8(%rsi),%rax
  4,180 (0.0%)  	movq	%r12,-32(%rdi)
  4,180 (0.0%)  	adcq	%rdx,%r13
      .         
  4,180 (0.0%)  	leaq	(%r14,%r10,2),%rbx
  4,180 (0.0%)  	movq	%r13,-24(%rdi)
  4,180 (0.0%)  	sbbq	%r15,%r15
  4,180 (0.0%)  	shrq	$63,%r10
  4,180 (0.0%)  	leaq	(%rcx,%r11,2),%r8
  4,180 (0.0%)  	shrq	$63,%r11
  4,180 (0.0%)  	orq	%r10,%r8
  4,180 (0.0%)  	mulq	%rax
  4,180 (0.0%)  	negq	%r15
  4,180 (0.0%)  	adcq	%rax,%rbx
  4,180 (0.0%)  	adcq	%rdx,%r8
  4,180 (0.0%)  	movq	%rbx,-16(%rdi)
  8,360 (0.0%)  	movq	%r8,-8(%rdi)
      .         .byte	102,72,15,126,213
      .         __bn_sqr8x_reduction:
  4,180 (0.0%)  	xorq	%rax,%rax
  4,180 (0.0%)  	leaq	(%r9,%rbp,1),%rcx
  4,180 (0.0%)  	leaq	48+8(%rsp,%r9,2),%rdx
  4,180 (0.0%)  	movq	%rcx,0+8(%rsp)
  4,180 (0.0%)  	leaq	48+8(%rsp,%r9,1),%rdi
  4,180 (0.0%)  	movq	%rdx,8+8(%rsp)
  4,180 (0.0%)  	negq	%r9
  4,180 (0.0%)  	jmp	.L8x_reduction_loop
      .         
      .         .align	32
      .         .L8x_reduction_loop:
 33,824 (0.0%)  	leaq	(%rdi,%r9,1),%rdi
      .         .byte	0x66
      .         	movq	0(%rdi),%rbx
 16,912 (0.0%)  	movq	8(%rdi),%r9
 16,912 (0.0%)  	movq	16(%rdi),%r10
 16,912 (0.0%)  	movq	24(%rdi),%r11
 16,912 (0.0%)  	movq	32(%rdi),%r12
 16,912 (0.0%)  	movq	40(%rdi),%r13
 16,912 (0.0%)  	movq	48(%rdi),%r14
 16,912 (0.0%)  	movq	56(%rdi),%r15
 16,912 (0.0%)  	movq	%rax,(%rdx)
 33,824 (0.0%)  	leaq	64(%rdi),%rdi
      .         
      .         .byte	0x67
      .         	movq	%rbx,%r8
 16,912 (0.0%)  	imulq	32+8(%rsp),%rbx
 16,912 (0.0%)  	movq	0(%rbp),%rax
 16,912 (0.0%)  	movl	$8,%ecx
 16,912 (0.0%)  	jmp	.L8x_reduce
      .         
      .         .align	32
      .         .L8x_reduce:
135,296 (0.1%)  	mulq	%rbx
135,296 (0.1%)  	movq	8(%rbp),%rax
135,296 (0.1%)  	negq	%r8
135,296 (0.1%)  	movq	%rdx,%r8
135,296 (0.1%)  	adcq	$0,%r8
      .         
135,296 (0.1%)  	mulq	%rbx
135,296 (0.1%)  	addq	%rax,%r9
135,296 (0.1%)  	movq	16(%rbp),%rax
135,296 (0.1%)  	adcq	$0,%rdx
135,296 (0.1%)  	addq	%r9,%r8
135,296 (0.1%)  	movq	%rbx,48-8+8(%rsp,%rcx,8)
135,296 (0.1%)  	movq	%rdx,%r9
135,296 (0.1%)  	adcq	$0,%r9
      .         
135,296 (0.1%)  	mulq	%rbx
135,296 (0.1%)  	addq	%rax,%r10
135,296 (0.1%)  	movq	24(%rbp),%rax
135,296 (0.1%)  	adcq	$0,%rdx
135,296 (0.1%)  	addq	%r10,%r9
135,296 (0.1%)  	movq	32+8(%rsp),%rsi
135,296 (0.1%)  	movq	%rdx,%r10
135,296 (0.1%)  	adcq	$0,%r10
      .         
135,296 (0.1%)  	mulq	%rbx
135,296 (0.1%)  	addq	%rax,%r11
135,296 (0.1%)  	movq	32(%rbp),%rax
135,296 (0.1%)  	adcq	$0,%rdx
135,296 (0.1%)  	imulq	%r8,%rsi
135,296 (0.1%)  	addq	%r11,%r10
135,296 (0.1%)  	movq	%rdx,%r11
135,296 (0.1%)  	adcq	$0,%r11
      .         
135,296 (0.1%)  	mulq	%rbx
135,296 (0.1%)  	addq	%rax,%r12
135,296 (0.1%)  	movq	40(%rbp),%rax
135,296 (0.1%)  	adcq	$0,%rdx
135,296 (0.1%)  	addq	%r12,%r11
135,296 (0.1%)  	movq	%rdx,%r12
135,296 (0.1%)  	adcq	$0,%r12
      .         
135,296 (0.1%)  	mulq	%rbx
135,296 (0.1%)  	addq	%rax,%r13
135,296 (0.1%)  	movq	48(%rbp),%rax
135,296 (0.1%)  	adcq	$0,%rdx
135,296 (0.1%)  	addq	%r13,%r12
135,296 (0.1%)  	movq	%rdx,%r13
135,296 (0.1%)  	adcq	$0,%r13
      .         
135,296 (0.1%)  	mulq	%rbx
135,296 (0.1%)  	addq	%rax,%r14
135,296 (0.1%)  	movq	56(%rbp),%rax
135,296 (0.1%)  	adcq	$0,%rdx
135,296 (0.1%)  	addq	%r14,%r13
135,296 (0.1%)  	movq	%rdx,%r14
135,296 (0.1%)  	adcq	$0,%r14
      .         
135,296 (0.1%)  	mulq	%rbx
135,296 (0.1%)  	movq	%rsi,%rbx
135,296 (0.1%)  	addq	%rax,%r15
135,296 (0.1%)  	movq	0(%rbp),%rax
135,296 (0.1%)  	adcq	$0,%rdx
135,296 (0.1%)  	addq	%r15,%r14
135,296 (0.1%)  	movq	%rdx,%r15
135,296 (0.1%)  	adcq	$0,%r15
      .         
135,296 (0.1%)  	decl	%ecx
135,296 (0.1%)  	jnz	.L8x_reduce
      .         
 16,912 (0.0%)  	leaq	64(%rbp),%rbp
 16,912 (0.0%)  	xorq	%rax,%rax
 16,912 (0.0%)  	movq	8+8(%rsp),%rdx
 16,912 (0.0%)  	cmpq	0+8(%rsp),%rbp
 33,824 (0.0%)  	jae	.L8x_no_tail
      .         
      .         .byte	0x66
      .         	addq	0(%rdi),%r8
 16,912 (0.0%)  	adcq	8(%rdi),%r9
 16,912 (0.0%)  	adcq	16(%rdi),%r10
 16,912 (0.0%)  	adcq	24(%rdi),%r11
 16,912 (0.0%)  	adcq	32(%rdi),%r12
 16,912 (0.0%)  	adcq	40(%rdi),%r13
 16,912 (0.0%)  	adcq	48(%rdi),%r14
 16,912 (0.0%)  	adcq	56(%rdi),%r15
 16,912 (0.0%)  	sbbq	%rsi,%rsi
      .         
 16,912 (0.0%)  	movq	48+56+8(%rsp),%rbx
 16,912 (0.0%)  	movl	$8,%ecx
 16,912 (0.0%)  	movq	0(%rbp),%rax
 16,912 (0.0%)  	jmp	.L8x_tail
      .         
      .         .align	32
      .         .L8x_tail:
418,176 (0.3%)  	mulq	%rbx
418,176 (0.3%)  	addq	%rax,%r8
418,176 (0.3%)  	movq	8(%rbp),%rax
418,176 (0.3%)  	movq	%r8,(%rdi)
418,176 (0.3%)  	movq	%rdx,%r8
418,176 (0.3%)  	adcq	$0,%r8
      .         
418,176 (0.3%)  	mulq	%rbx
418,176 (0.3%)  	addq	%rax,%r9
418,176 (0.3%)  	movq	16(%rbp),%rax
418,176 (0.3%)  	adcq	$0,%rdx
418,176 (0.3%)  	addq	%r9,%r8
418,176 (0.3%)  	leaq	8(%rdi),%rdi
418,176 (0.3%)  	movq	%rdx,%r9
418,176 (0.3%)  	adcq	$0,%r9
      .         
418,176 (0.3%)  	mulq	%rbx
418,176 (0.3%)  	addq	%rax,%r10
418,176 (0.3%)  	movq	24(%rbp),%rax
418,176 (0.3%)  	adcq	$0,%rdx
418,176 (0.3%)  	addq	%r10,%r9
418,176 (0.3%)  	movq	%rdx,%r10
418,176 (0.3%)  	adcq	$0,%r10
      .         
418,176 (0.3%)  	mulq	%rbx
418,176 (0.3%)  	addq	%rax,%r11
418,176 (0.3%)  	movq	32(%rbp),%rax
418,176 (0.3%)  	adcq	$0,%rdx
418,176 (0.3%)  	addq	%r11,%r10
418,176 (0.3%)  	movq	%rdx,%r11
418,176 (0.3%)  	adcq	$0,%r11
      .         
418,176 (0.3%)  	mulq	%rbx
418,176 (0.3%)  	addq	%rax,%r12
418,176 (0.3%)  	movq	40(%rbp),%rax
418,176 (0.3%)  	adcq	$0,%rdx
418,176 (0.3%)  	addq	%r12,%r11
418,176 (0.3%)  	movq	%rdx,%r12
418,176 (0.3%)  	adcq	$0,%r12
      .         
418,176 (0.3%)  	mulq	%rbx
418,176 (0.3%)  	addq	%rax,%r13
418,176 (0.3%)  	movq	48(%rbp),%rax
418,176 (0.3%)  	adcq	$0,%rdx
418,176 (0.3%)  	addq	%r13,%r12
418,176 (0.3%)  	movq	%rdx,%r13
418,176 (0.3%)  	adcq	$0,%r13
      .         
418,176 (0.3%)  	mulq	%rbx
418,176 (0.3%)  	addq	%rax,%r14
418,176 (0.3%)  	movq	56(%rbp),%rax
418,176 (0.3%)  	adcq	$0,%rdx
418,176 (0.3%)  	addq	%r14,%r13
418,176 (0.3%)  	movq	%rdx,%r14
418,176 (0.3%)  	adcq	$0,%r14
      .         
418,176 (0.3%)  	mulq	%rbx
418,176 (0.3%)  	movq	48-16+8(%rsp,%rcx,8),%rbx
418,176 (0.3%)  	addq	%rax,%r15
418,176 (0.3%)  	adcq	$0,%rdx
418,176 (0.3%)  	addq	%r15,%r14
418,176 (0.3%)  	movq	0(%rbp),%rax
418,176 (0.3%)  	movq	%rdx,%r15
418,176 (0.3%)  	adcq	$0,%r15
      .         
418,176 (0.3%)  	decl	%ecx
418,176 (0.3%)  	jnz	.L8x_tail
      .         
 52,272 (0.0%)  	leaq	64(%rbp),%rbp
 52,272 (0.0%)  	movq	8+8(%rsp),%rdx
 52,272 (0.0%)  	cmpq	0+8(%rsp),%rbp
 52,272 (0.0%)  	jae	.L8x_tail_done
      .         
 35,360 (0.0%)  	movq	48+56+8(%rsp),%rbx
 35,360 (0.0%)  	negq	%rsi
 35,360 (0.0%)  	movq	0(%rbp),%rax
 35,360 (0.0%)  	adcq	0(%rdi),%r8
 35,360 (0.0%)  	adcq	8(%rdi),%r9
 35,360 (0.0%)  	adcq	16(%rdi),%r10
 35,360 (0.0%)  	adcq	24(%rdi),%r11
 35,360 (0.0%)  	adcq	32(%rdi),%r12
 35,360 (0.0%)  	adcq	40(%rdi),%r13
 35,360 (0.0%)  	adcq	48(%rdi),%r14
 35,360 (0.0%)  	adcq	56(%rdi),%r15
 35,360 (0.0%)  	sbbq	%rsi,%rsi
      .         
 35,360 (0.0%)  	movl	$8,%ecx
 35,360 (0.0%)  	jmp	.L8x_tail
      .         
      .         .align	32
      .         .L8x_tail_done:
 16,912 (0.0%)  	xorq	%rax,%rax
 16,912 (0.0%)  	addq	(%rdx),%r8
 16,912 (0.0%)  	adcq	$0,%r9
 16,912 (0.0%)  	adcq	$0,%r10
 16,912 (0.0%)  	adcq	$0,%r11
 16,912 (0.0%)  	adcq	$0,%r12
 16,912 (0.0%)  	adcq	$0,%r13
 16,912 (0.0%)  	adcq	$0,%r14
 16,912 (0.0%)  	adcq	$0,%r15
 16,912 (0.0%)  	adcq	$0,%rax
      .         
 16,912 (0.0%)  	negq	%rsi
      .         .L8x_no_tail:
 16,912 (0.0%)  	adcq	0(%rdi),%r8
 16,912 (0.0%)  	adcq	8(%rdi),%r9
 16,912 (0.0%)  	adcq	16(%rdi),%r10
 16,912 (0.0%)  	adcq	24(%rdi),%r11
 16,912 (0.0%)  	adcq	32(%rdi),%r12
 16,912 (0.0%)  	adcq	40(%rdi),%r13
 16,912 (0.0%)  	adcq	48(%rdi),%r14
 16,912 (0.0%)  	adcq	56(%rdi),%r15
 16,912 (0.0%)  	adcq	$0,%rax
 16,912 (0.0%)  	movq	-8(%rbp),%rcx
 33,824 (0.0%)  	xorq	%rsi,%rsi
      .         
      .         .byte	102,72,15,126,213
      .         
 16,912 (0.0%)  	movq	%r8,0(%rdi)
 33,824 (0.0%)  	movq	%r9,8(%rdi)
      .         .byte	102,73,15,126,217
 16,912 (0.0%)  	movq	%r10,16(%rdi)
 16,912 (0.0%)  	movq	%r11,24(%rdi)
 16,912 (0.0%)  	movq	%r12,32(%rdi)
 16,912 (0.0%)  	movq	%r13,40(%rdi)
 16,912 (0.0%)  	movq	%r14,48(%rdi)
 16,912 (0.0%)  	movq	%r15,56(%rdi)
 16,912 (0.0%)  	leaq	64(%rdi),%rdi
      .         
 16,912 (0.0%)  	cmpq	%rdx,%rdi
 21,092 (0.0%)  	jb	.L8x_reduction_loop
      .         	.byte	0xf3,0xc3
      .         .cfi_endproc	
      .         .size	bn_sqr8x_internal,.-bn_sqr8x_internal
      .         .type	__bn_post4x_internal,@function
      .         .align	32
      .         __bn_post4x_internal:
      .         .cfi_startproc	
  4,090 (0.0%)  	movq	0(%rbp),%r12
  4,090 (0.0%)  	leaq	(%rdi,%r9,1),%rbx
  8,180 (0.0%)  	movq	%r9,%rcx
      .         .byte	102,72,15,126,207
  8,180 (0.0%)  	negq	%rax
      .         .byte	102,72,15,126,206
  4,090 (0.0%)  	sarq	$3+2,%rcx
  4,090 (0.0%)  	decq	%r12
  4,090 (0.0%)  	xorq	%r10,%r10
  4,090 (0.0%)  	movq	8(%rbp),%r13
  4,090 (0.0%)  	movq	16(%rbp),%r14
  4,090 (0.0%)  	movq	24(%rbp),%r15
  4,090 (0.0%)  	jmp	.Lsqr4x_sub_entry
      .         
      .         .align	16
      .         .Lsqr4x_sub:
 34,566 (0.0%)  	movq	0(%rbp),%r12
 34,566 (0.0%)  	movq	8(%rbp),%r13
 34,566 (0.0%)  	movq	16(%rbp),%r14
 34,566 (0.0%)  	movq	24(%rbp),%r15
      .         .Lsqr4x_sub_entry:
 39,504 (0.0%)  	leaq	32(%rbp),%rbp
 39,504 (0.0%)  	notq	%r12
 39,504 (0.0%)  	notq	%r13
 39,504 (0.0%)  	notq	%r14
 39,504 (0.0%)  	notq	%r15
 39,504 (0.0%)  	andq	%rax,%r12
 39,504 (0.0%)  	andq	%rax,%r13
 39,504 (0.0%)  	andq	%rax,%r14
 39,504 (0.0%)  	andq	%rax,%r15
      .         
 39,504 (0.0%)  	negq	%r10
 39,504 (0.0%)  	adcq	0(%rbx),%r12
 39,504 (0.0%)  	adcq	8(%rbx),%r13
 39,504 (0.0%)  	adcq	16(%rbx),%r14
 39,504 (0.0%)  	adcq	24(%rbx),%r15
 39,504 (0.0%)  	movq	%r12,0(%rdi)
 39,504 (0.0%)  	leaq	32(%rbx),%rbx
 39,504 (0.0%)  	movq	%r13,8(%rdi)
 39,504 (0.0%)  	sbbq	%r10,%r10
 39,504 (0.0%)  	movq	%r14,16(%rdi)
 39,504 (0.0%)  	movq	%r15,24(%rdi)
 39,504 (0.0%)  	leaq	32(%rdi),%rdi
      .         
 39,504 (0.0%)  	incq	%rcx
 39,504 (0.0%)  	jnz	.Lsqr4x_sub
      .         
  4,938 (0.0%)  	movq	%r9,%r10
  9,876 (0.0%)  	negq	%r9
      .         	.byte	0xf3,0xc3
      .         .cfi_endproc	
      .         .size	__bn_post4x_internal,.-__bn_post4x_internal
      .         .type	bn_mulx4x_mont_gather5,@function
      .         .align	32
      .         bn_mulx4x_mont_gather5:
      .         .cfi_startproc	
      .         	movq	%rsp,%rax
-- line 2071 ----------------------------------------
-- line 3411 ----------------------------------------
      .         .cfi_endproc	
      .         .size	__bn_postx4x_internal,.-__bn_postx4x_internal
      .         .globl	bn_scatter5
      .         .hidden bn_scatter5
      .         .type	bn_scatter5,@function
      .         .align	16
      .         bn_scatter5:
      .         .cfi_startproc	
     64 (0.0%)  	cmpl	$0,%esi
     64 (0.0%)  	jz	.Lscatter_epilogue
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
     64 (0.0%)  	leaq	(%rdx,%rcx,8),%rdx
      .         .Lscatter:
  2,048 (0.0%)  	movq	(%rdi),%rax
  2,048 (0.0%)  	leaq	8(%rdi),%rdi
  2,048 (0.0%)  	movq	%rax,(%rdx)
  2,048 (0.0%)  	leaq	256(%rdx),%rdx
  2,048 (0.0%)  	subl	$1,%esi
  2,116 (0.0%)  	jnz	.Lscatter
      .         .Lscatter_epilogue:
      .         	.byte	0xf3,0xc3
      .         .cfi_endproc	
      .         .size	bn_scatter5,.-bn_scatter5
      .         
      .         .globl	bn_gather5
      .         .hidden bn_gather5
      .         .type	bn_gather5,@function
-- line 3445 ----------------------------------------
-- line 3446 ----------------------------------------
      .         .align	32
      .         bn_gather5:
      .         .cfi_startproc	
      .         .LSEH_begin_bn_gather5:
      .         
      .         .byte	0x4c,0x8d,0x14,0x24
      .         .cfi_def_cfa_register	%r10
      .         .byte	0x48,0x81,0xec,0x08,0x01,0x00,0x00
      2 (0.0%)  	leaq	.Linc(%rip),%rax
      2 (0.0%)  	andq	$-16,%rsp
      .         
      2 (0.0%)  	movd	%ecx,%xmm5
      2 (0.0%)  	movdqa	0(%rax),%xmm0
      2 (0.0%)  	movdqa	16(%rax),%xmm1
      2 (0.0%)  	leaq	128(%rdx),%r11
      2 (0.0%)  	leaq	128(%rsp),%rax
      .         
      2 (0.0%)  	pshufd	$0,%xmm5,%xmm5
      2 (0.0%)  	movdqa	%xmm1,%xmm4
      2 (0.0%)  	movdqa	%xmm1,%xmm2
      2 (0.0%)  	paddd	%xmm0,%xmm1
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm0
      2 (0.0%)  	movdqa	%xmm4,%xmm3
      .         
      2 (0.0%)  	paddd	%xmm1,%xmm2
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm1
      2 (0.0%)  	movdqa	%xmm0,-128(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm0
      .         
      2 (0.0%)  	paddd	%xmm2,%xmm3
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm2
      2 (0.0%)  	movdqa	%xmm1,-112(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm1
      .         
      2 (0.0%)  	paddd	%xmm3,%xmm0
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm3
      2 (0.0%)  	movdqa	%xmm2,-96(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm2
      2 (0.0%)  	paddd	%xmm0,%xmm1
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm0
      2 (0.0%)  	movdqa	%xmm3,-80(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm3
      .         
      2 (0.0%)  	paddd	%xmm1,%xmm2
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm1
      2 (0.0%)  	movdqa	%xmm0,-64(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm0
      .         
      2 (0.0%)  	paddd	%xmm2,%xmm3
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm2
      2 (0.0%)  	movdqa	%xmm1,-48(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm1
      .         
      2 (0.0%)  	paddd	%xmm3,%xmm0
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm3
      2 (0.0%)  	movdqa	%xmm2,-32(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm2
      2 (0.0%)  	paddd	%xmm0,%xmm1
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm0
      2 (0.0%)  	movdqa	%xmm3,-16(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm3
      .         
      2 (0.0%)  	paddd	%xmm1,%xmm2
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm1
      2 (0.0%)  	movdqa	%xmm0,0(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm0
      .         
      2 (0.0%)  	paddd	%xmm2,%xmm3
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm2
      2 (0.0%)  	movdqa	%xmm1,16(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm1
      .         
      2 (0.0%)  	paddd	%xmm3,%xmm0
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm3
      2 (0.0%)  	movdqa	%xmm2,32(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm2
      2 (0.0%)  	paddd	%xmm0,%xmm1
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm0
      2 (0.0%)  	movdqa	%xmm3,48(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm3
      .         
      2 (0.0%)  	paddd	%xmm1,%xmm2
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm1
      2 (0.0%)  	movdqa	%xmm0,64(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm0
      .         
      2 (0.0%)  	paddd	%xmm2,%xmm3
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm2
      2 (0.0%)  	movdqa	%xmm1,80(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm1
      .         
      2 (0.0%)  	paddd	%xmm3,%xmm0
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm3
      2 (0.0%)  	movdqa	%xmm2,96(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm2
      2 (0.0%)  	movdqa	%xmm3,112(%rax)
      2 (0.0%)  	jmp	.Lgather
      .         
      .         .align	32
      .         .Lgather:
     64 (0.0%)  	pxor	%xmm4,%xmm4
     64 (0.0%)  	pxor	%xmm5,%xmm5
     64 (0.0%)  	movdqa	-128(%r11),%xmm0
     64 (0.0%)  	movdqa	-112(%r11),%xmm1
     64 (0.0%)  	movdqa	-96(%r11),%xmm2
     64 (0.0%)  	pand	-128(%rax),%xmm0
     64 (0.0%)  	movdqa	-80(%r11),%xmm3
     64 (0.0%)  	pand	-112(%rax),%xmm1
     64 (0.0%)  	por	%xmm0,%xmm4
     64 (0.0%)  	pand	-96(%rax),%xmm2
     64 (0.0%)  	por	%xmm1,%xmm5
     64 (0.0%)  	pand	-80(%rax),%xmm3
     64 (0.0%)  	por	%xmm2,%xmm4
     64 (0.0%)  	por	%xmm3,%xmm5
     64 (0.0%)  	movdqa	-64(%r11),%xmm0
     64 (0.0%)  	movdqa	-48(%r11),%xmm1
     64 (0.0%)  	movdqa	-32(%r11),%xmm2
     64 (0.0%)  	pand	-64(%rax),%xmm0
     64 (0.0%)  	movdqa	-16(%r11),%xmm3
     64 (0.0%)  	pand	-48(%rax),%xmm1
     64 (0.0%)  	por	%xmm0,%xmm4
     64 (0.0%)  	pand	-32(%rax),%xmm2
     64 (0.0%)  	por	%xmm1,%xmm5
     64 (0.0%)  	pand	-16(%rax),%xmm3
     64 (0.0%)  	por	%xmm2,%xmm4
     64 (0.0%)  	por	%xmm3,%xmm5
     64 (0.0%)  	movdqa	0(%r11),%xmm0
     64 (0.0%)  	movdqa	16(%r11),%xmm1
     64 (0.0%)  	movdqa	32(%r11),%xmm2
     64 (0.0%)  	pand	0(%rax),%xmm0
     64 (0.0%)  	movdqa	48(%r11),%xmm3
     64 (0.0%)  	pand	16(%rax),%xmm1
     64 (0.0%)  	por	%xmm0,%xmm4
     64 (0.0%)  	pand	32(%rax),%xmm2
     64 (0.0%)  	por	%xmm1,%xmm5
     64 (0.0%)  	pand	48(%rax),%xmm3
     64 (0.0%)  	por	%xmm2,%xmm4
     64 (0.0%)  	por	%xmm3,%xmm5
     64 (0.0%)  	movdqa	64(%r11),%xmm0
     64 (0.0%)  	movdqa	80(%r11),%xmm1
     64 (0.0%)  	movdqa	96(%r11),%xmm2
     64 (0.0%)  	pand	64(%rax),%xmm0
     64 (0.0%)  	movdqa	112(%r11),%xmm3
     64 (0.0%)  	pand	80(%rax),%xmm1
     64 (0.0%)  	por	%xmm0,%xmm4
     64 (0.0%)  	pand	96(%rax),%xmm2
     64 (0.0%)  	por	%xmm1,%xmm5
     64 (0.0%)  	pand	112(%rax),%xmm3
     64 (0.0%)  	por	%xmm2,%xmm4
     64 (0.0%)  	por	%xmm3,%xmm5
     64 (0.0%)  	por	%xmm5,%xmm4
     64 (0.0%)  	leaq	256(%r11),%r11
      .         
     64 (0.0%)  	pshufd	$0x4e,%xmm4,%xmm0
     64 (0.0%)  	por	%xmm4,%xmm0
     64 (0.0%)  	movq	%xmm0,(%rdi)
     64 (0.0%)  	leaq	8(%rdi),%rdi
     64 (0.0%)  	subl	$1,%esi
     64 (0.0%)  	jnz	.Lgather
      .         
      4 (0.0%)  	leaq	(%r10),%rsp
      .         .cfi_def_cfa_register	%rsp
      .         	.byte	0xf3,0xc3
      .         .LSEH_end_bn_gather5:
      .         .cfi_endproc	
      .         .size	bn_gather5,.-bn_gather5
      .         .section	.rodata
      .         .align	64
      .         .Linc:
-- line 3614 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 18 ----------------------------------------
      .         #include <sys/param.h>
      .         
      .         #include "error/s2n_errno.h"
      .         #include "utils/s2n_blob.h"
      .         #include "utils/s2n_mem.h"
      .         #include "utils/s2n_safety.h"
      .         
      .         S2N_RESULT s2n_stuffer_validate(const struct s2n_stuffer *stuffer)
315,588 (0.2%)  {
      .             /**
      .              * Note that we do not assert any properties on the tainted field,
      .              * as any boolean value in that field is valid.
      .              */
105,196 (0.1%)      RESULT_ENSURE_REF(stuffer);
420,784 (0.3%)      RESULT_GUARD(s2n_blob_validate(&stuffer->blob));
477,288 (0.3%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(stuffer->growable, stuffer->alloced), S2N_ERR_SAFETY);
      .         
      .             /* <= is valid because we can have a fully written/read stuffer */
473,382 (0.3%)      RESULT_DEBUG_ENSURE(stuffer->high_water_mark <= stuffer->blob.size, S2N_ERR_SAFETY);
473,382 (0.3%)      RESULT_DEBUG_ENSURE(stuffer->write_cursor <= stuffer->high_water_mark, S2N_ERR_SAFETY);
473,382 (0.3%)      RESULT_DEBUG_ENSURE(stuffer->read_cursor <= stuffer->write_cursor, S2N_ERR_SAFETY);
 52,598 (0.0%)      return S2N_RESULT_OK;
157,794 (0.1%)  }
      .         
      .         S2N_RESULT s2n_stuffer_reservation_validate(const struct s2n_stuffer_reservation *reservation)
      .         {
      .             /**
      .              * Note that we need two dereferences here to decrease proof complexity
      .              * for CBMC (see https://github.com/awslabs/s2n/issues/2290). We can roll back
      .              * this change once CBMC can handle common subexpression elimination.
      .              */
-- line 48 ----------------------------------------
-- line 56 ----------------------------------------
      .             /* The entire reservation must fit between the stuffer read and write cursors */
      .             RESULT_ENSURE_LTE(reserve_obj.write_cursor + reserve_obj.length, stuffer_obj.write_cursor);
      .             RESULT_ENSURE_GTE(reserve_obj.write_cursor, stuffer_obj.read_cursor);
      .         
      .             return S2N_RESULT_OK;
      .         }
      .         
      .         int s2n_stuffer_init(struct s2n_stuffer *stuffer, struct s2n_blob *in)
     70 (0.0%)  {
     20 (0.0%)      POSIX_ENSURE_MUT(stuffer);
    150 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(in));
     80 (0.0%)      stuffer->blob = *in;
     20 (0.0%)      stuffer->read_cursor = 0;
     20 (0.0%)      stuffer->write_cursor = 0;
     20 (0.0%)      stuffer->high_water_mark = 0;
     40 (0.0%)      stuffer->alloced = 0;
     40 (0.0%)      stuffer->growable = 0;
     40 (0.0%)      stuffer->tainted = 0;
    150 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     10 (0.0%)      return S2N_SUCCESS;
     30 (0.0%)  }
      .         
      .         int s2n_stuffer_init_written(struct s2n_stuffer *stuffer, struct s2n_blob *in)
      .         {
      .             POSIX_ENSURE_REF(in);
      .             POSIX_GUARD(s2n_stuffer_init(stuffer, in));
      .             POSIX_GUARD(s2n_stuffer_skip_write(stuffer, in->size));
      .             return S2N_SUCCESS;
      .         }
      .         
      .         int s2n_stuffer_alloc(struct s2n_stuffer *stuffer, const uint32_t size)
     42 (0.0%)  {
     12 (0.0%)      POSIX_ENSURE_REF(stuffer);
     30 (0.0%)      *stuffer = (struct s2n_stuffer){ 0 };
     42 (0.0%)      POSIX_GUARD(s2n_alloc(&stuffer->blob, size));
     42 (0.0%)      POSIX_GUARD(s2n_stuffer_init(stuffer, &stuffer->blob));
      .         
     24 (0.0%)      stuffer->alloced = 1;
      .         
     90 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
      6 (0.0%)      return S2N_SUCCESS;
     18 (0.0%)  }
      .         
      .         int s2n_stuffer_growable_alloc(struct s2n_stuffer *stuffer, const uint32_t size)
     18 (0.0%)  {
     21 (0.0%)      POSIX_GUARD(s2n_stuffer_alloc(stuffer, size));
      .         
     12 (0.0%)      stuffer->growable = 1;
      .         
     45 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
      3 (0.0%)      return S2N_SUCCESS;
      6 (0.0%)  }
      .         
      .         int s2n_stuffer_free(struct s2n_stuffer *stuffer)
     30 (0.0%)  {
     90 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
     30 (0.0%)      if (stuffer->alloced) {
     30 (0.0%)          POSIX_GUARD(s2n_free(&stuffer->blob));
      .             }
     30 (0.0%)      *stuffer = (struct s2n_stuffer){ 0 };
      6 (0.0%)      return S2N_SUCCESS;
     12 (0.0%)  }
      .         
      .         int s2n_stuffer_free_without_wipe(struct s2n_stuffer *stuffer)
      .         {
      .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
      .             if (stuffer->alloced) {
      .                 POSIX_GUARD(s2n_free_without_wipe(&stuffer->blob));
      .             }
      .             *stuffer = (struct s2n_stuffer){ 0 };
-- line 125 ----------------------------------------
-- line 170 ----------------------------------------
      .                 POSIX_ENSURE(stuffer->growable, S2N_ERR_RESIZE_STATIC_STUFFER);
      .                 POSIX_GUARD(s2n_realloc(&stuffer->blob, size));
      .             }
      .             POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
      .             return S2N_SUCCESS;
      .         }
      .         
      .         int s2n_stuffer_rewrite(struct s2n_stuffer *stuffer)
    535 (0.0%)  {
  1,605 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    214 (0.0%)      stuffer->write_cursor = 0;
    214 (0.0%)      stuffer->read_cursor = 0;
  1,605 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    107 (0.0%)      return S2N_SUCCESS;
    214 (0.0%)  }
      .         
      .         int s2n_stuffer_rewind_read(struct s2n_stuffer *stuffer, const uint32_t size)
      .         {
      .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
      .             POSIX_ENSURE(stuffer->read_cursor >= size, S2N_ERR_STUFFER_OUT_OF_DATA);
      .             stuffer->read_cursor -= size;
      .             POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
      .             return S2N_SUCCESS;
      .         }
      .         
      .         int s2n_stuffer_reread(struct s2n_stuffer *stuffer)
     25 (0.0%)  {
     75 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
     10 (0.0%)      stuffer->read_cursor = 0;
      5 (0.0%)      return S2N_SUCCESS;
     10 (0.0%)  }
      .         
      .         int s2n_stuffer_wipe_n(struct s2n_stuffer *stuffer, const uint32_t size)
      .         {
      .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
      .             uint32_t wipe_size = MIN(size, stuffer->write_cursor);
      .         
      .             stuffer->write_cursor -= wipe_size;
      .             stuffer->read_cursor = MIN(stuffer->read_cursor, stuffer->write_cursor);
-- line 208 ----------------------------------------
-- line 213 ----------------------------------------
      .         }
      .         
      .         bool s2n_stuffer_is_consumed(struct s2n_stuffer *stuffer)
      .         {
      .             return stuffer && (stuffer->read_cursor == stuffer->write_cursor) && !stuffer->tainted;
      .         }
      .         
      .         int s2n_stuffer_wipe(struct s2n_stuffer *stuffer)
      6 (0.0%)  {
     15 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
      4 (0.0%)      if (!s2n_stuffer_is_wiped(stuffer)) {
      .                 POSIX_CHECKED_MEMSET(stuffer->blob.data, S2N_WIPE_PATTERN, stuffer->high_water_mark);
      .             }
      .         
      4 (0.0%)      stuffer->tainted = 0;
      2 (0.0%)      stuffer->write_cursor = 0;
      2 (0.0%)      stuffer->read_cursor = 0;
      2 (0.0%)      stuffer->high_water_mark = 0;
     15 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
      1 (0.0%)      return S2N_SUCCESS;
      3 (0.0%)  }
      .         
      .         int s2n_stuffer_skip_read(struct s2n_stuffer *stuffer, uint32_t n)
 12,145 (0.0%)  {
 26,025 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 12,145 (0.0%)      POSIX_ENSURE(s2n_stuffer_data_available(stuffer) >= n, S2N_ERR_STUFFER_OUT_OF_DATA);
      .         
 10,410 (0.0%)      stuffer->read_cursor += n;
  1,735 (0.0%)      return S2N_SUCCESS;
  5,205 (0.0%)  }
      .         
      .         void *s2n_stuffer_raw_read(struct s2n_stuffer *stuffer, uint32_t data_len)
      6 (0.0%)  {
      7 (0.0%)      PTR_GUARD_POSIX(s2n_stuffer_skip_read(stuffer, data_len));
      .         
      4 (0.0%)      stuffer->tainted = 1;
      .         
     13 (0.0%)      return (stuffer->blob.data) ? (stuffer->blob.data + stuffer->read_cursor - data_len) : NULL;
      2 (0.0%)  }
      .         
      .         int s2n_stuffer_read(struct s2n_stuffer *stuffer, struct s2n_blob *out)
 12,138 (0.0%)  {
  3,468 (0.0%)      POSIX_ENSURE_REF(out);
      .         
 13,872 (0.0%)      return s2n_stuffer_read_bytes(stuffer, out->data, out->size);
  5,202 (0.0%)  }
      .         
      .         int s2n_stuffer_erase_and_read(struct s2n_stuffer *stuffer, struct s2n_blob *out)
      .         {
      .             POSIX_GUARD(s2n_stuffer_skip_read(stuffer, out->size));
      .         
      .             void *ptr = (stuffer->blob.data) ? (stuffer->blob.data + stuffer->read_cursor - out->size) : NULL;
      .             POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, out->size), S2N_ERR_NULL);
      .         
      .             POSIX_CHECKED_MEMCPY(out->data, ptr, out->size);
      .             POSIX_CHECKED_MEMSET(ptr, 0, out->size);
      .         
      .             return S2N_SUCCESS;
      .         }
      .         
      .         int s2n_stuffer_read_bytes(struct s2n_stuffer *stuffer, uint8_t *data, uint32_t size)
 13,872 (0.0%)  {
  3,468 (0.0%)      POSIX_ENSURE_REF(data);
 26,010 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 12,138 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_read(stuffer, size));
  6,936 (0.0%)      POSIX_ENSURE_REF(stuffer->blob.data);
 15,606 (0.0%)      void *ptr = stuffer->blob.data + stuffer->read_cursor - size;
      .         
 27,744 (0.0%)      POSIX_CHECKED_MEMCPY(data, ptr, size);
      .         
  1,734 (0.0%)      return S2N_SUCCESS;
  5,202 (0.0%)  }
      .         
      .         int s2n_stuffer_erase_and_read_bytes(struct s2n_stuffer *stuffer, uint8_t *data, uint32_t size)
      .         {
      .             POSIX_GUARD(s2n_stuffer_skip_read(stuffer, size));
      .             POSIX_ENSURE_REF(stuffer->blob.data);
      .             void *ptr = stuffer->blob.data + stuffer->read_cursor - size;
      .         
      .             POSIX_CHECKED_MEMCPY(data, ptr, size);
      .             POSIX_CHECKED_MEMSET(ptr, 0, size);
      .         
      .             return S2N_SUCCESS;
      .         }
      .         
      .         int s2n_stuffer_skip_write(struct s2n_stuffer *stuffer, const uint32_t n)
 52,002 (0.0%)  {
130,005 (0.1%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 60,669 (0.0%)      POSIX_GUARD(s2n_stuffer_reserve_space(stuffer, n));
 52,002 (0.0%)      stuffer->write_cursor += n;
 69,336 (0.0%)      stuffer->high_water_mark = MAX(stuffer->write_cursor, stuffer->high_water_mark);
130,005 (0.1%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  8,667 (0.0%)      return S2N_SUCCESS;
 17,334 (0.0%)  }
      .         
      .         void *s2n_stuffer_raw_write(struct s2n_stuffer *stuffer, const uint32_t data_len)
      .         {
      .             PTR_GUARD_POSIX(s2n_stuffer_skip_write(stuffer, data_len));
      .         
      .             stuffer->tainted = 1;
      .         
      .             return (stuffer->blob.data) ? (stuffer->blob.data + stuffer->write_cursor - data_len) : NULL;
-- line 314 ----------------------------------------
-- line 317 ----------------------------------------
      .         int s2n_stuffer_write(struct s2n_stuffer *stuffer, const struct s2n_blob *in)
      .         {
      .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
      .             POSIX_PRECONDITION(s2n_blob_validate(in));
      .             return s2n_stuffer_write_bytes(stuffer, in->data, in->size);
      .         }
      .         
      .         int s2n_stuffer_write_bytes(struct s2n_stuffer *stuffer, const uint8_t *data, const uint32_t size)
 55,480 (0.0%)  {
 27,740 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_SAFETY);
104,025 (0.1%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 48,545 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(stuffer, size));
      .         
 62,415 (0.0%)      void *ptr = stuffer->blob.data + stuffer->write_cursor - size;
 27,740 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, size), S2N_ERR_NULL);
      .         
 20,805 (0.0%)      if (ptr == data) {
      .                 POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
      .                 return S2N_SUCCESS;
      .             }
      .         
110,960 (0.1%)      POSIX_CHECKED_MEMCPY(ptr, data, size);
      .         
104,025 (0.1%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  6,935 (0.0%)      return S2N_SUCCESS;
 20,805 (0.0%)  }
      .         
      .         int s2n_stuffer_writev_bytes(struct s2n_stuffer *stuffer, const struct iovec *iov, size_t iov_count, uint32_t offs,
      .                 uint32_t size)
      .         {
      .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
      .             POSIX_ENSURE_REF(iov);
      .             void *ptr = s2n_stuffer_raw_write(stuffer, size);
      .             POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, size), S2N_ERR_NULL);
-- line 350 ----------------------------------------
-- line 382 ----------------------------------------
      .             uint8_t *to_ptr = (to->blob.data) ? (to->blob.data + to->write_cursor - len) : NULL;
      .         
      .             POSIX_CHECKED_MEMCPY(to_ptr, from_ptr, len);
      .         
      .             return S2N_SUCCESS;
      .         }
      .         
      .         int s2n_stuffer_reserve_space(struct s2n_stuffer *stuffer, uint32_t n)
 86,670 (0.1%)  {
130,005 (0.1%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 60,669 (0.0%)      if (s2n_stuffer_space_remaining(stuffer) < n) {
      .                 POSIX_ENSURE(stuffer->growable, S2N_ERR_STUFFER_IS_FULL);
      .                 /* Always grow a stuffer by at least 1k */
      .                 const uint32_t growth = MAX(n - s2n_stuffer_space_remaining(stuffer), S2N_MIN_STUFFER_GROWTH_IN_BYTES);
      .                 uint32_t new_size = 0;
      .                 POSIX_GUARD(s2n_add_overflow(stuffer->blob.size, growth, &new_size));
      .                 POSIX_GUARD(s2n_stuffer_resize(stuffer, new_size));
      .             }
130,005 (0.1%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  8,667 (0.0%)      return S2N_SUCCESS;
 52,002 (0.0%)  }
      .         
      .         /* Copies "len" bytes from "from" to "to".
      .          * If the copy cannot succeed (i.e. there are either not enough bytes available, or there is not enough space to write them
      .          * restore the old value of the stuffer */
      .         int s2n_stuffer_copy(struct s2n_stuffer *from, struct s2n_stuffer *to, const uint32_t len)
      .         {
      .             const uint32_t orig_read_cursor = from->read_cursor;
      .             const uint32_t orig_write_cursor = to->write_cursor;
-- line 410 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_base64.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 47 ----------------------------------------
     .             51, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
     .             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
     .             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
     .             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
     .             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
     .             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
     .         
     .         bool s2n_is_base64_char(unsigned char c)
35,190 (0.0%)  {
56,304 (0.0%)      return (b64_inverse[*((uint8_t *) (&c))] != 255);
14,076 (0.0%)  }
     .         
     .         /**
     .          * NOTE:
     .          * In general, shift before masking. This avoids needing to worry about how the
     .          * signed bit may be handled.
     .          */
     .         int s2n_stuffer_read_base64(struct s2n_stuffer *stuffer, struct s2n_stuffer *out)
 1,100 (0.0%)  {
 1,650 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 1,650 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(out));
   110 (0.0%)      int bytes_this_round = 3;
 1,760 (0.0%)      s2n_stack_blob(o, 4, 4);
     .         
     .             do {
14,712 (0.0%)          if (s2n_stuffer_data_available(stuffer) < o.size) {
   107 (0.0%)              break;
     .                 }
     .         
12,124 (0.0%)          POSIX_GUARD(s2n_stuffer_read(stuffer, &o));
     .         
12,124 (0.0%)          uint8_t value1 = b64_inverse[o.data[0]];
13,856 (0.0%)          uint8_t value2 = b64_inverse[o.data[1]];
13,856 (0.0%)          uint8_t value3 = b64_inverse[o.data[2]];
13,856 (0.0%)          uint8_t value4 = b64_inverse[o.data[3]];
     .         
     .                 /* We assume the entire thing is base64 data, thus, terminate cleanly if we encounter a non-base64 character */
 3,464 (0.0%)          if (value1 == 255) {
     .                     /* Undo the read */
     .                     stuffer->read_cursor -= o.size;
     .                     POSIX_BAIL(S2N_ERR_INVALID_BASE64);
     .                 }
     .         
     .                 /* The first two characters can never be '=' and in general
     .                  * everything has to be a valid character.
     .                  */
17,320 (0.0%)          POSIX_ENSURE(!(value1 == 64 || value2 == 64 || value2 == 255 || value3 == 255 || value4 == 255),
     .                         S2N_ERR_INVALID_BASE64);
     .         
 8,660 (0.0%)          if (o.data[2] == '=') {
     .                     /* If there is only one output byte, then the second value
     .                      * should have none of its bottom four bits set.
     .                      */
     9 (0.0%)              POSIX_ENSURE(!(o.data[3] != '=' || value2 & 0x0f), S2N_ERR_INVALID_BASE64);
     1 (0.0%)              bytes_this_round = 1;
     1 (0.0%)              value3 = 0;
     2 (0.0%)              value4 = 0;
 8,655 (0.0%)          } else if (o.data[3] == '=') {
     .                     /* The last two bits of the final value should be unset */
     8 (0.0%)              POSIX_ENSURE(!(value3 & 0x03), S2N_ERR_INVALID_BASE64);
     .         
     2 (0.0%)              bytes_this_round = 2;
     2 (0.0%)              value4 = 0;
     .                 }
     .         
     .                 /* Advance by bytes_this_round, and then fill in the data */
12,124 (0.0%)          POSIX_GUARD(s2n_stuffer_skip_write(out, bytes_this_round));
17,320 (0.0%)          uint8_t *ptr = out->blob.data + out->write_cursor - bytes_this_round;
     .         
     .                 /* value1 maps to the first 6 bits of the first data byte */
     .                 /* value2's top two bits are the rest */
15,588 (0.0%)          *ptr = ((value1 << 2) & 0xfc) | ((value2 >> 4) & 0x03);
     .         
 3,464 (0.0%)          if (bytes_this_round > 1) {
     .                     /* Put the next four bits in the second data byte */
     .                     /* Put the next four bits in the third data byte */
 1,731 (0.0%)              ptr++;
17,310 (0.0%)              *ptr = ((value2 << 4) & 0xf0) | ((value3 >> 2) & 0x0f);
     .                 }
     .         
 3,464 (0.0%)          if (bytes_this_round > 2) {
     .                     /* Put the next two bits in the third data byte */
     .                     /* Put the next six bits in the fourth data byte */
 1,729 (0.0%)              ptr++;
15,561 (0.0%)              *ptr = ((value3 << 6) & 0xc0) | (value4 & 0x3f);
     .                 }
 3,467 (0.0%)      } while (bytes_this_round == 3);
     .         
   110 (0.0%)      return S2N_SUCCESS;
   660 (0.0%)  }
     .         
     .         int s2n_stuffer_write_base64(struct s2n_stuffer *stuffer, struct s2n_stuffer *in)
     .         {
     .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
     .             POSIX_PRECONDITION(s2n_stuffer_validate(in));
     .             s2n_stack_blob(o, 4, 4);
     .             s2n_stack_blob(i, 3, 3);
     .         
-- line 144 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_pem.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 30 ----------------------------------------
     .         #define S2N_PEM_PKCS8_PRIVATE_KEY     "PRIVATE KEY"
     .         #define S2N_PEM_DH_PARAMETERS         "DH PARAMETERS"
     .         #define S2N_PEM_EC_PARAMETERS         "EC PARAMETERS"
     .         #define S2N_PEM_CERTIFICATE           "CERTIFICATE"
     .         #define S2N_PEM_CRL                   "X509 CRL"
     .         
     .         static int s2n_stuffer_pem_read_encapsulation_line(struct s2n_stuffer *pem, const char *encap_marker,
     .                 const char *keyword)
    63 (0.0%)  {
     .             /* Skip any number of Chars until a "-" is reached */
    54 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_to_char(pem, S2N_PEM_DELIMTER_CHAR));
     .         
     .             /* Ensure between 1 and 64 '-' chars at start of line */
    81 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_expected_char(pem, S2N_PEM_DELIMTER_CHAR, S2N_PEM_DELIMITER_MIN_COUNT,
     .                     S2N_PEM_DELIMITER_MAX_COUNT, NULL));
     .         
     .             /* Ensure next string in stuffer is "BEGIN " or "END " */
    63 (0.0%)      POSIX_GUARD(s2n_stuffer_read_expected_str(pem, encap_marker));
     .         
     .             /* Ensure next string is stuffer is the keyword (Eg "CERTIFICATE", "PRIVATE KEY", etc) */
    69 (0.0%)      POSIX_GUARD(s2n_stuffer_read_expected_str(pem, keyword));
     .         
     .             /* Ensure between 1 and 64 '-' chars at end of line */
    54 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_expected_char(pem, S2N_PEM_DELIMTER_CHAR, S2N_PEM_DELIMITER_MIN_COUNT,
     .                     S2N_PEM_DELIMITER_MAX_COUNT, NULL));
     .         
     .             /* Check for missing newline between dashes case: "-----END CERTIFICATE----------BEGIN CERTIFICATE-----" */
    48 (0.0%)      if (strncmp(encap_marker, S2N_PEM_END_TOKEN, strlen(S2N_PEM_END_TOKEN)) == 0
    21 (0.0%)              && s2n_stuffer_peek_check_for_str(pem, S2N_PEM_BEGIN_TOKEN) == S2N_SUCCESS) {
     .                 /* Rewind stuffer by 1 byte before BEGIN, so that next read will find the dash before the BEGIN */
     .                 POSIX_GUARD(s2n_stuffer_rewind_read(pem, 1));
     .             }
     .         
     .             /* Skip newlines and other whitepsace that may be after the dashes */
    24 (0.0%)      return s2n_stuffer_skip_whitespace(pem, NULL);
    18 (0.0%)  }
     .         
     .         static int s2n_stuffer_pem_read_begin(struct s2n_stuffer *pem, const char *keyword)
    36 (0.0%)  {
    36 (0.0%)      return s2n_stuffer_pem_read_encapsulation_line(pem, S2N_PEM_BEGIN_TOKEN, keyword);
    12 (0.0%)  }
     .         
     .         static int s2n_stuffer_pem_read_end(struct s2n_stuffer *pem, const char *keyword)
    18 (0.0%)  {
    18 (0.0%)      return s2n_stuffer_pem_read_encapsulation_line(pem, S2N_PEM_END_TOKEN, keyword);
     6 (0.0%)  }
     .         
     .         static int s2n_stuffer_pem_read_contents(struct s2n_stuffer *pem, struct s2n_stuffer *asn1)
    30 (0.0%)  {
    69 (0.0%)      s2n_stack_blob(base64__blob, 64, 64);
    12 (0.0%)      struct s2n_stuffer base64_stuffer = { 0 };
    21 (0.0%)      POSIX_GUARD(s2n_stuffer_init(&base64_stuffer, &base64__blob));
     .         
   110 (0.0%)      while (1) {
     .                 /* We need a byte... */
42,246 (0.0%)          POSIX_ENSURE(s2n_stuffer_data_available(pem) >= 1, S2N_ERR_STUFFER_OUT_OF_DATA);
     .         
     .                 /* Peek to see if the next char is a dash, meaning end of pem_contents */
56,328 (0.0%)          uint8_t c = pem->blob.data[pem->read_cursor];
21,123 (0.0%)          if (c == '-') {
     .                     break;
     .                 }
     .                 /* Else, move read pointer forward by 1 byte since we will be consuming it. */
35,190 (0.0%)          pem->read_cursor += 1;
     .         
     .                 /* Skip non-base64 characters */
49,266 (0.0%)          if (!s2n_is_base64_char(c)) {
   110 (0.0%)              continue;
     .                 }
     .         
     .                 /* Flush base64_stuffer to asn1 stuffer if we're out of space, and reset base64_stuffer read/write pointers */
27,712 (0.0%)          if (s2n_stuffer_space_remaining(&base64_stuffer) == 0) {
   749 (0.0%)              POSIX_GUARD(s2n_stuffer_read_base64(&base64_stuffer, asn1));
   535 (0.0%)              POSIX_GUARD(s2n_stuffer_rewrite(&base64_stuffer));
     .                 }
     .         
     .                 /* Copy next char to base64_stuffer */
55,424 (0.0%)          POSIX_GUARD(s2n_stuffer_write_bytes(&base64_stuffer, (uint8_t *) &c, 1));
     .             };
     .         
     .             /* Flush any remaining bytes to asn1 */
    24 (0.0%)      POSIX_GUARD(s2n_stuffer_read_base64(&base64_stuffer, asn1));
     .         
     3 (0.0%)      return S2N_SUCCESS;
    18 (0.0%)  }
     .         
     .         static int s2n_stuffer_data_from_pem(struct s2n_stuffer *pem, struct s2n_stuffer *asn1, const char *keyword)
    48 (0.0%)  {
    90 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(pem));
    90 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(asn1));
    12 (0.0%)      POSIX_ENSURE_REF(keyword);
     .         
    48 (0.0%)      POSIX_GUARD(s2n_stuffer_pem_read_begin(pem, keyword));
    21 (0.0%)      POSIX_GUARD(s2n_stuffer_pem_read_contents(pem, asn1));
    21 (0.0%)      POSIX_GUARD(s2n_stuffer_pem_read_end(pem, keyword));
     .         
    45 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(pem));
    45 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(asn1));
     3 (0.0%)      return S2N_SUCCESS;
    18 (0.0%)  }
     .         
     .         int s2n_stuffer_private_key_from_pem(struct s2n_stuffer *pem, struct s2n_stuffer *asn1, int *type)
     8 (0.0%)  {
    15 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(pem));
    15 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(asn1));
     2 (0.0%)      POSIX_ENSURE_REF(type);
     .         
     8 (0.0%)      if (s2n_stuffer_data_from_pem(pem, asn1, S2N_PEM_PKCS1_RSA_PRIVATE_KEY) == S2N_SUCCESS) {
     .                 *type = EVP_PKEY_RSA;
     .                 return S2N_SUCCESS;
     .             }
     .         
     5 (0.0%)      POSIX_GUARD(s2n_stuffer_reread(pem));
     5 (0.0%)      POSIX_GUARD(s2n_stuffer_reread(asn1));
     .         
     .             /* By default, OpenSSL tools always generate both "EC PARAMETERS" and "EC PRIVATE
     .              * KEY" PEM objects in the keyfile. Skip the first "EC PARAMETERS" object so that we're
     .              * compatible with OpenSSL's default output, and since "EC PARAMETERS" is
     .              * only needed for non-standard curves that aren't currently supported.
     .              */
     8 (0.0%)      if (s2n_stuffer_data_from_pem(pem, asn1, S2N_PEM_EC_PARAMETERS) != S2N_SUCCESS) {
     5 (0.0%)          POSIX_GUARD(s2n_stuffer_reread(pem));
     .             }
     5 (0.0%)      POSIX_GUARD(s2n_stuffer_wipe(asn1));
     .         
     8 (0.0%)      if (s2n_stuffer_data_from_pem(pem, asn1, S2N_PEM_PKCS1_EC_PRIVATE_KEY) == S2N_SUCCESS) {
     .                 *type = EVP_PKEY_EC;
     .                 return S2N_SUCCESS;
     .             }
     .         
     .             /* If it does not match either format, try PKCS#8 */
     5 (0.0%)      POSIX_GUARD(s2n_stuffer_reread(pem));
     5 (0.0%)      POSIX_GUARD(s2n_stuffer_reread(asn1));
     8 (0.0%)      if (s2n_stuffer_data_from_pem(pem, asn1, S2N_PEM_PKCS8_PRIVATE_KEY) == S2N_SUCCESS) {
     2 (0.0%)          *type = EVP_PKEY_RSA;
     2 (0.0%)          return S2N_SUCCESS;
     .             }
     .         
     .             POSIX_BAIL(S2N_ERR_INVALID_PEM);
     3 (0.0%)  }
     .         
     .         int s2n_stuffer_certificate_from_pem(struct s2n_stuffer *pem, struct s2n_stuffer *asn1)
    12 (0.0%)  {
    12 (0.0%)      return s2n_stuffer_data_from_pem(pem, asn1, S2N_PEM_CERTIFICATE);
     4 (0.0%)  }
     .         
     .         int s2n_stuffer_crl_from_pem(struct s2n_stuffer *pem, struct s2n_stuffer *asn1)
     .         {
     .             return s2n_stuffer_data_from_pem(pem, asn1, S2N_PEM_CRL);
     .         }
     .         
     .         int s2n_stuffer_dhparams_from_pem(struct s2n_stuffer *pem, struct s2n_stuffer *pkcs3)
     .         {
-- line 182 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 19 ----------------------------------------
      .         #include <string.h>
      .         #include <sys/param.h>
      .         
      .         #include "api/s2n.h"
      .         #include "error/s2n_errno.h"
      .         #include "utils/s2n_safety.h"
      .         
      .         S2N_RESULT s2n_blob_validate(const struct s2n_blob *b)
316,758 (0.2%)  {
105,586 (0.1%)      RESULT_ENSURE_REF(b);
369,684 (0.2%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->data == NULL, b->size == 0), S2N_ERR_SAFETY);
369,684 (0.2%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->data == NULL, b->allocated == 0), S2N_ERR_SAFETY);
741,054 (0.5%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->growable == 0, b->allocated == 0), S2N_ERR_SAFETY);
487,711 (0.3%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->growable != 0, b->size <= b->allocated), S2N_ERR_SAFETY);
420,392 (0.3%)      RESULT_DEBUG_ENSURE(S2N_MEM_IS_READABLE(b->data, b->allocated), S2N_ERR_SAFETY);
738,969 (0.5%)      RESULT_DEBUG_ENSURE(S2N_MEM_IS_READABLE(b->data, b->size), S2N_ERR_SAFETY);
 52,793 (0.0%)      return S2N_RESULT_OK;
158,379 (0.1%)  }
      .         
      .         int s2n_blob_init(struct s2n_blob *b, uint8_t *data, uint32_t size)
    968 (0.0%)  {
    242 (0.0%)      POSIX_ENSURE_REF(b);
    484 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_SAFETY);
  1,452 (0.0%)      *b = (struct s2n_blob){ .data = data, .size = size, .allocated = 0, .growable = 0 };
  1,815 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(b));
    121 (0.0%)      return S2N_SUCCESS;
    363 (0.0%)  }
      .         
      .         int s2n_blob_zero(struct s2n_blob *b)
     96 (0.0%)  {
    240 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(b));
    302 (0.0%)      POSIX_CHECKED_MEMSET(b->data, 0, MAX(b->allocated, b->size));
    240 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(b));
     16 (0.0%)      return S2N_SUCCESS;
     48 (0.0%)  }
      .         
      .         int s2n_blob_slice(const struct s2n_blob *b, struct s2n_blob *slice, uint32_t offset, uint32_t size)
     12 (0.0%)  {
     15 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(b));
     15 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(slice));
      .         
      1 (0.0%)      uint32_t slice_size = 0;
      8 (0.0%)      POSIX_GUARD(s2n_add_overflow(offset, size, &slice_size));
      5 (0.0%)      POSIX_ENSURE(b->size >= slice_size, S2N_ERR_SIZE_MISMATCH);
     11 (0.0%)      slice->data = (b->data) ? (b->data + offset) : NULL;
      3 (0.0%)      slice->size = size;
      4 (0.0%)      slice->growable = 0;
      2 (0.0%)      slice->allocated = 0;
      .         
     15 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(slice));
      1 (0.0%)      return S2N_SUCCESS;
      6 (0.0%)  }
      .         
      .         int s2n_blob_char_to_lower(struct s2n_blob *b)
     10 (0.0%)  {
     30 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(b));
    122 (0.0%)      for (size_t i = 0; i < b->size; i++) {
    270 (0.0%)          b->data[i] = tolower(b->data[i]);
      .             }
     30 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(b));
      2 (0.0%)      return S2N_SUCCESS;
      4 (0.0%)  }
      .         
      .         /* An inverse map from an ascii value to a hexidecimal nibble value
      .          * accounts for all possible char values, where 255 is invalid value */
      .         static const uint8_t hex_inverse[256] = {
      .             /* clang-format off */
      .             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      .             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      .             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-- line 88 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_ensure.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 11 ----------------------------------------
     .          * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
     .          * express or implied. See the License for the specific language governing
     .          * permissions and limitations under the License.
     .          */
     .         
     .         #include "utils/s2n_safety.h"
     .         
     .         void *s2n_ensure_memmove_trace(void *to, const void *from, size_t size)
69,408 (0.0%)  {
17,352 (0.0%)      PTR_ENSURE_REF(to);
17,352 (0.0%)      PTR_ENSURE_REF(from);
     .         
     .             /* use memmove instead of memcpy since it'll handle overlapping regions and not result in UB */
60,732 (0.0%)      void *result = memmove(to, from, size);
17,352 (0.0%)      PTR_ENSURE_REF(result);
 8,676 (0.0%)      return result;
26,028 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 79 ----------------------------------------
      .         #include "utils/s2n_result.h"
      .         
      .         #include <stdbool.h>
      .         
      .         #include "api/s2n.h"
      .         
      .         /* returns true when the result is S2N_RESULT_OK */
      .         inline bool s2n_result_is_ok(s2n_result result)
633,096 (0.4%)  {
474,822 (0.3%)      return result.__error_signal == S2N_SUCCESS;
316,548 (0.2%)  }
      .         
      .         /* returns true when the result is S2N_RESULT_ERROR */
      .         inline bool s2n_result_is_error(s2n_result result)
      .         {
      .             return result.__error_signal == S2N_FAILURE;
      .         }
      .         
      .         /* ignores the returned result of a function */
-- line 97 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir_________________ 

153,260,458 (98.9%)    annotated: files known & above threshold & readable, line numbers known
          0            annotated: files known & above threshold & readable, line numbers unknown
          0          unannotated: files known & above threshold & two or more non-identical
    169,627  (0.1%)  unannotated: files known & above threshold & unreadable 
  1,523,501  (1.0%)  unannotated: files known & below threshold
     13,662  (0.0%)  unannotated: files unknown

