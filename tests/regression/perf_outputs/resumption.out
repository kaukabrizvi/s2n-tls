--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate cachegrind.out.187591
Command:          target/debug/resumption
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir__________________ 

663,510,254 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir________________________  file:function

< 169,800,183 (25.6%, 25.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c:
   57,446,640  (8.7%)           base64_ascii_to_bin
   41,211,720  (6.2%)           constant_time_in_range_8
   31,845,420  (4.8%)           constant_time_lt_args_8
   22,424,772  (3.4%)           aws_lc_0_19_0_EVP_DecodeUpdate
   16,857,615  (2.5%)           base64_decode_quad

< 144,456,558 (21.8%, 47.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont5.S:
  110,679,210 (16.7%)           aws_lc_0_19_0_bn_sqr8x_internal
   31,398,048  (4.7%)           mul4x_internal
    2,229,680  (0.3%)           __bn_post4x_internal

<  95,543,268 (14.4%, 61.8%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h:
   26,225,640  (4.0%)           constant_time_msb_w
   26,225,640  (4.0%)           constant_time_is_zero_w
   22,479,120  (3.4%)           constant_time_eq_8
   20,605,860  (3.1%)           constant_time_eq_w

<  30,853,886  (4.7%, 66.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h:
   11,613,798  (1.8%)           constant_time_select_w
    8,848,608  (1.3%)           value_barrier_w
    3,079,424  (0.5%)           constant_time_select_int
    1,634,992  (0.2%)           constant_time_lt_w
    1,348,550  (0.2%)           constant_time_is_zero_w
    1,347,507  (0.2%)           constant_time_msb_w
    1,057,892  (0.2%)           constant_time_eq_w

<  27,036,089  (4.1%, 70.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c:
    8,261,089  (1.2%)           cbs_get
    5,594,535  (0.8%)           aws_lc_0_19_0_CBS_get_u8
    3,332,175  (0.5%)           cbs_get_any_asn1_element
    1,988,968  (0.3%)           aws_lc_0_19_0_CBS_len
    1,609,024  (0.2%)           parse_asn1_tag
    1,309,320  (0.2%)           aws_lc_0_19_0_CBS_init
    1,159,125  (0.2%)           aws_lc_0_19_0_CBS_get_any_ber_asn1_element
    1,149,270  (0.2%)           aws_lc_0_19_0_CBS_get_bytes
      767,620  (0.1%)           aws_lc_0_19_0_CBS_skip

<  20,834,701  (3.1%, 73.6%)  ./malloc/./malloc/malloc.c:
    7,563,347  (1.1%)           _int_malloc
    5,926,020  (0.9%)           _int_free
    3,949,997  (0.6%)           malloc
    2,490,908  (0.4%)           free

<  13,550,441  (2.0%, 75.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c:
    9,694,764  (1.5%)           aws_lc_0_19_0_bn_rshift1_words
    2,960,812  (0.4%)           aws_lc_0_19_0_bn_rshift_words

<  13,025,555  (2.0%, 77.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c:
    4,570,902  (0.7%)           asn1_item_ex_i2d_opt
    2,980,748  (0.4%)           asn1_template_ex_i2d
    2,757,867  (0.4%)           asn1_ex_i2c
    2,111,512  (0.3%)           asn1_i2d_ex_primitive

<  12,897,181  (1.9%, 79.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c:
    3,607,680  (0.5%)           aws_lc_0_19_0_OPENSSL_free
    2,806,720  (0.4%)           aws_lc_0_19_0_OPENSSL_malloc
    1,316,490  (0.2%)           aws_lc_0_19_0_OPENSSL_cleanse
    1,168,302  (0.2%)           aws_lc_0_19_0_OPENSSL_isspace
    1,117,903  (0.2%)           aws_lc_0_19_0_OPENSSL_zalloc
      726,048  (0.1%)           __asan_unpoison_memory_region
      726,048  (0.1%)           __asan_poison_memory_region

<  12,470,855  (1.9%, 81.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c:
    4,356,402  (0.7%)           asn1_item_ex_d2i
    2,159,678  (0.3%)           asn1_check_tlen
    1,988,685  (0.3%)           asn1_template_noexp_d2i
    1,710,862  (0.3%)           asn1_d2i_ex_primitive
    1,156,671  (0.2%)           asn1_template_ex_d2i
      950,742  (0.1%)           asn1_ex_c2i

<  11,146,412  (1.7%, 83.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c:
    8,516,884  (1.3%)           aws_lc_0_19_0_bn_select_words
    1,283,882  (0.2%)           aws_lc_0_19_0_bn_fits_in_words

<   9,217,913  (1.4%, 84.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c:
    4,847,753  (0.7%)           aws_lc_0_19_0_bn_add_words
    3,190,090  (0.5%)           aws_lc_0_19_0_bn_sub_words
      837,560  (0.1%)           aws_lc_0_19_0_bn_mul_add_words

<   7,342,915  (1.1%, 85.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c:
    1,548,774  (0.2%)           cbb_add_u
    1,260,630  (0.2%)           cbb_buffer_reserve
      936,468  (0.1%)           aws_lc_0_19_0_CBB_add_space
      920,736  (0.1%)           aws_lc_0_19_0_CBB_flush
      892,584  (0.1%)           cbb_get_base
      864,432  (0.1%)           cbb_buffer_add

<   6,192,977  (0.9%, 86.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c:
    2,982,073  (0.4%)           aws_lc_0_19_0_ASN1_get_object
    1,227,795  (0.2%)           aws_lc_0_19_0_ASN1_object_size
      781,346  (0.1%)           aws_lc_0_19_0_ASN1_put_object

<   5,998,082  (0.9%, 87.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c:
    2,044,001  (0.3%)           aws_lc_0_19_0_asn1_get_field_ptr
    1,283,104  (0.2%)           aws_lc_0_19_0_asn1_do_adb
    1,064,121  (0.2%)           asn1_get_enc_ptr

<   5,459,369  (0.8%, 88.3%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c:
    3,692,928  (0.6%)           aws_lc_0_19_0_X509_NAME_cmp
    1,766,045  (0.3%)           aws_lc_0_19_0_X509_subject_name_cmp

<   5,162,904  (0.8%, 89.1%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c:
    3,210,153  (0.5%)           s2n_stuffer_validate

<   4,941,597  (0.7%, 89.8%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c:
    2,910,951  (0.4%)           aws_lc_0_19_0_asn1_item_combine_free
      937,236  (0.1%)           aws_lc_0_19_0_ASN1_template_free
      922,575  (0.1%)           aws_lc_0_19_0_ASN1_primitive_free

<   4,539,631  (0.7%, 90.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c:
    2,908,780  (0.4%)           x509_object_cmp
    1,558,260  (0.2%)           x509_object_cmp_sk

<   4,535,618  (0.7%, 91.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/cmp.c:
    4,324,318  (0.7%)           bn_cmp_words_consttime

<   4,434,258  (0.7%, 91.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c:
    2,145,829  (0.3%)           asn1_item_ex_combine_new
      948,183  (0.1%)           ASN1_template_new
      764,436  (0.1%)           ASN1_primitive_new

<   4,219,874  (0.6%, 92.5%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c:
    4,183,674  (0.6%)           s2n_blob_validate

<   4,058,736  (0.6%, 93.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c:
    1,750,944  (0.3%)           aws_lc_0_19_0_cbs_get_latin1
      740,784  (0.1%)           aws_lc_0_19_0_cbb_add_utf8

<   3,379,016  (0.5%, 93.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/stack/stack.c:
      852,238  (0.1%)           aws_lc_0_19_0_OPENSSL_sk_insert

<   3,278,722  (0.5%, 94.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_mbstr.c:
    3,205,835  (0.5%)           aws_lc_0_19_0_ASN1_mbstring_ncopy

<   3,201,858  (0.5%, 94.6%)  ./stdlib/./stdlib/qsort.c:
    3,171,498  (0.5%)           msort_with_tmp.part.0

<   3,146,387  (0.5%, 95.1%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms

<   2,644,962  (0.4%, 95.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x_name.c:
    1,403,808  (0.2%)           asn1_string_canon

<   2,515,680  (0.4%, 95.8%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h:
    2,345,664  (0.4%)           OPENSSL_memset

<   2,078,884  (0.3%, 96.1%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:
    2,078,323  (0.3%)           __memcpy_avx_unaligned_erms

<   1,751,337  (0.3%, 96.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont.S:
    1,330,308  (0.2%)           bn_mul4x_mont

<   1,643,451  (0.2%, 96.7%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c:
    1,642,833  (0.2%)           s2n_result_is_ok

<   1,551,316  (0.2%, 96.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S:
      676,336  (0.1%)           __ecp_nistz256_mul_montq

<   1,146,496  (0.2%, 97.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/div.c:
      776,197  (0.1%)           aws_lc_0_19_0_bn_div_consttime

<   1,013,589  (0.2%, 97.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/pem/pem_lib.c:
      987,309  (0.1%)           aws_lc_0_19_0_PEM_read_bio

<     878,430  (0.1%, 97.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha256-x86_64.S:
      875,317  (0.1%)           sha256_block_data_order_avx

<     805,077  (0.1%, 97.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c:
      697,425  (0.1%)           aws_lc_0_19_0_OBJ_dup

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir________________________  function:file

> 110,679,210 (16.7%, 16.7%)  aws_lc_0_19_0_bn_sqr8x_internal:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont5.S

>  57,446,640  (8.7%, 25.3%)  base64_ascii_to_bin:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

>  41,211,720  (6.2%, 31.6%)  constant_time_in_range_8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

>  31,845,420  (4.8%, 36.3%)  constant_time_lt_args_8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

>  31,398,048  (4.7%, 41.1%)  mul4x_internal:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont5.S

>  27,574,190  (4.2%, 45.2%)  constant_time_is_zero_w:
   26,225,640  (4.0%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h
    1,348,550  (0.2%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>  27,573,147  (4.2%, 49.4%)  constant_time_msb_w:
   26,225,640  (4.0%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h
    1,347,507  (0.2%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>  22,479,120  (3.4%, 52.8%)  constant_time_eq_8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h

>  22,424,772  (3.4%, 56.2%)  aws_lc_0_19_0_EVP_DecodeUpdate:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

>  21,663,752  (3.3%, 59.4%)  constant_time_eq_w:
   20,605,860  (3.1%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h
    1,057,892  (0.2%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>  16,857,615  (2.5%, 62.0%)  base64_decode_quad:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

>  11,613,798  (1.8%, 63.7%)  constant_time_select_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>   9,694,764  (1.5%, 65.2%)  aws_lc_0_19_0_bn_rshift1_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c

>   8,848,608  (1.3%, 66.5%)  value_barrier_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>   8,516,884  (1.3%, 67.8%)  aws_lc_0_19_0_bn_select_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c

>   8,261,089  (1.2%, 69.0%)  cbs_get:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>   7,563,347  (1.1%, 70.2%)  _int_malloc:./malloc/./malloc/malloc.c

>   5,926,020  (0.9%, 71.1%)  _int_free:./malloc/./malloc/malloc.c

>   5,594,535  (0.8%, 71.9%)  aws_lc_0_19_0_CBS_get_u8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>   4,847,753  (0.7%, 72.6%)  aws_lc_0_19_0_bn_add_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c

>   4,570,902  (0.7%, 73.3%)  asn1_item_ex_i2d_opt:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>   4,356,402  (0.7%, 74.0%)  asn1_item_ex_d2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>   4,324,318  (0.7%, 74.6%)  bn_cmp_words_consttime:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/cmp.c

>   4,183,674  (0.6%, 75.3%)  s2n_blob_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c

>   4,051,170  (0.6%, 75.9%)  malloc:
    3,949,997  (0.6%)           ./malloc/./malloc/malloc.c

>   3,692,928  (0.6%, 76.4%)  aws_lc_0_19_0_X509_NAME_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c

>   3,607,680  (0.5%, 77.0%)  aws_lc_0_19_0_OPENSSL_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>   3,332,175  (0.5%, 77.5%)  cbs_get_any_asn1_element:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>   3,299,181  (0.5%, 78.0%)  msort_with_tmp.part.0:
    3,171,498  (0.5%)           ./stdlib/./stdlib/qsort.c

>   3,210,153  (0.5%, 78.5%)  s2n_stuffer_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>   3,205,835  (0.5%, 79.0%)  aws_lc_0_19_0_ASN1_mbstring_ncopy:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_mbstr.c

>   3,190,090  (0.5%, 79.4%)  aws_lc_0_19_0_bn_sub_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c

>   3,146,387  (0.5%, 79.9%)  __memset_avx2_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

>   3,079,424  (0.5%, 80.4%)  constant_time_select_int:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>   2,982,073  (0.4%, 80.8%)  aws_lc_0_19_0_ASN1_get_object:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c

>   2,980,748  (0.4%, 81.3%)  asn1_template_ex_i2d:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>   2,960,812  (0.4%, 81.7%)  aws_lc_0_19_0_bn_rshift_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c

>   2,910,951  (0.4%, 82.2%)  aws_lc_0_19_0_asn1_item_combine_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c

>   2,908,780  (0.4%, 82.6%)  x509_object_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c

>   2,830,760  (0.4%, 83.0%)  OPENSSL_memset:
    2,345,664  (0.4%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h

>   2,806,720  (0.4%, 83.4%)  aws_lc_0_19_0_OPENSSL_malloc:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>   2,757,867  (0.4%, 83.9%)  asn1_ex_i2c:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>   2,754,533  (0.4%, 84.3%)  free:
    2,490,908  (0.4%)           ./malloc/./malloc/malloc.c

>   2,229,680  (0.3%, 84.6%)  __bn_post4x_internal:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont5.S

>   2,159,678  (0.3%, 84.9%)  asn1_check_tlen:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>   2,145,829  (0.3%, 85.3%)  asn1_item_ex_combine_new:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c

>   2,111,512  (0.3%, 85.6%)  asn1_i2d_ex_primitive:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>   2,078,323  (0.3%, 85.9%)  __memcpy_avx_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

>   2,044,001  (0.3%, 86.2%)  aws_lc_0_19_0_asn1_get_field_ptr:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c

>   1,988,968  (0.3%, 86.5%)  aws_lc_0_19_0_CBS_len:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>   1,988,685  (0.3%, 86.8%)  asn1_template_noexp_d2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>   1,766,045  (0.3%, 87.1%)  aws_lc_0_19_0_X509_subject_name_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c

>   1,750,944  (0.3%, 87.3%)  aws_lc_0_19_0_cbs_get_latin1:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c

>   1,710,862  (0.3%, 87.6%)  asn1_d2i_ex_primitive:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>   1,642,833  (0.2%, 87.8%)  s2n_result_is_ok:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c

>   1,634,992  (0.2%, 88.1%)  constant_time_lt_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>   1,609,024  (0.2%, 88.3%)  parse_asn1_tag:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>   1,558,260  (0.2%, 88.6%)  x509_object_cmp_sk:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c

>   1,548,774  (0.2%, 88.8%)  cbb_add_u:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>   1,403,808  (0.2%, 89.0%)  asn1_string_canon:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x_name.c

>   1,330,308  (0.2%, 89.2%)  bn_mul4x_mont:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont.S

>   1,316,490  (0.2%, 89.4%)  aws_lc_0_19_0_OPENSSL_cleanse:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>   1,309,320  (0.2%, 89.6%)  aws_lc_0_19_0_CBS_init:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>   1,283,882  (0.2%, 89.8%)  aws_lc_0_19_0_bn_fits_in_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c

>   1,283,104  (0.2%, 90.0%)  aws_lc_0_19_0_asn1_do_adb:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c

>   1,260,630  (0.2%, 90.2%)  cbb_buffer_reserve:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>   1,227,795  (0.2%, 90.4%)  aws_lc_0_19_0_ASN1_object_size:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c

>   1,168,302  (0.2%, 90.5%)  aws_lc_0_19_0_OPENSSL_isspace:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>   1,159,125  (0.2%, 90.7%)  aws_lc_0_19_0_CBS_get_any_ber_asn1_element:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>   1,156,671  (0.2%, 90.9%)  asn1_template_ex_d2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>   1,149,270  (0.2%, 91.1%)  aws_lc_0_19_0_CBS_get_bytes:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>   1,117,903  (0.2%, 91.2%)  aws_lc_0_19_0_OPENSSL_zalloc:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>   1,064,121  (0.2%, 91.4%)  asn1_get_enc_ptr:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c

>     987,309  (0.1%, 91.5%)  aws_lc_0_19_0_PEM_read_bio:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/pem/pem_lib.c

>     950,742  (0.1%, 91.7%)  asn1_ex_c2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>     948,183  (0.1%, 91.8%)  ASN1_template_new:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c

>     937,236  (0.1%, 92.0%)  aws_lc_0_19_0_ASN1_template_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c

>     936,468  (0.1%, 92.1%)  aws_lc_0_19_0_CBB_add_space:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>     922,575  (0.1%, 92.2%)  aws_lc_0_19_0_ASN1_primitive_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c

>     920,736  (0.1%, 92.4%)  aws_lc_0_19_0_CBB_flush:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>     892,584  (0.1%, 92.5%)  cbb_get_base:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>     875,317  (0.1%, 92.6%)  sha256_block_data_order_avx:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha256-x86_64.S

>     864,432  (0.1%, 92.8%)  cbb_buffer_add:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>     852,238  (0.1%, 92.9%)  aws_lc_0_19_0_OPENSSL_sk_insert:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/stack/stack.c

>     837,560  (0.1%, 93.0%)  aws_lc_0_19_0_bn_mul_add_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c

>     781,346  (0.1%, 93.2%)  aws_lc_0_19_0_ASN1_put_object:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c

>     776,197  (0.1%, 93.3%)  aws_lc_0_19_0_bn_div_consttime:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/div.c

>     767,620  (0.1%, 93.4%)  aws_lc_0_19_0_CBS_skip:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>     764,436  (0.1%, 93.5%)  ASN1_primitive_new:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c

>     740,784  (0.1%, 93.6%)  aws_lc_0_19_0_cbb_add_utf8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c

>     726,048  (0.1%, 93.7%)  __asan_unpoison_memory_region:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>     726,048  (0.1%, 93.8%)  __asan_poison_memory_region:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>     697,425  (0.1%, 93.9%)  aws_lc_0_19_0_OBJ_dup:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c

>     676,336  (0.1%, 94.0%)  __ecp_nistz256_mul_montq:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

--------------------------------------------------------------------------------
-- Annotated source file: ./malloc/./malloc/malloc.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./malloc/./malloc/malloc.c

--------------------------------------------------------------------------------
-- Annotated source file: ./stdlib/./stdlib/qsort.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdlib/./stdlib/qsort.c

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_mbstr.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 69 ----------------------------------------
      .         // These functions take a string in UTF8, ASCII or multibyte form and a mask
      .         // of permissible ASN1 string types. It then works out the minimal type
      .         // (using the order Printable < IA5 < T61 < BMP < Universal < UTF8) and
      .         // creates a string of the correct type with the supplied data. Yes this is
      .         // horrible: it has to be :-( The 'ncopy' form checks minimum and maximum
      .         // size limits too.
      .         
      .         int ASN1_mbstring_copy(ASN1_STRING **out, const unsigned char *in,
 28,521 (0.0%)                         ossl_ssize_t len, int inform, unsigned long mask) {
 38,028 (0.0%)    return ASN1_mbstring_ncopy(out, in, len, inform, mask, /*minsize=*/0,
      .                                      /*maxsize=*/0);
  6,338 (0.0%)  }
      .         
      .         OPENSSL_DECLARE_ERROR_REASON(ASN1, INVALID_BMPSTRING)
      .         OPENSSL_DECLARE_ERROR_REASON(ASN1, INVALID_UNIVERSALSTRING)
      .         OPENSSL_DECLARE_ERROR_REASON(ASN1, INVALID_UTF8STRING)
      .         
      .         int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in,
      .                                 ossl_ssize_t len, int inform, unsigned long mask,
 41,197 (0.0%)                          ossl_ssize_t minsize, ossl_ssize_t maxsize) {
  6,338 (0.0%)    if (len == -1) {
      .             len = strlen((const char *)in);
      .           }
  6,338 (0.0%)    if (!mask) {
      .             mask = DIRSTRING_TYPE;
      .           }
      .         
      .           int (*decode_func)(CBS *, uint32_t *);
      .           int error;
 36,382 (0.0%)    switch (inform) {
      .             case MBSTRING_BMP:
      .               decode_func = cbs_get_ucs2_be;
      .               error = ASN1_R_INVALID_BMPSTRING;
      .               break;
      .         
      .             case MBSTRING_UNIV:
      .               decode_func = cbs_get_utf32_be;
      .               error = ASN1_R_INVALID_UNIVERSALSTRING;
      .               break;
      .         
      .             case MBSTRING_UTF8:
  1,646 (0.0%)        decode_func = cbs_get_utf8;
    823 (0.0%)        error = ASN1_R_INVALID_UTF8STRING;
    823 (0.0%)        break;
      .         
      .             case MBSTRING_ASC:
  4,692 (0.0%)        decode_func = cbs_get_latin1;
  2,346 (0.0%)        error = ERR_R_INTERNAL_ERROR;  // Latin-1 inputs are never invalid.
  2,346 (0.0%)        break;
      .         
      .             default:
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNKNOWN_FORMAT);
      .               return -1;
      .           }
      .         
      .           // Check |minsize| and |maxsize| and work out the minimal type, if any.
      .           CBS cbs;
 19,014 (0.0%)    CBS_init(&cbs, in, len);
  6,338 (0.0%)    size_t utf8_len = 0, nchar = 0;
269,229 (0.0%)    while (CBS_len(&cbs) != 0) {
      .             uint32_t c;
400,344 (0.1%)      if (!decode_func(&cbs, &c)) {
      .               OPENSSL_PUT_ERROR(ASN1, error);
      .               return -1;
      .             }
112,762 (0.0%)      if (nchar == 0 && (inform == MBSTRING_BMP || inform == MBSTRING_UNIV) &&
      .                 c == 0xfeff) {
      .               // Reject byte-order mark. We could drop it but that would mean
      .               // adding ambiguity around whether a BOM was included or not when
      .               // matching strings.
      .               //
      .               // For a little-endian UCS-2 string, the BOM will appear as 0xfffe
      .               // and will be rejected as noncharacter, below.
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_CHARACTERS);
      .               return -1;
      .             }
      .         
      .             // Update which output formats are still possible.
200,172 (0.0%)      if ((mask & B_ASN1_PRINTABLESTRING) && !asn1_is_printable(c)) {
      .               mask &= ~B_ASN1_PRINTABLESTRING;
      .             }
200,172 (0.0%)      if ((mask & B_ASN1_IA5STRING) && (c > 127)) {
      .               mask &= ~B_ASN1_IA5STRING;
      .             }
200,172 (0.0%)      if ((mask & B_ASN1_T61STRING) && (c > 0xff)) {
      .               mask &= ~B_ASN1_T61STRING;
      .             }
200,172 (0.0%)      if ((mask & B_ASN1_BMPSTRING) && (c > 0xffff)) {
      .               mask &= ~B_ASN1_BMPSTRING;
      .             }
100,086 (0.0%)      if (!mask) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_CHARACTERS);
      .               return -1;
      .             }
      .         
 50,043 (0.0%)      nchar++;
200,172 (0.0%)      utf8_len += cbb_get_utf8_len(c);
100,086 (0.0%)      if (maxsize > 0 && nchar > (size_t)maxsize) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_STRING_TOO_LONG);
      .         #if defined(OPENSSL_WINDOWS)
      .               ERR_add_error_dataf("maxsize=%lu", (unsigned long)maxsize);
      .         #else
      .               ERR_add_error_dataf("maxsize=%zu", (size_t)maxsize);
      .         #endif
      .               return -1;
      .             }
      .           }
      .         
  6,338 (0.0%)    if (minsize > 0 && nchar < (size_t)minsize) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_STRING_TOO_SHORT);
      .         #if defined(OPENSSL_WINDOWS)
      .             ERR_add_error_dataf("minsize=%lu", (unsigned long)minsize);
      .         #else
      .             ERR_add_error_dataf("minsize=%zu", (size_t)minsize);
      .         #endif
      .             return -1;
      .           }
      .         
      .           // Now work out output format and string type
      .           int str_type;
  6,338 (0.0%)    int (*encode_func)(CBB *, uint32_t) = cbb_add_latin1;
  6,338 (0.0%)    size_t size_estimate = nchar;
  3,169 (0.0%)    int outform = MBSTRING_ASC;
 12,676 (0.0%)    if (mask & B_ASN1_PRINTABLESTRING) {
      .             str_type = V_ASN1_PRINTABLESTRING;
 12,676 (0.0%)    } else if (mask & B_ASN1_IA5STRING) {
      .             str_type = V_ASN1_IA5STRING;
 12,676 (0.0%)    } else if (mask & B_ASN1_T61STRING) {
      .             str_type = V_ASN1_T61STRING;
 12,676 (0.0%)    } else if (mask & B_ASN1_BMPSTRING) {
      .             str_type = V_ASN1_BMPSTRING;
      .             outform = MBSTRING_BMP;
      .             encode_func = cbb_add_ucs2_be;
      .             size_estimate = 2 * nchar;
 12,676 (0.0%)    } else if (mask & B_ASN1_UNIVERSALSTRING) {
      .             str_type = V_ASN1_UNIVERSALSTRING;
      .             encode_func = cbb_add_utf32_be;
      .             size_estimate = 4 * nchar;
      .             outform = MBSTRING_UNIV;
 12,676 (0.0%)    } else if (mask & B_ASN1_UTF8STRING) {
  3,169 (0.0%)      str_type = V_ASN1_UTF8STRING;
  3,169 (0.0%)      outform = MBSTRING_UTF8;
  6,338 (0.0%)      encode_func = cbb_add_utf8;
  9,507 (0.0%)      size_estimate = utf8_len;
      .           } else {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_CHARACTERS);
      .             return -1;
      .           }
      .         
  6,338 (0.0%)    if (!out) {
      .             return str_type;
      .           }
      .         
  3,169 (0.0%)    int free_dest = 0;
      .           ASN1_STRING *dest;
 12,676 (0.0%)    if (*out) {
 12,676 (0.0%)      dest = *out;
      .           } else {
      .             free_dest = 1;
      .             dest = ASN1_STRING_type_new(str_type);
      .             if (!dest) {
      .               return -1;
      .             }
      .           }
      .         
      .           CBB cbb;
  9,507 (0.0%)    CBB_zero(&cbb);
      .           // If both the same type just copy across
  9,507 (0.0%)    if (inform == outform) {
  6,584 (0.0%)      if (!ASN1_STRING_set(dest, in, len)) {
      .               goto err;
      .             }
  2,469 (0.0%)      dest->type = str_type;
  2,469 (0.0%)      *out = dest;
  1,646 (0.0%)      return str_type;
      .           }
 18,768 (0.0%)    if (!CBB_init(&cbb, size_estimate + 1)) {
      .             goto err;
      .           }
 14,076 (0.0%)    CBS_init(&cbs, in, len);
182,436 (0.0%)    while (CBS_len(&cbs) != 0) {
      .             uint32_t c;
538,752 (0.1%)      if (!decode_func(&cbs, &c) || !encode_func(&cbb, c)) {
      .               OPENSSL_PUT_ERROR(ASN1, ERR_R_INTERNAL_ERROR);
      .               goto err;
      .             }
      .           }
  2,346 (0.0%)    uint8_t *data = NULL;
      .           size_t data_len;
  4,692 (0.0%)    if (// OpenSSL historically NUL-terminated this value with a single byte,
      .               // even for |MBSTRING_BMP| and |MBSTRING_UNIV|.
 32,844 (0.0%)        !CBB_add_u8(&cbb, 0) || !CBB_finish(&cbb, &data, &data_len) ||
 11,730 (0.0%)        data_len < 1 || data_len > INT_MAX) {
      .             OPENSSL_PUT_ERROR(ASN1, ERR_R_INTERNAL_ERROR);
      .             OPENSSL_free(data);
      .             goto err;
      .           }
  7,038 (0.0%)    dest->type = str_type;
 16,422 (0.0%)    ASN1_STRING_set0(dest, data, (int)data_len - 1);
  7,038 (0.0%)    *out = dest;
  4,692 (0.0%)    return str_type;
      .         
      .         err:
      .           if (free_dest) {
      .             ASN1_STRING_free(dest);
      .           }
      .           CBB_cleanup(&cbb);
      .           return -1;
 15,845 (0.0%)  }
      .         
      .         int asn1_is_printable(uint32_t value) {
      .           if (value > 0x7f) {
      .             return 0;
      .           }
      .           return OPENSSL_isalnum(value) || //
      .                  value == ' ' || value == '\'' || value == '(' || value == ')' ||
      .                  value == '+' || value == ',' || value == '-' || value == '.' ||
-- line 285 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 109 ----------------------------------------
      .         //
      .         // In particular, this limit is small enough that the bit count of a BIT STRING
      .         // comfortably fits in an |int|, with room for arithmetic.
      .         #define ASN1_STRING_MAX (64 * 1024 * 1024)
      .         
      .         static void asn1_put_length(unsigned char **pp, int length);
      .         
      .         int ASN1_get_object(const unsigned char **inp, long *out_len, int *out_tag,
421,500 (0.1%)                      int *out_class, long in_len) {
 70,250 (0.0%)    if (in_len < 0) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_HEADER_TOO_LONG);
      .             return 0x80;
      .           }
      .         
      .           // TODO(https://crbug.com/boringssl/354): This should use |CBS_get_asn1| to
      .           // reject non-minimal lengths, which are only allowed in BER. However,
      .           // Android sometimes needs allow a non-minimal length in certificate
      .           // signature fields (see b/18228011). Make this only apply to that field,
      .           // while requiring DER elsewhere. Better yet, it should be limited to an
      .           // preprocessing step in that part of Android.
      .           CBS_ASN1_TAG tag;
      .           size_t header_len;
      .           int indefinite;
      .           CBS cbs, body;
245,875 (0.0%)    CBS_init(&cbs, *inp, (size_t)in_len);
386,375 (0.1%)    if (!CBS_get_any_ber_asn1_element(&cbs, &body, &tag, &header_len,
105,375 (0.0%)                                      /*out_ber_found=*/NULL, &indefinite) ||
316,125 (0.0%)        indefinite || !CBS_skip(&body, header_len) ||
      .               // Bound the length to comfortably fit in an int. Lengths in this
      .               // module often switch between int and long without overflow checks.
105,375 (0.0%)        CBS_len(&body) > INT_MAX / 2) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_HEADER_TOO_LONG);
      .             return 0x80;
      .           }
      .         
      .           // Convert between tag representations.
140,500 (0.0%)    int tag_class = (tag & CBS_ASN1_CLASS_MASK) >> CBS_ASN1_TAG_SHIFT;
140,500 (0.0%)    int constructed = (tag & CBS_ASN1_CONSTRUCTED) >> CBS_ASN1_TAG_SHIFT;
105,375 (0.0%)    int tag_number = tag & CBS_ASN1_TAG_NUMBER_MASK;
      .         
      .           // To avoid ambiguity with V_ASN1_NEG, impose a limit on universal tags.
136,948 (0.0%)    if (tag_class == V_ASN1_UNIVERSAL && tag_number > V_ASN1_MAX_UNIVERSAL) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_HEADER_TOO_LONG);
      .             return 0x80;
      .           }
      .         
175,625 (0.0%)    *inp = CBS_data(&body);
210,750 (0.0%)    *out_len = CBS_len(&body);
105,375 (0.0%)    *out_tag = tag_number;
105,375 (0.0%)    *out_class = tag_class;
 35,125 (0.0%)    return constructed;
175,625 (0.0%)  }
      .         
      .         // class 0 is constructed constructed == 2 for indefinite length constructed
      .         void ASN1_put_object(unsigned char **pp, int constructed, int length, int tag,
178,644 (0.0%)                       int xclass) {
 44,661 (0.0%)    unsigned char *p = *pp;
      .           int i, ttag;
      .         
 66,770 (0.0%)    i = (constructed) ? V_ASN1_CONSTRUCTED : 0;
 44,661 (0.0%)    i |= (xclass & V_ASN1_PRIVATE);
 29,774 (0.0%)    if (tag < 31) {
178,644 (0.0%)      *(p++) = i | (tag & V_ASN1_PRIMITIVE_TAG);
      .           } else {
      .             *(p++) = i | V_ASN1_PRIMITIVE_TAG;
      .             for (i = 0, ttag = tag; ttag > 0; i++) {
      .               ttag >>= 7;
      .             }
      .             ttag = i;
      .             while (i-- > 0) {
      .               p[i] = tag & 0x7f;
      .               if (i != (ttag - 1)) {
      .                 p[i] |= 0x80;
      .               }
      .               tag >>= 7;
      .             }
      .             p += ttag;
      .           }
 29,774 (0.0%)    if (constructed == 2) {
      .             *(p++) = 0x80;
      .           } else {
 74,435 (0.0%)      asn1_put_length(&p, length);
      .           }
 44,661 (0.0%)    *pp = p;
 89,322 (0.0%)  }
      .         
      .         int ASN1_put_eoc(unsigned char **pp) {
      .           // This function is no longer used in the library, but some external code
      .           // uses it.
      .           unsigned char *p = *pp;
      .           *p++ = 0;
      .           *p++ = 0;
      .           *pp = p;
      .           return 2;
      .         }
      .         
 74,435 (0.0%)  static void asn1_put_length(unsigned char **pp, int length) {
 44,661 (0.0%)    unsigned char *p = *pp;
      .           int i, l;
 29,774 (0.0%)    if (length <= 127) {
 85,446 (0.0%)      *(p++) = (unsigned char)length;
      .           } else {
  1,292 (0.0%)      l = length;
  6,460 (0.0%)      for (i = 0; l > 0; i++) {
  1,292 (0.0%)        l >>= 8;
      .             }
  5,168 (0.0%)      *(p++) = i | 0x80;
  1,292 (0.0%)      l = i;
 10,336 (0.0%)      while (i-- > 0) {
  7,752 (0.0%)        p[i] = length & 0xff;
  1,292 (0.0%)        length >>= 8;
      .             }
  1,938 (0.0%)      p += l;
      .           }
 44,661 (0.0%)    *pp = p;
 44,661 (0.0%)  }
      .         
289,632 (0.0%)  int ASN1_object_size(int constructed, int length, int tag) {
 48,272 (0.0%)    int ret = 1;
 96,544 (0.0%)    if (length < 0) {
      .             return -1;
      .           }
 96,544 (0.0%)    if (tag >= 31) {
      .             while (tag > 0) {
      .               tag >>= 7;
      .               ret++;
      .             }
      .           }
 96,544 (0.0%)    if (constructed == 2) {
      .             ret += 3;
      .           } else {
 48,272 (0.0%)      ret++;
 96,544 (0.0%)      if (length > 127) {
  3,230 (0.0%)        int tmplen = length;
 11,305 (0.0%)        while (tmplen > 0) {
  3,230 (0.0%)          tmplen >>= 8;
  3,230 (0.0%)          ret++;
      .               }
      .             }
      .           }
193,088 (0.0%)    if (ret >= INT_MAX - length) {
      .             return -1;
      .           }
144,816 (0.0%)    return ret + length;
 96,544 (0.0%)  }
      .         
      .         int ASN1_STRING_copy(ASN1_STRING *dst, const ASN1_STRING *str) {
      .           if (str == NULL) {
      .             return 0;
      .           }
      .           if (!ASN1_STRING_set(dst, str->data, str->length)) {
      .             return 0;
      .           }
-- line 261 ----------------------------------------
-- line 275 ----------------------------------------
      .           }
      .           if (!ASN1_STRING_copy(ret, str)) {
      .             ASN1_STRING_free(ret);
      .             return NULL;
      .           }
      .           return ret;
      .         }
      .         
 50,939 (0.0%)  int ASN1_STRING_set(ASN1_STRING *str, const void *_data, ossl_ssize_t len_s) {
 14,554 (0.0%)    const char *data = _data;
      .           size_t len;
 14,554 (0.0%)    if (len_s < 0) {
      .             if (data == NULL) {
      .               return 0;
      .             }
      .             len = strlen(data);
      .           } else {
 14,554 (0.0%)      len = (size_t)len_s;
      .           }
      .         
      .           OPENSSL_STATIC_ASSERT(ASN1_STRING_MAX < INT_MAX, len_will_not_overflow_int);
 14,554 (0.0%)    if (len > ASN1_STRING_MAX) {
      .             OPENSSL_PUT_ERROR(ASN1, ERR_R_OVERFLOW);
      .             return 0;
      .           }
      .         
 36,385 (0.0%)    if (str->length <= (int)len || str->data == NULL) {
 21,831 (0.0%)      unsigned char *c = str->data;
 14,554 (0.0%)      if (c == NULL) {
 50,939 (0.0%)        str->data = OPENSSL_malloc(len + 1);
      .             } else {
      .               str->data = OPENSSL_realloc(c, len + 1);
      .             }
      .         
 29,108 (0.0%)      if (str->data == NULL) {
      .               str->data = c;
      .               return 0;
      .             }
      .           }
 29,108 (0.0%)    str->length = (int)len;
 14,554 (0.0%)    if (data != NULL) {
 50,939 (0.0%)      OPENSSL_memcpy(str->data, data, len);
      .             // Historically, OpenSSL would NUL-terminate most (but not all)
      .             // |ASN1_STRING|s, in case anyone accidentally passed |str->data| into a
      .             // function expecting a C string. We retain this behavior for compatibility,
      .             // but code must not rely on this. See CVE-2021-3712.
 36,385 (0.0%)      str->data[len] = '\0';
      .           }
  7,277 (0.0%)    return 1;
 14,554 (0.0%)  }
      .         
 16,422 (0.0%)  void ASN1_STRING_set0(ASN1_STRING *str, void *data, int len) {
  9,384 (0.0%)    OPENSSL_free(str->data);
  7,038 (0.0%)    str->data = data;
  7,038 (0.0%)    str->length = len;
  7,038 (0.0%)  }
      .         
      .         ASN1_STRING *ASN1_STRING_new(void) {
      .           return (ASN1_STRING_type_new(V_ASN1_OCTET_STRING));
      .         }
      .         
 52,530 (0.0%)  ASN1_STRING *ASN1_STRING_type_new(int type) {
      .           ASN1_STRING *ret;
      .         
 31,518 (0.0%)    ret = (ASN1_STRING *)OPENSSL_zalloc(sizeof(ASN1_STRING));
 21,012 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
 31,518 (0.0%)    ret->type = type;
 10,506 (0.0%)    return ret;
 21,012 (0.0%)  }
      .         
 68,970 (0.0%)  void ASN1_STRING_free(ASN1_STRING *str) {
 27,588 (0.0%)    if (str == NULL) {
  3,288 (0.0%)      return;
      .           }
 42,024 (0.0%)    OPENSSL_free(str->data);
 42,024 (0.0%)    OPENSSL_free(str);
 27,588 (0.0%)  }
      .         
      .         void ASN1_STRING_clear_free(ASN1_STRING *str) {
      .           ASN1_STRING_free(str);
      .         }
      .         
      .         int ASN1_STRING_cmp(const ASN1_STRING *a, const ASN1_STRING *b) {
      .           // Capture padding bits and implicit truncation in BIT STRINGs.
      .           int a_length = a->length, b_length = b->length;
-- line 361 ----------------------------------------
-- line 392 ----------------------------------------
      .             return -1;
      .           }
      .           if (a->type > b->type) {
      .             return 1;
      .           }
      .           return 0;
      .         }
      .         
      8 (0.0%)  int ASN1_STRING_length(const ASN1_STRING *str) { return str->length; }
      .         
      .         int ASN1_STRING_type(const ASN1_STRING *str) { return str->type; }
      .         
      8 (0.0%)  unsigned char *ASN1_STRING_data(ASN1_STRING *str) { return str->data; }
      .         
      .         const unsigned char *ASN1_STRING_get0_data(const ASN1_STRING *str) {
      .           return str->data;
      .         }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 121 ----------------------------------------
      .             B_ASN1_GRAPHICSTRING,
      .             B_ASN1_ISO64STRING,
      .             B_ASN1_GENERALSTRING,
      .             B_ASN1_UNIVERSALSTRING,
      .             B_ASN1_UNKNOWN,  // CHARACTER STRING
      .             B_ASN1_BMPSTRING,
      .         };
      .         
 28,872 (0.0%)  unsigned long ASN1_tag2bit(int tag) {
 28,872 (0.0%)    if (tag < 0 || tag > 30) {
      .             return 0;
      .           }
 36,090 (0.0%)    return tag2bit[tag];
 14,436 (0.0%)  }
      .         
      .         // Macro to initialize and invalidate the cache
      .         
      .         // Decode an ASN1 item, this currently behaves just like a standard 'd2i'
      .         // function. 'in' points to a buffer to read the data from, in future we
      .         // will have more advanced versions that can input data a piece at a time and
      .         // this will simply be a special case.
      .         
      .         ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
  4,939 (0.0%)                            const ASN1_ITEM *it) {
    449 (0.0%)    ASN1_VALUE *ptmpval = NULL;
    898 (0.0%)    if (!pval) {
    898 (0.0%)      pval = &ptmpval;
      .           }
      .         
  5,837 (0.0%)    if (asn1_item_ex_d2i(pval, in, len, it, -1, 0, 0, 0) > 0) {
  1,347 (0.0%)      return *pval;
      .           }
      .           return NULL;
  2,245 (0.0%)  }
      .         
      .         // Decode an item, taking care of IMPLICIT tagging, if any. If 'opt' set and
      .         // tag mismatch return -1 to handle OPTIONAL
      .         
      .         static int asn1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in,
      .                                     long len, const ASN1_ITEM *it, int tag, int aclass,
443,325 (0.1%)                              char opt, int depth) {
 29,555 (0.0%)    const ASN1_TEMPLATE *tt, *errtt = NULL;
      .           const ASN1_EXTERN_FUNCS *ef;
 29,555 (0.0%)    const unsigned char *p = NULL, *q;
      .           unsigned char oclass;
      .           char cst, isopt;
      .           int i;
      .           int otag;
 29,555 (0.0%)    int ret = 0;
      .           ASN1_VALUE **pchptr;
 88,665 (0.0%)    int combine = aclass & ASN1_TFLG_COMBINE;
 29,555 (0.0%)    aclass &= ~ASN1_TFLG_COMBINE;
118,220 (0.0%)    if (pval == NULL || it == NULL) {
      .             return 0;
      .           }
      .         
      .           // Bound |len| to comfortably fit in an int. Lengths in this module often
      .           // switch between int and long without overflow checks.
 88,665 (0.0%)    if (len > INT_MAX / 2) {
      .             len = INT_MAX / 2;
      .           }
      .         
 88,665 (0.0%)    if (++depth > ASN1_MAX_CONSTRUCTED_NEST) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_TOO_DEEP);
      .             goto err;
      .           }
      .         
384,215 (0.1%)    switch (it->itype) {
      .             case ASN1_ITYPE_PRIMITIVE:
 67,368 (0.0%)        if (it->templates) {
      .                 // tagging or OPTIONAL is currently illegal on an item template
      .                 // because the flags can't get passed down. In practice this
      .                 // isn't a problem: we include the relevant flags from the item
      .                 // template in the template itself.
 16,224 (0.0%)          if ((tag != -1) || opt) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
      .                   goto err;
      .                 }
 48,672 (0.0%)          return asn1_template_ex_d2i(pval, in, len, it->templates, opt, depth);
      .               }
166,218 (0.0%)        return asn1_d2i_ex_primitive(pval, in, len, it, tag, aclass, opt);
      .               break;
      .         
      .             case ASN1_ITYPE_MSTRING:
      .               // It never makes sense for multi-strings to have implicit tagging, so
      .               // if tag != -1, then this looks like an error in the template.
  8,100 (0.0%)        if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 goto err;
      .               }
      .         
 12,150 (0.0%)        p = *in;
      .               // Just read in tag and class
 64,800 (0.0%)        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, &p, len, -1, 0, 1);
  8,100 (0.0%)        if (!ret) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
      .         
      .               // Must be UNIVERSAL class
 12,150 (0.0%)        if (oclass != V_ASN1_UNIVERSAL) {
      .                 // If OPTIONAL, assume this is OK
      .                 if (opt) {
      .                   return -1;
      .                 }
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_MSTRING_NOT_UNIVERSAL);
      .                 goto err;
      .               }
      .               // Check tag matches bit map
 40,500 (0.0%)        if (!(ASN1_tag2bit(otag) & it->utype)) {
      .                 // If OPTIONAL, assume this is OK
      .                 if (opt) {
      .                   return -1;
      .                 }
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_MSTRING_WRONG_TAG);
      .                 goto err;
      .               }
 52,650 (0.0%)        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0);
      .         
      .             case ASN1_ITYPE_EXTERN:
      .               // Use new style d2i
  2,646 (0.0%)        ef = it->funcs;
 13,230 (0.0%)        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, NULL);
      .         
      .             case ASN1_ITYPE_CHOICE: {
      .               // It never makes sense for CHOICE types to have implicit tagging, so if
      .               // tag != -1, then this looks like an error in the template.
      8 (0.0%)        if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 goto err;
      .               }
      .         
     12 (0.0%)        const ASN1_AUX *aux = it->funcs;
     16 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
      8 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL)) {
      .                 goto auxerr;
      .               }
      .         
     16 (0.0%)        if (*pval) {
      .                 // Free up and zero CHOICE value if initialised
      .                 i = asn1_get_choice_selector(pval, it);
      .                 if ((i >= 0) && (i < it->tcount)) {
      .                   tt = it->templates + i;
      .                   pchptr = asn1_get_field_ptr(pval, tt);
      .                   ASN1_template_free(pchptr, tt);
      .                   asn1_set_choice_selector(pval, -1, it);
      .                 }
     28 (0.0%)        } else if (!ASN1_item_ex_new(pval, it)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
      .               // CHOICE type, try each possibility in turn
     12 (0.0%)        p = *in;
    108 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
     72 (0.0%)          pchptr = asn1_get_field_ptr(pval, tt);
      .                 // We mark field as OPTIONAL so its absence can be recognised.
    120 (0.0%)          ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, depth);
      .                 // If field not present, try the next one
     24 (0.0%)          if (ret == -1) {
      8 (0.0%)            continue;
      .                 }
      .                 // If positive return, read OK, break loop
      8 (0.0%)          if (ret > 0) {
      4 (0.0%)            break;
      .                 }
      .                 // Otherwise must be an ASN1 parsing error
      .                 errtt = tt;
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
      .         
      .               // Did we fall off the end without reading anything?
     24 (0.0%)        if (i == it->tcount) {
      .                 // If OPTIONAL, this is OK
      .                 if (opt) {
      .                   // Free and zero it
      .                   ASN1_item_ex_free(pval, it);
      .                   return -1;
      .                 }
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NO_MATCHING_CHOICE_TYPE);
      .                 goto err;
      .               }
      .         
     24 (0.0%)        asn1_set_choice_selector(pval, i, it);
      8 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL)) {
      .                 goto auxerr;
      .               }
     12 (0.0%)        *in = p;
      8 (0.0%)        return 1;
      .             }
      .         
      .             case ASN1_ITYPE_SEQUENCE: {
 23,331 (0.0%)        p = *in;
      .         
      .               // If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL
 15,554 (0.0%)        if (tag == -1) {
  7,773 (0.0%)          tag = V_ASN1_SEQUENCE;
  7,773 (0.0%)          aclass = V_ASN1_UNIVERSAL;
      .               }
      .               // Get SEQUENCE length and update len, p
155,540 (0.0%)        ret = asn1_check_tlen(&len, NULL, NULL, &cst, &p, len, tag, aclass, opt);
 15,554 (0.0%)        if (!ret) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
 15,554 (0.0%)        } else if (ret == -1) {
      8 (0.0%)          return -1;
      .               }
 23,319 (0.0%)        if (!cst) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
      .                 goto err;
      .               }
      .         
 66,981 (0.0%)        if (!*pval && !ASN1_item_ex_new(pval, it)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
      .         
 23,319 (0.0%)        const ASN1_AUX *aux = it->funcs;
 33,738 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
 23,484 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL)) {
      .                 goto auxerr;
      .               }
      .         
      .               // Free up and zero any ADB found
253,767 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
105,165 (0.0%)          if (tt->flags & ASN1_TFLG_ADB_MASK) {
      .                   const ASN1_TEMPLATE *seqtt;
      .                   ASN1_VALUE **pseqval;
      .                   seqtt = asn1_do_adb(pval, tt, 0);
      .                   if (seqtt == NULL) {
      .                     continue;
      .                   }
      .                   pseqval = asn1_get_field_ptr(pval, seqtt);
      .                   ASN1_template_free(pseqval, seqtt);
      .                 }
      .               }
      .         
      .               // Get each field entry
259,380 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
      .                 const ASN1_TEMPLATE *seqtt;
      .                 ASN1_VALUE **pseqval;
147,231 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
 42,066 (0.0%)          if (seqtt == NULL) {
      .                   goto err;
      .                 }
126,198 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
      .                 // Have we ran out of data?
 63,099 (0.0%)          if (!len) {
    240 (0.0%)            break;
      .                 }
 41,586 (0.0%)          q = p;
      .                 // This determines the OPTIONAL flag value. The field cannot be
      .                 // omitted if it is the last of a SEQUENCE and there is still
      .                 // data to be read. This isn't strictly necessary but it
      .                 // increases efficiency in some cases.
145,551 (0.0%)          if (i == (it->tcount - 1)) {
 15,066 (0.0%)            isopt = 0;
      .                 } else {
 79,560 (0.0%)            isopt = (seqtt->flags & ASN1_TFLG_OPTIONAL) != 0;
      .                 }
      .                 // attempt to read in field, allowing each to be OPTIONAL
      .         
228,723 (0.0%)          ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, depth);
 41,586 (0.0%)          if (!ret) {
      .                   errtt = seqtt;
      .                   goto err;
 41,586 (0.0%)          } else if (ret == -1) {
      .                   // OPTIONAL component absent. Free and zero the field.
  7,830 (0.0%)            ASN1_template_free(pseqval, seqtt);
  1,566 (0.0%)            continue;
      .                 }
      .                 // Update length
 96,135 (0.0%)          len -= p - q;
      .               }
      .         
      .               // Check all data read
 23,319 (0.0%)        if (len) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
      .                 goto err;
      .               }
      .         
      .               // If we get here we've got no more data in the SEQUENCE, however we
      .               // may not have read all fields so check all remaining are OPTIONAL
      .               // and clear any that are.
 48,558 (0.0%)        for (; i < it->tcount; tt++, i++) {
      .                 const ASN1_TEMPLATE *seqtt;
  1,680 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
    480 (0.0%)          if (seqtt == NULL) {
      .                   goto err;
      .                 }
  1,200 (0.0%)          if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
      .                   ASN1_VALUE **pseqval;
  1,440 (0.0%)            pseqval = asn1_get_field_ptr(pval, seqtt);
  1,440 (0.0%)            ASN1_template_free(pseqval, seqtt);
      .                 } else {
      .                   errtt = seqtt;
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_FIELD_MISSING);
      .                   goto err;
      .                 }
      .               }
      .               // Save encoding
116,595 (0.0%)        if (!asn1_enc_save(pval, *in, p - *in, it)) {
      .                 goto auxerr;
      .               }
 23,484 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL)) {
      .                 goto auxerr;
      .               }
 23,319 (0.0%)        *in = p;
 15,546 (0.0%)        return 1;
      .             }
      .         
      .             default:
      .               return 0;
      .           }
      .         auxerr:
      .           OPENSSL_PUT_ERROR(ASN1, ASN1_R_AUX_ERROR);
      .         err:
-- line 437 ----------------------------------------
-- line 439 ----------------------------------------
      .             ASN1_item_ex_free(pval, it);
      .           }
      .           if (errtt) {
      .             ERR_add_error_data(4, "Field=", errtt->field_name, ", Type=", it->sname);
      .           } else {
      .             ERR_add_error_data(2, "Type=", it->sname);
      .           }
      .           return 0;
147,775 (0.0%)  }
      .         
      .         int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
      .                              const ASN1_ITEM *it, int tag, int aclass, char opt,
 10,584 (0.0%)                       ASN1_TLC *ctx) {
 10,584 (0.0%)    return asn1_item_ex_d2i(pval, in, len, it, tag, aclass, opt, 0);
  1,764 (0.0%)  }
      .         
      .         // Templates are handled with two separate functions. One handles any
      .         // EXPLICIT tag and the other handles the rest.
      .         
      .         static int asn1_template_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                         long inlen, const ASN1_TEMPLATE *tt, char opt,
348,054 (0.1%)                                  int depth) {
      .           int aclass;
      .           int ret;
      .           long len;
      .           const unsigned char *p, *q;
 49,722 (0.0%)    if (!val) {
      .             return 0;
      .           }
 74,583 (0.0%)    uint32_t flags = tt->flags;
 74,583 (0.0%)    aclass = flags & ASN1_TFLG_TAG_CLASS;
      .         
 74,583 (0.0%)    p = *in;
      .         
      .           // Check if EXPLICIT tag expected
 99,444 (0.0%)    if (flags & ASN1_TFLG_EXPTAG) {
      .             char cst;
      .             // Need to work out amount of data available to the inner content and
      .             // where it starts: so read in EXPLICIT header to get the info.
 18,522 (0.0%)      ret = asn1_check_tlen(&len, NULL, NULL, &cst, &p, inlen, tt->tag, aclass,
      .                                   opt);
  1,764 (0.0%)      q = p;
  1,764 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
  1,764 (0.0%)      } else if (ret == -1) {
      .               return -1;
      .             }
  2,646 (0.0%)      if (!cst) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);
      .               return 0;
      .             }
      .             // We've found the field so it can't be OPTIONAL now
  8,820 (0.0%)      ret = asn1_template_noexp_d2i(val, &p, len, tt, 0, depth);
  1,764 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
      .             }
      .             // We read the field in OK so update length
  4,410 (0.0%)      len -= p - q;
      .             // Check for trailing data.
  2,646 (0.0%)      if (len) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_EXPLICIT_LENGTH_MISMATCH);
      .               goto err;
      .             }
      .           } else {
263,769 (0.0%)      return asn1_template_noexp_d2i(val, in, inlen, tt, opt, depth);
      .           }
      .         
  2,646 (0.0%)    *in = p;
    882 (0.0%)    return 1;
      .         
      .         err:
      .           ASN1_template_free(val, tt);
      .           return 0;
124,305 (0.0%)  }
      .         
      .         static int asn1_template_noexp_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                            long len, const ASN1_TEMPLATE *tt, char opt,
348,054 (0.1%)                                     int depth) {
      .           int aclass;
      .           int ret;
      .           const unsigned char *p;
 49,722 (0.0%)    if (!val) {
      .             return 0;
      .           }
 74,583 (0.0%)    uint32_t flags = tt->flags;
 74,583 (0.0%)    aclass = flags & ASN1_TFLG_TAG_CLASS;
      .         
 74,583 (0.0%)    p = *in;
      .         
 99,444 (0.0%)    if (flags & ASN1_TFLG_SK_MASK) {
      .             // SET OF, SEQUENCE OF
      .             int sktag, skaclass;
      .             // First work out expected inner tag value
 17,988 (0.0%)      if (flags & ASN1_TFLG_IMPTAG) {
      .               sktag = tt->tag;
      .               skaclass = aclass;
      .             } else {
  4,497 (0.0%)        skaclass = V_ASN1_UNIVERSAL;
 17,988 (0.0%)        if (flags & ASN1_TFLG_SET_OF) {
  6,336 (0.0%)          sktag = V_ASN1_SET;
      .               } else {
  1,329 (0.0%)          sktag = V_ASN1_SEQUENCE;
      .               }
      .             }
      .             // Get the tag
      .             ret =
 85,443 (0.0%)          asn1_check_tlen(&len, NULL, NULL, NULL, &p, len, sktag, skaclass, opt);
  8,994 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
  8,994 (0.0%)      } else if (ret == -1) {
      .               return -1;
      .             }
 17,988 (0.0%)      if (!*val) {
 17,988 (0.0%)        *val = (ASN1_VALUE *)sk_ASN1_VALUE_new_null();
      .             } else {
      .               // We've got a valid STACK: free up any items present
      .               STACK_OF(ASN1_VALUE) *sktmp = (STACK_OF(ASN1_VALUE) *)*val;
      .               ASN1_VALUE *vtmp;
      .               while (sk_ASN1_VALUE_num(sktmp) > 0) {
      .                 vtmp = sk_ASN1_VALUE_pop(sktmp);
      .                 ASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item));
      .               }
      .             }
      .         
 17,988 (0.0%)      if (!*val) {
      .               goto err;
      .             }
      .         
      .             // Read as many items as we can
 46,065 (0.0%)      while (len > 0) {
      .               ASN1_VALUE *skfield;
 15,720 (0.0%)        const unsigned char *q = p;
  7,860 (0.0%)        skfield = NULL;
117,900 (0.0%)        if (!asn1_item_ex_d2i(&skfield, &p, len, ASN1_ITEM_ptr(tt->item), -1, 0,
      .                                     0, depth)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
 39,300 (0.0%)        len -= p - q;
 62,880 (0.0%)        if (!sk_ASN1_VALUE_push((STACK_OF(ASN1_VALUE) *)*val, skfield)) {
      .                 ASN1_item_ex_free(&skfield, ASN1_ITEM_ptr(tt->item));
      .                 goto err;
      .               }
      .             }
 81,456 (0.0%)    } else if (flags & ASN1_TFLG_IMPTAG) {
      .             // IMPLICIT tagging
 15,198 (0.0%)      ret = asn1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), tt->tag,
      .                                    aclass, opt, depth);
  1,788 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               goto err;
  1,788 (0.0%)      } else if (ret == -1) {
  1,780 (0.0%)        return -1;
      .             }
      .           } else {
      .             // Nothing special
311,520 (0.0%)      ret = asn1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), -1,
 38,940 (0.0%)                             tt->flags & ASN1_TFLG_COMBINE, opt, depth);
 38,940 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               goto err;
 38,940 (0.0%)      } else if (ret == -1) {
  1,368 (0.0%)        return -1;
      .             }
      .           }
      .         
 69,861 (0.0%)    *in = p;
 46,574 (0.0%)    return 1;
      .         
      .         err:
      .           ASN1_template_free(val, tt);
      .           return 0;
124,305 (0.0%)  }
      .         
      .         static int asn1_d2i_ex_primitive(ASN1_VALUE **pval, const unsigned char **in,
      .                                          long inlen, const ASN1_ITEM *it, int tag,
252,540 (0.0%)                                   int aclass, char opt) {
 16,836 (0.0%)    int ret = 0, utype;
      .           long plen;
      .           char cst;
      .           const unsigned char *p;
 16,836 (0.0%)    const unsigned char *cont = NULL;
      .           long len;
 33,672 (0.0%)    if (!pval) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_NULL);
      .             return 0;  // Should never happen
      .           }
      .         
 67,344 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
  8,100 (0.0%)      utype = tag;
  8,100 (0.0%)      tag = -1;
      .           } else {
 38,358 (0.0%)      utype = it->utype;
      .           }
      .         
 50,508 (0.0%)    if (utype == V_ASN1_ANY) {
      .             // If type is ANY need to figure out type from tag
      .             unsigned char oclass;
  2,166 (0.0%)      if (tag >= 0) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_TAGGED_ANY);
      .               return 0;
      .             }
  2,166 (0.0%)      if (opt) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OPTIONAL_ANY);
      .               return 0;
      .             }
  3,249 (0.0%)      p = *in;
 17,328 (0.0%)      ret = asn1_check_tlen(NULL, &utype, &oclass, NULL, &p, inlen, -1, 0, 0);
  2,166 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
      .             }
  3,249 (0.0%)      if (oclass != V_ASN1_UNIVERSAL) {
      .               utype = V_ASN1_OTHER;
      .             }
      .           }
 33,672 (0.0%)    if (tag == -1) {
 31,892 (0.0%)      tag = utype;
 15,946 (0.0%)      aclass = V_ASN1_UNIVERSAL;
      .           }
 50,508 (0.0%)    p = *in;
      .           // Check header
336,720 (0.1%)    ret = asn1_check_tlen(&plen, NULL, NULL, &cst, &p, inlen, tag, aclass, opt);
 33,672 (0.0%)    if (!ret) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .             return 0;
 33,672 (0.0%)    } else if (ret == -1) {
  3,140 (0.0%)      return -1;
      .           }
 15,266 (0.0%)    ret = 0;
      .           // SEQUENCE, SET and "OTHER" are left in encoded form
122,128 (0.0%)    if ((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||
 15,266 (0.0%)        (utype == V_ASN1_OTHER)) {
      .             // SEQUENCE and SET must be constructed
      .             if (utype != V_ASN1_OTHER && !cst) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_TYPE_NOT_CONSTRUCTED);
      .               return 0;
      .             }
      .         
      .             cont = *in;
      .             len = p - cont + plen;
      .             p += plen;
 45,798 (0.0%)    } else if (cst) {
      .             // This parser historically supported BER constructed strings. We no
      .             // longer do and will gradually tighten this parser into a DER
      .             // parser. BER types should use |CBS_asn1_ber_to_der|.
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_TYPE_NOT_PRIMITIVE);
      .             return 0;
      .           } else {
 30,532 (0.0%)      cont = p;
 30,532 (0.0%)      len = plen;
 61,064 (0.0%)      p += plen;
      .           }
      .         
      .           // We now have content length and type: translate into a structure
152,660 (0.0%)    if (!asn1_ex_c2i(pval, cont, len, utype, it)) {
      .             goto err;
      .           }
      .         
 45,798 (0.0%)    *in = p;
 30,532 (0.0%)    ret = 1;
      .         err:
 15,266 (0.0%)    return ret;
 84,180 (0.0%)  }
      .         
      .         // Translate ASN1 content octets into a structure
      .         
      .         static int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, long len,
183,192 (0.0%)                         int utype, const ASN1_ITEM *it) {
 15,266 (0.0%)    ASN1_VALUE **opval = NULL;
      .           ASN1_STRING *stmp;
 15,266 (0.0%)    ASN1_TYPE *typ = NULL;
 15,266 (0.0%)    int ret = 0;
      .           ASN1_INTEGER **tint;
      .         
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of callbacks.
 61,064 (0.0%)    assert(it->funcs == NULL);
      .         
      .           // If ANY type clear type and set pointer to internal value
 61,064 (0.0%)    if (it->utype == V_ASN1_ANY) {
  4,332 (0.0%)      if (!*pval) {
  2,166 (0.0%)        typ = ASN1_TYPE_new();
  2,166 (0.0%)        if (typ == NULL) {
      .                 goto err;
      .               }
  4,332 (0.0%)        *pval = (ASN1_VALUE *)typ;
      .             } else {
      .               typ = (ASN1_TYPE *)*pval;
      .             }
      .         
  4,332 (0.0%)      if (utype != typ->type) {
  6,498 (0.0%)        ASN1_TYPE_set(typ, utype, NULL);
      .             }
  2,166 (0.0%)      opval = pval;
  3,249 (0.0%)      pval = &typ->value.asn1_value;
      .           }
120,228 (0.0%)    switch (utype) {
      .             case V_ASN1_OBJECT:
 49,048 (0.0%)        if (!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, &cont, len)) {
      .                 goto err;
      .               }
 12,262 (0.0%)        break;
      .         
      .             case V_ASN1_NULL:
  1,926 (0.0%)        if (len) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NULL_IS_WRONG_LENGTH);
      .                 goto err;
      .               }
  1,926 (0.0%)        *pval = (ASN1_VALUE *)1;
    963 (0.0%)        break;
      .         
      .             case V_ASN1_BOOLEAN:
  1,668 (0.0%)        if (len != 1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BOOLEAN_IS_WRONG_LENGTH);
      .                 goto err;
      .               } else {
      .                 ASN1_BOOLEAN *tbool;
  1,668 (0.0%)          tbool = (ASN1_BOOLEAN *)pval;
  4,170 (0.0%)          *tbool = *cont;
      .               }
    834 (0.0%)        break;
      .         
      .             case V_ASN1_BIT_STRING:
  7,072 (0.0%)        if (!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, &cont, len)) {
      .                 goto err;
      .               }
  1,768 (0.0%)        break;
      .         
      .             case V_ASN1_INTEGER:
      .             case V_ASN1_ENUMERATED:
  1,764 (0.0%)        tint = (ASN1_INTEGER **)pval;
  7,056 (0.0%)        if (!c2i_ASN1_INTEGER(tint, &cont, len)) {
      .                 goto err;
      .               }
      .               // Fixup type to match the expected form
  7,938 (0.0%)        (*tint)->type = utype | ((*tint)->type & V_ASN1_NEG);
    882 (0.0%)        break;
      .         
      .             case V_ASN1_OCTET_STRING:
      .             case V_ASN1_NUMERICSTRING:
      .             case V_ASN1_PRINTABLESTRING:
      .             case V_ASN1_T61STRING:
      .             case V_ASN1_VIDEOTEXSTRING:
      .             case V_ASN1_IA5STRING:
      .             case V_ASN1_UTCTIME:
-- line 787 ----------------------------------------
-- line 791 ----------------------------------------
      .             case V_ASN1_GENERALSTRING:
      .             case V_ASN1_UNIVERSALSTRING:
      .             case V_ASN1_BMPSTRING:
      .             case V_ASN1_UTF8STRING:
      .             case V_ASN1_OTHER:
      .             case V_ASN1_SET:
      .             case V_ASN1_SEQUENCE:
      .             default:
 11,144 (0.0%)        if (utype == V_ASN1_BMPSTRING && (len & 1)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
      .                 goto err;
      .               }
 11,144 (0.0%)        if (utype == V_ASN1_UNIVERSALSTRING && (len & 3)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
      .                 goto err;
      .               }
 11,144 (0.0%)        if (utype == V_ASN1_UTCTIME) {
      .                 CBS cbs;
  5,238 (0.0%)          CBS_init(&cbs, cont, (size_t)len);
  6,111 (0.0%)          if (!CBS_parse_utc_time(&cbs, NULL, /*allow_timezone_offset=*/1)) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_TIME_FORMAT);
      .                   goto err;
      .                 }
      .               }
 11,144 (0.0%)        if (utype == V_ASN1_GENERALIZEDTIME) {
      .                 CBS cbs;
     54 (0.0%)          CBS_init(&cbs, cont, (size_t)len);
     63 (0.0%)          if (!CBS_parse_generalized_time(&cbs, NULL,
      .                                                 /*allow_timezone_offset=*/0)) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_TIME_FORMAT);
      .                   goto err;
      .                 }
      .               }
      .               // All based on ASN1_STRING and handled the same
 22,288 (0.0%)        if (!*pval) {
     16 (0.0%)          stmp = ASN1_STRING_type_new(utype);
      8 (0.0%)          if (!stmp) {
      .                   goto err;
      .                 }
     16 (0.0%)          *pval = (ASN1_VALUE *)stmp;
      .               } else {
 16,704 (0.0%)          stmp = (ASN1_STRING *)*pval;
 16,704 (0.0%)          stmp->type = utype;
      .               }
 44,576 (0.0%)        if (!ASN1_STRING_set(stmp, cont, len)) {
      .                 ASN1_STRING_free(stmp);
      .                 *pval = NULL;
      .                 goto err;
      .               }
  5,572 (0.0%)        break;
      .           }
      .           // If ASN1_ANY and NULL type fix up value
 32,698 (0.0%)    if (typ && (utype == V_ASN1_NULL)) {
  1,926 (0.0%)      typ->value.ptr = NULL;
      .           }
      .         
 30,532 (0.0%)    ret = 1;
      .         err:
 30,532 (0.0%)    if (!ret) {
      .             ASN1_TYPE_free(typ);
      .             if (opval) {
      .               *opval = NULL;
      .             }
      .           }
 15,266 (0.0%)    return ret;
 76,330 (0.0%)  }
      .         
      .         // Check an ASN1 tag and length: a bit like ASN1_get_object but it
      .         // checks the expected tag.
      .         
      .         static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,
      .                                    char *cst, const unsigned char **in, long len,
526,875 (0.1%)                             int exptag, int expclass, char opt) {
      .           int i;
      .           int ptag, pclass;
      .           long plen;
      .           const unsigned char *p;
105,375 (0.0%)    p = *in;
      .         
316,125 (0.0%)    i = ASN1_get_object(&p, &plen, &ptag, &pclass, len);
140,500 (0.0%)    if (i & 0x80) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_OBJECT_HEADER);
      .             return 0;
      .           }
 70,250 (0.0%)    if (exptag >= 0) {
175,230 (0.0%)      if ((exptag != ptag) || (expclass != pclass)) {
      .               // If type is OPTIONAL, not an error: indicate missing type.
  3,148 (0.0%)        if (opt) {
  3,148 (0.0%)          return -1;
      .               }
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TAG);
      .               return 0;
      .             }
      .           }
      .         
 67,102 (0.0%)    if (cst) {
119,605 (0.0%)      *cst = i & V_ASN1_CONSTRUCTED;
      .           }
      .         
 67,102 (0.0%)    if (olen) {
 85,254 (0.0%)      *olen = plen;
      .           }
      .         
 67,102 (0.0%)    if (oclass) {
 20,532 (0.0%)      *oclass = pclass;
      .           }
      .         
 67,102 (0.0%)    if (otag) {
 15,399 (0.0%)      *otag = ptag;
      .           }
      .         
100,653 (0.0%)    *in = p;
 33,551 (0.0%)    return 1;
175,625 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 78 ----------------------------------------
      .         static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
      .                                     int skcontlen, const ASN1_ITEM *item, int do_sort);
      .         static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
      .                                         const ASN1_TEMPLATE *tt, int tag, int aclass,
      .                                         int optional);
      .         
      .         // Top level i2d equivalents
      .         
  4,430 (0.0%)  int ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it) {
  2,658 (0.0%)    if (out && !*out) {
      .             unsigned char *p, *buf;
  3,544 (0.0%)      int len = ASN1_item_ex_i2d(&val, NULL, it, /*tag=*/-1, /*aclass=*/0);
    886 (0.0%)      if (len <= 0) {
      .               return len;
      .             }
  2,215 (0.0%)      buf = OPENSSL_malloc(len);
    886 (0.0%)      if (!buf) {
      .               return -1;
      .             }
    886 (0.0%)      p = buf;
  3,544 (0.0%)      int len2 = ASN1_item_ex_i2d(&val, &p, it, /*tag=*/-1, /*aclass=*/0);
    886 (0.0%)      if (len2 <= 0) {
      .               OPENSSL_free(buf);
      .               return len2;
      .             }
  1,329 (0.0%)      assert(len == len2);
  1,329 (0.0%)      *out = buf;
    886 (0.0%)      return len;
      .           }
      .         
      .           return ASN1_item_ex_i2d(&val, out, it, /*tag=*/-1, /*aclass=*/0);
  2,215 (0.0%)  }
      .         
      .         // Encode an item, taking care of IMPLICIT tagging (if any). This function
      .         // performs the normal item handling: it can be used in external types.
      .         
      .         int ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
150,534 (0.0%)                       const ASN1_ITEM *it, int tag, int aclass) {
167,260 (0.0%)    int ret = asn1_item_ex_i2d_opt(pval, out, it, tag, aclass, /*optional=*/0);
 33,452 (0.0%)    assert(ret != 0);
 16,726 (0.0%)    return ret;
 33,452 (0.0%)  }
      .         
      .         // asn1_item_ex_i2d_opt behaves like |ASN1_item_ex_i2d| but, if |optional| is
      .         // non-zero and |*pval| is omitted, it returns zero and writes no bytes.
      .         int asn1_item_ex_i2d_opt(ASN1_VALUE **pval, unsigned char **out,
      .                                  const ASN1_ITEM *it, int tag, int aclass,
627,614 (0.1%)                           int optional) {
 48,278 (0.0%)    const ASN1_TEMPLATE *tt = NULL;
      .           int i, seqcontlen, seqlen;
      .         
      .           // Historically, |aclass| was repurposed to pass additional flags into the
      .           // encoding process.
193,112 (0.0%)    assert((aclass & ASN1_TFLG_TAG_CLASS) == aclass);
      .           // If not overridding the tag, |aclass| is ignored and should be zero.
193,112 (0.0%)    assert(tag != -1 || aclass == 0);
      .         
      .           // All fields are pointers, except for boolean |ASN1_ITYPE_PRIMITIVE|s.
      .           // Optional primitives are handled later.
290,700 (0.0%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) {
      .             if (optional) {
      .               return 0;
      .             }
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
      .             return -1;
      .           }
      .         
627,614 (0.1%)    switch (it->itype) {
      .             case ASN1_ITYPE_PRIMITIVE:
 95,524 (0.0%)        if (it->templates) {
      .                 // This is an |ASN1_ITEM_TEMPLATE|.
 38,016 (0.0%)          if (it->templates->flags & ASN1_TFLG_OPTIONAL) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                   return -1;
      .                 }
 76,032 (0.0%)          return asn1_template_ex_i2d(pval, out, it->templates, tag, aclass,
      .                                             optional);
      .               }
192,995 (0.0%)        return asn1_i2d_ex_primitive(pval, out, it, tag, aclass, optional);
      .         
      .             case ASN1_ITYPE_MSTRING:
      .               // It never makes sense for multi-strings to have implicit tagging, so
      .               // if tag != -1, then this looks like an error in the template.
 25,344 (0.0%)        if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 return -1;
      .               }
126,720 (0.0%)        return asn1_i2d_ex_primitive(pval, out, it, -1, 0, optional);
      .         
      .             case ASN1_ITYPE_CHOICE: {
      .               // It never makes sense for CHOICE types to have implicit tagging, so if
      .               // tag != -1, then this looks like an error in the template.
      .               if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 return -1;
      .               }
-- line 173 ----------------------------------------
-- line 195 ----------------------------------------
      .                 // must be pointers.
      .                 OPENSSL_PUT_ERROR(ASN1, ERR_R_INTERNAL_ERROR);
      .                 return -1;
      .               }
      .               return ret;
      .             }
      .         
      .             case ASN1_ITYPE_SEQUENCE: {
 82,075 (0.0%)        i = asn1_enc_restore(&seqcontlen, out, pval, it);
      .               // An error occurred
 23,450 (0.0%)        if (i < 0) {
      .                 return -1;
      .               }
      .               // We have a valid cached encoding...
 23,450 (0.0%)        if (i > 0) {
     12 (0.0%)          return seqcontlen;
      .               }
      .               // Otherwise carry on
 11,719 (0.0%)        seqcontlen = 0;
      .               // If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL
 23,438 (0.0%)        if (tag == -1) {
 11,719 (0.0%)          tag = V_ASN1_SEQUENCE;
 11,719 (0.0%)          aclass = V_ASN1_UNIVERSAL;
      .               }
      .               // First work out sequence content length
316,445 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
      .                 const ASN1_TEMPLATE *seqtt;
      .                 ASN1_VALUE **pseqval;
      .                 int tmplen;
164,094 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
 46,884 (0.0%)          if (!seqtt) {
      .                   return -1;
      .                 }
140,652 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
      .                 tmplen =
210,978 (0.0%)              asn1_template_ex_i2d(pseqval, NULL, seqtt, -1, 0, /*optional=*/0);
164,094 (0.0%)          if (tmplen == -1 || (tmplen > INT_MAX - seqcontlen)) {
      .                   return -1;
      .                 }
 93,768 (0.0%)          seqcontlen += tmplen;
      .               }
      .         
 70,314 (0.0%)        seqlen = ASN1_object_size(/*constructed=*/1, seqcontlen, tag);
 31,546 (0.0%)        if (!out || seqlen == -1) {
 15,330 (0.0%)          return seqlen;
      .               }
      .               // Output SEQUENCE header
 32,432 (0.0%)        ASN1_put_object(out, /*constructed=*/1, seqcontlen, tag, aclass);
109,474 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
      .                 const ASN1_TEMPLATE *seqtt;
      .                 ASN1_VALUE **pseqval;
 56,770 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
 16,220 (0.0%)          if (!seqtt) {
      .                   return -1;
      .                 }
 48,660 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
 81,100 (0.0%)          if (asn1_template_ex_i2d(pseqval, out, seqtt, -1, 0, /*optional=*/0) <
      .                     0) {
      .                   return -1;
      .                 }
      .               }
  8,108 (0.0%)        return seqlen;
      .             }
      .         
      .             default:
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .               return -1;
      .           }
241,390 (0.0%)  }
      .         
      .         // asn1_template_ex_i2d behaves like |asn1_item_ex_i2d_opt| but uses an
      .         // |ASN1_TEMPLATE| instead of an |ASN1_ITEM|. An |ASN1_TEMPLATE| wraps an
      .         // |ASN1_ITEM| with modifiers such as tagging, SEQUENCE or SET, etc.
      .         static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
      .                                         const ASN1_TEMPLATE *tt, int tag, int iclass,
492,544 (0.1%)                                  int optional) {
      .           int i, ret, ttag, tclass;
      .           size_t j;
113,664 (0.0%)    uint32_t flags = tt->flags;
      .         
      .           // Historically, |iclass| was repurposed to pass additional flags into the
      .           // encoding process.
151,552 (0.0%)    assert((iclass & ASN1_TFLG_TAG_CLASS) == iclass);
      .           // If not overridding the tag, |iclass| is ignored and should be zero.
151,552 (0.0%)    assert(tag != -1 || iclass == 0);
      .         
      .           // Work out tag and class to use: tagging may come either from the
      .           // template or the arguments, not both because this would create
      .           // ambiguity.
151,552 (0.0%)    if (flags & ASN1_TFLG_TAG_MASK) {
      .             // Error if argument and template tagging
      .             if (tag != -1) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .               return -1;
      .             }
      .             // Get tagging from template
      .             ttag = tt->tag;
      .             tclass = flags & ASN1_TFLG_TAG_CLASS;
 75,776 (0.0%)    } else if (tag != -1) {
      .             // No template tagging, get from arguments
      .             ttag = tag;
      .             tclass = iclass & ASN1_TFLG_TAG_CLASS;
      .           } else {
 37,888 (0.0%)      ttag = -1;
 37,888 (0.0%)      tclass = 0;
      .           }
      .         
      .           // The template may itself by marked as optional, or this may be the template
      .           // of an |ASN1_ITEM_TEMPLATE| type which was contained inside an outer
      .           // optional template. (They cannot both be true because the
      .           // |ASN1_ITEM_TEMPLATE| codepath rejects optional templates.)
 75,776 (0.0%)    assert(!optional || (flags & ASN1_TFLG_OPTIONAL) == 0);
304,876 (0.0%)    optional = optional || (flags & ASN1_TFLG_OPTIONAL) != 0;
      .         
      .           // At this point 'ttag' contains the outer tag to use, and 'tclass' is the
      .           // class.
      .         
151,552 (0.0%)    if (flags & ASN1_TFLG_SK_MASK) {
      .             // SET OF, SEQUENCE OF
 19,008 (0.0%)      STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;
      .             int isset, sktag, skaclass;
      .             int skcontlen, sklen;
      .             ASN1_VALUE *skitem;
      .         
 25,344 (0.0%)      if (!*pval) {
      .               if (optional) {
      .                 return 0;
      .               }
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
      .               return -1;
      .             }
      .         
 25,344 (0.0%)      if (flags & ASN1_TFLG_SET_OF) {
  6,336 (0.0%)        isset = 1;
      .               // Historically, types with both bits set were mutated when
      .               // serialized to apply the sort. We no longer support this.
 25,344 (0.0%)        assert((flags & ASN1_TFLG_SEQUENCE_OF) == 0);
      .             } else {
      .               isset = 0;
      .             }
      .         
      .             // Work out inner tag value: if EXPLICIT or no tagging use underlying
      .             // type.
 12,672 (0.0%)      if ((ttag != -1) && !(flags & ASN1_TFLG_EXPTAG)) {
      .               sktag = ttag;
      .               skaclass = tclass;
      .             } else {
  6,336 (0.0%)        skaclass = V_ASN1_UNIVERSAL;
 12,672 (0.0%)        if (isset) {
 12,672 (0.0%)          sktag = V_ASN1_SET;
      .               } else {
      .                 sktag = V_ASN1_SEQUENCE;
      .               }
      .             }
      .         
      .             // Determine total length of items
  6,336 (0.0%)      skcontlen = 0;
 82,368 (0.0%)      for (j = 0; j < sk_ASN1_VALUE_num(sk); j++) {
      .               int tmplen;
 38,016 (0.0%)        skitem = sk_ASN1_VALUE_value(sk, j);
 57,024 (0.0%)        tmplen = ASN1_item_ex_i2d(&skitem, NULL, ASN1_ITEM_ptr(tt->item), -1, 0);
 38,016 (0.0%)        if (tmplen == -1 || (skcontlen > INT_MAX - tmplen)) {
      .                 return -1;
      .               }
 12,672 (0.0%)        skcontlen += tmplen;
      .             }
 38,016 (0.0%)      sklen = ASN1_object_size(/*constructed=*/1, skcontlen, sktag);
 12,672 (0.0%)      if (sklen == -1) {
      .               return -1;
      .             }
      .             // If EXPLICIT need length of surrounding tag
 25,344 (0.0%)      if (flags & ASN1_TFLG_EXPTAG) {
      .               ret = ASN1_object_size(/*constructed=*/1, sklen, ttag);
      .             } else {
 12,672 (0.0%)        ret = sklen;
      .             }
      .         
 19,008 (0.0%)      if (!out || ret == -1) {
  6,336 (0.0%)        return ret;
      .             }
      .         
      .             // Now encode this lot...
      .             // EXPLICIT tag
 12,672 (0.0%)      if (flags & ASN1_TFLG_EXPTAG) {
      .               ASN1_put_object(out, /*constructed=*/1, sklen, ttag, tclass);
      .             }
      .             // SET or SEQUENCE and IMPLICIT tag
 25,344 (0.0%)      ASN1_put_object(out, /*constructed=*/1, skcontlen, sktag, skaclass);
      .             // And the stuff itself
 34,848 (0.0%)      if (!asn1_set_seq_out(sk, out, skcontlen, ASN1_ITEM_ptr(tt->item), isset)) {
      .               return -1;
      .             }
  6,336 (0.0%)      return ret;
      .           }
      .         
126,208 (0.0%)    if (flags & ASN1_TFLG_EXPTAG) {
      .             // EXPLICIT tagging
      .             // Find length of tagged item
      .             i = asn1_item_ex_i2d_opt(pval, NULL, ASN1_ITEM_ptr(tt->item), -1, 0,
      .                                      optional);
      .             if (i <= 0) {
      .               return i;
      .             }
      .             // Find length of EXPLICIT tag
-- line 398 ----------------------------------------
-- line 403 ----------------------------------------
      .               if (ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item), -1, 0) < 0) {
      .                 return -1;
      .               }
      .             }
      .             return ret;
      .           }
      .         
      .           // Either normal or IMPLICIT tagging
347,072 (0.1%)    return asn1_item_ex_i2d_opt(pval, out, ASN1_ITEM_ptr(tt->item), ttag, tclass,
      .                                       optional);
189,440 (0.0%)  }
      .         
      .         // Temporary structure used to hold DER encoding of items for SET OF
      .         
      .         typedef struct {
      .           unsigned char *data;
      .           int length;
      .         } DER_ENC;
      .         
-- line 421 ----------------------------------------
-- line 431 ----------------------------------------
      .         }
      .         
      .         // asn1_set_seq_out writes |sk| to |out| under the i2d output convention,
      .         // excluding the tag and length. It returns one on success and zero on error.
      .         // |skcontlen| must be the total encoded size. If |do_sort| is non-zero, the
      .         // elements are sorted for a SET OF type. Each element of |sk| has type
      .         // |item|.
      .         static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
 41,184 (0.0%)                              int skcontlen, const ASN1_ITEM *item, int do_sort) {
      .           // No need to sort if there are fewer than two items.
 22,176 (0.0%)    if (!do_sort || sk_ASN1_VALUE_num(sk) < 2) {
 41,184 (0.0%)      for (size_t i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
 19,008 (0.0%)        ASN1_VALUE *skitem = sk_ASN1_VALUE_value(sk, i);
 28,512 (0.0%)        if (ASN1_item_ex_i2d(&skitem, out, item, -1, 0) < 0) {
      .                 return 0;
      .               }
      .             }
  6,336 (0.0%)      return 1;
      .           }
      .         
      .           int ret = 0;
      .           unsigned char *const buf = OPENSSL_malloc(skcontlen);
      .           DER_ENC *encoded = OPENSSL_calloc(sk_ASN1_VALUE_num(sk), sizeof(*encoded));
      .           if (encoded == NULL || buf == NULL) {
      .             goto err;
      .           }
-- line 456 ----------------------------------------
-- line 478 ----------------------------------------
      .           *out = p;
      .         
      .           ret = 1;
      .         
      .         err:
      .           OPENSSL_free(encoded);
      .           OPENSSL_free(buf);
      .           return ret;
 19,008 (0.0%)  }
      .         
      .         // asn1_i2d_ex_primitive behaves like |ASN1_item_ex_i2d| but |item| must be a
      .         // a PRIMITIVE or MSTRING type that is not an |ASN1_ITEM_TEMPLATE|.
      .         static int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out,
      .                                          const ASN1_ITEM *it, int tag, int aclass,
392,821 (0.1%)                                   int optional) {
      .           // Get length of content octets and maybe find out the underlying type.
      .           int omit;
 90,651 (0.0%)    int utype = it->utype;
271,953 (0.0%)    int len = asn1_ex_i2c(pval, NULL, &omit, &utype, it);
 60,434 (0.0%)    if (len < 0) {
      .             return -1;
      .           }
 90,651 (0.0%)    if (omit) {
      .             if (optional) {
      .               return 0;
      .             }
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
      .             return -1;
      .           }
      .         
      .           // If SEQUENCE, SET or OTHER then header is included in pseudo content
      .           // octets so don't include tag+length. We need to check here because the
      .           // call to asn1_ex_i2c() could change utype.
 30,217 (0.0%)    int usetag =
332,387 (0.1%)        utype != V_ASN1_SEQUENCE && utype != V_ASN1_SET && utype != V_ASN1_OTHER;
      .         
      .           // If not implicitly tagged get tag from underlying type
 60,434 (0.0%)    if (tag == -1) {
 60,434 (0.0%)      tag = utype;
      .           }
      .         
      .           // Output tag+length followed by content octets
 60,434 (0.0%)    if (out) {
 15,330 (0.0%)      if (usetag) {
 61,320 (0.0%)        ASN1_put_object(out, /*constructed=*/0, len, tag, aclass);
      .             }
 76,650 (0.0%)      int len2 = asn1_ex_i2c(pval, *out, &omit, &utype, it);
 15,330 (0.0%)      if (len2 < 0) {
      .               return -1;
      .             }
 22,995 (0.0%)      assert(len == len2);
 22,995 (0.0%)      assert(!omit);
 53,655 (0.0%)      *out += len;
      .           }
      .         
 60,434 (0.0%)    if (usetag) {
181,302 (0.0%)      return ASN1_object_size(/*constructed=*/0, len, tag);
      .           }
      .           return len;
151,085 (0.0%)  }
      .         
      .         // asn1_ex_i2c writes the |*pval| to |cout| under the i2d output convention,
      .         // excluding the tag and length. It returns the number of bytes written,
      .         // possibly zero, on success or -1 on error. If |*pval| should be omitted, it
      .         // returns zero and sets |*out_omit| to true.
      .         //
      .         // If |it| is an MSTRING or ANY type, it gets the underlying type from |*pval|,
      .         // which must be an |ASN1_STRING| or |ASN1_TYPE|, respectively. It then updates
-- line 545 ----------------------------------------
-- line 548 ----------------------------------------
      .         // |V_ASN1_OTHER|, it additionally outputs the tag and length, so the caller
      .         // must not do so.
      .         //
      .         // Otherwise, |*putype| must contain |it->utype|.
      .         //
      .         // WARNING: Unlike most functions in this file, |asn1_ex_i2c| can return zero
      .         // without omitting the element. ASN.1 values may have empty contents.
      .         static int asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cout, int *out_omit,
454,584 (0.1%)                         int *putype, const ASN1_ITEM *it) {
 37,882 (0.0%)    ASN1_BOOLEAN *tbool = NULL;
      .           ASN1_STRING *strtmp;
      .           ASN1_OBJECT *otmp;
      .           int utype;
      .           const unsigned char *cont;
      .           unsigned char c;
      .           int len;
      .         
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of callbacks.
151,528 (0.0%)    assert(it->funcs == NULL);
      .         
 75,764 (0.0%)    *out_omit = 0;
      .         
      .           // Should type be omitted?
239,696 (0.0%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) || (it->utype != V_ASN1_BOOLEAN)) {
151,528 (0.0%)      if (!*pval) {
      .               *out_omit = 1;
      .               return 0;
      .             }
      .           }
      .         
151,528 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
      .             // If MSTRING type set the underlying type
 47,520 (0.0%)      strtmp = (ASN1_STRING *)*pval;
 47,520 (0.0%)      utype = strtmp->type;
 31,680 (0.0%)      if (utype < 0 && utype != V_ASN1_OTHER) {
      .               // MSTRINGs can have type -1 when default-constructed.
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TYPE);
      .               return -1;
      .             }
      .             // Negative INTEGER and ENUMERATED values use |ASN1_STRING| type values
      .             // that do not match their corresponding utype values. INTEGERs cannot
      .             // participate in MSTRING types, but ENUMERATEDs can.
      .             //
      .             // TODO(davidben): Is this a bug? Although arguably one of the MSTRING
      .             // types should contain more values, rather than less. See
      .             // https://crbug.com/boringssl/412. But it is not possible to fit all
      .             // possible ANY values into an |ASN1_STRING|, so matching the spec here
      .             // is somewhat hopeless.
 31,680 (0.0%)      if (utype == V_ASN1_NEG_INTEGER) {
      .               utype = V_ASN1_INTEGER;
 31,680 (0.0%)      } else if (utype == V_ASN1_NEG_ENUMERATED) {
      .               utype = V_ASN1_ENUMERATED;
      .             }
 63,360 (0.0%)      *putype = utype;
 88,168 (0.0%)    } else if (it->utype == V_ASN1_ANY) {
      .             // If ANY set type and pointer to value
      .             ASN1_TYPE *typ;
  6,645 (0.0%)      typ = (ASN1_TYPE *)*pval;
  6,645 (0.0%)      utype = typ->type;
  4,430 (0.0%)      if (utype < 0 && utype != V_ASN1_OTHER) {
      .               // |ASN1_TYPE|s can have type -1 when default-constructed.
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TYPE);
      .               return -1;
      .             }
  6,645 (0.0%)      *putype = utype;
  8,860 (0.0%)      pval = &typ->value.asn1_value;
      .           } else {
 59,481 (0.0%)      utype = *putype;
      .           }
      .         
252,100 (0.0%)    switch (utype) {
      .             case V_ASN1_OBJECT:
 55,965 (0.0%)        otmp = (ASN1_OBJECT *)*pval;
 55,965 (0.0%)        cont = otmp->data;
 55,965 (0.0%)        len = otmp->length;
 37,310 (0.0%)        if (len == 0) {
      .                 // Some |ASN1_OBJECT|s do not have OIDs and cannot be serialized.
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OBJECT);
      .                 return -1;
      .               }
 18,655 (0.0%)        break;
      .         
      .             case V_ASN1_NULL:
  1,615 (0.0%)        cont = NULL;
  1,615 (0.0%)        len = 0;
  1,615 (0.0%)        break;
      .         
      .             case V_ASN1_BOOLEAN:
      .               tbool = (ASN1_BOOLEAN *)pval;
      .               if (*tbool == ASN1_BOOLEAN_NONE) {
      .                 *out_omit = 1;
      .                 return 0;
      .               }
      .               if (it->utype != V_ASN1_ANY) {
-- line 642 ----------------------------------------
-- line 648 ----------------------------------------
      .               }
      .               c = *tbool ? 0xff : 0x00;
      .               cont = &c;
      .               len = 1;
      .               break;
      .         
      .             case V_ASN1_BIT_STRING: {
      .               int ret =
 18,163 (0.0%)            i2c_ASN1_BIT_STRING((ASN1_BIT_STRING *)*pval, cout ? &cout : NULL);
      .               // |i2c_ASN1_BIT_STRING| returns zero on error instead of -1.
  7,088 (0.0%)        return ret <= 0 ? -1 : ret;
      .             }
      .         
      .             case V_ASN1_INTEGER:
      .             case V_ASN1_ENUMERATED: {
      .               // |i2c_ASN1_INTEGER| also handles ENUMERATED.
      .               int ret = i2c_ASN1_INTEGER((ASN1_INTEGER *)*pval, cout ? &cout : NULL);
      .               // |i2c_ASN1_INTEGER| returns zero on error instead of -1.
      .               return ret <= 0 ? -1 : ret;
-- line 666 ----------------------------------------
-- line 679 ----------------------------------------
      .             case V_ASN1_GENERALSTRING:
      .             case V_ASN1_UNIVERSALSTRING:
      .             case V_ASN1_BMPSTRING:
      .             case V_ASN1_UTF8STRING:
      .             case V_ASN1_SEQUENCE:
      .             case V_ASN1_SET:
      .             default:
      .               // All based on ASN1_STRING and handled the same
 47,520 (0.0%)        strtmp = (ASN1_STRING *)*pval;
 47,520 (0.0%)        cont = strtmp->data;
 47,520 (0.0%)        len = strtmp->length;
      .         
 15,840 (0.0%)        break;
      .           }
122,774 (0.0%)    if (cout && len) {
 48,293 (0.0%)      OPENSSL_memcpy(cout, cont, len);
      .           }
 36,110 (0.0%)    return len;
189,410 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 60 ----------------------------------------
      .         
      .         #include <openssl/asn1t.h>
      .         #include <openssl/mem.h>
      .         
      .         #include "internal.h"
      .         
      .         // Free up an ASN1 structure
      .         
 59,202 (0.0%)  void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it) {
 59,202 (0.0%)    asn1_item_combine_free(&val, it, 0);
 29,601 (0.0%)  }
      .         
  9,132 (0.0%)  void ASN1_item_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
  9,132 (0.0%)    asn1_item_combine_free(pval, it, 0);
  4,566 (0.0%)  }
      .         
      .         void asn1_item_combine_free(ASN1_VALUE **pval, const ASN1_ITEM *it,
280,889 (0.0%)                              int combine) {
 40,127 (0.0%)    const ASN1_TEMPLATE *tt = NULL, *seqtt;
      .           const ASN1_EXTERN_FUNCS *ef;
      .           int i;
160,508 (0.0%)    if (pval == NULL || it == NULL) {
      .             return;
      .           }
245,512 (0.0%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) {
  3,522 (0.0%)      return;
      .           }
      .         
498,758 (0.1%)    switch (it->itype) {
      .             case ASN1_ITYPE_PRIMITIVE:
 75,504 (0.0%)        if (it->templates) {
  5,304 (0.0%)          ASN1_template_free(pval, it->templates);
      .               } else {
 89,960 (0.0%)          ASN1_primitive_free(pval, it);
      .               }
 18,876 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_MSTRING:
 36,090 (0.0%)        ASN1_primitive_free(pval, it);
  7,218 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_CHOICE: {
     12 (0.0%)        const ASN1_AUX *aux = it->funcs;
     16 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
      8 (0.0%)        if (asn1_cb) {
      .                 i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
      .                 if (i == 2) {
      .                   return;
      .                 }
      .               }
     24 (0.0%)        i = asn1_get_choice_selector(pval, it);
     32 (0.0%)        if ((i >= 0) && (i < it->tcount)) {
      .                 ASN1_VALUE **pchval;
     28 (0.0%)          tt = it->templates + i;
     24 (0.0%)          pchval = asn1_get_field_ptr(pval, tt);
     20 (0.0%)          ASN1_template_free(pchval, tt);
      .               }
      8 (0.0%)        if (asn1_cb) {
      .                 asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);
      .               }
      8 (0.0%)        if (!combine) {
     16 (0.0%)          OPENSSL_free(*pval);
      8 (0.0%)          *pval = NULL;
      .               }
     12 (0.0%)        break;
      .             }
      .         
      .             case ASN1_ITYPE_EXTERN:
  2,646 (0.0%)        ef = it->funcs;
  5,292 (0.0%)        if (ef && ef->asn1_ex_free) {
  6,174 (0.0%)          ef->asn1_ex_free(pval, it);
      .               }
  2,646 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_SEQUENCE: {
 79,702 (0.0%)        if (!asn1_refcount_dec_and_test_zero(pval, it)) {
    890 (0.0%)          return;
      .               }
 32,823 (0.0%)        const ASN1_AUX *aux = it->funcs;
 46,410 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
 21,882 (0.0%)        if (asn1_cb) {
  7,056 (0.0%)          i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
  1,764 (0.0%)          if (i == 2) {
      .                   return;
      .                 }
      .               }
 54,705 (0.0%)        asn1_enc_free(pval, it);
      .               // If we free up as normal we will invalidate any ANY DEFINED BY
      .               // field and we wont be able to determine the type of the field it
      .               // defines. So free up in reverse order.
 87,528 (0.0%)        tt = it->templates + it->tcount - 1;
306,480 (0.0%)        for (i = 0; i < it->tcount; tt--, i++) {
      .                 ASN1_VALUE **pseqval;
191,583 (0.0%)          seqtt = asn1_do_adb(pval, tt, 0);
 54,738 (0.0%)          if (!seqtt) {
      .                   continue;
      .                 }
164,214 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
164,214 (0.0%)          ASN1_template_free(pseqval, seqtt);
      .               }
 21,882 (0.0%)        if (asn1_cb) {
  6,174 (0.0%)          asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);
      .               }
 21,882 (0.0%)        if (!combine) {
 43,764 (0.0%)          OPENSSL_free(*pval);
 21,882 (0.0%)          *pval = NULL;
      .               }
 21,882 (0.0%)        break;
      .             }
      .           }
 80,254 (0.0%)  }
      .         
270,567 (0.0%)  void ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
150,315 (0.0%)    if (tt->flags & ASN1_TFLG_SK_MASK) {
  3,975 (0.0%)      STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;
 18,407 (0.0%)      for (size_t i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
  9,132 (0.0%)        ASN1_VALUE *vtmp = sk_ASN1_VALUE_value(sk, i);
  9,132 (0.0%)        ASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item));
      .             }
  3,975 (0.0%)      sk_ASN1_VALUE_free(sk);
  2,650 (0.0%)      *pval = NULL;
      .           } else {
229,904 (0.0%)      asn1_item_combine_free(pval, ASN1_ITEM_ptr(tt->item),
 57,476 (0.0%)                             tt->flags & ASN1_TFLG_COMBINE);
      .           }
181,703 (0.0%)  }
      .         
151,260 (0.0%)  void ASN1_primitive_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of calbacks.
100,840 (0.0%)    assert(it->funcs == NULL);
      .         
187,244 (0.0%)    int utype = it->itype == ASN1_ITYPE_MSTRING ? -1 : it->utype;
219,856 (0.0%)    switch (utype) {
      .             case V_ASN1_OBJECT:
 36,708 (0.0%)        ASN1_OBJECT_free((ASN1_OBJECT *)*pval);
  9,177 (0.0%)        break;
      .         
      .             case V_ASN1_BOOLEAN:
  4,404 (0.0%)        if (it) {
 11,010 (0.0%)          *(ASN1_BOOLEAN *)pval = (ASN1_BOOLEAN)it->size;
      .               } else {
      .                 *(ASN1_BOOLEAN *)pval = ASN1_BOOLEAN_NONE;
      .               }
  2,202 (0.0%)        return;
      .         
      .             case V_ASN1_NULL:
      .               break;
      .         
      .             case V_ASN1_ANY:
  6,252 (0.0%)        if (*pval != NULL) {
  4,332 (0.0%)          asn1_type_cleanup((ASN1_TYPE *)*pval);
  4,332 (0.0%)          OPENSSL_free(*pval);
      .               }
  2,646 (0.0%)        break;
      .         
      .             default:
 49,072 (0.0%)        ASN1_STRING_free((ASN1_STRING *)*pval);
 24,536 (0.0%)        *pval = NULL;
 12,268 (0.0%)        break;
      .           }
 46,016 (0.0%)    *pval = NULL;
 50,420 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 70 ----------------------------------------
      .         static int asn1_item_ex_combine_new(ASN1_VALUE **pval, const ASN1_ITEM *it,
      .                                             int combine);
      .         static void asn1_item_clear(ASN1_VALUE **pval, const ASN1_ITEM *it);
      .         static int ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);
      .         static void asn1_template_clear(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);
      .         static int ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it);
      .         static void asn1_primitive_clear(ASN1_VALUE **pval, const ASN1_ITEM *it);
      .         
 34,008 (0.0%)  ASN1_VALUE *ASN1_item_new(const ASN1_ITEM *it) {
  4,251 (0.0%)    ASN1_VALUE *ret = NULL;
 29,757 (0.0%)    if (ASN1_item_ex_new(&ret, it) > 0) {
  8,502 (0.0%)      return ret;
      .           }
      .           return NULL;
 21,255 (0.0%)  }
      .         
      .         // Allocate an ASN1 structure
      .         
 56,292 (0.0%)  int ASN1_item_ex_new(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 56,292 (0.0%)    return asn1_item_ex_combine_new(pval, it, 0);
 18,764 (0.0%)  }
      .         
      .         static int asn1_item_ex_combine_new(ASN1_VALUE **pval, const ASN1_ITEM *it,
225,022 (0.0%)                                      int combine) {
 32,146 (0.0%)    const ASN1_TEMPLATE *tt = NULL;
      .           const ASN1_EXTERN_FUNCS *ef;
      .           ASN1_VALUE **pseqval;
      .           int i;
      .         
417,898 (0.1%)    switch (it->itype) {
      .             case ASN1_ITYPE_EXTERN:
  2,646 (0.0%)        ef = it->funcs;
  5,292 (0.0%)        if (ef && ef->asn1_ex_new) {
  7,938 (0.0%)          if (!ef->asn1_ex_new(pval, it)) {
      .                   goto memerr;
      .                 }
      .               }
  1,764 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_PRIMITIVE:
 52,404 (0.0%)        if (it->templates) {
      .                 if (!ASN1_template_new(pval, it->templates)) {
      .                   goto memerr;
      .                 }
 91,707 (0.0%)        } else if (!ASN1_primitive_new(pval, it)) {
      .                 goto memerr;
      .               }
 26,202 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_MSTRING:
 50,526 (0.0%)        if (!ASN1_primitive_new(pval, it)) {
      .                 goto memerr;
      .               }
 14,436 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_CHOICE: {
     12 (0.0%)        const ASN1_AUX *aux = it->funcs;
     16 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
      8 (0.0%)        if (asn1_cb) {
      .                 i = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);
      .                 if (!i) {
      .                   goto auxerr;
      .                 }
      .                 if (i == 2) {
      .                   return 1;
      .                 }
      .               }
      8 (0.0%)        if (!combine) {
     24 (0.0%)          *pval = OPENSSL_zalloc(it->size);
     16 (0.0%)          if (!*pval) {
      .                   goto memerr;
      .                 }
      .               }
     20 (0.0%)        asn1_set_choice_selector(pval, -1, it);
      8 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL)) {
      .                 goto auxerr2;
      .               }
      8 (0.0%)        break;
      .             }
      .         
      .             case ASN1_ITYPE_SEQUENCE: {
 32,823 (0.0%)        const ASN1_AUX *aux = it->funcs;
 46,410 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
 21,882 (0.0%)        if (asn1_cb) {
  7,056 (0.0%)          i = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);
  1,764 (0.0%)          if (!i) {
      .                   goto auxerr;
      .                 }
  1,764 (0.0%)          if (i == 2) {
      .                   return 1;
      .                 }
      .               }
 21,882 (0.0%)        if (!combine) {
 65,646 (0.0%)          *pval = OPENSSL_zalloc(it->size);
 43,764 (0.0%)          if (!*pval) {
      .                   goto memerr;
      .                 }
 54,705 (0.0%)          asn1_refcount_set_one(pval, it);
 54,705 (0.0%)          asn1_enc_init(pval, it);
      .               }
339,303 (0.1%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
164,214 (0.0%)          pseqval = asn1_get_field_ptr(pval, tt);
191,583 (0.0%)          if (!ASN1_template_new(pseqval, tt)) {
      .                   goto memerr2;
      .                 }
      .               }
 29,820 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL)) {
      .                 goto auxerr2;
      .               }
 11,823 (0.0%)        break;
      .             }
      .           }
 64,292 (0.0%)    return 1;
      .         
      .         memerr2:
      .           asn1_item_combine_free(pval, it, combine);
      .         memerr:
      .           return 0;
      .         
      .         auxerr2:
      .           asn1_item_combine_free(pval, it, combine);
      .         auxerr:
      .           OPENSSL_PUT_ERROR(ASN1, ASN1_R_AUX_ERROR);
      .           return 0;
 64,292 (0.0%)  }
      .         
 24,984 (0.0%)  static void asn1_item_clear(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 54,132 (0.0%)    switch (it->itype) {
      .             case ASN1_ITYPE_EXTERN:
      .               *pval = NULL;
      .               break;
      .         
      .             case ASN1_ITYPE_PRIMITIVE:
 16,656 (0.0%)        if (it->templates) {
      .                 asn1_template_clear(pval, it->templates);
      .               } else {
 20,820 (0.0%)          asn1_primitive_clear(pval, it);
      .               }
  4,164 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_MSTRING:
      .               asn1_primitive_clear(pval, it);
      .               break;
      .         
      .             case ASN1_ITYPE_CHOICE:
      .             case ASN1_ITYPE_SEQUENCE:
      .               *pval = NULL;
      .               break;
      .           }
 12,492 (0.0%)  }
      .         
164,214 (0.0%)  static int ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
 82,107 (0.0%)    const ASN1_ITEM *it = ASN1_ITEM_ptr(tt->item);
      .           int ret;
136,845 (0.0%)    if (tt->flags & ASN1_TFLG_OPTIONAL) {
 23,025 (0.0%)      asn1_template_clear(pval, tt);
  9,210 (0.0%)      return 1;
      .           }
      .           // If ANY DEFINED BY nothing to do
      .         
113,820 (0.0%)    if (tt->flags & ASN1_TFLG_ADB_MASK) {
      .             *pval = NULL;
      .             return 1;
      .           }
      .           // If SET OF or SEQUENCE OF, its a STACK
113,820 (0.0%)    if (tt->flags & ASN1_TFLG_SK_MASK) {
      .             STACK_OF(ASN1_VALUE) *skval;
      .             skval = sk_ASN1_VALUE_new_null();
      .             if (!skval) {
      .               ret = 0;
      .               goto done;
      .             }
      .             *pval = (ASN1_VALUE *)skval;
      .             ret = 1;
      .             goto done;
      .           }
      .           // Otherwise pass it back to the item routine
227,640 (0.0%)    ret = asn1_item_ex_combine_new(pval, it, tt->flags & ASN1_TFLG_COMBINE);
      .         done:
 22,764 (0.0%)    return ret;
 54,738 (0.0%)  }
      .         
 27,630 (0.0%)  static void asn1_template_clear(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
      .           // If ADB or STACK just NULL the field
 23,025 (0.0%)    if (tt->flags & (ASN1_TFLG_ADB_MASK | ASN1_TFLG_SK_MASK)) {
    882 (0.0%)      *pval = NULL;
      .           } else {
 24,984 (0.0%)      asn1_item_clear(pval, ASN1_ITEM_ptr(tt->item));
      .           }
 14,256 (0.0%)  }
      .         
      .         // NB: could probably combine most of the real XXX_new() behaviour and junk
      .         // all the old functions.
      .         
121,914 (0.0%)  static int ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 40,638 (0.0%)    if (!it) {
      .             return 0;
      .           }
      .         
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of calbacks.
 81,276 (0.0%)    assert(it->funcs == NULL);
      .         
      .           int utype;
 81,276 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
 14,436 (0.0%)      utype = -1;
      .           } else {
 39,303 (0.0%)      utype = it->utype;
      .           }
159,951 (0.0%)    switch (utype) {
      .             case V_ASN1_OBJECT:
 27,531 (0.0%)        *pval = (ASN1_VALUE *)OBJ_get_undef();
 18,354 (0.0%)        return 1;
      .         
      .             case V_ASN1_BOOLEAN:
      .               *(ASN1_BOOLEAN *)pval = (ASN1_BOOLEAN)it->size;
      .               return 1;
      .         
      .             case V_ASN1_NULL:
      .               *pval = (ASN1_VALUE *)1;
      .               return 1;
      .         
      .             case V_ASN1_ANY: {
  3,249 (0.0%)        ASN1_TYPE *typ = OPENSSL_zalloc(sizeof(ASN1_TYPE));
  2,166 (0.0%)        if (!typ) {
      .                 return 0;
      .               }
  2,166 (0.0%)        typ->type = -1;
  3,249 (0.0%)        *pval = (ASN1_VALUE *)typ;
  1,083 (0.0%)        break;
      .             }
      .         
      .             default:
 50,295 (0.0%)        *pval = (ASN1_VALUE *)ASN1_STRING_type_new(utype);
 10,059 (0.0%)        break;
      .           }
 44,568 (0.0%)    if (*pval) {
 22,284 (0.0%)      return 1;
      .           }
      .           return 0;
 40,638 (0.0%)  }
      .         
 24,984 (0.0%)  static void asn1_primitive_clear(ASN1_VALUE **pval, const ASN1_ITEM *it) {
      .           int utype;
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of calbacks.
 24,984 (0.0%)    assert(it == NULL || it->funcs == NULL);
 24,984 (0.0%)    if (!it || (it->itype == ASN1_ITYPE_MSTRING)) {
      .             utype = -1;
      .           } else {
 12,492 (0.0%)      utype = it->utype;
      .           }
  8,328 (0.0%)    if (utype == V_ASN1_BOOLEAN) {
  7,590 (0.0%)      *(ASN1_BOOLEAN *)pval = (ASN1_BOOLEAN)it->size;
      .           } else {
  5,292 (0.0%)      *pval = NULL;
      .           }
 14,010 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 70 ----------------------------------------
      .         
      .         
      .         // Utility functions for manipulating fields and offsets
      .         
      .         // Add 'offset' to 'addr'
      .         #define offset2ptr(addr, offset) (void *)(((char *)(addr)) + (offset))
      .         
      .         // Given an ASN1_ITEM CHOICE type return the selector value
     20 (0.0%)  int asn1_get_choice_selector(ASN1_VALUE **pval, const ASN1_ITEM *it) {
     28 (0.0%)    int *sel = offset2ptr(*pval, it->utype);
      8 (0.0%)    return *sel;
      8 (0.0%)  }
      .         
      .         // Given an ASN1_ITEM CHOICE type set the selector value, return old value.
      .         int asn1_set_choice_selector(ASN1_VALUE **pval, int value,
     48 (0.0%)                               const ASN1_ITEM *it) {
      .           int *sel, ret;
     56 (0.0%)    sel = offset2ptr(*pval, it->utype);
     24 (0.0%)    ret = *sel;
     24 (0.0%)    *sel = value;
      8 (0.0%)    return ret;
     16 (0.0%)  }
      .         
      .         static CRYPTO_refcount_t *asn1_get_references(ASN1_VALUE **pval,
111,635 (0.0%)                                                const ASN1_ITEM *it) {
 89,308 (0.0%)    if (it->itype != ASN1_ITYPE_SEQUENCE) {
      .             return NULL;
      .           }
 66,981 (0.0%)    const ASN1_AUX *aux = it->funcs;
 60,109 (0.0%)    if (!aux || !(aux->flags & ASN1_AFLG_REFCOUNT)) {
 42,000 (0.0%)      return NULL;
      .           }
  7,962 (0.0%)    return offset2ptr(*pval, aux->ref_offset);
 44,654 (0.0%)  }
      .         
 65,646 (0.0%)  void asn1_refcount_set_one(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 65,646 (0.0%)    CRYPTO_refcount_t *references = asn1_get_references(pval, it);
 21,882 (0.0%)    if (references != NULL) {
    882 (0.0%)      *references = 1;
      .           }
 32,823 (0.0%)  }
      .         
 68,316 (0.0%)  int asn1_refcount_dec_and_test_zero(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 68,316 (0.0%)    CRYPTO_refcount_t *references = asn1_get_references(pval, it);
 22,772 (0.0%)    if (references != NULL) {
  3,544 (0.0%)      return CRYPTO_refcount_dec_and_test_zero(references);
      .           }
 10,500 (0.0%)    return 1;
 22,772 (0.0%)  }
      .         
248,280 (0.0%)  static ASN1_ENCODING *asn1_get_enc_ptr(ASN1_VALUE **pval, const ASN1_ITEM *it) {
165,520 (0.0%)    assert(it->itype == ASN1_ITYPE_SEQUENCE);
      .           const ASN1_AUX *aux;
248,280 (0.0%)    if (!pval || !*pval) {
      .             return NULL;
      .           }
124,140 (0.0%)    aux = it->funcs;
107,065 (0.0%)    if (!aux || !(aux->flags & ASN1_AFLG_ENCODING)) {
 80,102 (0.0%)      return NULL;
      .           }
  7,974 (0.0%)    return offset2ptr(*pval, aux->enc_offset);
 82,760 (0.0%)  }
      .         
 65,646 (0.0%)  void asn1_enc_init(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 65,646 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
 21,882 (0.0%)    if (enc) {
    882 (0.0%)      enc->enc = NULL;
    882 (0.0%)      enc->len = 0;
  1,764 (0.0%)      enc->alias_only = 0;
  1,764 (0.0%)      enc->alias_only_on_next_parse = 0;
      .           }
 32,823 (0.0%)  }
      .         
 65,646 (0.0%)  void asn1_enc_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 65,646 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
 21,882 (0.0%)    if (enc) {
  1,323 (0.0%)      asn1_encoding_clear(enc);
      .           }
 32,823 (0.0%)  }
      .         
      .         int asn1_enc_save(ASN1_VALUE **pval, const unsigned char *in, int inlen,
 62,184 (0.0%)                    const ASN1_ITEM *it) {
      .           ASN1_ENCODING *enc;
 46,638 (0.0%)    enc = asn1_get_enc_ptr(pval, it);
 15,546 (0.0%)    if (!enc) {
 14,664 (0.0%)      return 1;
      .           }
      .         
  2,205 (0.0%)    if (!enc->alias_only) {
  1,764 (0.0%)      OPENSSL_free(enc->enc);
      .           }
      .         
  4,851 (0.0%)    enc->alias_only = enc->alias_only_on_next_parse;
  1,764 (0.0%)    enc->alias_only_on_next_parse = 0;
      .         
  2,205 (0.0%)    if (enc->alias_only) {
      .             enc->enc = (uint8_t *)in;
      .           } else {
  3,528 (0.0%)      enc->enc = OPENSSL_memdup(in, inlen);
  1,764 (0.0%)      if (!enc->enc) {
      .               return 0;
      .             }
      .           }
      .         
  1,764 (0.0%)    enc->len = inlen;
    441 (0.0%)    return 1;
 15,546 (0.0%)  }
      .         
  2,205 (0.0%)  void asn1_encoding_clear(ASN1_ENCODING *enc) {
  2,205 (0.0%)    if (!enc->alias_only) {
  1,764 (0.0%)      OPENSSL_free(enc->enc);
      .           }
    882 (0.0%)    enc->enc = NULL;
    882 (0.0%)    enc->len = 0;
  1,764 (0.0%)    enc->alias_only = 0;
  1,764 (0.0%)    enc->alias_only_on_next_parse = 0;
  1,323 (0.0%)  }
      .         
      .         int asn1_enc_restore(int *len, unsigned char **out, ASN1_VALUE **pval,
 93,800 (0.0%)                       const ASN1_ITEM *it) {
 70,350 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
 23,474 (0.0%)    if (!enc || enc->len == 0) {
 23,438 (0.0%)      return 0;
      .           }
     12 (0.0%)    if (out) {
     20 (0.0%)      OPENSSL_memcpy(*out, enc->enc, enc->len);
     14 (0.0%)      *out += enc->len;
      .           }
     12 (0.0%)    if (len) {
     30 (0.0%)      *len = enc->len;
      .           }
      6 (0.0%)    return 1;
 23,450 (0.0%)  }
      .         
      .         // Given an ASN1_TEMPLATE get a pointer to a field
537,895 (0.1%)  ASN1_VALUE **asn1_get_field_ptr(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
      .           ASN1_VALUE **pvaltmp;
537,895 (0.1%)    if (tt->flags & ASN1_TFLG_COMBINE) {
      .             return pval;
      .           }
645,474 (0.1%)    pvaltmp = offset2ptr(*pval, tt->offset);
      .           // NOTE for BOOLEAN types the field is just a plain int so we can't return
      .           // int **, so settle for (int *).
107,579 (0.0%)    return pvaltmp;
215,158 (0.0%)  }
      .         
      .         // Handle ANY DEFINED BY template, find the selector, look up the relevant
      .         // ASN1_TEMPLATE in the table and return it.
      .         const ASN1_TEMPLATE *asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt,
561,358 (0.1%)                                   int nullerr) {
      .           const ASN1_ADB *adb;
      .           const ASN1_ADB_TABLE *atbl;
      .           ASN1_VALUE **sfld;
      .           int i;
400,970 (0.1%)    if (!(tt->flags & ASN1_TFLG_ADB_MASK)) {
160,388 (0.0%)      return tt;
      .           }
      .         
      .           // Else ANY DEFINED BY ... get the table
      .           adb = ASN1_ADB_ptr(tt->item);
      .         
      .           // Get the selector field
      .           sfld = offset2ptr(*pval, adb->offset);
      .         
-- line 233 ----------------------------------------
-- line 265 ----------------------------------------
      .           return adb->default_tt;
      .         
      .         err:
      .           // FIXME: should log the value or OID of unsupported type
      .           if (nullerr) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);
      .           }
      .           return NULL;
160,388 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h
--------------------------------------------------------------------------------
Ir_______________ 

-- line 318 ----------------------------------------
         .         #if defined(__GNUC__) || defined(__clang__)
         .           __asm__("" : "+r"(a) : /* no inputs */);
         .         #endif
         .           return a;
         .         }
         .         
         .         // constant_time_msb_w returns the given value with the MSB copied to all the
         .         // other bits.
11,239,560 (1.7%)  static inline crypto_word_t constant_time_msb_w(crypto_word_t a) {
 7,493,040 (1.1%)    return 0u - (a >> (sizeof(a) * 8 - 1));
 7,493,040 (1.1%)  }
         .         
         .         // constant_time_lt_w returns 0xff..f if a < b and 0 otherwise.
         .         static inline crypto_word_t constant_time_lt_w(crypto_word_t a,
         .                                                        crypto_word_t b) {
         .           // Consider the two cases of the problem:
         .           //   msb(a) == msb(b): a < b iff the MSB of a - b is set.
         .           //   msb(a) != msb(b): a < b iff the MSB of b is set.
         .           //
-- line 336 ----------------------------------------
-- line 377 ----------------------------------------
         .         
         .         // constant_time_ge_8 acts like |constant_time_ge_w| but returns an 8-bit
         .         // mask.
         .         static inline uint8_t constant_time_ge_8(crypto_word_t a, crypto_word_t b) {
         .           return (uint8_t)(constant_time_ge_w(a, b));
         .         }
         .         
         .         // constant_time_is_zero returns 0xff..f if a == 0 and 0 otherwise.
 7,493,040 (1.1%)  static inline crypto_word_t constant_time_is_zero_w(crypto_word_t a) {
         .           // Here is an SMT-LIB verification of this formula:
         .           //
         .           // (define-fun is_zero ((a (_ BitVec 32))) (_ BitVec 32)
         .           //   (bvand (bvnot a) (bvsub a #x00000001))
         .           // )
         .           //
         .           // (declare-fun a () (_ BitVec 32))
         .           //
         .           // (assert (not (= (= #x00000001 (bvlshr (is_zero a) #x0000001f)) (= a #x00000000))))
         .           // (check-sat)
         .           // (get-model)
14,986,080 (2.3%)    return constant_time_msb_w(~a & (a - 1));
 3,746,520 (0.6%)  }
         .         
         .         // constant_time_is_zero_8 acts like |constant_time_is_zero_w| but returns an
         .         // 8-bit mask.
         .         static inline uint8_t constant_time_is_zero_8(crypto_word_t a) {
         .           return (uint8_t)(constant_time_is_zero_w(a));
         .         }
         .         
         .         // constant_time_eq_w returns 0xff..f if a == b and 0 otherwise.
         .         static inline crypto_word_t constant_time_eq_w(crypto_word_t a,
 9,366,300 (1.4%)                                                 crypto_word_t b) {
 7,493,040 (1.1%)    return constant_time_is_zero_w(a ^ b);
 3,746,520 (0.6%)  }
         .         
         .         // constant_time_eq_8 acts like |constant_time_eq_w| but returns an 8-bit
         .         // mask.
 9,366,300 (1.4%)  static inline uint8_t constant_time_eq_8(crypto_word_t a, crypto_word_t b) {
 9,366,300 (1.4%)    return (uint8_t)(constant_time_eq_w(a, b));
 3,746,520 (0.6%)  }
         .         
         .         // constant_time_eq_int acts like |constant_time_eq_w| but works on int
         .         // values.
         .         static inline crypto_word_t constant_time_eq_int(int a, int b) {
         .           return constant_time_eq_w((crypto_word_t)(a), (crypto_word_t)(b));
         .         }
         .         
         .         // constant_time_eq_int_8 acts like |constant_time_eq_int| but returns an 8-bit
-- line 424 ----------------------------------------
-- line 882 ----------------------------------------
         .         static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
         .           if (n == 0) {
         .             return dst;
         .           }
         .         
         .           return memmove(dst, src, n);
         .         }
         .         
     2,628 (0.0%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
       876 (0.0%)    if (n == 0) {
         .             return dst;
         .           }
         .         
     2,628 (0.0%)    return memset(dst, c, n);
       876 (0.0%)  }
         .         
         .         
         .         // Loads and stores.
         .         //
         .         // The following functions load and store sized integers with the specified
         .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
         .         // requirements on the input and output pointers.
         .         
-- line 904 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c
--------------------------------------------------------------------------------
Ir_______________ 

-- line 62 ----------------------------------------
         .         
         .         #include <openssl/type_check.h>
         .         
         .         #include "../internal.h"
         .         
         .         
         .         // constant_time_lt_args_8 behaves like |constant_time_lt_8| but takes |uint8_t|
         .         // arguments for a slightly simpler implementation.
13,112,820 (2.0%)  static inline uint8_t constant_time_lt_args_8(uint8_t a, uint8_t b) {
 3,746,520 (0.6%)    crypto_word_t aw = a;
 3,746,520 (0.6%)    crypto_word_t bw = b;
         .           // |crypto_word_t| is larger than |uint8_t|, so |aw| and |bw| have the same
         .           // MSB. |aw| < |bw| iff MSB(|aw| - |bw|) is 1.
 7,493,040 (1.1%)    return constant_time_msb_w(aw - bw);
 3,746,520 (0.6%)  }
         .         
         .         // constant_time_in_range_8 returns |CONSTTIME_TRUE_8| if |min| <= |a| <= |max|
         .         // and |CONSTTIME_FALSE_8| otherwise.
         .         static inline uint8_t constant_time_in_range_8(uint8_t a, uint8_t min,
18,732,600 (2.8%)                                                 uint8_t max) {
 3,746,520 (0.6%)    a -= min;
14,986,080 (2.3%)    return constant_time_lt_args_8(a, max - min + 1);
 3,746,520 (0.6%)  }
         .         
         .         // Encoding.
         .         
         .         static uint8_t conv_bin2ascii(uint8_t a) {
         .           // Since PEM is sometimes used to carry private keys, we encode base64 data
         .           // itself in constant-time.
         .           a &= 0x3f;
         .           uint8_t ret = constant_time_select_8(constant_time_eq_8(a, 62), '+', '/');
-- line 92 ----------------------------------------
-- line 257 ----------------------------------------
         .           if (len % 4 != 0) {
         .             return 0;
         .           }
         .         
         .           *out_len = (len / 4) * 3;
         .           return 1;
         .         }
         .         
     2,190 (0.0%)  void EVP_DecodeInit(EVP_ENCODE_CTX *ctx) {
     2,190 (0.0%)    OPENSSL_memset(ctx, 0, sizeof(EVP_ENCODE_CTX));
     1,314 (0.0%)  }
         .         
 3,746,520 (0.6%)  static uint8_t base64_ascii_to_bin(uint8_t a) {
         .           // Since PEM is sometimes used to carry private keys, we decode base64 data
         .           // itself in constant-time.
 3,746,520 (0.6%)    const uint8_t is_upper = constant_time_in_range_8(a, 'A', 'Z');
 3,746,520 (0.6%)    const uint8_t is_lower = constant_time_in_range_8(a, 'a', 'z');
 3,746,520 (0.6%)    const uint8_t is_digit = constant_time_in_range_8(a, '0', '9');
 3,122,100 (0.5%)    const uint8_t is_plus = constant_time_eq_8(a, '+');
 3,122,100 (0.5%)    const uint8_t is_slash = constant_time_eq_8(a, '/');
 3,122,100 (0.5%)    const uint8_t is_equals = constant_time_eq_8(a, '=');
         .         
   624,420 (0.1%)    uint8_t ret = 0;
 4,995,360 (0.8%)    ret |= is_upper & (a - 'A');       // [0,26)
 4,995,360 (0.8%)    ret |= is_lower & (a - 'a' + 26);  // [26,52)
 4,995,360 (0.8%)    ret |= is_digit & (a - '0' + 52);  // [52,62)
 3,746,520 (0.6%)    ret |= is_plus & 62;
 3,746,520 (0.6%)    ret |= is_slash & 63;
         .           // Invalid inputs, 'A', and '=' have all been mapped to zero. Map invalid
         .           // inputs to 0xff. Note '=' is padding and handled separately by the caller.
 4,370,940 (0.7%)    const uint8_t is_valid =
         .               is_upper | is_lower | is_digit | is_plus | is_slash | is_equals;
 3,746,520 (0.6%)    ret |= ~is_valid;
   624,420 (0.1%)    return ret;
 1,248,840 (0.2%)  }
         .         
         .         // base64_decode_quad decodes a single “quad” (i.e. four characters) of base64
         .         // data and writes up to three bytes to |out|. It sets |*out_num_bytes| to the
         .         // number of bytes written, which will be less than three if the quad ended
         .         // with padding.  It returns one on success or zero on error.
         .         static int base64_decode_quad(uint8_t *out, size_t *out_num_bytes,
 1,092,735 (0.2%)                                const uint8_t *in) {
   936,630 (0.1%)    const uint8_t a = base64_ascii_to_bin(in[0]);
 1,092,735 (0.2%)    const uint8_t b = base64_ascii_to_bin(in[1]);
 1,092,735 (0.2%)    const uint8_t c = base64_ascii_to_bin(in[2]);
 1,092,735 (0.2%)    const uint8_t d = base64_ascii_to_bin(in[3]);
 1,248,840 (0.2%)    if (a == 0xff || b == 0xff || c == 0xff || d == 0xff) {
         .             return 0;
         .           }
         .         
 1,404,945 (0.2%)    const uint32_t v = ((uint32_t)a) << 18 | ((uint32_t)b) << 12 |
   468,315 (0.1%)                       ((uint32_t)c) << 6 | (uint32_t)d;
         .         
 1,092,735 (0.2%)    const unsigned padding_pattern = (in[0] == '=') << 3 |
 1,092,735 (0.2%)                                     (in[1] == '=') << 2 |
 1,092,846 (0.2%)                                     (in[2] == '=') << 1 |
   936,630 (0.1%)                                     (in[3] == '=');
         .         
   936,468 (0.1%)    switch (padding_pattern) {
         .             case 0:
         .               // The common case of no padding.
   311,706 (0.0%)        *out_num_bytes = 3;
   779,265 (0.1%)        out[0] = v >> 16;
   935,118 (0.1%)        out[1] = v >> 8;
   623,412 (0.1%)        out[2] = v;
   155,853 (0.0%)        break;
         .         
         .             case 1:  // xxx=
       282 (0.0%)        *out_num_bytes = 2;
       705 (0.0%)        out[0] = v >> 16;
       846 (0.0%)        out[1] = v >> 8;
       141 (0.0%)        break;
         .         
         .             case 3:  // xx==
       222 (0.0%)        *out_num_bytes = 1;
       555 (0.0%)        out[0] = v >> 16;
       111 (0.0%)        break;
         .         
         .             default:
         .               return 0;
         .           }
         .         
   156,105 (0.0%)    return 1;
   312,210 (0.0%)  }
         .         
         .         int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, uint8_t *out, int *out_len,
     5,256 (0.0%)                       const uint8_t *in, size_t in_len) {
       876 (0.0%)    *out_len = 0;
         .         
     1,752 (0.0%)    if (ctx->error_encountered) {
         .             return -1;
         .           }
         .         
       438 (0.0%)    size_t bytes_out = 0, i;
 2,539,686 (0.4%)    for (i = 0; i < in_len; i++) {
 3,171,870 (0.5%)      const char c = in[i];
 3,261,456 (0.5%)      switch (c) {
         .               case ' ':
         .               case '\t':
         .               case '\r':
         .               case '\n':
     9,954 (0.0%)          continue;
         .             }
         .         
 2,497,680 (0.4%)      if (ctx->eof_seen) {
         .               ctx->error_encountered = 1;
         .               return -1;
         .             }
         .         
 5,619,780 (0.8%)      ctx->data[ctx->data_used++] = c;
 2,497,680 (0.4%)      if (ctx->data_used == 4) {
         .               size_t num_bytes_resulting;
 1,404,945 (0.2%)        if (!base64_decode_quad(out, &num_bytes_resulting, ctx->data)) {
         .                 ctx->error_encountered = 1;
         .                 return -1;
         .               }
         .         
   312,210 (0.0%)        ctx->data_used = 0;
   312,210 (0.0%)        bytes_out += num_bytes_resulting;
   312,210 (0.0%)        out += num_bytes_resulting;
         .         
   468,315 (0.1%)        if (num_bytes_resulting < 3) {
       756 (0.0%)          ctx->eof_seen = 1;
         .               }
         .             }
         .           }
         .         
     1,314 (0.0%)    if (bytes_out > INT_MAX) {
         .             ctx->error_encountered = 1;
         .             *out_len = 0;
         .             return -1;
         .           }
     1,752 (0.0%)    *out_len = (int)bytes_out;
         .         
     1,752 (0.0%)    if (ctx->eof_seen) {
       504 (0.0%)      return 0;
         .           }
         .         
       186 (0.0%)    return 1;
     2,190 (0.0%)  }
         .         
     2,628 (0.0%)  int EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, uint8_t *out, int *out_len) {
       876 (0.0%)    *out_len = 0;
     3,504 (0.0%)    if (ctx->error_encountered || ctx->data_used != 0) {
         .             return -1;
         .           }
         .         
       438 (0.0%)    return 1;
       876 (0.0%)  }
         .         
         .         int EVP_DecodeBase64(uint8_t *out, size_t *out_len, size_t max_out,
         .                              const uint8_t *in, size_t in_len) {
         .           *out_len = 0;
         .         
         .           if (in_len % 4 != 0) {
         .             return 0;
         .           }
-- line 413 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 19 ----------------------------------------
      .         #include <string.h>
      .         
      .         #include <openssl/mem.h>
      .         #include <openssl/err.h>
      .         
      .         #include "../internal.h"
      .         
      .         
 27,575 (0.0%)  void CBB_zero(CBB *cbb) {
 27,575 (0.0%)    OPENSSL_memset(cbb, 0, sizeof(CBB));
 16,545 (0.0%)  }
      .         
 16,422 (0.0%)  static void cbb_init(CBB *cbb, uint8_t *buf, size_t cap, int can_resize) {
  4,692 (0.0%)    cbb->is_child = 0;
  4,692 (0.0%)    cbb->child = NULL;
  7,038 (0.0%)    cbb->u.base.buf = buf;
  4,692 (0.0%)    cbb->u.base.len = 0;
  7,038 (0.0%)    cbb->u.base.cap = cap;
 21,114 (0.0%)    cbb->u.base.can_resize = can_resize;
  9,384 (0.0%)    cbb->u.base.error = 0;
  7,038 (0.0%)  }
      .         
 14,076 (0.0%)  int CBB_init(CBB *cbb, size_t initial_capacity) {
  7,038 (0.0%)    CBB_zero(cbb);
      .         
  9,384 (0.0%)    uint8_t *buf = OPENSSL_malloc(initial_capacity);
  9,384 (0.0%)    if (initial_capacity > 0 && buf == NULL) {
      .             return 0;
      .           }
      .         
 14,076 (0.0%)    cbb_init(cbb, buf, initial_capacity, /*can_resize=*/1);
  2,346 (0.0%)    return 1;
  4,692 (0.0%)  }
      .         
      .         int CBB_init_fixed(CBB *cbb, uint8_t *buf, size_t len) {
      .           CBB_zero(cbb);
      .           cbb_init(cbb, buf, len, /*can_resize=*/0);
      .           return 1;
      .         }
      .         
 11,730 (0.0%)  void CBB_cleanup(CBB *cbb) {
      .           // Child |CBB|s are non-owning. They are implicitly discarded and should not
      .           // be used with |CBB_cleanup| or |ScopedCBB|.
  9,384 (0.0%)    assert(!cbb->is_child);
  9,384 (0.0%)    if (cbb->is_child) {
      .             return;
      .           }
      .         
 11,730 (0.0%)    if (cbb->u.base.can_resize) {
 11,730 (0.0%)      OPENSSL_free(cbb->u.base.buf);
      .           }
  4,692 (0.0%)  }
      .         
      .         static int cbb_buffer_reserve(struct cbb_buffer_st *base, uint8_t **out,
252,126 (0.0%)                                size_t len) {
 72,036 (0.0%)    if (base == NULL) {
      .             return 0;
      .           }
      .         
180,090 (0.0%)    size_t newlen = base->len + len;
144,072 (0.0%)    if (newlen < base->len) {
      .             // Overflow
      .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
      .             goto err;
      .           }
      .         
144,072 (0.0%)    if (newlen > base->cap) {
      .             if (!base->can_resize) {
      .               OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
      .               goto err;
      .             }
      .         
      .             size_t newcap = base->cap * 2;
      .             if (newcap < base->cap || newcap < newlen) {
      .               newcap = newlen;
-- line 93 ----------------------------------------
-- line 96 ----------------------------------------
      .             if (newbuf == NULL) {
      .               goto err;
      .             }
      .         
      .             base->buf = newbuf;
      .             base->cap = newcap;
      .           }
      .         
 72,036 (0.0%)    if (out) {
252,126 (0.0%)      *out = base->buf + base->len;
      .           }
      .         
 72,036 (0.0%)    return 1;
      .         
      .         err:
      .           base->error = 1;
      .           return 0;
 72,036 (0.0%)  }
      .         
      .         static int cbb_buffer_add(struct cbb_buffer_st *base, uint8_t **out,
252,126 (0.0%)                            size_t len) {
288,144 (0.0%)    if (!cbb_buffer_reserve(base, out, len)) {
      .             return 0;
      .           }
      .           // This will not overflow or |cbb_buffer_reserve| would have failed.
216,108 (0.0%)    base->len += len;
 36,018 (0.0%)    return 1;
 72,036 (0.0%)  }
      .         
 16,422 (0.0%)  int CBB_finish(CBB *cbb, uint8_t **out_data, size_t *out_len) {
  9,384 (0.0%)    if (cbb->is_child) {
      .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
      .             return 0;
      .           }
      .         
 11,730 (0.0%)    if (!CBB_flush(cbb)) {
      .             return 0;
      .           }
      .         
 21,114 (0.0%)    if (cbb->u.base.can_resize && (out_data == NULL || out_len == NULL)) {
      .             // |out_data| and |out_len| can only be NULL if the CBB is fixed.
      .             return 0;
      .           }
      .         
  4,692 (0.0%)    if (out_data != NULL) {
  9,384 (0.0%)      *out_data = cbb->u.base.buf;
      .           }
  4,692 (0.0%)    if (out_len != NULL) {
  9,384 (0.0%)      *out_len = cbb->u.base.len;
      .           }
  4,692 (0.0%)    cbb->u.base.buf = NULL;
  7,038 (0.0%)    CBB_cleanup(cbb);
  2,346 (0.0%)    return 1;
  4,692 (0.0%)  }
      .         
297,528 (0.0%)  static struct cbb_buffer_st *cbb_get_base(CBB *cbb) {
297,528 (0.0%)    if (cbb->is_child) {
      .             return cbb->u.child.base;
      .           }
148,764 (0.0%)    return &cbb->u.base;
148,764 (0.0%)  }
      .         
      .         static void cbb_on_error(CBB *cbb) {
      .           // Due to C's lack of destructors and |CBB|'s auto-flushing API, a failing
      .           // |CBB|-taking function may leave a dangling pointer to a child |CBB|. As a
      .           // result, the convention is callers may not write to |CBB|s that have failed.
      .           // But, as a safety measure, we lock the |CBB| into an error state. Once the
      .           // error bit is set, |cbb->child| will not be read.
      .           //
-- line 164 ----------------------------------------
-- line 176 ----------------------------------------
      .           // warning does not know |cbb->child| will not be read once |error| is set
      .           // above.
      .           cbb->child = NULL;
      .         }
      .         
      .         // CBB_flush recurses and then writes out any pending length prefix. The
      .         // current length of the underlying base is taken to be the length of the
      .         // length-prefixed data.
191,820 (0.0%)  int CBB_flush(CBB *cbb) {
      .           // If |base| has hit an error, the buffer is in an undefined state, so
      .           // fail all following calls. In particular, |cbb->child| may point to invalid
      .           // memory.
153,456 (0.0%)    struct cbb_buffer_st *base = cbb_get_base(cbb);
268,548 (0.0%)    if (base == NULL || base->error) {
      .             return 0;
      .           }
      .         
153,456 (0.0%)    if (cbb->child == NULL) {
      .             // Nothing to flush.
 76,728 (0.0%)      return 1;
      .           }
      .         
      .           assert(cbb->child->is_child);
      .           struct cbb_child_st *child = &cbb->child->u.child;
      .           assert(child->base == base);
      .           size_t child_start = child->offset + child->pending_len_len;
      .         
      .           if (!CBB_flush(cbb->child) ||
-- line 203 ----------------------------------------
-- line 264 ----------------------------------------
      .           child->base = NULL;
      .           cbb->child = NULL;
      .         
      .           return 1;
      .         
      .         err:
      .           cbb_on_error(cbb);
      .           return 0;
 76,728 (0.0%)  }
      .         
      .         const uint8_t *CBB_data(const CBB *cbb) {
      .           assert(cbb->child == NULL);
      .           if (cbb->is_child) {
      .             return cbb->u.child.base->buf + cbb->u.child.offset +
      .                    cbb->u.child.pending_len_len;
      .           }
      .           return cbb->u.base.buf;
-- line 280 ----------------------------------------
-- line 397 ----------------------------------------
      .           uint8_t *out;
      .           if (!CBB_add_space(cbb, &out, len)) {
      .             return 0;
      .           }
      .           OPENSSL_memset(out, 0, len);
      .           return 1;
      .         }
      .         
252,126 (0.0%)  int CBB_add_space(CBB *cbb, uint8_t **out_data, size_t len) {
252,126 (0.0%)    if (!CBB_flush(cbb) ||
324,162 (0.0%)        !cbb_buffer_add(cbb_get_base(cbb), out_data, len)) {
      .             return 0;
      .           }
 36,018 (0.0%)    return 1;
 72,036 (0.0%)  }
      .         
      .         int CBB_reserve(CBB *cbb, uint8_t **out_data, size_t len) {
      .           if (!CBB_flush(cbb) ||
      .               !cbb_buffer_reserve(cbb_get_base(cbb), out_data, len)) {
      .             return 0;
      .           }
      .           return 1;
      .         }
-- line 419 ----------------------------------------
-- line 425 ----------------------------------------
      .               newlen < base->len ||
      .               newlen > base->cap) {
      .             return 0;
      .           }
      .           base->len = newlen;
      .           return 1;
      .         }
      .         
360,180 (0.1%)  static int cbb_add_u(CBB *cbb, uint64_t v, size_t len_len) {
      .           uint8_t *buf;
288,144 (0.0%)    if (!CBB_add_space(cbb, &buf, len_len)) {
      .             return 0;
      .           }
      .         
396,198 (0.1%)    for (size_t i = len_len - 1; i < len_len; i--) {
180,090 (0.0%)      buf[i] = v;
 36,018 (0.0%)      v >>= 8;
      .           }
      .         
      .           // |v| must fit in |len_len| bytes.
 72,036 (0.0%)    if (v != 0) {
      .             cbb_on_error(cbb);
      .             return 0;
      .           }
      .         
 36,018 (0.0%)    return 1;
180,090 (0.0%)  }
      .         
252,126 (0.0%)  int CBB_add_u8(CBB *cbb, uint8_t value) {
216,108 (0.0%)    return cbb_add_u(cbb, value, 1);
 72,036 (0.0%)  }
      .         
      .         int CBB_add_u16(CBB *cbb, uint16_t value) {
      .           return cbb_add_u(cbb, value, 2);
      .         }
      .         
      .         int CBB_add_u16le(CBB *cbb, uint16_t value) {
      .           return CBB_add_u16(cbb, CRYPTO_bswap2(value));
      .         }
-- line 463 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 26 ----------------------------------------
        .         
        .         #include <string.h>
        .         
        .         #include "../asn1/internal.h"
        .         #include "../internal.h"
        .         #include "internal.h"
        .         
        .         
  523,728 (0.1%)  void CBS_init(CBS *cbs, const uint8_t *data, size_t len) {
  261,864 (0.0%)    cbs->data = data;
  261,864 (0.0%)    cbs->len = len;
  261,864 (0.0%)  }
        .         
1,729,776 (0.3%)  static int cbs_get(CBS *cbs, const uint8_t **p, size_t n) {
1,153,184 (0.2%)    if (cbs->len < n) {
   13,266 (0.0%)      return 0;
        .           }
        .         
1,126,652 (0.2%)    *p = cbs->data;
1,689,978 (0.3%)    cbs->data += n;
1,689,978 (0.3%)    cbs->len -= n;
  281,663 (0.0%)    return 1;
  576,592 (0.1%)  }
        .         
  345,429 (0.1%)  int CBS_skip(CBS *cbs, size_t len) {
        .           const uint8_t *dummy;
  230,286 (0.0%)    return cbs_get(cbs, &dummy, len);
  191,905 (0.0%)  }
        .         
  304,832 (0.0%)  const uint8_t *CBS_data(const CBS *cbs) { return cbs->data; }
        .         
1,988,968 (0.3%)  size_t CBS_len(const CBS *cbs) { return cbs->len; }
        .         
        .         int CBS_stow(const CBS *cbs, uint8_t **out_ptr, size_t *out_len) {
        .           OPENSSL_free(*out_ptr);
        .           *out_ptr = NULL;
        .           *out_len = 0;
        .         
        .           if (cbs->len == 0) {
        .             return 1;
-- line 65 ----------------------------------------
-- line 79 ----------------------------------------
        .           *out_ptr = OPENSSL_strndup((const char *)cbs->data, cbs->len);
        .           return (*out_ptr != NULL);
        .         }
        .         
        .         int CBS_contains_zero_byte(const CBS *cbs) {
        .           return OPENSSL_memchr(cbs->data, 0, cbs->len) != NULL;
        .         }
        .         
    2,436 (0.0%)  int CBS_mem_equal(const CBS *cbs, const uint8_t *data, size_t len) {
    1,392 (0.0%)    if (len != cbs->len) {
      240 (0.0%)      return 0;
        .           }
    2,280 (0.0%)    return CRYPTO_memcmp(cbs->data, data, len) == 0;
      696 (0.0%)  }
        .         
   36,640 (0.0%)  static int cbs_get_u(CBS *cbs, uint64_t *out, size_t len) {
    3,664 (0.0%)    uint64_t result = 0;
        .           const uint8_t *data;
        .         
   29,312 (0.0%)    if (!cbs_get(cbs, &data, len)) {
        .             return 0;
        .           }
   45,904 (0.0%)    for (size_t i = 0; i < len; i++) {
    6,896 (0.0%)      result <<= 8;
   41,376 (0.0%)      result |= data[i];
        .           }
   10,992 (0.0%)    *out = result;
    3,664 (0.0%)    return 1;
   18,320 (0.0%)  }
        .         
1,871,478 (0.3%)  int CBS_get_u8(CBS *cbs, uint8_t *out) {
        .           const uint8_t *v;
1,663,536 (0.3%)    if (!cbs_get(cbs, &v, 1)) {
   13,266 (0.0%)      return 0;
        .           }
  805,236 (0.1%)    *out = *v;
  201,309 (0.0%)    return 1;
1,039,710 (0.2%)  }
        .         
        .         int CBS_get_u16(CBS *cbs, uint16_t *out) {
        .           uint64_t v;
        .           if (!cbs_get_u(cbs, &v, 2)) {
        .             return 0;
        .           }
        .           *out = v;
        .           return 1;
-- line 124 ----------------------------------------
-- line 172 ----------------------------------------
        .           if (cbs->len == 0) {
        .             return 0;
        .           }
        .           *out = cbs->data[cbs->len - 1];
        .           cbs->len--;
        .           return 1;
        .         }
        .         
  383,090 (0.1%)  int CBS_get_bytes(CBS *cbs, CBS *out, size_t len) {
        .           const uint8_t *v;
  306,472 (0.0%)    if (!cbs_get(cbs, &v, len)) {
        .             return 0;
        .           }
  229,854 (0.0%)    CBS_init(out, v, len);
   38,309 (0.0%)    return 1;
  191,545 (0.0%)  }
        .         
        .         int CBS_copy_bytes(CBS *cbs, uint8_t *out, size_t len) {
        .           const uint8_t *v;
        .           if (!cbs_get(cbs, &v, len)) {
        .             return 0;
        .           }
        .           OPENSSL_memcpy(out, v, len);
        .           return 1;
-- line 195 ----------------------------------------
-- line 272 ----------------------------------------
        .         
        .             // Values end at an octet with the high bit cleared.
        .           } while (b & 0x80);
        .         
        .           *out = v;
        .           return 1;
        .         }
        .         
  344,799 (0.1%)  static int parse_asn1_tag(CBS *cbs, CBS_ASN1_TAG *out) {
        .           uint8_t tag_byte;
  268,177 (0.0%)    if (!CBS_get_u8(cbs, &tag_byte)) {
        4 (0.0%)      return 0;
        .           }
        .         
        .           // ITU-T X.690 section 8.1.2.3 specifies the format for identifiers with a tag
        .           // number no greater than 30.
        .           //
        .           // If the number portion is 31 (0x1f, the largest value that fits in the
        .           // allotted bits), then the tag is more than one byte long and the
        .           // continuation bytes contain the tag number.
  191,545 (0.0%)    CBS_ASN1_TAG tag = ((CBS_ASN1_TAG)tag_byte & 0xe0) << CBS_ASN1_TAG_SHIFT;
  153,236 (0.0%)    CBS_ASN1_TAG tag_number = tag_byte & 0x1f;
   76,618 (0.0%)    if (tag_number == 0x1f) {
        .             uint64_t v;
        .             if (!parse_base128_integer(cbs, &v) ||
        .                 // Check the tag number is within our supported bounds.
        .                 v > CBS_ASN1_TAG_NUMBER_MASK ||
        .                 // Small tag numbers should have used low tag number form, even in BER.
        .                 v < 0x1f) {
        .               return 0;
        .             }
        .             tag_number = (CBS_ASN1_TAG)v;
        .           }
        .         
   76,618 (0.0%)    tag |= tag_number;
        .         
        .           // Tag [UNIVERSAL 0] is reserved for use by the encoding. Reject it here to
        .           // avoid some ambiguity around ANY values and BER indefinite-length EOCs. See
        .           // https://crbug.com/boringssl/455.
  153,236 (0.0%)    if ((tag & ~CBS_ASN1_CONSTRUCTED) == 0) {
        .             return 0;
        .           }
        .         
  114,927 (0.0%)    *out = tag;
   38,309 (0.0%)    return 1;
  191,555 (0.0%)  }
        .         
        .         static int cbs_get_any_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
        .                                             size_t *out_header_len, int *out_ber_found,
  536,326 (0.1%)                                      int *out_indefinite, int ber_ok) {
  191,545 (0.0%)    CBS header = *cbs;
        .           CBS throwaway;
        .         
   76,618 (0.0%)    if (out == NULL) {
        .             out = &throwaway;
        .           }
   76,618 (0.0%)    if (ber_ok) {
   70,250 (0.0%)      *out_ber_found = 0;
  105,375 (0.0%)      *out_indefinite = 0;
        .           } else {
    6,368 (0.0%)      assert(out_ber_found == NULL);
    6,368 (0.0%)      assert(out_indefinite == NULL);
        .           }
        .         
        .           CBS_ASN1_TAG tag;
  268,163 (0.0%)    if (!parse_asn1_tag(&header, &tag)) {
        .             return 0;
        .           }
   76,618 (0.0%)    if (out_tag != NULL) {
  114,927 (0.0%)      *out_tag = tag;
        .           }
        .         
        .           uint8_t length_byte;
  268,163 (0.0%)    if (!CBS_get_u8(&header, &length_byte)) {
        .             return 0;
        .           }
        .         
  383,090 (0.1%)    size_t header_len = CBS_len(cbs) - CBS_len(&header);
        .         
        .           size_t len;
        .           // The format for the length encoding is specified in ITU-T X.690 section
        .           // 8.1.3.
  114,927 (0.0%)    if ((length_byte & 0x80) == 0) {
        .             // Short form length.
  173,225 (0.0%)      len = ((size_t)length_byte) + header_len;
   69,290 (0.0%)      if (out_header_len != NULL) {
  138,580 (0.0%)        *out_header_len = header_len;
        .             }
        .           } else {
        .             // The high bit indicate that this is the long form, while the next 7 bits
        .             // encode the number of subsequent octets used to encode the length (ITU-T
        .             // X.690 clause 8.1.3.5.b).
   14,656 (0.0%)      const size_t num_bytes = length_byte & 0x7f;
        .             uint64_t len64;
        .         
   20,144 (0.0%)      if (ber_ok && (tag & CBS_ASN1_CONSTRUCTED) != 0 && num_bytes == 0) {
        .               // indefinite length
        .               if (out_header_len != NULL) {
        .                 *out_header_len = header_len;
        .               }
        .               *out_ber_found = 1;
        .               *out_indefinite = 1;
        .               return CBS_get_bytes(cbs, out, header_len);
        .             }
        .         
        .             // ITU-T X.690 clause 8.1.3.5.c specifies that the value 0xff shall not be
        .             // used as the first byte of the length. If this parser encounters that
        .             // value, num_bytes will be parsed as 127, which will fail this check.
   14,656 (0.0%)      if (num_bytes == 0 || num_bytes > 4) {
        .               return 0;
        .             }
   29,312 (0.0%)      if (!cbs_get_u(&header, &len64, num_bytes)) {
        .               return 0;
        .             }
        .             // ITU-T X.690 section 10.1 (DER length forms) requires encoding the
        .             // length with the minimum number of octets. BER could, technically, have
        .             // 125 superfluous zero bytes. We do not attempt to handle that and still
        .             // require that the length fit in a |uint32_t| for BER.
   10,992 (0.0%)      if (len64 < 128) {
        .               // Length should have used short-form encoding.
        .               if (ber_ok) {
        .                 *out_ber_found = 1;
        .               } else {
        .                 return 0;
        .               }
        .             }
   32,976 (0.0%)      if ((len64 >> ((num_bytes - 1) * 8)) == 0) {
        .               // Length should have been at least one byte shorter.
        .               if (ber_ok) {
        .                 *out_ber_found = 1;
        .               } else {
        .                 return 0;
        .               }
        .             }
    7,328 (0.0%)      len = len64;
   25,648 (0.0%)      if (len + header_len + num_bytes < len) {
        .               // Overflow.
        .               return 0;
        .             }
   14,656 (0.0%)      len += header_len + num_bytes;
    7,328 (0.0%)      if (out_header_len != NULL) {
   18,320 (0.0%)        *out_header_len = header_len + num_bytes;
        .             }
        .           }
        .         
  229,854 (0.0%)    return CBS_get_bytes(cbs, out, len);
  229,854 (0.0%)  }
        .         
        .         int CBS_get_any_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag) {
        .           size_t header_len;
        .           if (!CBS_get_any_asn1_element(cbs, out, out_tag, &header_len)) {
        .             return 0;
        .           }
        .         
        .           if (!CBS_skip(out, header_len)) {
-- line 426 ----------------------------------------
-- line 427 ----------------------------------------
        .             assert(0);
        .             return 0;
        .           }
        .         
        .           return 1;
        .         }
        .         
        .         int CBS_get_any_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
   25,472 (0.0%)                               size_t *out_header_len) {
   35,024 (0.0%)    return cbs_get_any_asn1_element(cbs, out, out_tag, out_header_len, NULL, NULL,
        .                                           /*ber_ok=*/0);
    6,368 (0.0%)  }
        .         
        .         int CBS_get_any_ber_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
        .                                          size_t *out_header_len, int *out_ber_found,
  456,625 (0.1%)                                   int *out_indefinite) {
        .           int ber_found_temp;
  526,875 (0.1%)    return cbs_get_any_asn1_element(
        .               cbs, out, out_tag, out_header_len,
        .               out_ber_found ? out_ber_found : &ber_found_temp, out_indefinite,
        .               /*ber_ok=*/1);
  175,625 (0.0%)  }
        .         
        .         static int cbs_get_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value,
   35,024 (0.0%)                          int skip_header) {
        .           size_t header_len;
        .           CBS_ASN1_TAG tag;
        .           CBS throwaway;
        .         
    6,368 (0.0%)    if (out == NULL) {
        .             out = &throwaway;
        .           }
        .         
   31,840 (0.0%)    if (!CBS_get_any_asn1_element(cbs, out, &tag, &header_len) ||
    3,184 (0.0%)        tag != tag_value) {
        .             return 0;
        .           }
        .         
   28,656 (0.0%)    if (skip_header && !CBS_skip(out, header_len)) {
        .             assert(0);
        .             return 0;
        .           }
        .         
    3,184 (0.0%)    return 1;
   15,920 (0.0%)  }
        .         
   22,288 (0.0%)  int CBS_get_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value) {
   19,104 (0.0%)    return cbs_get_asn1(cbs, out, tag_value, 1 /* skip header */);
    6,368 (0.0%)  }
        .         
        .         int CBS_get_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value) {
        .           return cbs_get_asn1(cbs, out, tag_value, 0 /* include header */);
        .         }
        .         
       18 (0.0%)  int CBS_peek_asn1_tag(const CBS *cbs, CBS_ASN1_TAG tag_value) {
       10 (0.0%)    CBS copy = *cbs;
        .           CBS_ASN1_TAG actual_tag;
       16 (0.0%)    return parse_asn1_tag(&copy, &actual_tag) && tag_value == actual_tag;
       10 (0.0%)  }
        .         
       18 (0.0%)  int CBS_get_asn1_uint64(CBS *cbs, uint64_t *out) {
        .           CBS bytes;
       20 (0.0%)    if (!CBS_get_asn1(cbs, &bytes, CBS_ASN1_INTEGER) ||
        6 (0.0%)        !CBS_is_unsigned_asn1_integer(&bytes)) {
        .             return 0;
        .           }
        .         
        4 (0.0%)    *out = 0;
        8 (0.0%)    const uint8_t *data = CBS_data(&bytes);
        8 (0.0%)    size_t len = CBS_len(&bytes);
       18 (0.0%)    for (size_t i = 0; i < len; i++) {
       10 (0.0%)      if ((*out >> 56) != 0) {
        .               // Too large to represent as a uint64_t.
        .               return 0;
        .             }
       12 (0.0%)      *out <<= 8;
       20 (0.0%)      *out |= data[i];
        .           }
        .         
        2 (0.0%)    return 1;
       10 (0.0%)  }
        .         
        .         int CBS_get_asn1_int64(CBS *cbs, int64_t *out) {
        .           int is_negative;
        .           CBS bytes;
        .           if (!CBS_get_asn1(cbs, &bytes, CBS_ASN1_INTEGER) ||
        .               !CBS_is_valid_asn1_integer(&bytes, &is_negative)) {
        .             return 0;
        .           }
-- line 515 ----------------------------------------
-- line 670 ----------------------------------------
        .         
        .           // Unused bits are zero, and this function does not distinguish between
        .           // missing and unset bits. Thus it is sufficient to do a byte-level length
        .           // check.
        .           return byte_num < CBS_len(cbs) &&
        .                  (CBS_data(cbs)[byte_num] & (1 << bit_num)) != 0;
        .         }
        .         
   13,806 (0.0%)  int CBS_is_valid_asn1_integer(const CBS *cbs, int *out_is_negative) {
    7,670 (0.0%)    CBS copy = *cbs;
        .           uint8_t first_byte, second_byte;
   10,738 (0.0%)    if (!CBS_get_u8(&copy, &first_byte)) {
        .             return 0;  // INTEGERs may not be empty.
        .           }
    3,068 (0.0%)    if (out_is_negative != NULL) {
    7,670 (0.0%)      *out_is_negative = (first_byte & 0x80) != 0;
        .           }
   10,738 (0.0%)    if (!CBS_get_u8(&copy, &second_byte)) {
    1,000 (0.0%)      return 1;  // One byte INTEGERs are always minimal.
        .           }
    6,289 (0.0%)    if ((first_byte == 0x00 && (second_byte & 0x80) == 0) ||
    1,034 (0.0%)        (first_byte == 0xff && (second_byte & 0x80) != 0)) {
        .             return 0;  // The value is minimal iff the first 9 bits are not all equal.
        .           }
    1,034 (0.0%)    return 1;
    7,670 (0.0%)  }
        .         
       16 (0.0%)  int CBS_is_unsigned_asn1_integer(const CBS *cbs) {
        .           int is_negative;
       24 (0.0%)    return CBS_is_valid_asn1_integer(cbs, &is_negative) && !is_negative;
       10 (0.0%)  }
        .         
        .         static int add_decimal(CBB *out, uint64_t v) {
        .           char buf[DECIMAL_SIZE(uint64_t) + 1];
        .           snprintf(buf, sizeof(buf), "%" PRIu64, v);
        .           return CBB_add_bytes(out, (const uint8_t *)buf, strlen(buf));
        .         }
        .         
   49,048 (0.0%)  int CBS_is_valid_asn1_oid(const CBS *cbs) {
   30,655 (0.0%)    if (CBS_len(cbs) == 0) {
        .             return 0;  // OID encodings cannot be empty.
        .           }
        .         
   30,655 (0.0%)    CBS copy = *cbs;
    6,131 (0.0%)    uint8_t v, prev = 0;
  233,897 (0.0%)    while (CBS_get_u8(&copy, &v)) {
        .             // OID encodings are a sequence of minimally-encoded base-128 integers (see
        .             // |parse_base128_integer|). If |prev|'s MSB was clear, it was the last byte
        .             // of an integer (or |v| is the first byte). |v| is then the first byte of
        .             // the next integer. If first byte of an integer is 0x80, it is not
        .             // minimally-encoded.
  147,021 (0.0%)      if ((prev & 0x80) == 0 && v == 0x80) {
        .               return 0;
        .             }
   52,814 (0.0%)      prev = v;
        .           }
        .         
        .           // The last byte should must end an integer encoding.
   24,524 (0.0%)    return (prev & 0x80) == 0;
   30,655 (0.0%)  }
        .         
        .         char *CBS_asn1_oid_to_text(const CBS *cbs) {
        .           CBB cbb;
        .           if (!CBB_init(&cbb, 32)) {
        .             goto err;
        .           }
        .         
        .           CBS copy = *cbs;
-- line 737 ----------------------------------------
-- line 766 ----------------------------------------
        .         
        .           return (char *)txt;
        .         
        .         err:
        .           CBB_cleanup(&cbb);
        .           return NULL;
        .         }
        .         
   47,826 (0.0%)  static int cbs_get_two_digits(CBS *cbs, int *out) {
        .           uint8_t first_digit, second_digit;
   37,198 (0.0%)    if (!CBS_get_u8(cbs, &first_digit)) {
        .             return 0;
        .           }
   31,884 (0.0%)    if (!OPENSSL_isdigit(first_digit)) {
        .             return 0;
        .           }
   37,198 (0.0%)    if (!CBS_get_u8(cbs, &second_digit)) {
        .             return 0;
        .           }
   31,884 (0.0%)    if (!OPENSSL_isdigit(second_digit)) {
        .             return 0;
        .           }
   74,396 (0.0%)    *out = (first_digit - '0') * 10 + (second_digit - '0');
    5,314 (0.0%)    return 1;
   26,570 (0.0%)  }
        .         
    5,304 (0.0%)  static int is_valid_day(int year, int month, int day) {
    1,768 (0.0%)    if (day < 1) {
        .             return 0;
        .           }
   15,660 (0.0%)    switch (month) {
        .             case 1:
        .             case 3:
        .             case 5:
        .             case 7:
        .             case 8:
        .             case 10:
        .             case 12:
    2,216 (0.0%)        return day <= 31;
        .             case 4:
        .             case 6:
        .             case 9:
        .             case 11:
      984 (0.0%)        return day <= 30;
        .             case 2:
    1,428 (0.0%)        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
       72 (0.0%)          return day <= 29;
        .               } else {
      264 (0.0%)          return day <= 28;
        .               }
        .             default:
        .               return 0;
        .           }
    1,768 (0.0%)  }
        .         
        .         static int CBS_parse_rfc5280_time_internal(const CBS *cbs, int is_gentime,
        .                                                    int allow_timezone_offset,
    9,724 (0.0%)                                             struct tm *out_tm) {
        .           int year, month, day, hour, min, sec, tmp;
    4,420 (0.0%)    CBS copy = *cbs;
        .           uint8_t tz;
        .         
    1,768 (0.0%)    if (is_gentime) {
       70 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
        .               return 0;
        .             }
       30 (0.0%)      year = tmp * 100;
       70 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
        .               return 0;
        .             }
       30 (0.0%)      year += tmp;
        .           } else {
      874 (0.0%)      year = 1900;
    6,118 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
        .               return 0;
        .             }
    1,748 (0.0%)      year += tmp;
    1,748 (0.0%)      if (year < 1950) {
      868 (0.0%)        year += 100;
        .             }
    1,748 (0.0%)      if (year >= 2050) {
        .               return 0;  // A Generalized time must be used.
        .             }
        .           }
   10,608 (0.0%)    if (!cbs_get_two_digits(&copy, &month) || month < 1 ||
    2,652 (0.0%)        month > 12 ||  // Reject invalid months.
    6,188 (0.0%)        !cbs_get_two_digits(&copy, &day) ||
    7,072 (0.0%)        !is_valid_day(year, month, day) ||  // Reject invalid days.
    6,188 (0.0%)        !cbs_get_two_digits(&copy, &hour) ||
    2,652 (0.0%)        hour > 23 ||  // Reject invalid hours.
    6,188 (0.0%)        !cbs_get_two_digits(&copy, &min) ||
    2,652 (0.0%)        min > 59 ||  // Reject invalid minutes.
   13,260 (0.0%)        !cbs_get_two_digits(&copy, &sec) || sec > 59 || !CBS_get_u8(&copy, &tz)) {
        .             return 0;
        .           }
        .         
      884 (0.0%)    int offset_sign = 0;
    3,536 (0.0%)    switch (tz) {
        .             case 'Z':
      884 (0.0%)        break;  // We correctly have 'Z' on the end as per spec.
        .             case '+':
        .               offset_sign = 1;
        .               break;  // Should not be allowed per RFC 5280.
        .             case '-':
        .               offset_sign = -1;
        .               break;  // Should not be allowed per RFC 5280.
        .             default:
        .               return 0;  // Reject anything else after the time.
-- line 873 ----------------------------------------
-- line 880 ----------------------------------------
        .           // are now difficult to change. These certificates were generated with the
        .           // 'openssl' command that permissively allowed the creation of certificates
        .           // with notBefore and notAfter times specified as strings for direct
        .           // certificate inclusion on the command line. For context see cl/237068815.
        .           //
        .           // TODO(bbe): This has been expunged from public web-pki as the ecosystem has
        .           // managed to encourage CA compliance with standards. We should find a way to
        .           // get rid of this or make it off by default.
      884 (0.0%)    int offset_seconds = 0;
    1,768 (0.0%)    if (offset_sign != 0) {
        .             if (!allow_timezone_offset) {
        .               return 0;
        .             }
        .             int offset_hours, offset_minutes;
        .             if (!cbs_get_two_digits(&copy, &offset_hours) ||
        .                 offset_hours > 23 ||  // Reject invalid hours.
        .                 !cbs_get_two_digits(&copy, &offset_minutes) ||
        .                 offset_minutes > 59) {  // Reject invalid minutes.
        .               return 0;
        .             }
        .             offset_seconds = offset_sign * (offset_hours * 3600 + offset_minutes * 60);
        .           }
        .         
    4,420 (0.0%)    if (CBS_len(&copy) != 0) {
        .             return 0;  // Reject invalid lengths.
        .           }
        .         
    1,768 (0.0%)    if (out_tm != NULL) {
        .             // Fill in the tm fields corresponding to what we validated.
        8 (0.0%)      out_tm->tm_year = year - 1900;
        8 (0.0%)      out_tm->tm_mon = month - 1;
        6 (0.0%)      out_tm->tm_mday = day;
        6 (0.0%)      out_tm->tm_hour = hour;
        6 (0.0%)      out_tm->tm_min = min;
        6 (0.0%)      out_tm->tm_sec = sec;
        4 (0.0%)      if (offset_seconds && !OPENSSL_gmtime_adj(out_tm, 0, offset_seconds)) {
        .               return 0;
        .             }
        .           }
      884 (0.0%)    return 1;
    4,420 (0.0%)  }
        .         
        .         int CBS_parse_generalized_time(const CBS *cbs, struct tm *out_tm,
       70 (0.0%)                                 int allow_timezone_offset) {
       60 (0.0%)    return CBS_parse_rfc5280_time_internal(cbs, 1, allow_timezone_offset, out_tm);
       20 (0.0%)  }
        .         
        .         int CBS_parse_utc_time(const CBS *cbs, struct tm *out_tm,
    6,118 (0.0%)                         int allow_timezone_offset) {
    5,244 (0.0%)    return CBS_parse_rfc5280_time_internal(cbs, 0, allow_timezone_offset, out_tm);
    1,748 (0.0%)  }
        .         
        .         int CBS_get_optional_asn1_int64(CBS *cbs, int64_t *out, CBS_ASN1_TAG tag,
        .                                         int64_t default_value) {
        .           CBS child;
        .           int present;
        .           if (!CBS_get_optional_asn1(cbs, &child, &present, tag)) {
        .             return 0;
        .           }
-- line 938 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 12 ----------------------------------------
      .          * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
      .          * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
      .         
      .         #include <openssl/bytestring.h>
      .         
      .         #include "internal.h"
      .         
      .         
134,880 (0.0%)  static int is_valid_code_point(uint32_t v) {
      .           // References in the following are to Unicode 9.0.0.
 67,440 (0.0%)    if (// The Unicode space runs from zero to 0x10ffff (3.4 D9).
 67,440 (0.0%)        v > 0x10ffff ||
      .               // Values 0x...fffe, 0x...ffff, and 0xfdd0-0xfdef are permanently reserved
      .               // (3.4 D14)
134,880 (0.0%)        (v & 0xfffe) == 0xfffe ||
 67,440 (0.0%)        (v >= 0xfdd0 && v <= 0xfdef) ||
      .               // Surrogate code points are invalid (3.2 C1).
      .               (v >= 0xd800 && v <= 0xdfff)) {
      .             return 0;
      .           }
 33,720 (0.0%)    return 1;
 67,440 (0.0%)  }
      .         
      .         // BOTTOM_BITS returns a byte with the bottom |n| bits set.
      .         #define BOTTOM_BITS(n) (uint8_t)((1u << (n)) - 1)
      .         
      .         // TOP_BITS returns a byte with the top |n| bits set.
      .         #define TOP_BITS(n) ((uint8_t)~BOTTOM_BITS(8 - (n)))
      .         
147,339 (0.0%)  int cbs_get_utf8(CBS *cbs, uint32_t *out) {
      .           uint8_t c;
114,597 (0.0%)    if (!CBS_get_u8(cbs, &c)) {
      .             return 0;
      .           }
 49,113 (0.0%)    if (c <= 0x7f) {
 65,292 (0.0%)      *out = c;
 32,646 (0.0%)      return 1;
      .           }
      .           uint32_t v, lower_bound;
      .           size_t len;
    240 (0.0%)    if ((c & TOP_BITS(3)) == TOP_BITS(2)) {
    192 (0.0%)      v = c & BOTTOM_BITS(5);
     48 (0.0%)      len = 1;
     96 (0.0%)      lower_bound = 0x80;
      .           } else if ((c & TOP_BITS(4)) == TOP_BITS(3)) {
      .             v = c & BOTTOM_BITS(4);
      .             len = 2;
      .             lower_bound = 0x800;
      .           } else if ((c & TOP_BITS(5)) == TOP_BITS(4)) {
      .             v = c & BOTTOM_BITS(3);
      .             len = 3;
      .             lower_bound = 0x10000;
      .           } else {
      .             return 0;
      .           }
    432 (0.0%)    for (size_t i = 0; i < len; i++) {
    432 (0.0%)      if (!CBS_get_u8(cbs, &c) ||
    144 (0.0%)          (c & TOP_BITS(2)) != TOP_BITS(1)) {
      .               return 0;
      .             }
     48 (0.0%)      v <<= 6;
    192 (0.0%)      v |= c & BOTTOM_BITS(6);
      .           }
    384 (0.0%)    if (!is_valid_code_point(v) ||
      .               v < lower_bound) {
      .             return 0;
      .           }
    144 (0.0%)    *out = v;
     48 (0.0%)    return 1;
 81,855 (0.0%)  }
      .         
606,096 (0.1%)  int cbs_get_latin1(CBS *cbs, uint32_t *out) {
      .           uint8_t c;
471,408 (0.1%)    if (!CBS_get_u8(cbs, &c)) {
      .             return 0;
      .           }
269,376 (0.0%)    *out = c;
 67,344 (0.0%)    return 1;
336,720 (0.1%)  }
      .         
      .         int cbs_get_ucs2_be(CBS *cbs, uint32_t *out) {
      .           // Note UCS-2 (used by BMPString) does not support surrogates.
      .           uint16_t c;
      .           if (!CBS_get_u16(cbs, &c) ||
      .               !is_valid_code_point(c)) {
      .             return 0;
      .           }
-- line 98 ----------------------------------------
-- line 99 ----------------------------------------
      .           *out = c;
      .           return 1;
      .         }
      .         
      .         int cbs_get_utf32_be(CBS *cbs, uint32_t *out) {
      .           return CBS_get_u32(cbs, out) && is_valid_code_point(*out);
      .         }
      .         
200,172 (0.0%)  size_t cbb_get_utf8_len(uint32_t u) {
100,086 (0.0%)    if (u <= 0x7f) {
 99,990 (0.0%)      return 1;
      .           }
     96 (0.0%)    if (u <= 0x7ff) {
     96 (0.0%)      return 2;
      .           }
      .           if (u <= 0xffff) {
      .             return 3;
      .           }
      .           return 4;
100,086 (0.0%)  }
      .         
202,032 (0.0%)  int cbb_add_utf8(CBB *cbb, uint32_t u) {
168,360 (0.0%)    if (!is_valid_code_point(u)) {
      .             return 0;
      .           }
 67,344 (0.0%)    if (u <= 0x7f) {
235,704 (0.0%)      return CBB_add_u8(cbb, (uint8_t)u);
      .           }
      .           if (u <= 0x7ff) {
      .             return CBB_add_u8(cbb, TOP_BITS(2) | (u >> 6)) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | (u & BOTTOM_BITS(6)));
      .           }
      .           if (u <= 0xffff) {
      .             return CBB_add_u8(cbb, TOP_BITS(3) | (u >> 12)) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | ((u >> 6) & BOTTOM_BITS(6))) &&
-- line 133 ----------------------------------------
-- line 135 ----------------------------------------
      .           }
      .           if (u <= 0x10ffff) {
      .             return CBB_add_u8(cbb, TOP_BITS(4) | (u >> 18)) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | ((u >> 12) & BOTTOM_BITS(6))) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | ((u >> 6) & BOTTOM_BITS(6))) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | (u & BOTTOM_BITS(6)));
      .           }
      .           return 0;
 67,344 (0.0%)  }
      .         
      .         int cbb_add_latin1(CBB *cbb, uint32_t u) {
      .           return u <= 0xff && CBB_add_u8(cbb, (uint8_t)u);
      .         }
      .         
      .         int cbb_add_ucs2_be(CBB *cbb, uint32_t u) {
      .           return u <= 0xffff && is_valid_code_point(u) && CBB_add_u16(cbb, (uint16_t)u);
      .         }
-- line 151 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h
--------------------------------------------------------------------------------
Ir______________ 

-- line 218 ----------------------------------------
        .         #define OPENSSL_HAS_BUILTIN(x) 0
        .         #endif
        .         
        .         
        .         // Pointer utility functions.
        .         
        .         // buffers_alias returns one if |a| and |b| alias and zero otherwise.
        .         static inline int buffers_alias(const uint8_t *a, size_t a_len,
      102 (0.0%)                                  const uint8_t *b, size_t b_len) {
        .           // Cast |a| and |b| to integers. In C, pointer comparisons between unrelated
        .           // objects are undefined whereas pointer to integer conversions are merely
        .           // implementation-defined. We assume the implementation defined it in a sane
        .           // way.
       34 (0.0%)    uintptr_t a_u = (uintptr_t)a;
       34 (0.0%)    uintptr_t b_u = (uintptr_t)b;
      204 (0.0%)    return a_u + a_len > b_u && b_u + b_len > a_u;
       34 (0.0%)  }
        .         
        .         typedef uint8_t stack_align_type;
        .         OPENSSL_STATIC_ASSERT(sizeof(stack_align_type) == 1,
        .                               stack_align_type_is_not_8_bits_long)
        .         
        .         // align_pointer returns |ptr|, advanced to |alignment|. |alignment| must be a
        .         // power of two, and |ptr| must have at least |alignment - 1| bytes of scratch
        .         // space.
      430 (0.0%)  static inline void *align_pointer(void *ptr, size_t alignment) {
        .           // |alignment| must be a power of two.
      602 (0.0%)    assert(alignment != 0 && (alignment & (alignment - 1)) == 0);
        .           // Instead of aligning |ptr| as a |uintptr_t| and casting back, compute the
        .           // offset and advance in pointer space. C guarantees that casting from pointer
        .           // to |uintptr_t| and back gives the same pointer, but general
        .           // integer-to-pointer conversions are implementation-defined. GCC does define
        .           // it in the useful way, but this makes fewer assumptions.
      602 (0.0%)    uintptr_t offset = (0u - (uintptr_t)ptr) & (alignment - 1);
      172 (0.0%)    ptr = (char *)ptr + offset;
      516 (0.0%)    assert(((uintptr_t)ptr & (alignment - 1)) == 0);
       86 (0.0%)    return ptr;
      172 (0.0%)  }
        .         
        .         
        .         // Constant-time utility functions.
        .         //
        .         // The following methods return a bitmask of all ones (0xff...f) for true and 0
        .         // for false. This is useful for choosing a value based on the result of a
        .         // conditional in constant time. For example,
        .         //
-- line 263 ----------------------------------------
-- line 293 ----------------------------------------
        .         
        .         // value_barrier_w returns |a|, but prevents GCC and Clang from reasoning about
        .         // the returned value. This is used to mitigate compilers undoing constant-time
        .         // code, until we can express our requirements directly in the language.
        .         //
        .         // Note the compiler is aware that |value_barrier_w| has no side effects and
        .         // always has the same output for a given input. This allows it to eliminate
        .         // dead code, move computations across loops, and vectorize.
3,318,228 (0.5%)  static inline crypto_word_t value_barrier_w(crypto_word_t a) {
        .         #if defined(__GNUC__) || defined(__clang__)
2,212,152 (0.3%)    __asm__("" : "+r"(a) : /* no inputs */);
        .         #endif
1,106,076 (0.2%)    return a;
2,212,152 (0.3%)  }
        .         
        .         // value_barrier_u32 behaves like |value_barrier_w| but takes a |uint32_t|.
       39 (0.0%)  static inline uint32_t value_barrier_u32(uint32_t a) {
        .         #if defined(__GNUC__) || defined(__clang__)
       26 (0.0%)    __asm__("" : "+r"(a) : /* no inputs */);
        .         #endif
       13 (0.0%)    return a;
       26 (0.0%)  }
        .         
        .         // value_barrier_u64 behaves like |value_barrier_w| but takes a |uint64_t|.
        .         static inline uint64_t value_barrier_u64(uint64_t a) {
        .         #if defined(__GNUC__) || defined(__clang__)
        .           __asm__("" : "+r"(a) : /* no inputs */);
        .         #endif
        .           return a;
        .         }
        .         
        .         // constant_time_msb_w returns the given value with the MSB copied to all the
        .         // other bits.
  577,503 (0.1%)  static inline crypto_word_t constant_time_msb_w(crypto_word_t a) {
  385,002 (0.1%)    return 0u - (a >> (sizeof(a) * 8 - 1));
  385,002 (0.1%)  }
        .         
        .         // constant_time_lt_w returns 0xff..f if a < b and 0 otherwise.
        .         static inline crypto_word_t constant_time_lt_w(crypto_word_t a,
  480,880 (0.1%)                                                 crypto_word_t b) {
        .           // Consider the two cases of the problem:
        .           //   msb(a) == msb(b): a < b iff the MSB of a - b is set.
        .           //   msb(a) != msb(b): a < b iff the MSB of b is set.
        .           //
        .           // If msb(a) == msb(b) then the following evaluates as:
        .           //   msb(a^((a^b)|((a-b)^a))) ==
        .           //   msb(a^((a-b) ^ a))       ==   (because msb(a^b) == 0)
        .           //   msb(a^a^(a-b))           ==   (rearranging)
-- line 340 ----------------------------------------
-- line 355 ----------------------------------------
        .           // )
        .           //
        .           // (declare-fun a () (_ BitVec 32))
        .           // (declare-fun b () (_ BitVec 32))
        .           //
        .           // (assert (not (= (= #x00000001 (bvlshr (lt a b) #x0000001f)) (bvult a b))))
        .           // (check-sat)
        .           // (get-model)
  961,760 (0.1%)    return constant_time_msb_w(a^((a^b)|((a-b)^a)));
  192,352 (0.0%)  }
        .         
        .         // constant_time_lt_8 acts like |constant_time_lt_w| but returns an 8-bit
        .         // mask.
        .         static inline uint8_t constant_time_lt_8(crypto_word_t a, crypto_word_t b) {
        .           return (uint8_t)(constant_time_lt_w(a, b));
        .         }
        .         
        .         // constant_time_ge_w returns 0xff..f if a >= b and 0 otherwise.
-- line 372 ----------------------------------------
-- line 377 ----------------------------------------
        .         
        .         // constant_time_ge_8 acts like |constant_time_ge_w| but returns an 8-bit
        .         // mask.
        .         static inline uint8_t constant_time_ge_8(crypto_word_t a, crypto_word_t b) {
        .           return (uint8_t)(constant_time_ge_w(a, b));
        .         }
        .         
        .         // constant_time_is_zero returns 0xff..f if a == 0 and 0 otherwise.
  385,300 (0.1%)  static inline crypto_word_t constant_time_is_zero_w(crypto_word_t a) {
        .           // Here is an SMT-LIB verification of this formula:
        .           //
        .           // (define-fun is_zero ((a (_ BitVec 32))) (_ BitVec 32)
        .           //   (bvand (bvnot a) (bvsub a #x00000001))
        .           // )
        .           //
        .           // (declare-fun a () (_ BitVec 32))
        .           //
        .           // (assert (not (= (= #x00000001 (bvlshr (is_zero a) #x0000001f)) (= a #x00000000))))
        .           // (check-sat)
        .           // (get-model)
  770,600 (0.1%)    return constant_time_msb_w(~a & (a - 1));
  192,650 (0.0%)  }
        .         
        .         // constant_time_is_zero_8 acts like |constant_time_is_zero_w| but returns an
        .         // 8-bit mask.
        .         static inline uint8_t constant_time_is_zero_8(crypto_word_t a) {
        .           return (uint8_t)(constant_time_is_zero_w(a));
        .         }
        .         
        .         // constant_time_eq_w returns 0xff..f if a == b and 0 otherwise.
        .         static inline crypto_word_t constant_time_eq_w(crypto_word_t a,
  480,860 (0.1%)                                                 crypto_word_t b) {
  384,688 (0.1%)    return constant_time_is_zero_w(a ^ b);
  192,344 (0.0%)  }
        .         
        .         // constant_time_eq_8 acts like |constant_time_eq_w| but returns an 8-bit
        .         // mask.
        .         static inline uint8_t constant_time_eq_8(crypto_word_t a, crypto_word_t b) {
        .           return (uint8_t)(constant_time_eq_w(a, b));
        .         }
        .         
        .         // constant_time_eq_int acts like |constant_time_eq_w| but works on int
-- line 418 ----------------------------------------
-- line 427 ----------------------------------------
        .           return constant_time_eq_8((crypto_word_t)(a), (crypto_word_t)(b));
        .         }
        .         
        .         // constant_time_select_w returns (mask & a) | (~mask & b). When |mask| is all
        .         // 1s or all 0s (as returned by the methods above), the select methods return
        .         // either |a| (if |mask| is nonzero) or |b| (if |mask| is zero).
        .         static inline crypto_word_t constant_time_select_w(crypto_word_t mask,
        .                                                            crypto_word_t a,
3,871,266 (0.6%)                                                     crypto_word_t b) {
        .           // Clang recognizes this pattern as a select. While it usually transforms it
        .           // to a cmov, it sometimes further transforms it into a branch, which we do
        .           // not want.
        .           //
        .           // Adding barriers to both |mask| and |~mask| breaks the relationship between
        .           // the two, which makes the compiler stick with bitmasks.
6,083,418 (0.9%)    return (value_barrier_w(mask) & a) | (value_barrier_w(~mask) & b);
1,659,114 (0.3%)  }
        .         
        .         // constant_time_select_8 acts like |constant_time_select| but operates on
        .         // 8-bit values.
        .         static inline uint8_t constant_time_select_8(uint8_t mask, uint8_t a,
        .                                                      uint8_t b) {
        .           return (uint8_t)(constant_time_select_w(mask, a, b));
        .         }
        .         
        .         // constant_time_select_int acts like |constant_time_select| but operates on
        .         // ints.
1,154,784 (0.2%)  static inline int constant_time_select_int(crypto_word_t mask, int a, int b) {
1,539,712 (0.2%)    return (int)(constant_time_select_w(mask, (crypto_word_t)(a),
        .                                               (crypto_word_t)(b)));
  384,928 (0.1%)  }
        .         
        .         #if defined(BORINGSSL_CONSTANT_TIME_VALIDATION)
        .         
        .         // CONSTTIME_SECRET takes a pointer and a number of bytes and marks that region
        .         // of memory as secret. Secret data is tracked as it flows to registers and
        .         // other parts of a memory. If secret data is used as a condition for a branch,
        .         // or as a memory index, it will trigger warnings in valgrind.
        .         #define CONSTTIME_SECRET(ptr, len) VALGRIND_MAKE_MEM_UNDEFINED(ptr, len)
-- line 465 ----------------------------------------
-- line 487 ----------------------------------------
        .           // significantly impact optimizations.
        .           //
        .           // Thus, to be safe, stick a value barrier, in hopes of comparably inhibiting
        .           // compiler analysis.
        .           CONSTTIME_DECLASSIFY(&v, sizeof(v));
        .           return value_barrier_w(v);
        .         }
        .         
       52 (0.0%)  static inline int constant_time_declassify_int(int v) {
        .           OPENSSL_STATIC_ASSERT(sizeof(uint32_t) == sizeof(int),
        .                         int_is_not_the_same_size_as_uint32_t);
        .           // See comment above.
        .           CONSTTIME_DECLASSIFY(&v, sizeof(v));
       39 (0.0%)    return value_barrier_u32(v);
       26 (0.0%)  }
        .         
        .         
        .         // Thread-safe initialisation.
        .         
        .         #if !defined(OPENSSL_THREADS)
        .         typedef uint32_t CRYPTO_once_t;
        .         #define CRYPTO_ONCE_INIT 0
        .         #elif defined(OPENSSL_WINDOWS_THREADS)
-- line 509 ----------------------------------------
-- line 800 ----------------------------------------
        .         static inline uint64_t CRYPTO_bswap8(uint64_t x) {
        .           return _byteswap_uint64(x);
        .         }
        .         #else
        .         static inline uint16_t CRYPTO_bswap2(uint16_t x) {
        .           return (x >> 8) | (x << 8);
        .         }
        .         
  115,713 (0.0%)  static inline uint32_t CRYPTO_bswap4(uint32_t x) {
   38,571 (0.0%)    x = (x >> 16) | (x << 16);
  347,139 (0.1%)    x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);
   38,571 (0.0%)    return x;
   77,142 (0.0%)  }
        .         
   92,205 (0.0%)  static inline uint64_t CRYPTO_bswap8(uint64_t x) {
  202,851 (0.0%)    return CRYPTO_bswap4(x >> 32) | (((uint64_t)CRYPTO_bswap4(x)) << 32);
   55,323 (0.0%)  }
        .         #endif
        .         
        .         
        .         // Language bug workarounds.
        .         //
        .         // Most C standard library functions are undefined if passed NULL, even when the
        .         // corresponding length is zero. This gives them (and, in turn, all functions
        .         // which call them) surprising behavior on empty arrays. Some compilers will
-- line 824 ----------------------------------------
-- line 848 ----------------------------------------
        .           }
        .         
        .           return memchr(s, c, n);
        .         }
        .         
        .         }  // extern "C++"
        .         #else  // __cplusplus
        .         
       12 (0.0%)  static inline void *OPENSSL_memchr(const void *s, int c, size_t n) {
        4 (0.0%)    if (n == 0) {
        2 (0.0%)      return NULL;
        .           }
        .         
        6 (0.0%)    return memchr(s, c, n);
        4 (0.0%)  }
        .         
        .         #endif  // __cplusplus
        .         
        6 (0.0%)  static inline int OPENSSL_memcmp(const void *s1, const void *s2, size_t n) {
        2 (0.0%)    if (n == 0) {
        .             return 0;
        .           }
        .         
        6 (0.0%)    return memcmp(s1, s2, n);
        2 (0.0%)  }
        .         
  140,736 (0.0%)  static inline void *OPENSSL_memcpy(void *dst, const void *src, size_t n) {
   46,912 (0.0%)    if (n == 0) {
    1,414 (0.0%)      return dst;
        .           }
        .         
  136,494 (0.0%)    return memcpy(dst, src, n);
   46,912 (0.0%)  }
        .         
       18 (0.0%)  static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
        6 (0.0%)    if (n == 0) {
        .             return dst;
        .           }
        .         
       18 (0.0%)    return memmove(dst, src, n);
        6 (0.0%)  }
        .         
   30,432 (0.0%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
   10,144 (0.0%)    if (n == 0) {
    7,156 (0.0%)      return dst;
        .           }
        .         
    8,964 (0.0%)    return memset(dst, c, n);
   10,144 (0.0%)  }
        .         
        .         
        .         // Loads and stores.
        .         //
        .         // The following functions load and store sized integers with the specified
        .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
        .         // requirements on the input and output pointers.
        .         
-- line 904 ----------------------------------------
-- line 949 ----------------------------------------
        .         static inline void CRYPTO_store_u32_le(void *out, uint32_t v) {
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           v = CRYPTO_bswap4(v);
        .         #endif
        .           OPENSSL_memcpy(out, &v, sizeof(v));
        .         
        .         }
        .         
      525 (0.0%)  static inline uint32_t CRYPTO_load_u32_be(const void *in) {
        .           uint32_t v;
      450 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           return v;
        .         #else
      225 (0.0%)    return CRYPTO_bswap4(v);
        .         #endif
      375 (0.0%)  }
        .         
    8,070 (0.0%)  static inline void CRYPTO_store_u32_be(void *out, uint32_t v) {
        .         
        .         #if !defined(OPENSSL_BIG_ENDIAN)
    6,456 (0.0%)    v = CRYPTO_bswap4(v);
        .         #endif
    9,684 (0.0%)    OPENSSL_memcpy(out, &v, sizeof(v));
        .         
    4,842 (0.0%)  }
        .         
        .         static inline uint64_t CRYPTO_load_u64_le(const void *in) {
        .           uint64_t v;
        .           OPENSSL_memcpy(&v, in, sizeof(v));
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           return CRYPTO_bswap8(v);
        .         #else
        .           return v;
-- line 982 ----------------------------------------
-- line 986 ----------------------------------------
        .         static inline void CRYPTO_store_u64_le(void *out, uint64_t v) {
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           v = CRYPTO_bswap8(v);
        .         #endif
        .           OPENSSL_memcpy(out, &v, sizeof(v));
        .         
        .         }
        .         
      175 (0.0%)  static inline uint64_t CRYPTO_load_u64_be(const void *ptr) {
        .           uint64_t ret;
      150 (0.0%)    OPENSSL_memcpy(&ret, ptr, sizeof(ret));
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           return ret;
        .         #else
       75 (0.0%)    return CRYPTO_bswap8(ret);
        .         #endif
      125 (0.0%)  }
        .         
      160 (0.0%)  static inline void CRYPTO_store_u64_be(void *out, uint64_t v) {
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .         #else
      128 (0.0%)    v = CRYPTO_bswap8(v);
        .         #endif
      192 (0.0%)    OPENSSL_memcpy(out, &v, sizeof(v));
        .         
       96 (0.0%)  }
        .         
      672 (0.0%)  static inline crypto_word_t CRYPTO_load_word_le(const void *in) {
        .         
        .           crypto_word_t v;
      576 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           return CRYPTO_bswap_word(v);
        .         #else
       96 (0.0%)    return v;
        .         #endif
      480 (0.0%)  }
        .         
      240 (0.0%)  static inline void CRYPTO_store_word_le(void *out, crypto_word_t v) {
        .         
        .         
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           v = CRYPTO_bswap_word(v);
        .         #endif
      288 (0.0%)    OPENSSL_memcpy(out, &v, sizeof(v));
        .         
      144 (0.0%)  }
        .         
  128,688 (0.0%)  static inline crypto_word_t CRYPTO_load_word_be(const void *in) {
        .           crypto_word_t v;
  110,304 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           return v;
        .         #else
        .         #if defined(OPENSSL_64_BIT)
        .           assert(sizeof(v) == 8);
   55,152 (0.0%)    return CRYPTO_bswap8(v);
        .         #else
        .           assert(sizeof(v) == 4);
        .           return CRYPTO_bswap4(v);
        .         #endif
        .         #endif
   91,920 (0.0%)  }
        .         
        .         // Bit rotation functions.
        .         //
        .         // Note these functions use |(-shift) & 31|, etc., because shifting by the bit
        .         // width is undefined. Both Clang and GCC recognize this pattern as a rotation,
        .         // but MSVC does not. Instead, we call MSVC's built-in functions.
        .         
        .         static inline uint32_t CRYPTO_rotl_u32(uint32_t value, int shift) {
-- line 1056 ----------------------------------------
-- line 1122 ----------------------------------------
        .           assert(carry <= 1);
        .           uint64_t ret = carry;
        .           ret += (uint64_t)x + y;
        .           *out_carry = (uint32_t)(ret >> 32);
        .           return (uint32_t)ret;
        .         }
        .         
        .         static inline uint64_t CRYPTO_addc_u64(uint64_t x, uint64_t y, uint64_t carry,
   20,216 (0.0%)                                         uint64_t *out_carry) {
    5,054 (0.0%)    assert(carry <= 1);
        .         #if defined(BORINGSSL_HAS_UINT128)
    7,581 (0.0%)    uint128_t ret = carry;
   20,216 (0.0%)    ret += (uint128_t)x + y;
   17,689 (0.0%)    *out_carry = (uint64_t)(ret >> 64);
    2,527 (0.0%)    return (uint64_t)ret;
        .         #else
        .           x += carry;
        .           carry = x < carry;
        .           uint64_t ret = x + y;
        .           carry += ret < x;
        .           *out_carry = carry;
        .           return ret;
        .         #endif
    7,581 (0.0%)  }
        .         #endif
        .         
        .         // CRYPTO_subc_* returns |x - y - borrow|, and sets |*out_borrow| to the borrow
        .         // bit. |borrow| must be zero or one.
        .         #if OPENSSL_HAS_BUILTIN(__builtin_subc)
        .         
        .         #define CRYPTO_GENERIC_SUBC(x, y, borrow, out_borrow) \
        .           (_Generic((x),                                      \
-- line 1153 ----------------------------------------
-- line 1173 ----------------------------------------
        .                                                uint32_t *out_borrow) {
        .           assert(borrow <= 1);
        .           uint32_t ret = x - y - borrow;
        .           *out_borrow = (x < y) | ((x == y) & borrow);
        .           return ret;
        .         }
        .         
        .         static inline uint64_t CRYPTO_subc_u64(uint64_t x, uint64_t y, uint64_t borrow,
    2,940 (0.0%)                                         uint64_t *out_borrow) {
      840 (0.0%)    assert(borrow <= 1);
    1,680 (0.0%)    uint64_t ret = x - y - borrow;
    5,040 (0.0%)    *out_borrow = (x < y) | ((x == y) & borrow);
      420 (0.0%)    return ret;
      840 (0.0%)  }
        .         #endif
        .         
        .         #if defined(OPENSSL_64_BIT)
        .         #define CRYPTO_addc_w CRYPTO_addc_u64
        .         #define CRYPTO_subc_w CRYPTO_subc_u64
        .         #else
        .         #define CRYPTO_addc_w CRYPTO_addc_u32
        .         #define CRYPTO_subc_w CRYPTO_subc_u32
-- line 1194 ----------------------------------------
-- line 1235 ----------------------------------------
        .         // run in this address space. If not, it runs it and crashes the address space
        .         // if unsuccessful.
        .         void boringssl_ensure_ffdh_self_test(void);
        .         
        .         #else
        .         
        .         // Outside of FIPS mode, the lazy tests are no-ops.
        .         
       15 (0.0%)  OPENSSL_INLINE void boringssl_ensure_rsa_self_test(void) {}
       10 (0.0%)  OPENSSL_INLINE void boringssl_ensure_ecc_self_test(void) {}
        .         OPENSSL_INLINE void boringssl_ensure_ffdh_self_test(void) {}
        .         
        .         #endif  // FIPS
        .         
        .         // boringssl_self_test_sha256 performs a SHA-256 KAT.
        .         int boringssl_self_test_sha256(void);
        .         
        .         // boringssl_self_test_hmac_sha256 performs an HMAC-SHA-256 KAT.
        .         int boringssl_self_test_hmac_sha256(void);
        .         
        .         #if defined(BORINGSSL_FIPS_COUNTERS)
        .         void boringssl_fips_inc_counter(enum fips_counter_t counter);
        .         #else
       54 (0.0%)  OPENSSL_INLINE void boringssl_fips_inc_counter(enum fips_counter_t counter) {}
        .         #endif
        .         
        .         #if defined(BORINGSSL_FIPS_BREAK_TESTS)
        .         OPENSSL_INLINE int boringssl_fips_break_test(const char *test) {
        .           const char *const value = getenv("BORINGSSL_FIPS_BREAK_TEST");
        .           return value != NULL && strcmp(value, test) == 0;
        .         }
        .         #else
-- line 1266 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 90 ----------------------------------------
        .                     : "cc");                                                       \
        .             (r) = (carry);                                                         \
        .             (carry) = high;                                                        \
        .           } while (0)
        .         #undef sqr
        .         #define sqr(r0, r1, a) __asm__("mulq %2" : "=a"(r0), "=d"(r1) : "a"(a) : "cc");
        .         
        .         BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, size_t num,
    6,696 (0.0%)                            BN_ULONG w) {
      744 (0.0%)    BN_ULONG c1 = 0;
        .         
    1,488 (0.0%)    if (num == 0) {
        .             return (c1);
        .           }
        .         
   18,976 (0.0%)    while (num & ~3) {
  201,112 (0.0%)      mul_add(rp[0], ap[0], w, c1);
  192,368 (0.0%)      mul_add(rp[1], ap[1], w, c1);
  192,368 (0.0%)      mul_add(rp[2], ap[2], w, c1);
  192,368 (0.0%)      mul_add(rp[3], ap[3], w, c1);
    8,744 (0.0%)      ap += 4;
    8,744 (0.0%)      rp += 4;
    8,744 (0.0%)      num -= 4;
        .           }
    1,488 (0.0%)    if (num) {
        .             mul_add(rp[0], ap[0], w, c1);
        .             if (--num == 0) {
        .               return c1;
        .             }
        .             mul_add(rp[1], ap[1], w, c1);
        .             if (--num == 0) {
        .               return c1;
        .             }
        .             mul_add(rp[2], ap[2], w, c1);
        .             return c1;
        .           }
        .         
      744 (0.0%)    return c1;
    2,976 (0.0%)  }
        .         
        .         BN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, size_t num,
    1,800 (0.0%)                        BN_ULONG w) {
      200 (0.0%)    BN_ULONG c1 = 0;
        .         
      400 (0.0%)    if (num == 0) {
        .             return c1;
        .           }
        .         
    6,768 (0.0%)    while (num & ~3) {
   57,312 (0.0%)      mul(rp[0], ap[0], w, c1);
   63,680 (0.0%)      mul(rp[1], ap[1], w, c1);
   63,680 (0.0%)      mul(rp[2], ap[2], w, c1);
   63,680 (0.0%)      mul(rp[3], ap[3], w, c1);
    3,184 (0.0%)      ap += 4;
    3,184 (0.0%)      rp += 4;
    3,184 (0.0%)      num -= 4;
        .           }
      400 (0.0%)    if (num) {
    3,582 (0.0%)      mul(rp[0], ap[0], w, c1);
      597 (0.0%)      if (--num == 0) {
      398 (0.0%)        return c1;
        .             }
        .             mul(rp[1], ap[1], w, c1);
        .             if (--num == 0) {
        .               return c1;
        .             }
        .             mul(rp[2], ap[2], w, c1);
        .           }
        1 (0.0%)    return c1;
      800 (0.0%)  }
        .         
        .         void bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, size_t n) {
        .           if (n == 0) {
        .             return;
        .           }
        .         
        .           while (n & ~3) {
        .             sqr(r[0], r[1], a[0]);
-- line 167 ----------------------------------------
-- line 181 ----------------------------------------
        .             if (--n == 0) {
        .               return;
        .             }
        .             sqr(r[4], r[5], a[2]);
        .           }
        .         }
        .         
        .         BN_ULONG bn_add_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,
  118,888 (0.0%)                        size_t n) {
        .           BN_ULONG ret;
   16,984 (0.0%)    size_t i = 0;
        .         
   33,968 (0.0%)    if (n == 0) {
        2 (0.0%)      return 0;
        .           }
        .         
4,609,977 (0.7%)    __asm__ volatile (
        .               "	subq	%0,%0		\n"  // clear carry
        .               "	jmp	1f		\n"
        .               ".p2align 4			\n"
        .               "1:"
        .               "	movq	(%4,%2,8),%0	\n"
        .               "	adcq	(%5,%2,8),%0	\n"
        .               "	movq	%0,(%3,%2,8)	\n"
        .               "	lea	1(%2),%2	\n"
        .               "	dec	%1		\n"
        .               "	jnz	1b		\n"
        .               "	sbbq	%0,%0		\n"
        .               : "=&r"(ret), "+c"(n), "+r"(i)
        .               : "r"(rp), "r"(ap), "r"(bp)
        .               : "cc", "memory");
        .         
   33,966 (0.0%)    return ret & 1;
   33,968 (0.0%)  }
        .         
        .         BN_ULONG bn_sub_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,
  100,478 (0.0%)                        size_t n) {
        .           BN_ULONG ret;
   14,354 (0.0%)    size_t i = 0;
        .         
   28,708 (0.0%)    if (n == 0) {
        4 (0.0%)      return 0;
        .           }
        .         
2,989,134 (0.5%)    __asm__ volatile (
        .               "	subq	%0,%0		\n"  // clear borrow
        .               "	jmp	1f		\n"
        .               ".p2align 4			\n"
        .               "1:"
        .               "	movq	(%4,%2,8),%0	\n"
        .               "	sbbq	(%5,%2,8),%0	\n"
        .               "	movq	%0,(%3,%2,8)	\n"
        .               "	lea	1(%2),%2	\n"
        .               "	dec	%1		\n"
        .               "	jnz	1b		\n"
        .               "	sbbq	%0,%0		\n"
        .               : "=&r"(ret), "+c"(n), "+r"(i)
        .               : "r"(rp), "r"(ap), "r"(bp)
        .               : "cc", "memory");
        .         
   28,704 (0.0%)    return ret & 1;
   28,708 (0.0%)  }
        .         
        .         // mul_add_c(a,b,c0,c1,c2)  -- c+=a*b for three word number c=(c2,c1,c0)
        .         // mul_add_c2(a,b,c0,c1,c2) -- c+=2*a*b for three word number c=(c2,c1,c0)
        .         // sqr_add_c(a,i,c0,c1,c2)  -- c+=a[i]^2 for three word number c=(c2,c1,c0)
        .         // sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0)
        .         
        .         // Keep in mind that carrying into high part of multiplication result can not
        .         // overflow, because it cannot be all-ones.
-- line 250 ----------------------------------------
-- line 279 ----------------------------------------
        .             __asm__("addq %3,%0; adcq %4,%1; adcq %5,%2"                     \
        .                     : "+r"(c0), "+r"(c1), "+r"(c2)                           \
        .                     : "r"(t1), "r"(t2), "g"(0)                               \
        .                     : "cc");                                                 \
        .           } while (0)
        .         
        .         #define sqr_add_c2(a, i, j, c0, c1, c2) mul_add_c2((a)[i], (a)[j], c0, c1, c2)
        .         
      378 (0.0%)  void bn_mul_comba8(BN_ULONG r[16], const BN_ULONG a[8], const BN_ULONG b[8]) {
        .           BN_ULONG c1, c2, c3;
        .         
       54 (0.0%)    c1 = 0;
       54 (0.0%)    c2 = 0;
       54 (0.0%)    c3 = 0;
      918 (0.0%)    mul_add_c(a[0], b[0], c1, c2, c3);
      162 (0.0%)    r[0] = c1;
       54 (0.0%)    c1 = 0;
      972 (0.0%)    mul_add_c(a[0], b[1], c2, c3, c1);
      972 (0.0%)    mul_add_c(a[1], b[0], c2, c3, c1);
      216 (0.0%)    r[1] = c2;
       54 (0.0%)    c2 = 0;
      972 (0.0%)    mul_add_c(a[2], b[0], c3, c1, c2);
    1,026 (0.0%)    mul_add_c(a[1], b[1], c3, c1, c2);
      972 (0.0%)    mul_add_c(a[0], b[2], c3, c1, c2);
      216 (0.0%)    r[2] = c3;
       54 (0.0%)    c3 = 0;
      972 (0.0%)    mul_add_c(a[0], b[3], c1, c2, c3);
    1,026 (0.0%)    mul_add_c(a[1], b[2], c1, c2, c3);
    1,026 (0.0%)    mul_add_c(a[2], b[1], c1, c2, c3);
      972 (0.0%)    mul_add_c(a[3], b[0], c1, c2, c3);
      216 (0.0%)    r[3] = c1;
       54 (0.0%)    c1 = 0;
      972 (0.0%)    mul_add_c(a[4], b[0], c2, c3, c1);
    1,026 (0.0%)    mul_add_c(a[3], b[1], c2, c3, c1);
    1,026 (0.0%)    mul_add_c(a[2], b[2], c2, c3, c1);
    1,026 (0.0%)    mul_add_c(a[1], b[3], c2, c3, c1);
      972 (0.0%)    mul_add_c(a[0], b[4], c2, c3, c1);
      216 (0.0%)    r[4] = c2;
       54 (0.0%)    c2 = 0;
      972 (0.0%)    mul_add_c(a[0], b[5], c3, c1, c2);
    1,026 (0.0%)    mul_add_c(a[1], b[4], c3, c1, c2);
    1,026 (0.0%)    mul_add_c(a[2], b[3], c3, c1, c2);
    1,026 (0.0%)    mul_add_c(a[3], b[2], c3, c1, c2);
    1,026 (0.0%)    mul_add_c(a[4], b[1], c3, c1, c2);
      972 (0.0%)    mul_add_c(a[5], b[0], c3, c1, c2);
      216 (0.0%)    r[5] = c3;
       54 (0.0%)    c3 = 0;
      972 (0.0%)    mul_add_c(a[6], b[0], c1, c2, c3);
    1,026 (0.0%)    mul_add_c(a[5], b[1], c1, c2, c3);
    1,026 (0.0%)    mul_add_c(a[4], b[2], c1, c2, c3);
    1,026 (0.0%)    mul_add_c(a[3], b[3], c1, c2, c3);
    1,026 (0.0%)    mul_add_c(a[2], b[4], c1, c2, c3);
    1,026 (0.0%)    mul_add_c(a[1], b[5], c1, c2, c3);
      972 (0.0%)    mul_add_c(a[0], b[6], c1, c2, c3);
      216 (0.0%)    r[6] = c1;
       54 (0.0%)    c1 = 0;
      972 (0.0%)    mul_add_c(a[0], b[7], c2, c3, c1);
    1,026 (0.0%)    mul_add_c(a[1], b[6], c2, c3, c1);
    1,026 (0.0%)    mul_add_c(a[2], b[5], c2, c3, c1);
    1,026 (0.0%)    mul_add_c(a[3], b[4], c2, c3, c1);
    1,026 (0.0%)    mul_add_c(a[4], b[3], c2, c3, c1);
    1,026 (0.0%)    mul_add_c(a[5], b[2], c2, c3, c1);
    1,026 (0.0%)    mul_add_c(a[6], b[1], c2, c3, c1);
      972 (0.0%)    mul_add_c(a[7], b[0], c2, c3, c1);
      216 (0.0%)    r[7] = c2;
       54 (0.0%)    c2 = 0;
    1,026 (0.0%)    mul_add_c(a[7], b[1], c3, c1, c2);
    1,026 (0.0%)    mul_add_c(a[6], b[2], c3, c1, c2);
    1,026 (0.0%)    mul_add_c(a[5], b[3], c3, c1, c2);
    1,026 (0.0%)    mul_add_c(a[4], b[4], c3, c1, c2);
    1,026 (0.0%)    mul_add_c(a[3], b[5], c3, c1, c2);
    1,026 (0.0%)    mul_add_c(a[2], b[6], c3, c1, c2);
    1,026 (0.0%)    mul_add_c(a[1], b[7], c3, c1, c2);
      216 (0.0%)    r[8] = c3;
       54 (0.0%)    c3 = 0;
    1,026 (0.0%)    mul_add_c(a[2], b[7], c1, c2, c3);
    1,026 (0.0%)    mul_add_c(a[3], b[6], c1, c2, c3);
    1,026 (0.0%)    mul_add_c(a[4], b[5], c1, c2, c3);
    1,026 (0.0%)    mul_add_c(a[5], b[4], c1, c2, c3);
    1,026 (0.0%)    mul_add_c(a[6], b[3], c1, c2, c3);
    1,026 (0.0%)    mul_add_c(a[7], b[2], c1, c2, c3);
      216 (0.0%)    r[9] = c1;
       54 (0.0%)    c1 = 0;
    1,026 (0.0%)    mul_add_c(a[7], b[3], c2, c3, c1);
    1,026 (0.0%)    mul_add_c(a[6], b[4], c2, c3, c1);
    1,026 (0.0%)    mul_add_c(a[5], b[5], c2, c3, c1);
    1,026 (0.0%)    mul_add_c(a[4], b[6], c2, c3, c1);
    1,026 (0.0%)    mul_add_c(a[3], b[7], c2, c3, c1);
      216 (0.0%)    r[10] = c2;
       54 (0.0%)    c2 = 0;
    1,026 (0.0%)    mul_add_c(a[4], b[7], c3, c1, c2);
    1,026 (0.0%)    mul_add_c(a[5], b[6], c3, c1, c2);
    1,026 (0.0%)    mul_add_c(a[6], b[5], c3, c1, c2);
    1,026 (0.0%)    mul_add_c(a[7], b[4], c3, c1, c2);
      216 (0.0%)    r[11] = c3;
       54 (0.0%)    c3 = 0;
    1,026 (0.0%)    mul_add_c(a[7], b[5], c1, c2, c3);
    1,026 (0.0%)    mul_add_c(a[6], b[6], c1, c2, c3);
    1,026 (0.0%)    mul_add_c(a[5], b[7], c1, c2, c3);
      216 (0.0%)    r[12] = c1;
       54 (0.0%)    c1 = 0;
    1,026 (0.0%)    mul_add_c(a[6], b[7], c2, c3, c1);
    1,026 (0.0%)    mul_add_c(a[7], b[6], c2, c3, c1);
      216 (0.0%)    r[13] = c2;
       54 (0.0%)    c2 = 0;
    1,026 (0.0%)    mul_add_c(a[7], b[7], c3, c1, c2);
      216 (0.0%)    r[14] = c3;
      216 (0.0%)    r[15] = c1;
      162 (0.0%)  }
        .         
        .         void bn_mul_comba4(BN_ULONG r[8], const BN_ULONG a[4], const BN_ULONG b[4]) {
        .           BN_ULONG c1, c2, c3;
        .         
        .           c1 = 0;
        .           c2 = 0;
        .           c3 = 0;
        .           mul_add_c(a[0], b[0], c1, c2, c3);
-- line 395 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 66 ----------------------------------------
        .         #include "../delocate.h"
        .         
        .         
        .         // BN_MAX_WORDS is the maximum number of words allowed in a |BIGNUM|. It is
        .         // sized so byte and bit counts of a |BIGNUM| always fit in |int|, with room to
        .         // spare.
        .         #define BN_MAX_WORDS (INT_MAX / (4 * BN_BITS2))
        .         
    2,748 (0.0%)  BIGNUM *BN_new(void) {
    2,061 (0.0%)    BIGNUM *bn = OPENSSL_zalloc(sizeof(BIGNUM));
        .         
    1,374 (0.0%)    if (bn == NULL) {
        .             return NULL;
        .           }
        .         
    1,374 (0.0%)    bn->flags = BN_FLG_MALLOCED;
        .         
      687 (0.0%)    return bn;
    1,374 (0.0%)  }
        .         
        .         BIGNUM *BN_secure_new(void) { return BN_new(); }
        .         
       85 (0.0%)  void BN_init(BIGNUM *bn) {
       85 (0.0%)    OPENSSL_memset(bn, 0, sizeof(BIGNUM));
       51 (0.0%)  }
        .         
   19,580 (0.0%)  void BN_free(BIGNUM *bn) {
    7,832 (0.0%)    if (bn == NULL) {
    3,212 (0.0%)      return;
        .           }
        .         
    3,520 (0.0%)    if ((bn->flags & BN_FLG_STATIC_DATA) == 0) {
    2,816 (0.0%)      OPENSSL_free(bn->d);
        .           }
        .         
    3,520 (0.0%)    if (bn->flags & BN_FLG_MALLOCED) {
    2,748 (0.0%)      OPENSSL_free(bn);
        .           } else {
       51 (0.0%)      bn->d = NULL;
        .           }
    7,832 (0.0%)  }
        .         
        .         void BN_clear_free(BIGNUM *bn) {
        .           BN_free(bn);
        .         }
        .         
       15 (0.0%)  BIGNUM *BN_dup(const BIGNUM *src) {
        .           BIGNUM *copy;
        .         
        6 (0.0%)    if (src == NULL) {
        .             return NULL;
        .           }
        .         
        6 (0.0%)    copy = BN_new();
        6 (0.0%)    if (copy == NULL) {
        .             return NULL;
        .           }
        .         
       21 (0.0%)    if (!BN_copy(copy, src)) {
        .             BN_free(copy);
        .             return NULL;
        .           }
        .         
        3 (0.0%)    return copy;
        6 (0.0%)  }
        .         
      246 (0.0%)  BIGNUM *BN_copy(BIGNUM *dest, const BIGNUM *src) {
      123 (0.0%)    if (src == dest) {
       10 (0.0%)      return dest;
        .           }
        .         
      324 (0.0%)    if (!bn_wexpand(dest, src->width)) {
        .             return NULL;
        .           }
        .         
      396 (0.0%)    OPENSSL_memcpy(dest->d, src->d, sizeof(src->d[0]) * src->width);
        .         
      144 (0.0%)    dest->width = src->width;
      144 (0.0%)    dest->neg = src->neg;
       36 (0.0%)    return dest;
       82 (0.0%)  }
        .         
        .         void BN_clear(BIGNUM *bn) {
        .           if (bn->d != NULL) {
        .             OPENSSL_memset(bn->d, 0, bn->dmax * sizeof(bn->d[0]));
        .           }
        .         
        .           bn->width = 0;
        .           bn->neg = 0;
        .         }
        .         
       90 (0.0%)  DEFINE_METHOD_FUNCTION(BIGNUM, BN_value_one) {
        .           static const BN_ULONG kOneLimbs[1] = { 1 };
        3 (0.0%)    out->d = (BN_ULONG*) kOneLimbs;
        2 (0.0%)    out->width = 1;
        2 (0.0%)    out->dmax = 1;
        2 (0.0%)    out->neg = 0;
        2 (0.0%)    out->flags = BN_FLG_STATIC_DATA;
        3 (0.0%)  }
        .         
        .         // BN_num_bits_word returns the minimum number of bits needed to represent the
        .         // value in |l|.
    4,340 (0.0%)  unsigned BN_num_bits_word(BN_ULONG l) {
        .           // |BN_num_bits| is often called on RSA prime factors. These have public bit
        .           // lengths, but all bits beyond the high bit are secret, so count bits in
        .           // constant time.
        .           BN_ULONG x, mask;
    4,340 (0.0%)    int bits = (l != 0);
        .         
        .         #if BN_BITS2 > 32
        .           // Look at the upper half of |x|. |x| is at most 64 bits long.
    3,255 (0.0%)    x = l >> 32;
        .           // Set |mask| to all ones if |x| (the top 32 bits of |l|) is non-zero and all
        .           // all zeros otherwise.
    3,255 (0.0%)    mask = 0u - x;
    3,255 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
        .           // If |x| is non-zero, the lower half is included in the bit count in full,
        .           // and we count the upper half. Otherwise, we count the lower half.
    6,510 (0.0%)    bits += 32 & mask;
    4,340 (0.0%)    l ^= (x ^ l) & mask;  // |l| is |x| if |mask| and remains |l| otherwise.
        .         #endif
        .         
        .           // The remaining blocks are analogous iterations at lower powers of two.
    3,255 (0.0%)    x = l >> 16;
    3,255 (0.0%)    mask = 0u - x;
    3,255 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
    6,510 (0.0%)    bits += 16 & mask;
    4,340 (0.0%)    l ^= (x ^ l) & mask;
        .         
    3,255 (0.0%)    x = l >> 8;
    3,255 (0.0%)    mask = 0u - x;
    3,255 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
    6,510 (0.0%)    bits += 8 & mask;
    4,340 (0.0%)    l ^= (x ^ l) & mask;
        .         
    3,255 (0.0%)    x = l >> 4;
    3,255 (0.0%)    mask = 0u - x;
    3,255 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
    6,510 (0.0%)    bits += 4 & mask;
    4,340 (0.0%)    l ^= (x ^ l) & mask;
        .         
    3,255 (0.0%)    x = l >> 2;
    3,255 (0.0%)    mask = 0u - x;
    3,255 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
    6,510 (0.0%)    bits += 2 & mask;
    4,340 (0.0%)    l ^= (x ^ l) & mask;
        .         
    3,255 (0.0%)    x = l >> 1;
    3,255 (0.0%)    mask = 0u - x;
    3,255 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
    6,510 (0.0%)    bits += 1 & mask;
        .         
    1,085 (0.0%)    return bits;
    2,170 (0.0%)  }
        .         
    6,486 (0.0%)  unsigned BN_num_bits(const BIGNUM *bn) {
    4,324 (0.0%)    const int width = bn_minimal_width(bn);
    2,162 (0.0%)    if (width == 0) {
        .             return 0;
        .           }
        .         
   16,215 (0.0%)    return (width - 1) * BN_BITS2 + BN_num_bits_word(bn->d[width - 1]);
    3,243 (0.0%)  }
        .         
    2,035 (0.0%)  unsigned BN_num_bytes(const BIGNUM *bn) {
    2,035 (0.0%)    return (BN_num_bits(bn) + 7) / 8;
      814 (0.0%)  }
        .         
      328 (0.0%)  void BN_zero(BIGNUM *bn) {
      492 (0.0%)    bn->width = bn->neg = 0;
      246 (0.0%)  }
        .         
        5 (0.0%)  int BN_one(BIGNUM *bn) {
        4 (0.0%)    return BN_set_word(bn, 1);
        2 (0.0%)  }
        .         
        6 (0.0%)  int BN_set_word(BIGNUM *bn, BN_ULONG value) {
        2 (0.0%)    if (value == 0) {
        .             BN_zero(bn);
        .             return 1;
        .           }
        .         
        6 (0.0%)    if (!bn_wexpand(bn, 1)) {
        .             return 0;
        .           }
        .         
        2 (0.0%)    bn->neg = 0;
        4 (0.0%)    bn->d[0] = value;
        2 (0.0%)    bn->width = 1;
        1 (0.0%)    return 1;
        2 (0.0%)  }
        .         
        .         int BN_set_u64(BIGNUM *bn, uint64_t value) {
        .         #if BN_BITS2 == 64
        .           return BN_set_word(bn, value);
        .         #elif BN_BITS2 == 32
        .           if (value <= BN_MASK2) {
        .             return BN_set_word(bn, (BN_ULONG)value);
        .           }
-- line 264 ----------------------------------------
-- line 283 ----------------------------------------
        .           }
        .           OPENSSL_memmove(bn->d, words, num * sizeof(BN_ULONG));
        .           // |bn_wexpand| verified that |num| isn't too large.
        .           bn->width = (int)num;
        .           bn->neg = 0;
        .           return 1;
        .         }
        .         
       84 (0.0%)  void bn_set_static_words(BIGNUM *bn, const BN_ULONG *words, size_t num) {
       60 (0.0%)    if ((bn->flags & BN_FLG_STATIC_DATA) == 0) {
       48 (0.0%)      OPENSSL_free(bn->d);
        .           }
       36 (0.0%)    bn->d = (BN_ULONG *)words;
        .         
       24 (0.0%)    assert(num <= BN_MAX_WORDS);
       48 (0.0%)    bn->width = (int)num;
       48 (0.0%)    bn->dmax = (int)num;
       24 (0.0%)    bn->neg = 0;
       72 (0.0%)    bn->flags |= BN_FLG_STATIC_DATA;
       36 (0.0%)  }
        .         
   14,670 (0.0%)  int bn_fits_in_words(const BIGNUM *bn, size_t num) {
        .           // All words beyond |num| must be zero.
    2,934 (0.0%)    BN_ULONG mask = 0;
  590,304 (0.1%)    for (size_t i = num; i < (size_t)bn->width; i++) {
  661,304 (0.1%)      mask |= bn->d[i];
        .           }
    8,802 (0.0%)    return mask == 0;
    5,868 (0.0%)  }
        .         
        .         int bn_copy_words(BN_ULONG *out, size_t num, const BIGNUM *bn) {
        .           if (bn->neg) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_NEGATIVE_NUMBER);
        .             return 0;
        .           }
        .         
        .           size_t width = (size_t)bn->width;
-- line 319 ----------------------------------------
-- line 325 ----------------------------------------
        .             width = num;
        .           }
        .         
        .           OPENSSL_memset(out, 0, sizeof(BN_ULONG) * num);
        .           OPENSSL_memcpy(out, bn->d, sizeof(BN_ULONG) * width);
        .           return 1;
        .         }
        .         
    2,752 (0.0%)  int BN_is_negative(const BIGNUM *bn) {
    3,440 (0.0%)    return bn->neg != 0;
    1,376 (0.0%)  }
        .         
        .         void BN_set_negative(BIGNUM *bn, int sign) {
        .           if (sign && !BN_is_zero(bn)) {
        .             bn->neg = 1;
        .           } else {
        .             bn->neg = 0;
        .           }
        .         }
        .         
  109,422 (0.0%)  int bn_wexpand(BIGNUM *bn, size_t words) {
        .           BN_ULONG *a;
        .         
   91,185 (0.0%)    if (words <= (size_t)bn->dmax) {
   35,048 (0.0%)      return 1;
        .           }
        .         
    1,426 (0.0%)    if (words > BN_MAX_WORDS) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_BIGNUM_TOO_LONG);
        .             return 0;
        .           }
        .         
    3,565 (0.0%)    if (bn->flags & BN_FLG_STATIC_DATA) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);
        .             return 0;
        .           }
        .         
    3,565 (0.0%)    a = OPENSSL_calloc(words, sizeof(BN_ULONG));
    1,426 (0.0%)    if (a == NULL) {
        .             return 0;
        .           }
        .         
    7,130 (0.0%)    OPENSSL_memcpy(a, bn->d, sizeof(BN_ULONG) * bn->width);
        .         
    2,852 (0.0%)    OPENSSL_free(bn->d);
    2,139 (0.0%)    bn->d = a;
    2,852 (0.0%)    bn->dmax = (int)words;
        .         
      713 (0.0%)    return 1;
   36,474 (0.0%)  }
        .         
        .         int bn_expand(BIGNUM *bn, size_t bits) {
        .           if (bits + BN_BITS2 - 1 < bits) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_BIGNUM_TOO_LONG);
        .             return 0;
        .           }
        .           return bn_wexpand(bn, (bits+BN_BITS2-1)/BN_BITS2);
        .         }
        .         
      216 (0.0%)  int bn_resize_words(BIGNUM *bn, size_t words) {
        .         #if defined(OPENSSL_PPC64LE)
        .           // This is a workaround for a miscompilation bug in Clang 7.0.1 on POWER.
        .           // The unittests catch the miscompilation, if it occurs, and it manifests
        .           // as a crash in |bn_fits_in_words|.
        .           //
        .           // The bug only triggers if building in FIPS mode and with -O3. Clang 8.0.1
        .           // has the same bug but this workaround is not effective there---I've not
        .           // been able to find a workaround for 8.0.1.
-- line 392 ----------------------------------------
-- line 394 ----------------------------------------
        .           // At the time of writing (2019-08-08), Clang git does *not* have this bug
        .           // and does not need this workaroud. The current git version should go on to
        .           // be Clang 10 thus, once we can depend on that, this can be removed.
        .           if (value_barrier_w((size_t)bn->width == words)) {
        .             return 1;
        .           }
        .         #endif
        .         
      180 (0.0%)    if ((size_t)bn->width <= words) {
      231 (0.0%)      if (!bn_wexpand(bn, words)) {
        .               return 0;
        .             }
      363 (0.0%)      OPENSSL_memset(bn->d + bn->width, 0,
      165 (0.0%)                     (words - bn->width) * sizeof(BN_ULONG));
      132 (0.0%)      bn->width = (int)words;
       66 (0.0%)      return 1;
        .           }
        .         
        .           // All words beyond the new width must be zero.
       21 (0.0%)    if (!bn_fits_in_words(bn, words)) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_BIGNUM_TOO_LONG);
        .             return 0;
        .           }
       12 (0.0%)    bn->width = (int)words;
        3 (0.0%)    return 1;
       72 (0.0%)  }
        .         
        .         void bn_select_words(BN_ULONG *r, BN_ULONG mask, const BN_ULONG *a,
  112,140 (0.0%)                       const BN_ULONG *b, size_t num) {
1,498,262 (0.2%)    for (size_t i = 0; i < num; i++) {
        .             OPENSSL_STATIC_ASSERT(sizeof(BN_ULONG) <= sizeof(crypto_word_t),
        .                                   crypto_word_t_is_too_small)
6,850,412 (1.0%)      r[i] = constant_time_select_w(mask, a[i], b[i]);
        .           }
   56,070 (0.0%)  }
        .         
   73,684 (0.0%)  int bn_minimal_width(const BIGNUM *bn) {
   55,263 (0.0%)    int ret = bn->width;
  320,415 (0.0%)    while (ret > 0 && bn->d[ret - 1] == 0) {
    6,746 (0.0%)      ret--;
        .           }
   18,421 (0.0%)    return ret;
   36,842 (0.0%)  }
        .         
   86,660 (0.0%)  void bn_set_minimal_width(BIGNUM *bn) {
   86,660 (0.0%)    bn->width = bn_minimal_width(bn);
   69,328 (0.0%)    if (bn->width == 0) {
        2 (0.0%)      bn->neg = 0;
        .           }
   51,996 (0.0%)  }
        .         
        .         int BN_get_flags(const BIGNUM *bn, int flags) {
        .           return bn->flags & flags;
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/cmp.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 59 ----------------------------------------
        .         #include <openssl/mem.h>
        .         #include <openssl/type_check.h>
        .         
        .         #include "internal.h"
        .         #include "../../internal.h"
        .         
        .         
        .         static int bn_cmp_words_consttime(const BN_ULONG *a, size_t a_len,
   25,344 (0.0%)                                    const BN_ULONG *b, size_t b_len) {
        .           OPENSSL_STATIC_ASSERT(sizeof(BN_ULONG) <= sizeof(crypto_word_t),
        .                                 crypto_word_t_is_too_small)
    3,168 (0.0%)    int ret = 0;
        .           // Process the common words in little-endian order.
   15,840 (0.0%)    size_t min = a_len < b_len ? a_len : b_len;
  400,528 (0.1%)    for (size_t i = 0; i < min; i++) {
1,346,408 (0.2%)      crypto_word_t eq = constant_time_eq_w(a[i], b[i]);
1,346,408 (0.2%)      crypto_word_t lt = constant_time_lt_w(a[i], b[i]);
        .             ret =
1,154,064 (0.2%)          constant_time_select_int(eq, ret, constant_time_select_int(lt, -1, 1));
        .           }
        .         
        .           // If |a| or |b| has non-zero words beyond |min|, they take precedence.
    9,504 (0.0%)    if (a_len < b_len) {
       62 (0.0%)      crypto_word_t mask = 0;
      868 (0.0%)      for (size_t i = a_len; i < b_len; i++) {
      744 (0.0%)        mask |= b[i];
        .             }
      682 (0.0%)      ret = constant_time_select_int(constant_time_is_zero_w(mask), ret, -1);
    9,318 (0.0%)    } else if (b_len < a_len) {
       58 (0.0%)      crypto_word_t mask = 0;
      704 (0.0%)      for (size_t i = b_len; i < a_len; i++) {
      534 (0.0%)        mask |= a[i];
        .             }
      580 (0.0%)      ret = constant_time_select_int(constant_time_is_zero_w(mask), ret, 1);
        .           }
        .         
    3,168 (0.0%)    return ret;
    6,336 (0.0%)  }
        .         
   17,520 (0.0%)  int BN_ucmp(const BIGNUM *a, const BIGNUM *b) {
   35,040 (0.0%)    return bn_cmp_words_consttime(a->d, a->width, b->d, b->width);
    5,840 (0.0%)  }
        .         
       90 (0.0%)  int BN_cmp(const BIGNUM *a, const BIGNUM *b) {
       60 (0.0%)    if ((a == NULL) || (b == NULL)) {
        .             if (a != NULL) {
        .               return -1;
        .             } else if (b != NULL) {
        .               return 1;
        .             } else {
        .               return 0;
        .             }
        .           }
        .         
        .           // We do not attempt to process the sign bit in constant time. Negative
        .           // |BIGNUM|s should never occur in crypto, only calculators.
       90 (0.0%)    if (a->neg != b->neg) {
        .             if (a->neg) {
        .               return -1;
        .             }
        .             return 1;
        .           }
        .         
       90 (0.0%)    int ret = BN_ucmp(a, b);
       75 (0.0%)    return a->neg ? -ret : ret;
       30 (0.0%)  }
        .         
    1,736 (0.0%)  int bn_less_than_words(const BN_ULONG *a, const BN_ULONG *b, size_t len) {
    1,984 (0.0%)    return bn_cmp_words_consttime(a, len, b, len) < 0;
      496 (0.0%)  }
        .         
       15 (0.0%)  int BN_abs_is_word(const BIGNUM *bn, BN_ULONG w) {
       12 (0.0%)    if (bn->width == 0) {
        .             return w == 0;
        .           }
       15 (0.0%)    BN_ULONG mask = bn->d[0] ^ w;
      338 (0.0%)    for (int i = 1; i < bn->width; i++) {
      512 (0.0%)      mask |= bn->d[i];
        .           }
        9 (0.0%)    return mask == 0;
        6 (0.0%)  }
        .         
        .         int BN_cmp_word(const BIGNUM *a, BN_ULONG b) {
        .           BIGNUM b_bn;
        .           BN_init(&b_bn);
        .         
        .           b_bn.d = &b;
        .           b_bn.width = b > 0;
        .           b_bn.dmax = 1;
        .           b_bn.flags = BN_FLG_STATIC_DATA;
        .           return BN_cmp(a, &b_bn);
        .         }
        .         
   14,560 (0.0%)  int BN_is_zero(const BIGNUM *bn) {
   11,648 (0.0%)    return bn_fits_in_words(bn, 0);
    5,824 (0.0%)  }
        .         
       15 (0.0%)  int BN_is_one(const BIGNUM *bn) {
       36 (0.0%)    return bn->neg == 0 && BN_abs_is_word(bn, 1);
        6 (0.0%)  }
        .         
        .         int BN_is_word(const BIGNUM *bn, BN_ULONG w) {
        .           return BN_abs_is_word(bn, w) && (w == 0 || bn->neg == 0);
        .         }
        .         
   25,652 (0.0%)  int BN_is_odd(const BIGNUM *bn) {
   74,123 (0.0%)    return bn->width > 0 && (bn->d[0] & 1) == 1;
   12,826 (0.0%)  }
        .         
        .         int BN_is_pow2(const BIGNUM *bn) {
        .           int width = bn_minimal_width(bn);
        .           if (width == 0 || bn->neg) {
        .             return 0;
        .           }
        .         
        .           for (int i = 0; i < width - 1; i++) {
-- line 174 ----------------------------------------
-- line 175 ----------------------------------------
        .             if (bn->d[i] != 0) {
        .               return 0;
        .             }
        .           }
        .         
        .           return 0 == (bn->d[width-1] & (bn->d[width-1] - 1));
        .         }
        .         
       10 (0.0%)  int BN_equal_consttime(const BIGNUM *a, const BIGNUM *b) {
        2 (0.0%)    BN_ULONG mask = 0;
        .           // If |a| or |b| has more words than the other, all those words must be zero.
       16 (0.0%)    for (int i = a->width; i < b->width; i++) {
        .             mask |= b->d[i];
        .           }
       16 (0.0%)    for (int i = b->width; i < a->width; i++) {
        .             mask |= a->d[i];
        .           }
        .           // Common words must match.
       14 (0.0%)    int min = a->width < b->width ? a->width : b->width;
      522 (0.0%)    for (int i = 0; i < min; i++) {
    2,048 (0.0%)      mask |= (a->d[i] ^ b->d[i]);
        .           }
        .           // The sign bit must match.
       14 (0.0%)    mask |= (a->neg ^ b->neg);
        6 (0.0%)    return mask == 0;
        4 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/div.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 132 ----------------------------------------
      .             l = (l & BN_MASK2l) << BN_BITS4;
      .           }
      .         
      .           ret |= q;
      .           return ret;
      .         }
      .         
      .         static inline void bn_div_rem_words(BN_ULONG *quotient_out, BN_ULONG *rem_out,
  1,386 (0.0%)                                      BN_ULONG n0, BN_ULONG n1, BN_ULONG d0) {
      .           // GCC and Clang generate function calls to |__udivdi3| and |__umoddi3| when
      .           // the |BN_ULLONG|-based C code is used.
      .           //
      .           // GCC bugs:
      .           //   * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=14224
      .           //   * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43721
      .           //   * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54183
      .           //   * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58897
-- line 148 ----------------------------------------
-- line 155 ----------------------------------------
      .           // These issues aren't specific to x86 and x86_64, so it might be worthwhile
      .           // to add more assembly language implementations.
      .         #if defined(BN_CAN_USE_INLINE_ASM) && defined(OPENSSL_X86)
      .           __asm__ volatile("divl %4"
      .                            : "=a"(*quotient_out), "=d"(*rem_out)
      .                            : "a"(n1), "d"(n0), "rm"(d0)
      .                            : "cc");
      .         #elif defined(BN_CAN_USE_INLINE_ASM) && defined(OPENSSL_X86_64)
  1,584 (0.0%)    __asm__ volatile("divq %4"
      .                            : "=a"(*quotient_out), "=d"(*rem_out)
      .                            : "a"(n1), "d"(n0), "rm"(d0)
      .                            : "cc");
      .         #else
      .         #if defined(BN_CAN_DIVIDE_ULLONG)
      .           BN_ULLONG n = (((BN_ULLONG)n0) << BN_BITS2) | n1;
      .           *quotient_out = (BN_ULONG)(n / d0);
      .         #else
      .           *quotient_out = bn_div_words(n0, n1, d0);
      .         #endif
      .           *rem_out = n1 - (*quotient_out * d0);
      .         #endif
    594 (0.0%)  }
      .         
      .         // BN_div computes "quotient := numerator / divisor", rounding towards zero,
      .         // and sets up |rem| such that "quotient * divisor + rem = numerator" holds.
      .         //
      .         // Thus:
      .         //
      .         //     quotient->neg == numerator->neg ^ divisor->neg
      .         //        (unless the result is zero)
-- line 184 ----------------------------------------
-- line 187 ----------------------------------------
      .         //
      .         // If |quotient| or |rem| is NULL, the respective value is not returned.
      .         //
      .         // This was specifically designed to contain fewer branches that may leak
      .         // sensitive information; see "New Branch Prediction Vulnerabilities in OpenSSL
      .         // and Necessary Software Countermeasures" by Onur Acıçmez, Shay Gueron, and
      .         // Jean-Pierre Seifert.
      .         int BN_div(BIGNUM *quotient, BIGNUM *rem, const BIGNUM *numerator,
     39 (0.0%)             const BIGNUM *divisor, BN_CTX *ctx) {
      .           int norm_shift, loop;
      .           BIGNUM wnum;
      .           BN_ULONG *resp, *wnump;
      .           BN_ULONG d0, d1;
      .           int num_n, div_n;
      .         
      .           // This function relies on the historical minimal-width |BIGNUM| invariant.
      .           // It is already not constant-time (constant-time reductions should use
      .           // Montgomery logic), so we shrink all inputs and intermediate values to
      .           // retain the previous behavior.
      .         
      .           // Invalid zero-padding would have particularly bad consequences.
     12 (0.0%)    int numerator_width = bn_minimal_width(numerator);
     12 (0.0%)    int divisor_width = bn_minimal_width(divisor);
     42 (0.0%)    if ((numerator_width > 0 && numerator->d[numerator_width - 1] == 0) ||
     30 (0.0%)        (divisor_width > 0 && divisor->d[divisor_width - 1] == 0)) {
      .             OPENSSL_PUT_ERROR(BN, BN_R_NOT_INITIALIZED);
      .             return 0;
      .           }
      .         
     15 (0.0%)    if (BN_is_zero(divisor)) {
      .             OPENSSL_PUT_ERROR(BN, BN_R_DIV_BY_ZERO);
      .             return 0;
      .           }
      .         
      9 (0.0%)    BN_CTX_start(ctx);
     12 (0.0%)    BIGNUM *tmp = BN_CTX_get(ctx);
     12 (0.0%)    BIGNUM *snum = BN_CTX_get(ctx);
     12 (0.0%)    BIGNUM *sdiv = BN_CTX_get(ctx);
      3 (0.0%)    BIGNUM *res = NULL;
      6 (0.0%)    if (quotient == NULL) {
     15 (0.0%)      res = BN_CTX_get(ctx);
      .           } else {
      .             res = quotient;
      .           }
     12 (0.0%)    if (sdiv == NULL || res == NULL) {
      .             goto err;
      .           }
      .         
      .           // First we normalise the numbers
     24 (0.0%)    norm_shift = BN_BITS2 - (BN_num_bits(divisor) % BN_BITS2);
     24 (0.0%)    if (!BN_lshift(sdiv, divisor, norm_shift)) {
      .             goto err;
      .           }
      9 (0.0%)    bn_set_minimal_width(sdiv);
      6 (0.0%)    sdiv->neg = 0;
      3 (0.0%)    norm_shift += BN_BITS2;
     24 (0.0%)    if (!BN_lshift(snum, numerator, norm_shift)) {
      .             goto err;
      .           }
      9 (0.0%)    bn_set_minimal_width(snum);
      6 (0.0%)    snum->neg = 0;
      .         
      .           // Since we don't want to have special-case logic for the case where snum is
      .           // larger than sdiv, we pad snum with enough zeroes without changing its
      .           // value.
     21 (0.0%)    if (snum->width <= sdiv->width + 1) {
      .             if (!bn_wexpand(snum, sdiv->width + 2)) {
      .               goto err;
      .             }
      .             for (int i = snum->width; i < sdiv->width + 2; i++) {
      .               snum->d[i] = 0;
      .             }
      .             snum->width = sdiv->width + 2;
      .           } else {
     30 (0.0%)      if (!bn_wexpand(snum, snum->width + 1)) {
      .               goto err;
      .             }
     24 (0.0%)      snum->d[snum->width] = 0;
     15 (0.0%)      snum->width++;
      .           }
      .         
      9 (0.0%)    div_n = sdiv->width;
      9 (0.0%)    num_n = snum->width;
      9 (0.0%)    loop = num_n - div_n;
      .           // Lets setup a 'window' into snum
      .           // This is the part that corresponds to the current
      .           // 'area' being divided
      3 (0.0%)    wnum.neg = 0;
     21 (0.0%)    wnum.d = &(snum->d[loop]);
      6 (0.0%)    wnum.width = div_n;
      .           // only needed when BN_ucmp messes up the values between width and max
     12 (0.0%)    wnum.dmax = snum->dmax - loop;  // so we don't step out of bounds
      .         
      .           // Get the top 2 words of sdiv
      .           // div_n=sdiv->width;
     27 (0.0%)    d0 = sdiv->d[div_n - 1];
     36 (0.0%)    d1 = (div_n == 1) ? 0 : sdiv->d[div_n - 2];
      .         
      .           // pointer to the 'top' of snum
     24 (0.0%)    wnump = &(snum->d[num_n - 1]);
      .         
      .           // Setup |res|. |numerator| and |res| may alias, so we save |numerator->neg|
      .           // for later.
      9 (0.0%)    const int numerator_neg = numerator->neg;
     18 (0.0%)    res->neg = (numerator_neg ^ divisor->neg);
     27 (0.0%)    if (!bn_wexpand(res, loop + 1)) {
      .             goto err;
      .           }
     12 (0.0%)    res->width = loop - 1;
     24 (0.0%)    resp = &(res->d[loop - 1]);
      .         
      .           // space for temp
     27 (0.0%)    if (!bn_wexpand(tmp, div_n + 1)) {
      .             goto err;
      .           }
      .         
      .           // if res->width == 0 then clear the neg value otherwise decrease
      .           // the resp pointer
     12 (0.0%)    if (res->width == 0) {
      .             res->neg = 0;
      .           } else {
      3 (0.0%)      resp--;
      .           }
      .         
  1,404 (0.0%)    for (int i = 0; i < loop - 1; i++, wnump--, resp--) {
      .             BN_ULONG q, l0;
      .             // the first part of the loop uses the top two words of snum and sdiv to
      .             // calculate a BN_ULONG q such that | wnum - sdiv * q | < sdiv
    198 (0.0%)      BN_ULONG n0, n1, rm = 0;
      .         
    594 (0.0%)      n0 = wnump[0];
    594 (0.0%)      n1 = wnump[-1];
    594 (0.0%)      if (n0 == d0) {
      .               q = BN_MASK2;
      .             } else {
      .               // n0 < d0
  1,584 (0.0%)        bn_div_rem_words(&q, &rm, n0, n1, d0);
      .         
      .         #ifdef BN_ULLONG
  3,366 (0.0%)        BN_ULLONG t2 = (BN_ULLONG)d1 * q;
      .               for (;;) {
  3,627 (0.0%)          if (t2 <= ((((BN_ULLONG)rm) << BN_BITS2) | wnump[-2])) {
    318 (0.0%)            break;
      .                 }
    198 (0.0%)          q--;
    264 (0.0%)          rm += d0;
    198 (0.0%)          if (rm < d0) {
     39 (0.0%)            break;  // don't let rm overflow
      .                 }
    108 (0.0%)          t2 -= d1;
      .               }
      .         #else  // !BN_ULLONG
      .               BN_ULONG t2l, t2h;
      .               BN_UMULT_LOHI(t2l, t2h, d1, q);
      .               for (;;) {
      .                 if (t2h < rm ||
      .                     (t2h == rm && t2l <= wnump[-2])) {
      .                   break;
-- line 344 ----------------------------------------
-- line 351 ----------------------------------------
      .                 if (t2l < d1) {
      .                   t2h--;
      .                 }
      .                 t2l -= d1;
      .               }
      .         #endif  // !BN_ULLONG
      .             }
      .         
  1,980 (0.0%)      l0 = bn_mul_words(tmp->d, sdiv->d, div_n, q);
  1,584 (0.0%)      tmp->d[div_n] = l0;
    594 (0.0%)      wnum.d--;
      .             // ingore top values of the bignums just sub the two
      .             // BN_ULONG arrays with bn_sub_words
  2,178 (0.0%)      if (bn_sub_words(wnum.d, wnum.d, tmp->d, div_n + 1)) {
      .               // Note: As we have considered only the leading
      .               // two BN_ULONGs in the calculation of q, sdiv * q
      .               // might be greater than wnum (but then (q-1) * sdiv
      .               // is less or equal than wnum)
      .               q--;
      .               if (bn_add_words(wnum.d, wnum.d, sdiv->d, div_n)) {
      .                 // we can't have an overflow here (assuming
      .                 // that q != 0, but if q == 0 then tmp is
      .                 // zero anyway)
      .                 (*wnump)++;
      .               }
      .             }
      .             // store part of the result
    594 (0.0%)      *resp = q;
      .           }
      .         
      9 (0.0%)    bn_set_minimal_width(snum);
      .         
      6 (0.0%)    if (rem != NULL) {
     24 (0.0%)      if (!BN_rshift(rem, snum, norm_shift)) {
      .               goto err;
      .             }
     15 (0.0%)      if (!BN_is_zero(rem)) {
      9 (0.0%)        rem->neg = numerator_neg;
      .             }
      .           }
      .         
      9 (0.0%)    bn_set_minimal_width(res);
      9 (0.0%)    BN_CTX_end(ctx);
      6 (0.0%)    return 1;
      .         
      .         err:
      .           BN_CTX_end(ctx);
      .           return 0;
     18 (0.0%)  }
      .         
      .         int BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx) {
      .           if (!(BN_mod(r, m, d, ctx))) {
      .             return 0;
      .           }
      .           if (!r->neg) {
      .             return 1;
      .           }
      .         
      .           // now -|d| < r < 0, so we have to set r := r + |d|.
      .           return (d->neg ? BN_sub : BN_add)(r, r, d);
      .         }
      .         
      .         BN_ULONG bn_reduce_once(BN_ULONG *r, const BN_ULONG *a, BN_ULONG carry,
    234 (0.0%)                          const BN_ULONG *m, size_t num) {
     78 (0.0%)    assert(r != a);
      .           // |r| = |a| - |m|. |bn_sub_words| performs the bulk of the subtraction, and
      .           // then we apply the borrow to |carry|.
    182 (0.0%)    carry -= bn_sub_words(r, a, m, num);
      .           // We know 0 <= |a| < 2*|m|, so -|m| <= |r| < |m|.
      .           //
      .           // If 0 <= |r| < |m|, |r| fits in |num| words and |carry| is zero. We then
      .           // wish to select |r| as the answer. Otherwise -m <= r < 0 and we wish to
      .           // return |r| + |m|, or |a|. |carry| must then be -1 or all ones. In both
      .           // cases, |carry| is a suitable input to |bn_select_words|.
      .           //
      .           // Although |carry| may be one if it was one on input and |bn_sub_words|
      .           // returns zero, this would give |r| > |m|, violating our input assumptions.
    102 (0.0%)    assert(carry == 0 || carry == (BN_ULONG)-1);
    208 (0.0%)    bn_select_words(r, carry, a /* r < 0 */, r /* r >= 0 */, num);
     26 (0.0%)    return carry;
     52 (0.0%)  }
      .         
      .         BN_ULONG bn_reduce_once_in_place(BN_ULONG *r, BN_ULONG carry, const BN_ULONG *m,
 99,774 (0.0%)                                   BN_ULONG *tmp, size_t num) {
      .           // See |bn_reduce_once| for why this logic works.
 77,602 (0.0%)    carry -= bn_sub_words(tmp, r, m, num);
 33,606 (0.0%)    assert(carry == 0 || carry == (BN_ULONG)-1);
 88,688 (0.0%)    bn_select_words(r, carry, r /* tmp < 0 */, tmp /* tmp >= 0 */, num);
 11,086 (0.0%)    return carry;
 22,172 (0.0%)  }
      .         
      .         void bn_mod_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,
    240 (0.0%)                        const BN_ULONG *m, BN_ULONG *tmp, size_t num) {
      .           // r = a - b
    168 (0.0%)    BN_ULONG borrow = bn_sub_words(r, a, b, num);
      .           // tmp = a - b + m
    144 (0.0%)    bn_add_words(tmp, r, m, num);
    240 (0.0%)    bn_select_words(r, 0 - borrow, tmp /* r < 0 */, r /* r >= 0 */, num);
     72 (0.0%)  }
      .         
      .         void bn_mod_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,
  3,340 (0.0%)                        const BN_ULONG *m, BN_ULONG *tmp, size_t num) {
  2,338 (0.0%)    BN_ULONG carry = bn_add_words(r, a, b, num);
  2,672 (0.0%)    bn_reduce_once_in_place(r, carry, m, tmp, num);
  1,002 (0.0%)  }
      .         
      .         int bn_div_consttime(BIGNUM *quotient, BIGNUM *remainder,
      .                              const BIGNUM *numerator, const BIGNUM *divisor,
     50 (0.0%)                       unsigned divisor_min_bits, BN_CTX *ctx) {
     50 (0.0%)    if (BN_is_negative(numerator) || BN_is_negative(divisor)) {
      .             OPENSSL_PUT_ERROR(BN, BN_R_NEGATIVE_NUMBER);
      .             return 0;
      .           }
     25 (0.0%)    if (BN_is_zero(divisor)) {
      .             OPENSSL_PUT_ERROR(BN, BN_R_DIV_BY_ZERO);
      .             return 0;
      .           }
      .         
      .           // This function implements long division in binary. It is not very efficient,
      .           // but it is simple, easy to make constant-time, and performant enough for RSA
      .           // key generation.
      .         
      5 (0.0%)    int ret = 0;
     15 (0.0%)    BN_CTX_start(ctx);
     20 (0.0%)    BIGNUM *q = quotient, *r = remainder;
     10 (0.0%)    if (quotient == NULL || quotient == numerator || quotient == divisor) {
     20 (0.0%)      q = BN_CTX_get(ctx);
      .           }
     34 (0.0%)    if (remainder == NULL || remainder == numerator || remainder == divisor) {
      8 (0.0%)      r = BN_CTX_get(ctx);
      .           }
     20 (0.0%)    BIGNUM *tmp = BN_CTX_get(ctx);
     40 (0.0%)    if (q == NULL || r == NULL || tmp == NULL ||
     45 (0.0%)        !bn_wexpand(q, numerator->width) ||
     45 (0.0%)        !bn_wexpand(r, divisor->width) ||
     35 (0.0%)        !bn_wexpand(tmp, divisor->width)) {
      .             goto err;
      .           }
      .         
     45 (0.0%)    OPENSSL_memset(q->d, 0, numerator->width * sizeof(BN_ULONG));
     20 (0.0%)    q->width = numerator->width;
     10 (0.0%)    q->neg = 0;
      .         
     45 (0.0%)    OPENSSL_memset(r->d, 0, divisor->width * sizeof(BN_ULONG));
     20 (0.0%)    r->width = divisor->width;
     10 (0.0%)    r->neg = 0;
      .         
      .           // Incorporate |numerator| into |r|, one bit at a time, reducing after each
      .           // step. We maintain the invariant that |0 <= r < divisor| and
      .           // |q * divisor + r = n| where |n| is the portion of |numerator| incorporated
      .           // so far.
      .           //
      .           // First, we short-circuit the loop: if we know |divisor| has at least
      .           // |divisor_min_bits| bits, the top |divisor_min_bits - 1| can be incorporated
      .           // without reductions. This significantly speeds up |RSA_check_key|. For
      .           // simplicity, we round down to a whole number of words.
     25 (0.0%)    assert(divisor_min_bits <= BN_num_bits(divisor));
      5 (0.0%)    int initial_words = 0;
     10 (0.0%)    if (divisor_min_bits > 0) {
     20 (0.0%)      initial_words = (divisor_min_bits - 1) / BN_BITS2;
     20 (0.0%)      if (initial_words > numerator->width) {
      .               initial_words = numerator->width;
      .             }
     90 (0.0%)      OPENSSL_memcpy(r->d, numerator->d + numerator->width - initial_words,
      .                            initial_words * sizeof(BN_ULONG));
      .           }
      .         
    544 (0.0%)    for (int i = numerator->width - initial_words - 1; i >= 0; i--) {
 32,928 (0.0%)      for (int bit = BN_BITS2 - 1; bit >= 0; bit--) {
      .               // Incorporate the next bit of the numerator, by computing
      .               // r = 2*r or 2*r + 1. Note the result fits in one more word. We store the
      .               // extra word in |carry|.
129,024 (0.0%)        BN_ULONG carry = bn_add_words(r->d, r->d, r->d, divisor->width);
215,040 (0.0%)        r->d[0] |= (numerator->d[i] >> bit) & 1;
      .               // |r| was previously fully-reduced, so we know:
      .               //      2*0 <= r <= 2*(divisor-1) + 1
      .               //        0 <= r <= 2*divisor - 1 < 2*divisor.
      .               // Thus |r| satisfies the preconditions for |bn_reduce_once_in_place|.
129,024 (0.0%)        BN_ULONG subtracted = bn_reduce_once_in_place(r->d, carry, divisor->d,
 21,504 (0.0%)                                                      tmp->d, divisor->width);
      .               // The corresponding bit of the quotient is set iff we needed to subtract.
247,296 (0.0%)        q->d[i] |= (~subtracted & 1) << bit;
      .             }
      .           }
      .         
     20 (0.0%)    if ((quotient != NULL && !BN_copy(quotient, q)) ||
     35 (0.0%)        (remainder != NULL && !BN_copy(remainder, r))) {
      .             goto err;
      .           }
      .         
     10 (0.0%)    ret = 1;
      .         
      .         err:
     15 (0.0%)    BN_CTX_end(ctx);
      5 (0.0%)    return ret;
     10 (0.0%)  }
      .         
     24 (0.0%)  static BIGNUM *bn_scratch_space_from_ctx(size_t width, BN_CTX *ctx) {
     16 (0.0%)    BIGNUM *ret = BN_CTX_get(ctx);
     16 (0.0%)    if (ret == NULL ||
     20 (0.0%)        !bn_wexpand(ret, width)) {
      .             return NULL;
      .           }
      8 (0.0%)    ret->neg = 0;
     16 (0.0%)    ret->width = (int)width;
      4 (0.0%)    return ret;
      8 (0.0%)  }
      .         
      .         // bn_resized_from_ctx returns |bn| with width at least |width| or NULL on
      .         // error. This is so it may be used with low-level "words" functions. If
      .         // necessary, it allocates a new |BIGNUM| with a lifetime of the current scope
      .         // in |ctx|, so the caller does not need to explicitly free it. |bn| must fit in
      .         // |width| words.
      .         static const BIGNUM *bn_resized_from_ctx(const BIGNUM *bn, size_t width,
     28 (0.0%)                                           BN_CTX *ctx) {
     20 (0.0%)    if ((size_t)bn->width >= width) {
      .             // Any excess words must be zero.
     28 (0.0%)      assert(bn_fits_in_words(bn, width));
      8 (0.0%)      return bn;
      .           }
      .           BIGNUM *ret = bn_scratch_space_from_ctx(width, ctx);
      .           if (ret == NULL ||
      .               !BN_copy(ret, bn) ||
      .               !bn_resize_words(ret, width)) {
      .             return NULL;
      .           }
      .           return ret;
      8 (0.0%)  }
      .         
      .         int BN_mod_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,
      .                        BN_CTX *ctx) {
      .           if (!BN_add(r, a, b)) {
      .             return 0;
      .           }
      .           return BN_nnmod(r, r, m, ctx);
      .         }
-- line 586 ----------------------------------------
-- line 615 ----------------------------------------
      .                        BN_CTX *ctx) {
      .           if (!BN_sub(r, a, b)) {
      .             return 0;
      .           }
      .           return BN_nnmod(r, r, m, ctx);
      .         }
      .         
      .         int bn_mod_sub_consttime(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
     18 (0.0%)                           const BIGNUM *m, BN_CTX *ctx) {
      6 (0.0%)    BN_CTX_start(ctx);
     18 (0.0%)    a = bn_resized_from_ctx(a, m->width, ctx);
     18 (0.0%)    b = bn_resized_from_ctx(b, m->width, ctx);
     16 (0.0%)    BIGNUM *tmp = bn_scratch_space_from_ctx(m->width, ctx);
     22 (0.0%)    int ok = a != NULL && b != NULL && tmp != NULL &&
     14 (0.0%)             bn_wexpand(r, m->width);
      4 (0.0%)    if (ok) {
     34 (0.0%)      bn_mod_sub_words(r->d, a->d, b->d, m->d, tmp->d, m->width);
      8 (0.0%)      r->width = m->width;
      4 (0.0%)      r->neg = 0;
      .           }
      6 (0.0%)    BN_CTX_end(ctx);
      2 (0.0%)    return ok;
      4 (0.0%)  }
      .         
      .         int BN_mod_sub_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
      .                              const BIGNUM *m) {
      .           BN_CTX *ctx = BN_CTX_new();
      .           int ok = ctx != NULL &&
      .                    bn_mod_sub_consttime(r, a, b, m, ctx);
      .           BN_CTX_free(ctx);
      .           return ok;
-- line 645 ----------------------------------------
-- line 705 ----------------------------------------
      .         
      .           ret = bn_mod_lshift_consttime(r, r, n, (abs_m ? abs_m : m), ctx);
      .         
      .           BN_free(abs_m);
      .           return ret;
      .         }
      .         
      .         int bn_mod_lshift_consttime(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m,
     18 (0.0%)                              BN_CTX *ctx) {
     18 (0.0%)    if (!BN_copy(r, a) ||
     14 (0.0%)        !bn_resize_words(r, m->width)) {
      .             return 0;
      .           }
      .         
      6 (0.0%)    BN_CTX_start(ctx);
     16 (0.0%)    BIGNUM *tmp = bn_scratch_space_from_ctx(m->width, ctx);
      8 (0.0%)    int ok = tmp != NULL;
      4 (0.0%)    if (ok) {
    274 (0.0%)      for (int i = 0; i < n; i++) {
  1,122 (0.0%)        bn_mod_add_words(r->d, r->d, r->d, m->d, tmp->d, m->width);
      .             }
      4 (0.0%)      r->neg = 0;
      .           }
      6 (0.0%)    BN_CTX_end(ctx);
      2 (0.0%)    return ok;
      4 (0.0%)  }
      .         
      .         int BN_mod_lshift_quick(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m) {
      .           BN_CTX *ctx = BN_CTX_new();
      .           int ok = ctx != NULL &&
      .                    bn_mod_lshift_consttime(r, a, n, m, ctx);
      .           BN_CTX_free(ctx);
      .           return ok;
      .         }
-- line 738 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 59 ----------------------------------------
        .         #include <string.h>
        .         
        .         #include <openssl/err.h>
        .         #include <openssl/type_check.h>
        .         
        .         #include "internal.h"
        .         
        .         
       42 (0.0%)  int BN_lshift(BIGNUM *r, const BIGNUM *a, int n) {
        .           int i, nw, lb, rb;
        .           BN_ULONG *t, *f;
        .           BN_ULONG l;
        .         
       12 (0.0%)    if (n < 0) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_NEGATIVE_NUMBER);
        .             return 0;
        .           }
        .         
       24 (0.0%)    r->neg = a->neg;
       36 (0.0%)    nw = n / BN_BITS2;
       72 (0.0%)    if (!bn_wexpand(r, a->width + nw + 1)) {
        .             return 0;
        .           }
       48 (0.0%)    lb = n % BN_BITS2;
       18 (0.0%)    rb = BN_BITS2 - lb;
       18 (0.0%)    f = a->d;
       18 (0.0%)    t = r->d;
       54 (0.0%)    t[a->width + nw] = 0;
       12 (0.0%)    if (lb == 0) {
    1,785 (0.0%)      for (i = a->width - 1; i >= 0; i--) {
    8,106 (0.0%)        t[nw + i] = f[i];
        .             }
        .           } else {
        .             for (i = a->width - 1; i >= 0; i--) {
        .               l = f[i];
        .               t[nw + i + 1] |= l >> rb;
        .               t[nw + i] = l << lb;
        .             }
        .           }
       42 (0.0%)    OPENSSL_memset(t, 0, nw * sizeof(t[0]));
       42 (0.0%)    r->width = a->width + nw + 1;
       18 (0.0%)    bn_set_minimal_width(r);
        .         
        6 (0.0%)    return 1;
       12 (0.0%)  }
        .         
        .         int BN_lshift1(BIGNUM *r, const BIGNUM *a) {
        .           BN_ULONG *ap, *rp, t, c;
        .           int i;
        .         
        .           if (r != a) {
        .             r->neg = a->neg;
        .             if (!bn_wexpand(r, a->width + 1)) {
-- line 111 ----------------------------------------
-- line 129 ----------------------------------------
        .             *rp = 1;
        .             r->width++;
        .           }
        .         
        .           return 1;
        .         }
        .         
        .         void bn_rshift_words(BN_ULONG *r, const BN_ULONG *a, unsigned shift,
   23,096 (0.0%)                       size_t num) {
    8,661 (0.0%)    unsigned shift_bits = shift % BN_BITS2;
   11,548 (0.0%)    size_t shift_words = shift / BN_BITS2;
    8,661 (0.0%)    if (shift_words >= num) {
        .             OPENSSL_memset(r, 0, num * sizeof(BN_ULONG));
        .             return;
        .           }
    5,774 (0.0%)    if (shift_bits == 0) {
       36 (0.0%)      OPENSSL_memmove(r, a + shift_words, (num - shift_words) * sizeof(BN_ULONG));
        .           } else {
  471,668 (0.1%)      for (size_t i = shift_words; i < num - 1; i++) {
  541,776 (0.1%)        r[i - shift_words] =
1,805,920 (0.3%)            (a[i] >> shift_bits) | (a[i + 1] << (BN_BITS2 - shift_bits));
        .             }
   49,028 (0.0%)      r[num - 1 - shift_words] = a[num - 1] >> shift_bits;
        .           }
   28,870 (0.0%)    OPENSSL_memset(r + num - shift_words, 0, shift_words * sizeof(BN_ULONG));
    5,774 (0.0%)  }
        .         
   20,209 (0.0%)  int BN_rshift(BIGNUM *r, const BIGNUM *a, int n) {
    5,774 (0.0%)    if (n < 0) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_NEGATIVE_NUMBER);
        .             return 0;
        .           }
        .         
   25,983 (0.0%)    if (!bn_wexpand(r, a->width)) {
        .             return 0;
        .           }
   28,870 (0.0%)    bn_rshift_words(r->d, a->d, n, a->width);
   11,548 (0.0%)    r->neg = a->neg;
   11,548 (0.0%)    r->width = a->width;
    8,661 (0.0%)    bn_set_minimal_width(r);
    2,887 (0.0%)    return 1;
    5,774 (0.0%)  }
        .         
        .         int bn_rshift_secret_shift(BIGNUM *r, const BIGNUM *a, unsigned n,
        .                                    BN_CTX *ctx) {
        .           int ret = 0;
        .           BN_CTX_start(ctx);
        .           BIGNUM *tmp = BN_CTX_get(ctx);
        .           if (tmp == NULL ||
        .               !BN_copy(r, a) ||
-- line 178 ----------------------------------------
-- line 192 ----------------------------------------
        .         
        .           ret = 1;
        .         
        .         err:
        .           BN_CTX_end(ctx);
        .           return ret;
        .         }
        .         
   34,458 (0.0%)  void bn_rshift1_words(BN_ULONG *r, const BN_ULONG *a, size_t num) {
   11,486 (0.0%)    if (num == 0) {
        .             return;
        .           }
1,865,703 (0.3%)    for (size_t i = 0; i < num - 1; i++) {
7,691,229 (1.2%)      r[i] = (a[i] >> 1) | (a[i + 1] << (BN_BITS2 - 1));
        .           }
   80,402 (0.0%)    r[num - 1] = a[num - 1] >> 1;
   11,486 (0.0%)  }
        .         
   34,458 (0.0%)  int BN_rshift1(BIGNUM *r, const BIGNUM *a) {
   51,687 (0.0%)    if (!bn_wexpand(r, a->width)) {
        .             return 0;
        .           }
   57,430 (0.0%)    bn_rshift1_words(r->d, a->d, a->width);
   22,972 (0.0%)    r->width = a->width;
   22,972 (0.0%)    r->neg = a->neg;
   17,229 (0.0%)    bn_set_minimal_width(r);
    5,743 (0.0%)    return 1;
   11,486 (0.0%)  }
        .         
       30 (0.0%)  int BN_set_bit(BIGNUM *a, int n) {
       10 (0.0%)    if (n < 0) {
        .             return 0;
        .           }
        .         
       30 (0.0%)    int i = n / BN_BITS2;
       40 (0.0%)    int j = n % BN_BITS2;
       20 (0.0%)    if (a->width <= i) {
       45 (0.0%)      if (!bn_wexpand(a, i + 1)) {
        .               return 0;
        .             }
    1,839 (0.0%)      for (int k = a->width; k < i + 1; k++) {
    3,157 (0.0%)        a->d[k] = 0;
        .             }
       20 (0.0%)      a->width = i + 1;
        .           }
        .         
       95 (0.0%)    a->d[i] |= (((BN_ULONG)1) << j);
        .         
        5 (0.0%)    return 1;
       10 (0.0%)  }
        .         
        .         int BN_clear_bit(BIGNUM *a, int n) {
        .           int i, j;
        .         
        .           if (n < 0) {
        .             return 0;
        .           }
        .         
-- line 249 ----------------------------------------
-- line 253 ----------------------------------------
        .             return 0;
        .           }
        .         
        .           a->d[i] &= (~(((BN_ULONG)1) << j));
        .           bn_set_minimal_width(a);
        .           return 1;
        .         }
        .         
   69,648 (0.0%)  int bn_is_bit_set_words(const BN_ULONG *a, size_t num, size_t bit) {
   34,824 (0.0%)    size_t i = bit / BN_BITS2;
   34,824 (0.0%)    size_t j = bit % BN_BITS2;
   34,824 (0.0%)    if (i >= num) {
        .             return 0;
        .           }
  104,472 (0.0%)    return (a[i] >> j) & 1;
   23,216 (0.0%)  }
        .         
   69,648 (0.0%)  int BN_is_bit_set(const BIGNUM *a, int n) {
   23,216 (0.0%)    if (n < 0) {
        .             return 0;
        .           }
  116,080 (0.0%)    return bn_is_bit_set_words(a->d, a->width, n);
   23,216 (0.0%)  }
        .         
        .         int BN_mask_bits(BIGNUM *a, int n) {
        .           if (n < 0) {
        .             return 0;
        .           }
        .         
        .           int w = n / BN_BITS2;
        .           int b = n % BN_BITS2;
-- line 283 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h
--------------------------------------------------------------------------------
Ir____________ 

-- line 866 ----------------------------------------
      .         static inline int OPENSSL_memcmp(const void *s1, const void *s2, size_t n) {
      .           if (n == 0) {
      .             return 0;
      .           }
      .         
      .           return memcmp(s1, s2, n);
      .         }
      .         
 63,756 (0.0%)  static inline void *OPENSSL_memcpy(void *dst, const void *src, size_t n) {
 21,252 (0.0%)    if (n == 0) {
      .             return dst;
      .           }
      .         
 63,756 (0.0%)    return memcpy(dst, src, n);
 21,252 (0.0%)  }
      .         
      .         static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
      .           if (n == 0) {
      .             return dst;
      .           }
      .         
      .           return memmove(dst, src, n);
      .         }
      .         
879,624 (0.1%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
293,208 (0.0%)    if (n == 0) {
      .             return dst;
      .           }
      .         
879,624 (0.1%)    return memset(dst, c, n);
293,208 (0.0%)  }
      .         
      .         
      .         // Loads and stores.
      .         //
      .         // The following functions load and store sized integers with the specified
      .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
      .         // requirements on the input and output pointers.
      .         
-- line 904 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 77 ----------------------------------------
      .         #define OPENSSL_MALLOC_PREFIX 8
      .         OPENSSL_STATIC_ASSERT(OPENSSL_MALLOC_PREFIX >= sizeof(size_t),
      .                               size_t_too_large)
      .         
      .         #if defined(OPENSSL_ASAN)
      .         void __asan_poison_memory_region(const volatile void *addr, size_t size);
      .         void __asan_unpoison_memory_region(const volatile void *addr, size_t size);
      .         #else
726,048 (0.1%)  static void __asan_poison_memory_region(const void *addr, size_t size) {}
726,048 (0.1%)  static void __asan_unpoison_memory_region(const void *addr, size_t size) {}
      .         #endif
      .         
      .         // Windows doesn't really support weak symbols as of May 2019, and Clang on
      .         // Windows will emit strong symbols instead. See
      .         // https://bugs.llvm.org/show_bug.cgi?id=37598
      .         #if defined(__ELF__) && defined(__GNUC__)
      .         #define WEAK_SYMBOL_FUNC(rettype, name, args) \
      .           rettype name args __attribute__((weak));
-- line 94 ----------------------------------------
-- line 157 ----------------------------------------
      .             return 0;
      .           }
      .           malloc_impl = m;
      .           realloc_impl = r;
      .           free_impl = f;
      .           return 1;
      .         }
      .         
438,550 (0.1%)  void *OPENSSL_malloc(size_t size) {
263,130 (0.0%)    if (malloc_impl != NULL) {
      .             assert(OPENSSL_memory_alloc == NULL);
      .             assert(OPENSSL_memory_realloc == NULL);
      .             assert(OPENSSL_memory_free == NULL);
      .             assert(OPENSSL_memory_get_size == NULL);
      .             assert(realloc_impl != NULL);
      .             assert(free_impl != NULL);
      .             return malloc_impl(size, AWSLC_FILE, AWSLC_LINE);
      .           }
263,130 (0.0%)    if (OPENSSL_memory_alloc != NULL) {
      .             assert(OPENSSL_memory_free != NULL);
      .             assert(OPENSSL_memory_get_size != NULL);
      .             void *ptr = OPENSSL_memory_alloc(size);
      .             if (ptr == NULL && size != 0) {
      .               goto err;
      .             }
      .             return ptr;
      .           }
      .         
175,420 (0.0%)    if (size + OPENSSL_MALLOC_PREFIX < size) {
      .             goto err;
      .           }
      .         
438,550 (0.1%)    void *ptr = malloc(size + OPENSSL_MALLOC_PREFIX);
175,420 (0.0%)    if (ptr == NULL) {
      .             goto err;
      .           }
      .         
263,130 (0.0%)    *(size_t *)ptr = size;
      .         
350,840 (0.1%)    __asan_poison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
263,130 (0.0%)    return ((uint8_t *)ptr) + OPENSSL_MALLOC_PREFIX;
      .         
      .          err:
      .           // This only works because ERR does not call OPENSSL_malloc.
      .           OPENSSL_PUT_ERROR(CRYPTO, ERR_R_MALLOC_FAILURE);
      .           return NULL;
175,420 (0.0%)  }
      .         
294,185 (0.0%)  void *OPENSSL_zalloc(size_t size) {
235,348 (0.0%)    void *ret = OPENSSL_malloc(size);
117,674 (0.0%)    if (ret != NULL) {
294,185 (0.0%)      OPENSSL_memset(ret, 0, size);
      .           }
 58,837 (0.0%)    return ret;
117,674 (0.0%)  }
      .         
 66,318 (0.0%)  void *OPENSSL_calloc(size_t num, size_t size) {
 99,477 (0.0%)    if (size != 0 && num > SIZE_MAX / size) {
      .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
      .             return NULL;
      .           }
      .         
 44,212 (0.0%)    return OPENSSL_zalloc(num * size);
 22,106 (0.0%)  }
      .         
575,900 (0.1%)  void OPENSSL_free(void *orig_ptr) {
230,360 (0.0%)    if (orig_ptr == NULL) {
 27,470 (0.0%)      return;
      .           }
263,130 (0.0%)    if (free_impl != NULL) {
      .             assert(OPENSSL_memory_alloc == NULL);
      .             assert(OPENSSL_memory_realloc == NULL);
      .             assert(OPENSSL_memory_free == NULL);
      .             assert(OPENSSL_memory_get_size == NULL);
      .             assert(malloc_impl != NULL);
      .             assert(realloc_impl != NULL);
      .             free_impl(orig_ptr, AWSLC_FILE, AWSLC_LINE);
      .             return;
      .           }
      .         
263,130 (0.0%)    if (OPENSSL_memory_free != NULL) {
      .             OPENSSL_memory_free(orig_ptr);
      .             return;
      .           }
      .         
263,130 (0.0%)    void *ptr = ((uint8_t *)orig_ptr) - OPENSSL_MALLOC_PREFIX;
350,840 (0.1%)    __asan_unpoison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
      .         
263,130 (0.0%)    size_t size = *(size_t *)ptr;
526,260 (0.1%)    OPENSSL_cleanse(ptr, size + OPENSSL_MALLOC_PREFIX);
      .         
      .         // ASan knows to intercept malloc and free, but not sdallocx.
      .         #if defined(OPENSSL_ASAN)
      .           (void)sdallocx;
      .           free(ptr);
      .           (void) sdallocx;
      .         #else
263,130 (0.0%)    if (sdallocx) {
      .             sdallocx(ptr, size + OPENSSL_MALLOC_PREFIX, 0 /* flags */);
      .           } else {
350,840 (0.1%)      free(ptr);
      .           }
      .         #endif
230,360 (0.0%)  }
      .         
 31,482 (0.0%)  void *OPENSSL_realloc(void *orig_ptr, size_t new_size) {
 10,494 (0.0%)    if (orig_ptr == NULL) {
  8,804 (0.0%)      return OPENSSL_malloc(new_size);
      .           }
  9,138 (0.0%)    if (realloc_impl != NULL) {
      .             assert(OPENSSL_memory_alloc == NULL);
      .             assert(OPENSSL_memory_realloc == NULL);
      .             assert(OPENSSL_memory_free == NULL);
      .             assert(OPENSSL_memory_get_size == NULL);
      .             assert(malloc_impl != NULL);
      .             assert(free_impl != NULL);
      .             return realloc_impl(orig_ptr, new_size, AWSLC_FILE, AWSLC_LINE);
      .           }
  9,138 (0.0%)    if (OPENSSL_memory_realloc != NULL) {
      .             assert(OPENSSL_memory_alloc != NULL);
      .             assert(OPENSSL_memory_free != NULL);
      .             assert(OPENSSL_memory_get_size != NULL);
      .             return OPENSSL_memory_realloc(orig_ptr, new_size);
      .           }
      .           size_t old_size;
  9,138 (0.0%)    if (OPENSSL_memory_get_size != NULL) {
      .             old_size = OPENSSL_memory_get_size(orig_ptr);
      .           } else {
  9,138 (0.0%)      void *ptr = ((uint8_t *)orig_ptr) - OPENSSL_MALLOC_PREFIX;
 12,184 (0.0%)      __asan_unpoison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
  9,138 (0.0%)      old_size = *(size_t *)ptr;
 12,184 (0.0%)      __asan_poison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
      .           }
      .         
 12,184 (0.0%)    void *ret = OPENSSL_malloc(new_size);
  6,092 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
  6,092 (0.0%)    size_t to_copy = new_size;
  9,138 (0.0%)    if (old_size < to_copy) {
  6,092 (0.0%)      to_copy = old_size;
      .           }
      .         
 18,276 (0.0%)    memcpy(ret, orig_ptr, to_copy);
  9,138 (0.0%)    OPENSSL_free(orig_ptr);
      .         
  3,046 (0.0%)    return ret;
 10,494 (0.0%)  }
      .         
526,596 (0.1%)  void OPENSSL_cleanse(void *ptr, size_t len) {
      .         #if defined(OPENSSL_WINDOWS)
      .           SecureZeroMemory(ptr, len);
      .         #else
438,830 (0.1%)    OPENSSL_memset(ptr, 0, len);
      .         
      .         #if !defined(OPENSSL_NO_ASM)
      .           /* As best as we can tell, this is sufficient to break any optimisations that
      .              might try to eliminate "superfluous" memsets. If there's an easy way to
      .              detect memset_s, it would be better to use that. */
 87,766 (0.0%)    __asm__ __volatile__("" : : "r"(ptr) : "memory");
      .         #endif
      .         #endif  // !OPENSSL_NO_ASM
263,298 (0.0%)  }
      .         
      .         void OPENSSL_clear_free(void *ptr, size_t unused) { OPENSSL_free(ptr); }
      .         
      .         int CRYPTO_secure_malloc_init(size_t size, size_t min_size) { return 0; }
      .         
      .         int CRYPTO_secure_malloc_initialized(void) { return 0; }
      .         
      .         size_t CRYPTO_secure_used(void) { return 0; }
-- line 328 ----------------------------------------
-- line 330 ----------------------------------------
      .         void *OPENSSL_secure_malloc(size_t size) { return OPENSSL_malloc(size); }
      .         
      .         void *OPENSSL_secure_zalloc(size_t size) { return OPENSSL_zalloc(size); }
      .         
      .         void OPENSSL_secure_clear_free(void *ptr, size_t len) {
      .           OPENSSL_clear_free(ptr, len);
      .         }
      .         
  2,142 (0.0%)  int CRYPTO_memcmp(const void *in_a, const void *in_b, size_t len) {
    714 (0.0%)    const uint8_t *a = in_a;
    714 (0.0%)    const uint8_t *b = in_b;
    357 (0.0%)    uint8_t x = 0;
      .         
 29,593 (0.0%)    for (size_t i = 0; i < len; i++) {
 69,520 (0.0%)      x |= a[i] ^ b[i];
      .           }
      .         
    357 (0.0%)    return x;
    714 (0.0%)  }
      .         
      .         uint32_t OPENSSL_hash32(const void *ptr, size_t len) {
      .           // These are the FNV-1a parameters for 32 bits.
      .           static const uint32_t kPrime = 16777619u;
      .           static const uint32_t kOffsetBasis = 2166136261u;
      .         
      .           const uint8_t *in = ptr;
      .           uint32_t h = kOffsetBasis;
-- line 356 ----------------------------------------
-- line 387 ----------------------------------------
      .           OPENSSL_memcpy(ret, s, len);
      .           return ret;
      .         }
      .         
      .         int OPENSSL_isalpha(int c) {
      .           return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
      .         }
      .         
127,536 (0.0%)  int OPENSSL_isdigit(int c) { return c >= '0' && c <= '9'; }
      .         
      .         int OPENSSL_isxdigit(int c) {
      .           return OPENSSL_isdigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
      .         }
      .         
      .         int OPENSSL_fromxdigit(uint8_t *out, int c) {
      .           if (OPENSSL_isdigit(c)) {
      .             *out = c - '0';
-- line 403 ----------------------------------------
-- line 411 ----------------------------------------
      .             *out = c - 'A' + 10;
      .             return 1;
      .           }
      .           return 0;
      .         }
      .         
      .         int OPENSSL_isalnum(int c) { return OPENSSL_isalpha(c) || OPENSSL_isdigit(c); }
      .         
181,056 (0.0%)  int OPENSSL_tolower(int c) {
174,912 (0.0%)    if (c >= 'A' && c <= 'Z') {
 38,628 (0.0%)      return c + ('a' - 'A');
      .           }
 32,388 (0.0%)    return c;
 90,528 (0.0%)  }
      .         
244,944 (0.0%)  int OPENSSL_isspace(int c) {
800,886 (0.1%)    return c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r' ||
      .                  c == ' ';
122,472 (0.0%)  }
      .         
      .         int OPENSSL_strcasecmp(const char *a, const char *b) {
      .           for (size_t i = 0;; i++) {
      .             const int aa = OPENSSL_tolower(a[i]);
      .             const int bb = OPENSSL_tolower(b[i]);
      .         
      .             if (aa < bb) {
      .               return -1;
-- line 437 ----------------------------------------
-- line 542 ----------------------------------------
      .             return NULL;
      .           }
      .         
      .           OPENSSL_memcpy(ret, str, size);
      .           ret[size] = '\0';
      .           return ret;
      .         }
      .         
     21 (0.0%)  size_t OPENSSL_strlcpy(char *dst, const char *src, size_t dst_size) {
      3 (0.0%)    size_t l = 0;
      .         
    387 (0.0%)    for (; dst_size > 1 && *src; dst_size--) {
    432 (0.0%)      *dst++ = *src++;
     54 (0.0%)      l++;
      .           }
      .         
      6 (0.0%)    if (dst_size) {
      6 (0.0%)      *dst = 0;
      .           }
      .         
     15 (0.0%)    return l + strlen(src);
      6 (0.0%)  }
      .         
      .         size_t OPENSSL_strlcat(char *dst, const char *src, size_t dst_size) {
      .           size_t l = 0;
      .           for (; dst_size > 0 && *dst; dst_size--, dst++) {
      .             l++;
      .           }
      .           return l + OPENSSL_strlcpy(dst, src, dst_size);
      .         }
      .         
 63,756 (0.0%)  void *OPENSSL_memdup(const void *data, size_t size) {
 21,252 (0.0%)    if (size == 0) {
      .             return NULL;
      .           }
      .         
 42,504 (0.0%)    void *ret = OPENSSL_malloc(size);
 21,252 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
 63,756 (0.0%)    OPENSSL_memcpy(ret, data, size);
 10,626 (0.0%)    return ret;
 21,252 (0.0%)  }
      .         
      .         void *CRYPTO_malloc(size_t size, const char *file, int line) {
      .           return OPENSSL_malloc(size);
      .         }
      .         
      .         void *CRYPTO_realloc(void *ptr, size_t new_size, const char *file, int line) {
      .           return OPENSSL_realloc(ptr, new_size);
      .         }
-- line 593 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 97 ----------------------------------------
     .         
     .           CRYPTO_STATIC_MUTEX_lock_write(&global_next_nid_lock);
     .           ret = global_next_nid++;
     .           CRYPTO_STATIC_MUTEX_unlock_write(&global_next_nid_lock);
     .         
     .           return ret;
     .         }
     .         
46,495 (0.0%)  ASN1_OBJECT *OBJ_dup(const ASN1_OBJECT *o) {
     .           ASN1_OBJECT *r;
 9,299 (0.0%)    unsigned char *data = NULL;
18,598 (0.0%)    char *sn = NULL, *ln = NULL;
     .         
18,598 (0.0%)    if (o == NULL) {
     .             return NULL;
     .           }
     .         
46,495 (0.0%)    if (!(o->flags & ASN1_OBJECT_FLAG_DYNAMIC)) {
     .             // TODO(fork): this is a little dangerous.
     .             return (ASN1_OBJECT *)o;
     .           }
     .         
18,598 (0.0%)    r = ASN1_OBJECT_new();
18,598 (0.0%)    if (r == NULL) {
     .             OPENSSL_PUT_ERROR(OBJ, ERR_R_ASN1_LIB);
     .             return NULL;
     .           }
55,794 (0.0%)    r->ln = r->sn = NULL;
     .         
     .           // once data is attached to an object, it remains const
92,990 (0.0%)    r->data = OPENSSL_memdup(o->data, o->length);
74,392 (0.0%)    if (o->length != 0 && r->data == NULL) {
     .             goto err;
     .           }
     .         
37,196 (0.0%)    r->length = o->length;
37,196 (0.0%)    r->nid = o->nid;
     .         
37,196 (0.0%)    if (o->ln != NULL) {
     .             ln = OPENSSL_strdup(o->ln);
     .             if (ln == NULL) {
     .               goto err;
     .             }
     .           }
     .         
37,196 (0.0%)    if (o->sn != NULL) {
     .             sn = OPENSSL_strdup(o->sn);
     .             if (sn == NULL) {
     .               goto err;
     .             }
     .           }
     .         
27,897 (0.0%)    r->sn = sn;
27,897 (0.0%)    r->ln = ln;
     .         
18,598 (0.0%)    r->flags =
37,196 (0.0%)        o->flags | (ASN1_OBJECT_FLAG_DYNAMIC | ASN1_OBJECT_FLAG_DYNAMIC_STRINGS |
     .                           ASN1_OBJECT_FLAG_DYNAMIC_DATA);
18,598 (0.0%)    return r;
     .         
     .         err:
     .           OPENSSL_free(ln);
     .           OPENSSL_free(sn);
     .           OPENSSL_free(data);
     .           OPENSSL_free(r);
     .           return NULL;
18,598 (0.0%)  }
     .         
 4,464 (0.0%)  int OBJ_cmp(const ASN1_OBJECT *a, const ASN1_OBJECT *b) {
 4,464 (0.0%)    if (a->length < b->length) {
   412 (0.0%)      return -1;
 3,228 (0.0%)    } else if (a->length > b->length) {
    20 (0.0%)      return 1;
     .           }
 5,280 (0.0%)    return OPENSSL_memcmp(a->data, b->data, a->length);
 1,488 (0.0%)  }
     .         
     .         const uint8_t *OBJ_get0_data(const ASN1_OBJECT *obj) {
     .           if (obj == NULL) {
     .             return NULL;
     .           }
     .         
     .           return obj->data;
     .         }
-- line 180 ----------------------------------------
-- line 182 ----------------------------------------
     .         size_t OBJ_length(const ASN1_OBJECT *obj) {
     .           if (obj == NULL || obj->length < 0) {
     .             return 0;
     .           }
     .         
     .           return (size_t)obj->length;
     .         }
     .         
 4,075 (0.0%)  static const ASN1_OBJECT *get_builtin_object(int nid) {
     .           // |NID_undef| is stored separately, so all the indices are off by one. The
     .           // caller of this function must have a valid built-in, non-undef NID.
 3,260 (0.0%)    BSSL_CHECK(nid > 0 && nid < NUM_NID);
 7,335 (0.0%)    return &kObjects[nid - 1];
 1,630 (0.0%)  }
     .         
     .         // obj_cmp is called to search the kNIDsInOIDOrder array. The |key| argument is
     .         // an |ASN1_OBJECT|* that we're looking for and |element| is a pointer to an
     .         // unsigned int in the array.
 4,428 (0.0%)  static int obj_cmp(const void *key, const void *element) {
 2,214 (0.0%)    uint16_t nid = *((const uint16_t *)element);
 5,904 (0.0%)    return OBJ_cmp(key, get_builtin_object(nid));
 1,476 (0.0%)  }
     .         
   375 (0.0%)  int OBJ_obj2nid(const ASN1_OBJECT *obj) {
   150 (0.0%)    if (obj == NULL) {
     .             return NID_undef;
     .           }
     .         
   300 (0.0%)    if (obj->nid != 0) {
     .             return obj->nid;
     .           }
     .         
   225 (0.0%)    CRYPTO_STATIC_MUTEX_lock_read(&global_added_lock);
   225 (0.0%)    if (global_added_by_data != NULL) {
     .             ASN1_OBJECT *match;
     .         
     .             match = lh_ASN1_OBJECT_retrieve(global_added_by_data, obj);
     .             if (match != NULL) {
     .               CRYPTO_STATIC_MUTEX_unlock_read(&global_added_lock);
     .               return match->nid;
     .             }
     .           }
   225 (0.0%)    CRYPTO_STATIC_MUTEX_unlock_read(&global_added_lock);
     .         
     .           const uint16_t *nid_ptr =
   600 (0.0%)        bsearch(obj, kNIDsInOIDOrder, OPENSSL_ARRAY_SIZE(kNIDsInOIDOrder),
     .                       sizeof(kNIDsInOIDOrder[0]), obj_cmp);
   150 (0.0%)    if (nid_ptr == NULL) {
     .             return NID_undef;
     .           }
     .         
   450 (0.0%)    return get_builtin_object(*nid_ptr)->nid;
   150 (0.0%)  }
     .         
     .         int OBJ_cbs2nid(const CBS *cbs) {
     .           if (CBS_len(cbs) > INT_MAX) {
     .             return NID_undef;
     .           }
     .         
     .           ASN1_OBJECT obj;
     .           OPENSSL_memset(&obj, 0, sizeof(obj));
-- line 242 ----------------------------------------
-- line 334 ----------------------------------------
     .               !CBB_add_bytes(&oid, obj->data, obj->length) ||
     .               !CBB_flush(out)) {
     .             return 0;
     .           }
     .         
     .           return 1;
     .         }
     .         
27,531 (0.0%)  const ASN1_OBJECT *OBJ_get_undef(void) {
     .           static const ASN1_OBJECT kUndef = {
     .               /*sn=*/SN_undef,
     .               /*ln=*/LN_undef,
     .               /*nid=*/NID_undef,
     .               /*length=*/0,
     .               /*data=*/NULL,
     .               /*flags=*/0,
     .           };
 9,177 (0.0%)    return &kUndef;
18,354 (0.0%)  }
     .         
    16 (0.0%)  ASN1_OBJECT *OBJ_nid2obj(int nid) {
     4 (0.0%)    if (nid == NID_undef) {
     .             return (ASN1_OBJECT *)OBJ_get_undef();
     .           }
     .         
     8 (0.0%)    if (nid > 0 && nid < NUM_NID) {
     8 (0.0%)      const ASN1_OBJECT *obj = get_builtin_object(nid);
    12 (0.0%)      if (nid != NID_undef && obj->nid == NID_undef) {
     .               goto err;
     .             }
     4 (0.0%)      return (ASN1_OBJECT *)obj;
     .           }
     .         
     .           CRYPTO_STATIC_MUTEX_lock_read(&global_added_lock);
     .           if (global_added_by_nid != NULL) {
     .             ASN1_OBJECT *match, template;
     .         
     .             template.nid = nid;
     .             match = lh_ASN1_OBJECT_retrieve(global_added_by_nid, &template);
-- line 372 ----------------------------------------
-- line 375 ----------------------------------------
     .               return match;
     .             }
     .           }
     .           CRYPTO_STATIC_MUTEX_unlock_read(&global_added_lock);
     .         
     .         err:
     .           OPENSSL_PUT_ERROR(OBJ, OBJ_R_UNKNOWN_NID);
     .           return NULL;
    10 (0.0%)  }
     .         
     .         const char *OBJ_nid2sn(int nid) {
     .           const ASN1_OBJECT *obj = OBJ_nid2obj(nid);
     .           if (obj == NULL) {
     .             return NULL;
     .           }
     .         
     .           return obj->sn;
-- line 391 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/pem/pem_lib.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 369 ----------------------------------------
      .           OPENSSL_cleanse(iv, sizeof(iv));
      .           OPENSSL_cleanse((char *)&ctx, sizeof(ctx));
      .           OPENSSL_cleanse(buf, PEM_BUFSIZE);
      .           OPENSSL_free(data);
      .           return ret;
      .         }
      .         
      .         int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,
  6,132 (0.0%)                    pem_password_cb *callback, void *u) {
    438 (0.0%)    int i = 0, j, o, klen;
      .           long len;
      .           EVP_CIPHER_CTX ctx;
      .           unsigned char key[EVP_MAX_KEY_LENGTH];
      .           char buf[PEM_BUFSIZE];
      .         
  1,314 (0.0%)    len = *plen;
      .         
  1,752 (0.0%)    if (cipher->cipher == NULL) {
    876 (0.0%)      return 1;
      .           }
      .         
      .           klen = 0;
      .           if (!callback) {
      .             callback = PEM_def_callback;
      .           }
      .           klen = callback(buf, PEM_BUFSIZE, 0, u);
      .           if (klen <= 0) {
-- line 395 ----------------------------------------
-- line 416 ----------------------------------------
      .           OPENSSL_cleanse((char *)key, sizeof(key));
      .           if (!o) {
      .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_DECRYPT);
      .             return 0;
      .           }
      .           j += i;
      .           *plen = j;
      .           return 1;
  3,504 (0.0%)  }
      .         
  2,628 (0.0%)  int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher) {
    438 (0.0%)    const EVP_CIPHER *enc = NULL;
      .           char *p, c;
    876 (0.0%)    char **header_pp = &header;
      .         
    876 (0.0%)    cipher->cipher = NULL;
  2,628 (0.0%)    OPENSSL_memset(cipher->iv, 0, sizeof(cipher->iv));
  3,066 (0.0%)    if ((header == NULL) || (*header == '\0') || (*header == '\n')) {
    876 (0.0%)      return 1;
      .           }
      .           if (strncmp(header, "Proc-Type: ", 11) != 0) {
      .             OPENSSL_PUT_ERROR(PEM, PEM_R_NOT_PROC_TYPE);
      .             return 0;
      .           }
      .           header += 11;
      .           if (*header != '4') {
      .             return 0;
-- line 442 ----------------------------------------
-- line 489 ----------------------------------------
      .             OPENSSL_PUT_ERROR(PEM, PEM_R_UNSUPPORTED_ENCRYPTION);
      .             return 0;
      .           }
      .           if (!load_iv(header_pp, &(cipher->iv[0]), EVP_CIPHER_iv_length(enc))) {
      .             return 0;
      .           }
      .         
      .           return 1;
    876 (0.0%)  }
      .         
      .         static int load_iv(char **fromp, unsigned char *to, size_t num) {
      .           uint8_t v;
      .           char *from;
      .         
      .           from = *fromp;
      .           for (size_t i = 0; i < num; i++) {
      .             to[i] = 0;
-- line 505 ----------------------------------------
-- line 599 ----------------------------------------
      .             return 0;
      .           }
      .           int ret = PEM_read_bio(b, name, header, data, len);
      .           BIO_free(b);
      .           return ret;
      .         }
      .         
      .         int PEM_read_bio(BIO *bp, char **name, char **header, unsigned char **data,
  5,292 (0.0%)                   long *len) {
      .           EVP_ENCODE_CTX ctx;
  1,764 (0.0%)    int end = 0, i, k, bl = 0, hl = 0, nohead = 0;
      .           char buf[256];
      .           BUF_MEM *nameB;
      .           BUF_MEM *headerB;
      .           BUF_MEM *dataB, *tmpB;
      .         
    882 (0.0%)    nameB = BUF_MEM_new();
    882 (0.0%)    headerB = BUF_MEM_new();
    882 (0.0%)    dataB = BUF_MEM_new();
  2,646 (0.0%)    if ((nameB == NULL) || (headerB == NULL) || (dataB == NULL)) {
      .             BUF_MEM_free(nameB);
      .             BUF_MEM_free(headerB);
      .             BUF_MEM_free(dataB);
      .             return 0;
      .           }
      .         
    441 (0.0%)    buf[254] = '\0';
      .           for (;;) {
  3,087 (0.0%)      i = BIO_gets(bp, buf, 254);
      .         
    882 (0.0%)      if (i <= 0) {
     21 (0.0%)        OPENSSL_PUT_ERROR(PEM, PEM_R_NO_START_LINE);
      3 (0.0%)        goto err;
      .             }
      .         
  9,198 (0.0%)      while ((i >= 0) && (buf[i] <= ' ')) {
    876 (0.0%)        i--;
      .             }
  1,752 (0.0%)      buf[++i] = '\n';
  1,752 (0.0%)      buf[++i] = '\0';
      .         
  3,504 (0.0%)      if (strncmp(buf, "-----BEGIN ", 11) == 0) {
  2,190 (0.0%)        i = strlen(&(buf[11]));
      .         
  5,256 (0.0%)        if (strncmp(&(buf[11 + i - 6]), "-----\n", 6) != 0) {
      .                 continue;
      .               }
  3,942 (0.0%)        if (!BUF_MEM_grow(nameB, i + 9)) {
      .                 goto err;
      .               }
  4,380 (0.0%)        OPENSSL_memcpy(nameB->data, &(buf[11]), i - 6);
  3,066 (0.0%)        nameB->data[i - 6] = '\0';
    438 (0.0%)        break;
      .             }
      .           }
    438 (0.0%)    hl = 0;
  2,628 (0.0%)    if (!BUF_MEM_grow(headerB, 256)) {
      .             goto err;
      .           }
  1,314 (0.0%)    headerB->data[0] = '\0';
      .           for (;;) {
 82,698 (0.0%)      i = BIO_gets(bp, buf, 254);
 20,784 (0.0%)      if (i <= 0) {
      .               break;
      .             }
      .         
228,624 (0.0%)      while ((i >= 0) && (buf[i] <= ' ')) {
 20,784 (0.0%)        i--;
      .             }
 41,568 (0.0%)      buf[++i] = '\n';
 41,568 (0.0%)      buf[++i] = '\0';
      .         
 31,176 (0.0%)      if (buf[0] == '\n') {
      .               break;
      .             }
114,312 (0.0%)      if (!BUF_MEM_grow(headerB, hl + i + 9)) {
      .               goto err;
      .             }
 83,136 (0.0%)      if (strncmp(buf, "-----END ", 9) == 0) {
    438 (0.0%)        nohead = 1;
    438 (0.0%)        break;
      .             }
109,494 (0.0%)      OPENSSL_memcpy(&(headerB->data[hl]), buf, i);
 79,632 (0.0%)      headerB->data[hl + i] = '\0';
 19,908 (0.0%)      hl += i;
      .           }
      .         
    438 (0.0%)    bl = 0;
  2,628 (0.0%)    if (!BUF_MEM_grow(dataB, 1024)) {
      .             goto err;
      .           }
  1,314 (0.0%)    dataB->data[0] = '\0';
    876 (0.0%)    if (!nohead) {
      .             for (;;) {
      .               i = BIO_gets(bp, buf, 254);
      .               if (i <= 0) {
      .                 break;
      .               }
      .         
      .               while ((i >= 0) && (buf[i] <= ' ')) {
      .                 i--;
-- line 699 ----------------------------------------
-- line 728 ----------------------------------------
      .                 }
      .                 buf[++i] = '\n';
      .                 buf[++i] = '\0';
      .         
      .                 break;
      .               }
      .             }
      .           } else {
    876 (0.0%)      tmpB = headerB;
    876 (0.0%)      headerB = dataB;
    876 (0.0%)      dataB = tmpB;
  1,314 (0.0%)      bl = hl;
      .           }
  2,190 (0.0%)    i = strlen(nameB->data);
  4,380 (0.0%)    if ((strncmp(buf, "-----END ", 9) != 0) ||
  4,818 (0.0%)        (strncmp(nameB->data, &(buf[9]), i) != 0) ||
  4,380 (0.0%)        (strncmp(&(buf[9 + i]), "-----\n", 6) != 0)) {
      .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_END_LINE);
      .             goto err;
      .           }
      .         
  1,314 (0.0%)    EVP_DecodeInit(&ctx);
  4,380 (0.0%)    i = EVP_DecodeUpdate(&ctx, (unsigned char *)dataB->data, &bl,
    876 (0.0%)                         (unsigned char *)dataB->data, bl);
    876 (0.0%)    if (i < 0) {
      .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_BASE64_DECODE);
      .             goto err;
      .           }
  4,818 (0.0%)    i = EVP_DecodeFinal(&ctx, (unsigned char *)&(dataB->data[bl]), &k);
    876 (0.0%)    if (i < 0) {
      .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_BASE64_DECODE);
      .             goto err;
      .           }
  1,752 (0.0%)    bl += k;
      .         
  1,314 (0.0%)    if (bl == 0) {
      .             goto err;
      .           }
  1,752 (0.0%)    *name = nameB->data;
  1,752 (0.0%)    *header = headerB->data;
  1,752 (0.0%)    *data = (unsigned char *)dataB->data;
  1,752 (0.0%)    *len = bl;
  1,314 (0.0%)    OPENSSL_free(nameB);
  1,314 (0.0%)    OPENSSL_free(headerB);
  1,314 (0.0%)    OPENSSL_free(dataB);
    876 (0.0%)    return 1;
      .         err:
      9 (0.0%)    BUF_MEM_free(nameB);
      9 (0.0%)    BUF_MEM_free(headerB);
      9 (0.0%)    BUF_MEM_free(dataB);
      3 (0.0%)    return 0;
  2,205 (0.0%)  }
      .         
      .         int PEM_def_callback(char *buf, int size, int rwflag, void *userdata) {
      .           if (!buf || !userdata || size < 0) {
      .             return 0;
      .           }
      .           size_t len = strlen((char *)userdata);
      .           if (len >= (size_t)size) {
      .             return 0;
-- line 787 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/stack/stack.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 78 ----------------------------------------
      .           // comp is an optional comparison function.
      .           OPENSSL_sk_cmp_func comp;
      .         };
      .         
      .         // kMinSize is the number of pointers that will be initially allocated in a new
      .         // stack.
      .         static const size_t kMinSize = 4;
      .         
 51,695 (0.0%)  OPENSSL_STACK *OPENSSL_sk_new(OPENSSL_sk_cmp_func comp) {
 31,017 (0.0%)    OPENSSL_STACK *ret = OPENSSL_zalloc(sizeof(OPENSSL_STACK));
 20,678 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
 62,034 (0.0%)    ret->data = OPENSSL_calloc(kMinSize, sizeof(void *));
 41,356 (0.0%)    if (ret->data == NULL) {
      .             goto err;
      .           }
      .         
 31,017 (0.0%)    ret->comp = comp;
 31,017 (0.0%)    ret->num_alloc = kMinSize;
      .         
 20,678 (0.0%)    return ret;
      .         
      .         err:
      .           OPENSSL_free(ret);
      .           return NULL;
 20,678 (0.0%)  }
      .         
 72,331 (0.0%)  OPENSSL_STACK *OPENSSL_sk_new_null(void) { return OPENSSL_sk_new(NULL); }
      .         
196,424 (0.0%)  size_t OPENSSL_sk_num(const OPENSSL_STACK *sk) {
 98,212 (0.0%)    if (sk == NULL) {
  1,776 (0.0%)      return 0;
      .           }
 96,436 (0.0%)    return sk->num;
 98,212 (0.0%)  }
      .         
      .         void OPENSSL_sk_zero(OPENSSL_STACK *sk) {
      .           if (sk == NULL || sk->num == 0) {
      .             return;
      .           }
      .           OPENSSL_memset(sk->data, 0, sizeof(void*) * sk->num);
      .           sk->num = 0;
      .           sk->sorted = 0;
      .         }
      .         
137,410 (0.0%)  void *OPENSSL_sk_value(const OPENSSL_STACK *sk, size_t i) {
164,892 (0.0%)    if (!sk || i >= sk->num) {
      .             return NULL;
      .           }
164,892 (0.0%)    return sk->data[i];
 54,964 (0.0%)  }
      .         
 19,014 (0.0%)  void *OPENSSL_sk_set(OPENSSL_STACK *sk, size_t i, void *value) {
 19,014 (0.0%)    if (!sk || i >= sk->num) {
      .             return NULL;
      .           }
 25,352 (0.0%)    return sk->data[i] = value;
  6,338 (0.0%)  }
      .         
 56,105 (0.0%)  void OPENSSL_sk_free(OPENSSL_STACK *sk) {
 22,442 (0.0%)    if (sk == NULL) {
    880 (0.0%)      return;
      .           }
 41,364 (0.0%)    OPENSSL_free(sk->data);
 41,364 (0.0%)    OPENSSL_free(sk);
 22,442 (0.0%)  }
      .         
      .         void OPENSSL_sk_pop_free_ex(OPENSSL_STACK *sk,
      .                                     OPENSSL_sk_call_free_func call_free_func,
 47,159 (0.0%)                              OPENSSL_sk_free_func free_func) {
 13,474 (0.0%)    if (sk == NULL) {
     10 (0.0%)      return;
      .           }
      .         
108,317 (0.0%)    for (size_t i = 0; i < sk->num; i++) {
108,728 (0.0%)      if (sk->data[i] != NULL) {
149,501 (0.0%)        call_free_func(free_func, sk->data[i]);
      .             }
      .           }
 26,908 (0.0%)    OPENSSL_sk_free(sk);
 13,474 (0.0%)  }
      .         
      .         // Historically, |sk_pop_free| called the function as |OPENSSL_sk_free_func|
      .         // directly. This is undefined in C. Some callers called |sk_pop_free| directly,
      .         // so we must maintain a compatibility version for now.
      .         static void call_free_func_legacy(OPENSSL_sk_free_func func, void *ptr) {
      .           func(ptr);
      .         }
      .         
      .         void sk_pop_free(OPENSSL_STACK *sk, OPENSSL_sk_free_func free_func) {
      .           OPENSSL_sk_pop_free_ex(sk, call_free_func_legacy, free_func);
      .         }
      .         
127,960 (0.0%)  size_t OPENSSL_sk_insert(OPENSSL_STACK *sk, void *p, size_t where) {
 36,560 (0.0%)    if (sk == NULL) {
      .             return 0;
      .           }
      .         
 73,120 (0.0%)    if (sk->num >= INT_MAX) {
      .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
      .             return 0;
      .           }
      .         
127,960 (0.0%)    if (sk->num_alloc <= sk->num + 1) {
      .             // Attempt to double the size of the array.
  5,044 (0.0%)      size_t new_alloc = sk->num_alloc << 1;
  3,783 (0.0%)      size_t alloc_size = new_alloc * sizeof(void *);
      .             void **data;
      .         
      .             // If the doubling overflowed, try to increment.
 10,088 (0.0%)      if (new_alloc < sk->num_alloc || alloc_size / sizeof(void *) != new_alloc) {
      .               new_alloc = sk->num_alloc + 1;
      .               alloc_size = new_alloc * sizeof(void *);
      .             }
      .         
      .             // If the increment also overflowed, fail.
 10,088 (0.0%)      if (new_alloc < sk->num_alloc || alloc_size / sizeof(void *) != new_alloc) {
      .               return 0;
      .             }
      .         
  8,827 (0.0%)      data = OPENSSL_realloc(sk->data, alloc_size);
  2,522 (0.0%)      if (data == NULL) {
      .               return 0;
      .             }
      .         
  3,783 (0.0%)      sk->data = data;
  3,783 (0.0%)      sk->num_alloc = new_alloc;
      .           }
      .         
 73,120 (0.0%)    if (where >= sk->num) {
164,520 (0.0%)      sk->data[sk->num] = p;
      .           } else {
      .             OPENSSL_memmove(&sk->data[where + 1], &sk->data[where],
      .                             sizeof(void *) * (sk->num - where));
      .             sk->data[where] = p;
      .           }
      .         
 91,400 (0.0%)    sk->num++;
 36,560 (0.0%)    sk->sorted = 0;
      .         
 36,560 (0.0%)    return sk->num;
 36,560 (0.0%)  }
      .         
      .         void *OPENSSL_sk_delete(OPENSSL_STACK *sk, size_t where) {
      .           void *ret;
      .         
      .           if (!sk || where >= sk->num) {
      .             return NULL;
      .           }
      .         
-- line 229 ----------------------------------------
-- line 265 ----------------------------------------
      .               sk->data[new_num] = sk->data[i];
      .               new_num++;
      .             }
      .           }
      .           sk->num = new_num;
      .         }
      .         
      .         int OPENSSL_sk_find(const OPENSSL_STACK *sk, size_t *out_index, const void *p,
  3,552 (0.0%)                      OPENSSL_sk_call_cmp_func call_cmp_func) {
    888 (0.0%)    if (sk == NULL) {
      .             return 0;
      .           }
      .         
  1,776 (0.0%)    if (sk->comp == NULL) {
      .             // Use pointer equality when no comparison function has been set.
      .             for (size_t i = 0; i < sk->num; i++) {
      .               if (sk->data[i] == p) {
      .                 if (out_index) {
      .                   *out_index = i;
      .                 }
      .                 return 1;
      .               }
      .             }
      .             return 0;
      .           }
      .         
    888 (0.0%)    if (p == NULL) {
      .             return 0;
      .           }
      .         
  2,220 (0.0%)    if (!OPENSSL_sk_is_sorted(sk)) {
      .             for (size_t i = 0; i < sk->num; i++) {
      .               if (call_cmp_func(sk->comp, p, sk->data[i]) == 0) {
      .                 if (out_index) {
      .                   *out_index = i;
      .                 }
      .                 return 1;
      .               }
      .             }
      .             return 0;
      .           }
      .         
      .           // The stack is sorted, so binary search to find the element.
      .           //
      .           // |lo| and |hi| maintain a half-open interval of where the answer may be. All
      .           // indices such that |lo <= idx < hi| are candidates.
  1,776 (0.0%)    size_t lo = 0, hi = sk->num;
  9,516 (0.0%)    while (lo < hi) {
      .             // Bias |mid| towards |lo|. See the |r == 0| case below.
 20,680 (0.0%)      size_t mid = lo + (hi - lo - 1) / 2;
 15,510 (0.0%)      assert(lo <= mid && mid < hi);
 36,190 (0.0%)      int r = call_cmp_func(sk->comp, p, sk->data[mid]);
  5,170 (0.0%)      if (r > 0) {
  5,736 (0.0%)        lo = mid + 1;  // |mid| is too low.
  2,302 (0.0%)      } else if (r < 0) {
  3,423 (0.0%)        hi = mid;  // |mid| is too high.
      .             } else {
      .               // |mid| matches. However, this function returns the earliest match, so we
      .               // can only return if the range has size one.
     40 (0.0%)        if (hi - lo == 1) {
     10 (0.0%)          if (out_index != NULL) {
     15 (0.0%)            *out_index = mid;
      .                 }
     10 (0.0%)          return 1;
      .               }
      .               // The sample is biased towards |lo|. |mid| can only be |hi - 1| if
      .               // |hi - lo| was one, so this makes forward progress.
     20 (0.0%)        assert(mid + 1 < hi);
     15 (0.0%)        hi = mid + 1;
      .             }
      .           }
      .         
  1,317 (0.0%)    assert(lo == hi);
    439 (0.0%)    return 0;  // Not found.
    888 (0.0%)  }
      .         
      .         int OPENSSL_sk_unshift(OPENSSL_STACK *sk, void *data) {
      .             return (int)OPENSSL_sk_insert(sk, data, 0);
      .         }
      .         
      .         void *OPENSSL_sk_shift(OPENSSL_STACK *sk) {
      .           if (sk == NULL) {
      .             return NULL;
      .           }
      .           if (sk->num == 0) {
      .             return NULL;
      .           }
      .           return OPENSSL_sk_delete(sk, 0);
      .         }
      .         
109,680 (0.0%)  size_t OPENSSL_sk_push(OPENSSL_STACK *sk, void *p) {
127,960 (0.0%)    return OPENSSL_sk_insert(sk, p, sk->num);
 36,560 (0.0%)  }
      .         
      .         void *OPENSSL_sk_pop(OPENSSL_STACK *sk) {
      .           if (sk == NULL) {
      .             return NULL;
      .           }
      .           if (sk->num == 0) {
      .             return NULL;
      .           }
      .           return OPENSSL_sk_delete(sk, sk->num - 1);
      .         }
      .         
     10 (0.0%)  OPENSSL_STACK *OPENSSL_sk_dup(const OPENSSL_STACK *sk) {
      4 (0.0%)    if (sk == NULL) {
      .             return NULL;
      .           }
      .         
      6 (0.0%)    OPENSSL_STACK *ret = OPENSSL_zalloc(sizeof(OPENSSL_STACK));
      4 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
     20 (0.0%)    ret->data = OPENSSL_memdup(sk->data, sizeof(void *) * sk->num_alloc);
      8 (0.0%)    if (ret->data == NULL) {
      .             goto err;
      .           }
      .         
      8 (0.0%)    ret->num = sk->num;
      8 (0.0%)    ret->sorted = sk->sorted;
      8 (0.0%)    ret->num_alloc = sk->num_alloc;
      8 (0.0%)    ret->comp = sk->comp;
      4 (0.0%)    return ret;
      .         
      .         err:
      .           OPENSSL_sk_free(ret);
      .           return NULL;
      4 (0.0%)  }
      .         
      .         #if defined(_MSC_VER)
      .         struct sort_compare_ctx {
      .           OPENSSL_sk_call_cmp_func call_cmp_func;
      .           OPENSSL_sk_cmp_func cmp_func;
      .         };
      .         
      .         static int sort_compare(void *ctx_v, const void *a, const void *b) {
-- line 401 ----------------------------------------
-- line 403 ----------------------------------------
      .           // |a| and |b| point to |void*| pointers which contain the actual values.
      .           const void *const *a_ptr = a;
      .           const void *const *b_ptr = b;
      .           return ctx->call_cmp_func(ctx->cmp_func, *a_ptr, *b_ptr);
      .         }
      .         #endif
      .         
      .         void OPENSSL_sk_sort(OPENSSL_STACK *sk,
  2,664 (0.0%)                       OPENSSL_sk_call_cmp_func call_cmp_func) {
  4,440 (0.0%)    if (sk == NULL || sk->comp == NULL || sk->sorted) {
      4 (0.0%)      return;
      .           }
      .         
  1,760 (0.0%)    if (sk->num >= 2) {
      .         #if defined(_MSC_VER)
      .             // MSVC's |qsort_s| is different from the C11 one.
      .             // https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/qsort-s?view=msvc-170
      .             struct sort_compare_ctx ctx = {call_cmp_func, sk->comp};
      .             qsort_s(sk->data, sk->num, sizeof(void *), sort_compare, &ctx);
      .         #else
      .             // sk->comp is a function that takes pointers to pointers to elements, but
      .             // qsort take a comparison function that just takes pointers to elements.
      .             // However, since we're passing an array of pointers to qsort, we can just
      .             // cast the comparison function and everything works.
      .             //
      .             // TODO(davidben): This is undefined behavior, but the call is in libc so,
      .             // e.g., CFI does not notice. |qsort| is missing a void* parameter in its
      .             // callback, while no one defines |qsort_r| or |qsort_s| consistently. See
      .             // https://stackoverflow.com/a/39561369
  1,302 (0.0%)      int (*comp_func)(const void *, const void *) =
      .                 (int (*)(const void *, const void *))(sk->comp);
  3,906 (0.0%)      qsort(sk->data, sk->num, sizeof(void *), comp_func);
      .         #endif
      .           }
  1,320 (0.0%)    sk->sorted = 1;
    888 (0.0%)  }
      .         
  1,776 (0.0%)  int OPENSSL_sk_is_sorted(const OPENSSL_STACK *sk) {
    888 (0.0%)    if (!sk) {
      .             return 1;
      .           }
      .           // Zero- and one-element lists are always sorted.
  2,664 (0.0%)    return sk->sorted || (sk->comp != NULL && sk->num < 2);
    888 (0.0%)  }
      .         
      .         OPENSSL_sk_cmp_func OPENSSL_sk_set_cmp_func(OPENSSL_STACK *sk,
      .                                                     OPENSSL_sk_cmp_func comp) {
      .           OPENSSL_sk_cmp_func old = sk->comp;
      .         
      .           if (sk->comp != comp) {
      .             sk->sorted = 0;
      .           }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 69 ----------------------------------------
      .         #include "../internal.h"
      .         #include "internal.h"
      .         
      .         
      .         int X509_issuer_name_cmp(const X509 *a, const X509 *b) {
      .           return (X509_NAME_cmp(a->cert_info->issuer, b->cert_info->issuer));
      .         }
      .         
623,310 (0.1%)  int X509_subject_name_cmp(const X509 *a, const X509 *b) {
934,965 (0.1%)    return (X509_NAME_cmp(a->cert_info->subject, b->cert_info->subject));
207,770 (0.0%)  }
      .         
      .         int X509_CRL_cmp(const X509_CRL *a, const X509_CRL *b) {
      .           return (X509_NAME_cmp(a->crl->issuer, b->crl->issuer));
      .         }
      .         
      .         int X509_CRL_match(const X509_CRL *a, const X509_CRL *b) {
      .           return OPENSSL_memcmp(a->crl_hash, b->crl_hash, SHA256_DIGEST_LENGTH);
      .         }
      .         
     52 (0.0%)  X509_NAME *X509_get_issuer_name(const X509 *a) {
     39 (0.0%)    return a->cert_info->issuer;
     26 (0.0%)  }
      .         
      .         uint32_t X509_issuer_name_hash(X509 *x) {
      .           return X509_NAME_hash(x->cert_info->issuer);
      .         }
      .         
      .         uint32_t X509_issuer_name_hash_old(X509 *x) {
      .           return (X509_NAME_hash_old(x->cert_info->issuer));
      .         }
      .         
     68 (0.0%)  X509_NAME *X509_get_subject_name(const X509 *a) {
     51 (0.0%)    return a->cert_info->subject;
     34 (0.0%)  }
      .         
      .         ASN1_INTEGER *X509_get_serialNumber(X509 *a) {
      .           return a->cert_info->serialNumber;
      .         }
      .         
      .         const ASN1_INTEGER *X509_get0_serialNumber(const X509 *x509) {
      .           return x509->cert_info->serialNumber;
      .         }
-- line 111 ----------------------------------------
-- line 119 ----------------------------------------
      .         }
      .         
      .         // Compare two certificates: they must be identical for this to work. NB:
      .         // Although "cmp" operations are generally prototyped to take "const"
      .         // arguments (eg. for use in STACKs), the way X509 handling is - these
      .         // operations may involve ensuring the hashes are up-to-date and ensuring
      .         // certain cert information is cached. So this is the point where the
      .         // "depth-first" constification tree has to halt with an evil cast.
      6 (0.0%)  int X509_cmp(const X509 *a, const X509 *b) {
      .           // Fill in the |cert_hash| fields.
      .           //
      .           // TODO(davidben): This may fail, in which case the the hash will be all
      .           // zeros. This produces a consistent comparison (failures are sticky), but
      .           // not a good one. OpenSSL now returns -2, but this is not a consistent
      .           // comparison and may cause misbehaving sorts by transitivity. For now, we
      .           // retain the old OpenSSL behavior, which was to ignore the error. See
      .           // https://crbug.com/boringssl/355.
      3 (0.0%)    x509v3_cache_extensions((X509 *)a);
      3 (0.0%)    x509v3_cache_extensions((X509 *)b);
      .         
      8 (0.0%)    return OPENSSL_memcmp(a->cert_hash, b->cert_hash, SHA256_DIGEST_LENGTH);
      2 (0.0%)  }
      .         
623,400 (0.1%)  int X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b) {
      .           int ret;
      .         
      .           // Ensure canonical encoding is present and up to date
      .         
831,200 (0.1%)    if (!a->canon_enc || a->modified) {
      .             ret = i2d_X509_NAME((X509_NAME *)a, NULL);
      .             if (ret < 0) {
      .               return -2;
      .             }
      .           }
      .         
831,200 (0.1%)    if (!b->canon_enc || b->modified) {
      .             ret = i2d_X509_NAME((X509_NAME *)b, NULL);
      .             if (ret < 0) {
      .               return -2;
      .             }
      .           }
      .         
623,400 (0.1%)    ret = a->canon_enclen - b->canon_enclen;
      .         
207,800 (0.0%)    if (ret) {
167,718 (0.0%)      return ret;
      .           }
      .         
200,410 (0.0%)    return OPENSSL_memcmp(a->canon_enc, b->canon_enc, a->canon_enclen);
207,800 (0.0%)  }
      .         
      .         uint32_t X509_NAME_hash(X509_NAME *x) {
      .           // Make sure the X509_NAME structure contains a valid cached encoding.
      .           if (i2d_X509_NAME(x, NULL) < 0) {
      .             return 0;
      .           }
      .         
      .           uint8_t md[SHA_DIGEST_LENGTH];
-- line 176 ----------------------------------------
-- line 220 ----------------------------------------
      .         
      .         EVP_PKEY *X509_get0_pubkey(const X509 *x) {
      .           if (x == NULL) {
      .             return NULL;
      .           }
      .           return X509_PUBKEY_get0(x->cert_info->key);
      .         }
      .         
     25 (0.0%)  EVP_PKEY *X509_get_pubkey(const X509 *x) {
     10 (0.0%)    if (x == NULL) {
      .             return NULL;
      .           }
     25 (0.0%)    return X509_PUBKEY_get(x->cert_info->key);
     10 (0.0%)  }
      .         
      .         ASN1_BIT_STRING *X509_get0_pubkey_bitstr(const X509 *x) {
      .           if (!x) {
      .             return NULL;
      .           }
      .           return x->cert_info->key->public_key;
      .         }
      .         
-- line 241 ----------------------------------------
-- line 263 ----------------------------------------
      .           }
      .         
      .           return 0;
      .         }
      .         
      .         // Not strictly speaking an "up_ref" as a STACK doesn't have a reference
      .         // count but it has the same effect by duping the STACK and upping the ref of
      .         // each X509 structure.
      5 (0.0%)  STACK_OF(X509) *X509_chain_up_ref(STACK_OF(X509) *chain) {
      4 (0.0%)    STACK_OF(X509) *ret = sk_X509_dup(chain);
      2 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
     13 (0.0%)    for (size_t i = 0; i < sk_X509_num(ret); i++) {
      7 (0.0%)      X509_up_ref(sk_X509_value(ret, i));
      .           }
      1 (0.0%)    return ret;
      2 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 74 ----------------------------------------
      .         static int X509_OBJECT_up_ref_count(X509_OBJECT *a);
      .         
      .         static X509_LOOKUP *X509_LOOKUP_new(const X509_LOOKUP_METHOD *method,
      .                                             X509_STORE *store);
      .         static int X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,
      .                                           X509_OBJECT *ret);
      .         
      .         static X509_LOOKUP *X509_LOOKUP_new(const X509_LOOKUP_METHOD *method,
     36 (0.0%)                                      X509_STORE *store) {
     18 (0.0%)    X509_LOOKUP *ret = OPENSSL_zalloc(sizeof(X509_LOOKUP));
     12 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
     18 (0.0%)    ret->method = method;
     18 (0.0%)    ret->store_ctx = store;
     45 (0.0%)    if ((method->new_item != NULL) && !method->new_item(ret)) {
      .             OPENSSL_free(ret);
      .             return NULL;
      .           }
      6 (0.0%)    return ret;
     12 (0.0%)  }
      .         
     30 (0.0%)  void X509_LOOKUP_free(X509_LOOKUP *ctx) {
     12 (0.0%)    if (ctx == NULL) {
      .             return;
      .           }
     54 (0.0%)    if (ctx->method != NULL && ctx->method->free != NULL) {
     18 (0.0%)      (*ctx->method->free)(ctx);
      .           }
     24 (0.0%)    OPENSSL_free(ctx);
     12 (0.0%)  }
      .         
      .         int X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc, long argl,
     54 (0.0%)                       char **ret) {
     24 (0.0%)    if (ctx->method == NULL) {
      .             return -1;
      .           }
     30 (0.0%)    if (ctx->method->ctrl != NULL) {
     72 (0.0%)      return ctx->method->ctrl(ctx, cmd, argc, argl, ret);
      .           } else {
      .             return 1;
      .           }
     12 (0.0%)  }
      .         
      .         static int X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,
      .                                           X509_OBJECT *ret) {
      .           if (ctx->method == NULL || ctx->method->get_by_subject == NULL) {
      .             return 0;
      .           }
      .           // Note |get_by_subject| leaves |ret| in an inconsistent state. It has
      .           // pointers to an |X509| or |X509_CRL|, but has not bumped the refcount yet.
      .           // For now, the caller is expected to fix this, but ideally we'd fix the
      .           // |X509_LOOKUP| convention itself.
      .           return ctx->method->get_by_subject(ctx, type, name, ret) > 0;
      .         }
      .         
623,310 (0.1%)  static int x509_object_cmp(const X509_OBJECT *a, const X509_OBJECT *b) {
623,310 (0.1%)    int ret = a->type - b->type;
207,770 (0.0%)    if (ret) {
      .             return ret;
      .           }
415,540 (0.1%)    switch (a->type) {
      .             case X509_LU_X509:
831,080 (0.1%)        return X509_subject_name_cmp(a->data.x509, b->data.x509);
      .             case X509_LU_CRL:
      .               return X509_CRL_cmp(a->data.crl, b->data.crl);
      .             default:
      .               // abort();
      .               return 0;
      .           }
207,770 (0.0%)  }
      .         
      .         static int x509_object_cmp_sk(const X509_OBJECT *const *a,
623,304 (0.1%)                                const X509_OBJECT *const *b) {
727,188 (0.1%)    return x509_object_cmp(*a, *b);
207,768 (0.0%)  }
      .         
      .         static CRYPTO_EX_DATA_CLASS g_ex_data_class =
      .             CRYPTO_EX_DATA_CLASS_INIT_WITH_APP_DATA;
      .         
     12 (0.0%)  X509_STORE *X509_STORE_new(void) {
      9 (0.0%)    X509_STORE *ret = OPENSSL_zalloc(sizeof(X509_STORE));
      6 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
      6 (0.0%)    ret->references = 1;
     12 (0.0%)    CRYPTO_MUTEX_init(&ret->objs_lock);
     12 (0.0%)    CRYPTO_new_ex_data(&ret->ex_data);
     15 (0.0%)    ret->objs = sk_X509_OBJECT_new(x509_object_cmp_sk);
      9 (0.0%)    ret->get_cert_methods = sk_X509_LOOKUP_new_null();
      9 (0.0%)    ret->param = X509_VERIFY_PARAM_new();
     18 (0.0%)    if (ret->objs == NULL ||
     12 (0.0%)        ret->get_cert_methods == NULL ||
      6 (0.0%)        ret->param == NULL) {
      .             X509_STORE_free(ret);
      .             return NULL;
      .           }
      .         
      3 (0.0%)    return ret;
      6 (0.0%)  }
      .         
      .         int X509_STORE_lock(X509_STORE *v) {
      .             if (v == NULL) {
      .               return 0;
      .             }
      .             CRYPTO_MUTEX_lock_write(&v->objs_lock);
      .             return 1;
      .         }
-- line 183 ----------------------------------------
-- line 190 ----------------------------------------
      .             return 1;
      .         }
      .         
      .         int X509_STORE_up_ref(X509_STORE *store) {
      .           CRYPTO_refcount_inc(&store->references);
      .           return 1;
      .         }
      .         
     15 (0.0%)  void X509_STORE_free(X509_STORE *vfy) {
      6 (0.0%)    if (vfy == NULL) {
      .             return;
      .           }
      .         
     18 (0.0%)    if (!CRYPTO_refcount_dec_and_test_zero(&vfy->references)) {
      .             return;
      .           }
      .         
     12 (0.0%)    CRYPTO_MUTEX_cleanup(&vfy->objs_lock);
     21 (0.0%)    CRYPTO_free_ex_data(&g_ex_data_class, vfy, &vfy->ex_data);
     18 (0.0%)    sk_X509_LOOKUP_pop_free(vfy->get_cert_methods, X509_LOOKUP_free);
     18 (0.0%)    sk_X509_OBJECT_pop_free(vfy->objs, X509_OBJECT_free);
     12 (0.0%)    X509_VERIFY_PARAM_free(vfy->param);
     12 (0.0%)    OPENSSL_free(vfy);
      6 (0.0%)  }
      .         
     36 (0.0%)  X509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, const X509_LOOKUP_METHOD *m) {
     18 (0.0%)    STACK_OF(X509_LOOKUP) *sk = v->get_cert_methods;
     60 (0.0%)    for (size_t i = 0; i < sk_X509_LOOKUP_num(sk); i++) {
     18 (0.0%)      X509_LOOKUP *lu = sk_X509_LOOKUP_value(sk, i);
     12 (0.0%)      if (m == lu->method) {
      .               return lu;
      .             }
      .           }
      .         
     36 (0.0%)    X509_LOOKUP *lu = X509_LOOKUP_new(m, v);
     60 (0.0%)    if (lu == NULL || !sk_X509_LOOKUP_push(v->get_cert_methods, lu)) {
      .             X509_LOOKUP_free(lu);
      .             return NULL;
      .           }
      .         
      6 (0.0%)    return lu;
     12 (0.0%)  }
      .         
      .         int X509_STORE_CTX_get_by_subject(X509_STORE_CTX *vs, int type, X509_NAME *name,
     22 (0.0%)                                    X509_OBJECT *ret) {
      6 (0.0%)    X509_STORE *ctx = vs->ctx;
      .           X509_OBJECT stmp;
      8 (0.0%)    CRYPTO_MUTEX_lock_write(&ctx->objs_lock);
     16 (0.0%)    X509_OBJECT *tmp = X509_OBJECT_retrieve_by_subject(ctx->objs, type, name);
      8 (0.0%)    CRYPTO_MUTEX_unlock_write(&ctx->objs_lock);
      .         
      8 (0.0%)    if (tmp == NULL || type == X509_LU_CRL) {
      .             for (size_t i = 0; i < sk_X509_LOOKUP_num(ctx->get_cert_methods); i++) {
      .               X509_LOOKUP *lu = sk_X509_LOOKUP_value(ctx->get_cert_methods, i);
      .               if (X509_LOOKUP_by_subject(lu, type, name, &stmp)) {
      .                 tmp = &stmp;
      .                 break;
      .               }
      .             }
      .             if (tmp == NULL) {
      .               return 0;
      .             }
      .           }
      .         
      .           // if (ret->data.ptr != NULL) X509_OBJECT_free_contents(ret);
      .         
      8 (0.0%)    ret->type = tmp->type;
      8 (0.0%)    ret->data.ptr = tmp->data.ptr;
      .         
      6 (0.0%)    X509_OBJECT_up_ref_count(ret);
      .         
      2 (0.0%)    return 1;
     10 (0.0%)  }
      .         
  3,073 (0.0%)  static int x509_store_add(X509_STORE *ctx, void *x, int is_crl) {
    878 (0.0%)    if (x == NULL) {
      .             return 0;
      .           }
      .         
    878 (0.0%)    X509_OBJECT *const obj = X509_OBJECT_new();
    878 (0.0%)    if (obj == NULL) {
      .             return 0;
      .           }
      .         
    878 (0.0%)    if (is_crl) {
      .             obj->type = X509_LU_CRL;
      .             obj->data.crl = (X509_CRL *)x;
      .           } else {
    878 (0.0%)      obj->type = X509_LU_X509;
  1,317 (0.0%)      obj->data.x509 = (X509 *)x;
      .           }
  1,317 (0.0%)    X509_OBJECT_up_ref_count(obj);
      .         
  1,756 (0.0%)    CRYPTO_MUTEX_lock_write(&ctx->objs_lock);
      .         
    439 (0.0%)    int ret = 1;
    439 (0.0%)    int added = 0;
      .           // Duplicates are silently ignored
  3,512 (0.0%)    if (!X509_OBJECT_retrieve_match(ctx->objs, obj)) {
  5,268 (0.0%)      ret = added = (sk_X509_OBJECT_push(ctx->objs, obj) != 0);
      .           }
      .         
  1,756 (0.0%)    CRYPTO_MUTEX_unlock_write(&ctx->objs_lock);
      .         
    878 (0.0%)    if (!added) {
      .             X509_OBJECT_free(obj);
      .           }
      .         
    439 (0.0%)    return ret;
    878 (0.0%)  }
      .         
  2,634 (0.0%)  int X509_STORE_add_cert(X509_STORE *ctx, X509 *x) {
  2,634 (0.0%)    return x509_store_add(ctx, x, /*is_crl=*/0);
    878 (0.0%)  }
      .         
      .         int X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x) {
      .           return x509_store_add(ctx, x, /*is_crl=*/1);
      .         }
      .         
  1,317 (0.0%)  X509_OBJECT *X509_OBJECT_new(void) {
    878 (0.0%)    return OPENSSL_zalloc(sizeof(X509_OBJECT));
    878 (0.0%)  }
      .         
  2,195 (0.0%)  void X509_OBJECT_free(X509_OBJECT *obj) {
    878 (0.0%)    if (obj == NULL) {
      .             return;
      .           }
  1,317 (0.0%)    X509_OBJECT_free_contents(obj);
  1,756 (0.0%)    OPENSSL_free(obj);
    878 (0.0%)  }
      .         
  2,205 (0.0%)  static int X509_OBJECT_up_ref_count(X509_OBJECT *a) {
  1,764 (0.0%)    switch (a->type) {
      .             case X509_LU_X509:
  1,764 (0.0%)        X509_up_ref(a->data.x509);
    441 (0.0%)        break;
      .             case X509_LU_CRL:
      .               X509_CRL_up_ref(a->data.crl);
      .               break;
      .           }
    441 (0.0%)    return 1;
    882 (0.0%)  }
      .         
  2,205 (0.0%)  void X509_OBJECT_free_contents(X509_OBJECT *a) {
  1,764 (0.0%)    switch (a->type) {
      .             case X509_LU_X509:
  1,764 (0.0%)        X509_free(a->data.x509);
    441 (0.0%)        break;
      .             case X509_LU_CRL:
      .               X509_CRL_free(a->data.crl);
      .               break;
      .           }
      .         
  2,205 (0.0%)    OPENSSL_memset(a, 0, sizeof(X509_OBJECT));
  1,323 (0.0%)  }
      .         
      .         int X509_OBJECT_get_type(const X509_OBJECT *a) { return a->type; }
      .         
      .         X509 *X509_OBJECT_get0_X509(const X509_OBJECT *a) {
      .           if (a == NULL || a->type != X509_LU_X509) {
      .             return NULL;
      .           }
      .           return a->data.x509;
-- line 352 ----------------------------------------
-- line 377 ----------------------------------------
      .         
      .             X509_OBJECT_free_contents(a);
      .             a->type = X509_LU_CRL;
      .             a->data.crl = obj;
      .             return 1;
      .         }
      .         
      .         static int x509_object_idx_cnt(STACK_OF(X509_OBJECT) *h, int type,
     55 (0.0%)                                 X509_NAME *name, int *pnmatch) {
      .           X509_OBJECT stmp;
      .           X509 x509_s;
      .           X509_CINF cinf_s;
      .           X509_CRL crl_s;
      .           X509_CRL_INFO crl_info_s;
      .         
     10 (0.0%)    stmp.type = type;
     10 (0.0%)    switch (type) {
      .             case X509_LU_X509:
     10 (0.0%)        stmp.data.x509 = &x509_s;
     10 (0.0%)        x509_s.cert_info = &cinf_s;
     10 (0.0%)        cinf_s.subject = name;
      5 (0.0%)        break;
      .             case X509_LU_CRL:
      .               stmp.data.crl = &crl_s;
      .               crl_s.crl = &crl_info_s;
      .               crl_info_s.issuer = name;
      .               break;
      .             default:
      .               // abort();
      .               return -1;
      .           }
      .         
      .           size_t idx;
     15 (0.0%)    sk_X509_OBJECT_sort(h);
     40 (0.0%)    if (!sk_X509_OBJECT_find_awslc(h, &idx, &stmp)) {
      .             return -1;
      .           }
      .         
     10 (0.0%)    if (pnmatch != NULL) {
      2 (0.0%)      *pnmatch = 1;
      9 (0.0%)      for (size_t tidx = idx + 1; tidx < sk_X509_OBJECT_num(h); tidx++) {
      6 (0.0%)        const X509_OBJECT *tobj = sk_X509_OBJECT_value(h, tidx);
      7 (0.0%)        if (x509_object_cmp(tobj, &stmp)) {
      1 (0.0%)          break;
      .               }
      .               (*pnmatch)++;
      .             }
      .           }
      .         
      5 (0.0%)    return (int)idx;
     25 (0.0%)  }
      .         
      .         static int X509_OBJECT_idx_by_subject(STACK_OF(X509_OBJECT) *h, int type,
     28 (0.0%)                                        X509_NAME *name) {
     24 (0.0%)    return x509_object_idx_cnt(h, type, name, NULL);
      8 (0.0%)  }
      .         
      .         X509_OBJECT *X509_OBJECT_retrieve_by_subject(STACK_OF(X509_OBJECT) *h,
     14 (0.0%)                                                      int type, X509_NAME *name) {
      .           int idx;
     14 (0.0%)    idx = X509_OBJECT_idx_by_subject(h, type, name);
      4 (0.0%)    if (idx == -1) {
      .             return NULL;
      .           }
     12 (0.0%)    return sk_X509_OBJECT_value(h, idx);
      4 (0.0%)  }
      .         
      .         STACK_OF(X509_OBJECT) *X509_STORE_get0_objects(X509_STORE *st) {
      .           return st->objs;
      .         }
      .         
      9 (0.0%)  STACK_OF(X509) *X509_STORE_CTX_get1_certs(X509_STORE_CTX *ctx, X509_NAME *nm) {
      .           int cnt;
      2 (0.0%)    STACK_OF(X509) *sk = sk_X509_new_null();
      2 (0.0%)    if (sk == NULL) {
      .             return NULL;
      .           }
      5 (0.0%)    CRYPTO_MUTEX_lock_write(&ctx->ctx->objs_lock);
      9 (0.0%)    int idx = x509_object_idx_cnt(ctx->ctx->objs, X509_LU_X509, nm, &cnt);
      2 (0.0%)    if (idx < 0) {
      .             // Nothing found in cache: do lookup to possibly add new objects to
      .             // cache
      .             X509_OBJECT xobj;
      .             CRYPTO_MUTEX_unlock_write(&ctx->ctx->objs_lock);
      .             if (!X509_STORE_CTX_get_by_subject(ctx, X509_LU_X509, nm, &xobj)) {
      .               sk_X509_free(sk);
      .               return NULL;
      .             }
-- line 464 ----------------------------------------
-- line 466 ----------------------------------------
      .             CRYPTO_MUTEX_lock_write(&ctx->ctx->objs_lock);
      .             idx = x509_object_idx_cnt(ctx->ctx->objs, X509_LU_X509, nm, &cnt);
      .             if (idx < 0) {
      .               CRYPTO_MUTEX_unlock_write(&ctx->ctx->objs_lock);
      .               sk_X509_free(sk);
      .               return NULL;
      .             }
      .           }
     10 (0.0%)    for (int i = 0; i < cnt; i++, idx++) {
      9 (0.0%)      X509_OBJECT *obj = sk_X509_OBJECT_value(ctx->ctx->objs, idx);
      3 (0.0%)      X509 *x = obj->data.x509;
      7 (0.0%)      if (!sk_X509_push(sk, x)) {
      .               CRYPTO_MUTEX_unlock_write(&ctx->ctx->objs_lock);
      .               sk_X509_pop_free(sk, X509_free);
      .               return NULL;
      .             }
      3 (0.0%)      X509_up_ref(x);
      .           }
      5 (0.0%)    CRYPTO_MUTEX_unlock_write(&ctx->ctx->objs_lock);
      1 (0.0%)    return sk;
      5 (0.0%)  }
      .         
      .         STACK_OF(X509_CRL) *X509_STORE_CTX_get1_crls(X509_STORE_CTX *ctx,
      .                                                      X509_NAME *nm) {
      .           int cnt;
      .           X509_OBJECT xobj;
      .           STACK_OF(X509_CRL) *sk = sk_X509_CRL_new_null();
      .           if (sk == NULL) {
      .             return NULL;
-- line 494 ----------------------------------------
-- line 519 ----------------------------------------
      .               return NULL;
      .             }
      .           }
      .           CRYPTO_MUTEX_unlock_write(&ctx->ctx->objs_lock);
      .           return sk;
      .         }
      .         
      .         static X509_OBJECT *X509_OBJECT_retrieve_match(STACK_OF(X509_OBJECT) *h,
  3,951 (0.0%)                                                 X509_OBJECT *x) {
  1,317 (0.0%)    sk_X509_OBJECT_sort(h);
      .           size_t idx;
  3,512 (0.0%)    if (!sk_X509_OBJECT_find_awslc(h, &idx, x)) {
    878 (0.0%)      return NULL;
      .           }
      .           if ((x->type != X509_LU_X509) && (x->type != X509_LU_CRL)) {
      .             return sk_X509_OBJECT_value(h, idx);
      .           }
      .           for (size_t i = idx; i < sk_X509_OBJECT_num(h); i++) {
      .             X509_OBJECT *obj = sk_X509_OBJECT_value(h, i);
      .             if (x509_object_cmp(obj, x)) {
      .               return NULL;
-- line 539 ----------------------------------------
-- line 546 ----------------------------------------
      .               if (!X509_CRL_match(obj->data.crl, x->data.crl)) {
      .                 return obj;
      .               }
      .             } else {
      .               return obj;
      .             }
      .           }
      .           return NULL;
  2,195 (0.0%)  }
      .         
      .         // Try to get issuer certificate from store. Due to limitations of the API
      .         // this can only retrieve a single certificate matching a given subject name.
      .         // However it will fill the cache with all matching certificates, so we can
      .         // examine the cache for all matches. Return values are: 1 lookup
      .         // successful.  0 certificate not found. -1 some other error.
     20 (0.0%)  int X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x) {
      .           X509_NAME *xn;
      .           X509_OBJECT obj, *pobj;
      .           int idx, ret;
      .           size_t i;
      4 (0.0%)    *issuer = NULL;
      8 (0.0%)    xn = X509_get_issuer_name(x);
     16 (0.0%)    if (!X509_STORE_CTX_get_by_subject(ctx, X509_LU_X509, xn, &obj)) {
      .             return 0;
      .           }
      .           // If certificate matches all OK
     16 (0.0%)    if (x509_check_issued_with_callback(ctx, x, obj.data.x509)) {
      .             if (x509_check_cert_time(ctx, obj.data.x509, /*suppress_error*/1)) {
      .               *issuer = obj.data.x509;
      .               return 1;
      .             }
      .           }
      6 (0.0%)    X509_OBJECT_free_contents(&obj);
      .         
      .           // Else find index of first cert accepted by
      .           // |x509_check_issued_with_callback|.
      2 (0.0%)    ret = 0;
     10 (0.0%)    CRYPTO_MUTEX_lock_write(&ctx->ctx->objs_lock);
     16 (0.0%)    idx = X509_OBJECT_idx_by_subject(ctx->ctx->objs, X509_LU_X509, xn);
      4 (0.0%)    if (idx != -1) {  // should be true as we've had at least one
      .                             // match
      .             // Look through all matching certs for suitable issuer
     38 (0.0%)      for (i = idx; i < sk_X509_OBJECT_num(ctx->ctx->objs); i++) {
     32 (0.0%)        pobj = sk_X509_OBJECT_value(ctx->ctx->objs, i);
      .               // See if we've run past the matches
     16 (0.0%)        if (pobj->type != X509_LU_X509) {
      .                 break;
      .               }
     44 (0.0%)        if (X509_NAME_cmp(xn, X509_get_subject_name(pobj->data.x509))) {
      4 (0.0%)          break;
      .               }
     18 (0.0%)        if (x509_check_issued_with_callback(ctx, x, pobj->data.x509)) {
      .                 *issuer = pobj->data.x509;
      .                 ret = 1;
      .                 // Break the loop with a match if the time check is valid, otherwise
      .                 // we continue searching. We leave the last tested issuer certificate in
      .                 // |issuer| on purpose. This returns the closest match if none of the
      .                 // candidate issuer certificates' timestamps were valid.
      .                 if (x509_check_cert_time(ctx, *issuer, /*suppress_error*/1)) {
      .                   break;
      .                 }
      .               }
      .             }
      .           }
     10 (0.0%)    CRYPTO_MUTEX_unlock_write(&ctx->ctx->objs_lock);
      8 (0.0%)    if(*issuer) {
      .             X509_up_ref(*issuer);
      .           }
      2 (0.0%)    return ret;
     10 (0.0%)  }
      .         
      .         int X509_STORE_set_flags(X509_STORE *ctx, unsigned long flags) {
      .           return X509_VERIFY_PARAM_set_flags(ctx->param, flags);
      .         }
      .         
      .         int X509_STORE_set_depth(X509_STORE *ctx, int depth) {
      .           X509_VERIFY_PARAM_set_depth(ctx->param, depth);
      .           return 1;
-- line 623 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x_name.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 67 ----------------------------------------
      .         #include <openssl/x509.h>
      .         
      .         #include "../asn1/internal.h"
      .         #include "../internal.h"
      .         #include "internal.h"
      .         
      .         
      .         typedef STACK_OF(X509_NAME_ENTRY) STACK_OF_X509_NAME_ENTRY;
215,856 (0.0%)  DEFINE_STACK_OF(STACK_OF_X509_NAME_ENTRY)
      .         
      .         // Maximum length of X509_NAME: much larger than anything we should
      .         // ever see in practice.
      .         
      .         #define X509_NAME_MAX (1024 * 1024)
      .         
      .         static int x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                     long len, const ASN1_ITEM *it, int tag, int aclass,
-- line 83 ----------------------------------------
-- line 94 ----------------------------------------
      .         static int i2d_name_canon(STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname,
      .                                   unsigned char **in);
      .         
      .         ASN1_SEQUENCE(X509_NAME_ENTRY) = {
      .             ASN1_SIMPLE(X509_NAME_ENTRY, object, ASN1_OBJECT),
      .             ASN1_SIMPLE(X509_NAME_ENTRY, value, ASN1_PRINTABLE),
      .         } ASN1_SEQUENCE_END(X509_NAME_ENTRY)
      .         
101,376 (0.0%)  IMPLEMENT_ASN1_FUNCTIONS_const(X509_NAME_ENTRY)
      .         IMPLEMENT_ASN1_DUP_FUNCTION_const(X509_NAME_ENTRY)
      .         
      .         // For the "Name" type we need a SEQUENCE OF { SET OF X509_NAME_ENTRY } so
      .         // declare two template wrappers for this
      .         
      .         ASN1_ITEM_TEMPLATE(X509_NAME_ENTRIES) = ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SET_OF,
      .                                                                       0, RDNS,
      .                                                                       X509_NAME_ENTRY)
-- line 110 ----------------------------------------
-- line 129 ----------------------------------------
      .         };
      .         
      .         IMPLEMENT_EXTERN_ASN1(X509_NAME, V_ASN1_SEQUENCE, x509_name_ff)
      .         
      .         IMPLEMENT_ASN1_FUNCTIONS(X509_NAME)
      .         
      .         IMPLEMENT_ASN1_DUP_FUNCTION(X509_NAME)
      .         
 10,584 (0.0%)  static int x509_name_ex_new(ASN1_VALUE **val, const ASN1_ITEM *it) {
  1,764 (0.0%)    X509_NAME *ret = NULL;
  5,292 (0.0%)    ret = OPENSSL_malloc(sizeof(X509_NAME));
  3,528 (0.0%)    if (!ret) {
      .             goto memerr;
      .           }
 12,348 (0.0%)    if ((ret->entries = sk_X509_NAME_ENTRY_new_null()) == NULL) {
      .             goto memerr;
      .           }
 12,348 (0.0%)    if ((ret->bytes = BUF_MEM_new()) == NULL) {
      .             goto memerr;
      .           }
  3,528 (0.0%)    ret->canon_enc = NULL;
  3,528 (0.0%)    ret->canon_enclen = 0;
  3,528 (0.0%)    ret->modified = 1;
  5,292 (0.0%)    *val = (ASN1_VALUE *)ret;
  3,528 (0.0%)    return 1;
      .         
      .         memerr:
      .           if (ret) {
      .             if (ret->entries) {
      .               sk_X509_NAME_ENTRY_free(ret->entries);
      .             }
      .             OPENSSL_free(ret);
      .           }
      .           return 0;
  3,528 (0.0%)  }
      .         
 10,584 (0.0%)  static void x509_name_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
      .           X509_NAME *a;
 10,584 (0.0%)    if (!pval || !*pval) {
      .             return;
      .           }
  5,292 (0.0%)    a = (X509_NAME *)*pval;
      .         
  7,056 (0.0%)    BUF_MEM_free(a->bytes);
 10,584 (0.0%)    sk_X509_NAME_ENTRY_pop_free(a->entries, X509_NAME_ENTRY_free);
  7,056 (0.0%)    if (a->canon_enc) {
  3,528 (0.0%)      OPENSSL_free(a->canon_enc);
      .           }
  5,292 (0.0%)    OPENSSL_free(a);
  5,292 (0.0%)    *pval = NULL;
  3,528 (0.0%)  }
      .         
 15,840 (0.0%)  static void local_sk_X509_NAME_ENTRY_free(STACK_OF(X509_NAME_ENTRY) *ne) {
  9,504 (0.0%)    sk_X509_NAME_ENTRY_free(ne);
  9,504 (0.0%)  }
      .         
 15,840 (0.0%)  static void local_sk_X509_NAME_ENTRY_pop_free(STACK_OF(X509_NAME_ENTRY) *ne) {
 15,840 (0.0%)    sk_X509_NAME_ENTRY_pop_free(ne, X509_NAME_ENTRY_free);
  9,504 (0.0%)  }
      .         
      .         static int x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                     long len, const ASN1_ITEM *it, int tag, int aclass,
 14,994 (0.0%)                              char opt, ASN1_TLC *ctx) {
  2,646 (0.0%)    const unsigned char *p = *in, *q;
    882 (0.0%)    STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname = NULL;
    882 (0.0%)    X509_NAME *nm = NULL;
      .           size_t i, j;
      .           int ret;
      .           STACK_OF(X509_NAME_ENTRY) *entries;
      .           X509_NAME_ENTRY *entry;
      .           // Bound the size of an X509_NAME we are willing to parse.
  1,764 (0.0%)    if (len > X509_NAME_MAX) {
      .             len = X509_NAME_MAX;
      .           }
  1,764 (0.0%)    q = p;
      .         
      .           // Get internal representation of Name
    882 (0.0%)    ASN1_VALUE *intname_val = NULL;
 13,230 (0.0%)    ret = ASN1_item_ex_d2i(&intname_val, &p, len,
      .                                  ASN1_ITEM_rptr(X509_NAME_INTERNAL), tag, aclass, opt,
      .                                  ctx);
  1,764 (0.0%)    if (ret <= 0) {
      .             return ret;
      .           }
  1,764 (0.0%)    intname = (STACK_OF(STACK_OF_X509_NAME_ENTRY) *)intname_val;
      .         
  3,528 (0.0%)    if (*val) {
  3,528 (0.0%)      x509_name_ex_free(val, NULL);
      .           }
    882 (0.0%)    ASN1_VALUE *nm_val = NULL;
  5,292 (0.0%)    if (!x509_name_ex_new(&nm_val, NULL)) {
      .             goto err;
      .           }
  1,764 (0.0%)    nm = (X509_NAME *)nm_val;
      .           // We've decoded it: now cache encoding
  8,820 (0.0%)    if (!BUF_MEM_grow(nm->bytes, p - q)) {
      .             goto err;
      .           }
  8,820 (0.0%)    OPENSSL_memcpy(nm->bytes->data, q, p - q);
      .         
      .           // Convert internal representation to X509_NAME structure
 25,182 (0.0%)    for (i = 0; i < sk_STACK_OF_X509_NAME_ENTRY_num(intname); i++) {
 19,008 (0.0%)      entries = sk_STACK_OF_X509_NAME_ENTRY_value(intname, i);
 41,184 (0.0%)      for (j = 0; j < sk_X509_NAME_ENTRY_num(entries); j++) {
 19,008 (0.0%)        entry = sk_X509_NAME_ENTRY_value(entries, j);
 12,672 (0.0%)        entry->set = (int)i;
 25,344 (0.0%)        if (!sk_X509_NAME_ENTRY_push(nm->entries, entry)) {
      .                 goto err;
      .               }
 19,008 (0.0%)        (void)sk_X509_NAME_ENTRY_set(entries, j, NULL);
      .             }
      .           }
  3,528 (0.0%)    ret = x509_name_canon(nm);
  1,764 (0.0%)    if (!ret) {
      .             goto err;
      .           }
  4,410 (0.0%)    sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname, local_sk_X509_NAME_ENTRY_free);
  1,764 (0.0%)    nm->modified = 0;
  2,646 (0.0%)    *val = (ASN1_VALUE *)nm;
  2,646 (0.0%)    *in = p;
  1,764 (0.0%)    return ret;
      .         err:
      .           X509_NAME_free(nm);
      .           sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname,
      .                                                local_sk_X509_NAME_ENTRY_pop_free);
      .           OPENSSL_PUT_ERROR(X509, ERR_R_ASN1_LIB);
      .           return 0;
  4,410 (0.0%)  }
      .         
      .         static int x509_name_ex_i2d(ASN1_VALUE **val, unsigned char **out,
      .                                     const ASN1_ITEM *it, int tag, int aclass) {
      .           X509_NAME *a = (X509_NAME *)*val;
      .           if (a->modified && (!x509_name_encode(a) || !x509_name_canon(a))) {
      .             return -1;
      .           }
      .           int ret = a->bytes->length;
-- line 264 ----------------------------------------
-- line 324 ----------------------------------------
      .         // it all strings are converted to UTF8, leading, trailing and multiple
      .         // spaces collapsed, converted to lower case and the leading SEQUENCE header
      .         // removed. In future we could also normalize the UTF8 too. By doing this
      .         // comparison of Name structures can be rapidly perfomed by just using
      .         // OPENSSL_memcmp() of the canonical encoding. By omitting the leading SEQUENCE
      .         // name constraints of type dirName can also be checked with a simple
      .         // OPENSSL_memcmp().
      .         
  7,056 (0.0%)  static int x509_name_canon(X509_NAME *a) {
      .           unsigned char *p;
    882 (0.0%)    STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname = NULL;
    882 (0.0%)    STACK_OF(X509_NAME_ENTRY) *entries = NULL;
    882 (0.0%)    X509_NAME_ENTRY *entry, *tmpentry = NULL;
  1,764 (0.0%)    int set = -1, ret = 0, len;
      .           size_t i;
      .         
  3,528 (0.0%)    if (a->canon_enc) {
      .             OPENSSL_free(a->canon_enc);
      .             a->canon_enc = NULL;
      .           }
      .           // Special case: empty X509_NAME => null encoding
  5,292 (0.0%)    if (sk_X509_NAME_ENTRY_num(a->entries) == 0) {
      .             a->canon_enclen = 0;
      .             return 1;
      .           }
  1,764 (0.0%)    intname = sk_STACK_OF_X509_NAME_ENTRY_new_null();
  1,764 (0.0%)    if (!intname) {
      .             goto err;
      .           }
 29,232 (0.0%)    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {
 22,176 (0.0%)      entry = sk_X509_NAME_ENTRY_value(a->entries, i);
 12,672 (0.0%)      if (entry->set != set) {
  6,336 (0.0%)        entries = sk_X509_NAME_ENTRY_new_null();
  6,336 (0.0%)        if (!entries) {
      .                 goto err;
      .               }
 22,176 (0.0%)        if (!sk_STACK_OF_X509_NAME_ENTRY_push(intname, entries)) {
      .                 sk_X509_NAME_ENTRY_free(entries);
      .                 goto err;
      .               }
  9,504 (0.0%)        set = entry->set;
      .             }
  6,336 (0.0%)      tmpentry = X509_NAME_ENTRY_new();
  6,336 (0.0%)      if (tmpentry == NULL) {
      .               goto err;
      .             }
 19,008 (0.0%)      tmpentry->object = OBJ_dup(entry->object);
 28,512 (0.0%)      if (!asn1_string_canon(tmpentry->value, entry->value)) {
      .               goto err;
      .             }
 22,176 (0.0%)      if (!sk_X509_NAME_ENTRY_push(entries, tmpentry)) {
      .               goto err;
      .             }
  3,168 (0.0%)      tmpentry = NULL;
      .           }
      .         
      .           // Finally generate encoding
      .         
  4,410 (0.0%)    len = i2d_name_canon(intname, NULL);
  1,764 (0.0%)    if (len < 0) {
      .             goto err;
      .           }
  2,646 (0.0%)    a->canon_enclen = len;
      .         
  5,292 (0.0%)    p = OPENSSL_malloc(a->canon_enclen);
      .         
  2,646 (0.0%)    if (!p) {
      .             goto err;
      .           }
      .         
  2,646 (0.0%)    a->canon_enc = p;
      .         
  4,410 (0.0%)    i2d_name_canon(intname, &p);
      .         
  1,764 (0.0%)    ret = 1;
      .         
      .         err:
      .         
  1,764 (0.0%)    if (tmpentry) {
      .             X509_NAME_ENTRY_free(tmpentry);
      .           }
  1,764 (0.0%)    if (intname) {
  4,410 (0.0%)      sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname,
      .                                                  local_sk_X509_NAME_ENTRY_pop_free);
      .           }
    882 (0.0%)    return ret;
  4,410 (0.0%)  }
      .         
      .         // Bitmap of all the types of string that will be canonicalized.
      .         
      .         #define ASN1_MASK_CANON                                            \
      .           (B_ASN1_UTF8STRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | \
      .            B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING |  \
      .            B_ASN1_VISIBLESTRING)
      .         
 19,008 (0.0%)  static int asn1_string_canon(ASN1_STRING *out, ASN1_STRING *in) {
      .           unsigned char *to, *from;
      .           int len, i;
      .         
      .           // If type not in bitmask just copy string across
 22,176 (0.0%)    if (!(ASN1_tag2bit(in->type) & ASN1_MASK_CANON)) {
      .             if (!ASN1_STRING_copy(out, in)) {
      .               return 0;
      .             }
      .             return 1;
      .           }
      .         
  6,336 (0.0%)    out->type = V_ASN1_UTF8STRING;
 25,344 (0.0%)    out->length = ASN1_STRING_to_UTF8(&out->data, in);
 12,672 (0.0%)    if (out->length == -1) {
      .             return 0;
      .           }
      .         
  9,504 (0.0%)    to = out->data;
  6,336 (0.0%)    from = to;
      .         
  9,504 (0.0%)    len = out->length;
      .         
      .           // Convert string in place to canonical form.
      .         
      .           // Ignore leading spaces
 31,680 (0.0%)    while ((len > 0) && OPENSSL_isspace(*from)) {
      .             from++;
      .             len--;
      .           }
      .         
 15,840 (0.0%)    to = from + len;
      .         
      .           // Ignore trailing spaces
 34,848 (0.0%)    while ((len > 0) && OPENSSL_isspace(to[-1])) {
      .             to--;
      .             len--;
      .           }
      .         
  9,504 (0.0%)    to = out->data;
      .         
  3,168 (0.0%)    i = 0;
162,918 (0.0%)    while (i < len) {
      .             // Collapse multiple spaces
350,574 (0.1%)      if (OPENSSL_isspace(*from)) {
      .               // Copy one space across
 19,272 (0.0%)        *to++ = ' ';
      .               // Ignore subsequent spaces. Note: don't need to check len here
      .               // because we know the last character is a non-space so we can't
      .               // overflow.
      .               do {
  4,818 (0.0%)          from++;
  4,818 (0.0%)          i++;
 38,544 (0.0%)        } while (OPENSSL_isspace(*from));
      .             } else {
497,904 (0.1%)        *to++ = OPENSSL_tolower(*from);
 45,264 (0.0%)        from++;
 45,264 (0.0%)        i++;
      .             }
      .           }
      .         
 19,008 (0.0%)    out->length = to - out->data;
      .         
  3,168 (0.0%)    return 1;
  6,336 (0.0%)  }
      .         
      .         static int i2d_name_canon(STACK_OF(STACK_OF_X509_NAME_ENTRY) *_intname,
 15,876 (0.0%)                            unsigned char **in) {
      .           int len, ltmp;
      .           size_t i;
      .           ASN1_VALUE *v;
  3,528 (0.0%)    STACK_OF(ASN1_VALUE) *intname = (STACK_OF(ASN1_VALUE) *)_intname;
      .         
  1,764 (0.0%)    len = 0;
 50,364 (0.0%)    for (i = 0; i < sk_ASN1_VALUE_num(intname); i++) {
 38,016 (0.0%)      v = sk_ASN1_VALUE_value(intname, i);
 50,688 (0.0%)      ltmp = ASN1_item_ex_i2d(&v, in, ASN1_ITEM_rptr(X509_NAME_ENTRIES),
      .                                     /*tag=*/-1, /*aclass=*/0);
 12,672 (0.0%)      if (ltmp < 0) {
      .               return ltmp;
      .             }
 12,672 (0.0%)      len += ltmp;
      .           }
  1,764 (0.0%)    return len;
  8,820 (0.0%)  }
      .         
      .         int X509_NAME_set(X509_NAME **xn, X509_NAME *name) {
      .           if ((name = X509_NAME_dup(name)) == NULL) {
      .             return 0;
      .           }
      .           X509_NAME_free(*xn);
      .           *xn = name;
      .           return 1;
-- line 511 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S
--------------------------------------------------------------------------------
Ir__________ 

-- line 33 ----------------------------------------
    .         
    .         
    .         .globl	ecp_nistz256_neg
    .         .hidden ecp_nistz256_neg
    .         .type	ecp_nistz256_neg,@function
    .         .align	32
    .         ecp_nistz256_neg:
    .         .cfi_startproc	
  176 (0.0%)  	pushq	%r12
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r12,-16
  176 (0.0%)  	pushq	%r13
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r13,-24
    .         .Lneg_body:
    .         
  176 (0.0%)  	xorq	%r8,%r8
  176 (0.0%)  	xorq	%r9,%r9
  176 (0.0%)  	xorq	%r10,%r10
  176 (0.0%)  	xorq	%r11,%r11
  176 (0.0%)  	xorq	%r13,%r13
    .         
  176 (0.0%)  	subq	0(%rsi),%r8
  176 (0.0%)  	sbbq	8(%rsi),%r9
  176 (0.0%)  	sbbq	16(%rsi),%r10
  176 (0.0%)  	movq	%r8,%rax
  176 (0.0%)  	sbbq	24(%rsi),%r11
  176 (0.0%)  	leaq	.Lpoly(%rip),%rsi
  176 (0.0%)  	movq	%r9,%rdx
  176 (0.0%)  	sbbq	$0,%r13
    .         
  176 (0.0%)  	addq	0(%rsi),%r8
  176 (0.0%)  	movq	%r10,%rcx
  176 (0.0%)  	adcq	8(%rsi),%r9
  176 (0.0%)  	adcq	16(%rsi),%r10
  176 (0.0%)  	movq	%r11,%r12
  176 (0.0%)  	adcq	24(%rsi),%r11
  176 (0.0%)  	testq	%r13,%r13
    .         
  176 (0.0%)  	cmovzq	%rax,%r8
  176 (0.0%)  	cmovzq	%rdx,%r9
  176 (0.0%)  	movq	%r8,0(%rdi)
  176 (0.0%)  	cmovzq	%rcx,%r10
  176 (0.0%)  	movq	%r9,8(%rdi)
  176 (0.0%)  	cmovzq	%r12,%r11
  176 (0.0%)  	movq	%r10,16(%rdi)
  176 (0.0%)  	movq	%r11,24(%rdi)
    .         
  176 (0.0%)  	movq	0(%rsp),%r13
    .         .cfi_restore	%r13
  176 (0.0%)  	movq	8(%rsp),%r12
    .         .cfi_restore	%r12
  352 (0.0%)  	leaq	16(%rsp),%rsp
    .         .cfi_adjust_cfa_offset	-16
    .         .Lneg_epilogue:
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	ecp_nistz256_neg,.-ecp_nistz256_neg
    .         
    .         
    .         
-- line 93 ----------------------------------------
-- line 1188 ----------------------------------------
    .         
    .         
    .         .globl	ecp_nistz256_mul_mont
    .         .hidden ecp_nistz256_mul_mont
    .         .type	ecp_nistz256_mul_mont,@function
    .         .align	32
    .         ecp_nistz256_mul_mont:
    .         .cfi_startproc	
   52 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
   52 (0.0%)  	movq	8(%rcx),%rcx
   52 (0.0%)  	andl	$0x80100,%ecx
    .         .Lmul_mont:
   52 (0.0%)  	pushq	%rbp
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbp,-16
   52 (0.0%)  	pushq	%rbx
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbx,-24
   52 (0.0%)  	pushq	%r12
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r12,-32
   52 (0.0%)  	pushq	%r13
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r13,-40
   52 (0.0%)  	pushq	%r14
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r14,-48
   52 (0.0%)  	pushq	%r15
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r15,-56
    .         .Lmul_body:
   52 (0.0%)  	cmpl	$0x80100,%ecx
   52 (0.0%)  	je	.Lmul_montx
   52 (0.0%)  	movq	%rdx,%rbx
   52 (0.0%)  	movq	0(%rdx),%rax
   52 (0.0%)  	movq	0(%rsi),%r9
   52 (0.0%)  	movq	8(%rsi),%r10
   52 (0.0%)  	movq	16(%rsi),%r11
   52 (0.0%)  	movq	24(%rsi),%r12
    .         
   52 (0.0%)  	call	__ecp_nistz256_mul_montq
   52 (0.0%)  	jmp	.Lmul_mont_done
    .         
    .         .align	32
    .         .Lmul_montx:
    .         	movq	%rdx,%rbx
    .         	movq	0(%rdx),%rdx
    .         	movq	0(%rsi),%r9
    .         	movq	8(%rsi),%r10
    .         	movq	16(%rsi),%r11
    .         	movq	24(%rsi),%r12
    .         	leaq	-128(%rsi),%rsi
    .         
    .         	call	__ecp_nistz256_mul_montx
    .         .Lmul_mont_done:
   52 (0.0%)  	movq	0(%rsp),%r15
    .         .cfi_restore	%r15
   52 (0.0%)  	movq	8(%rsp),%r14
    .         .cfi_restore	%r14
   52 (0.0%)  	movq	16(%rsp),%r13
    .         .cfi_restore	%r13
   52 (0.0%)  	movq	24(%rsp),%r12
    .         .cfi_restore	%r12
   52 (0.0%)  	movq	32(%rsp),%rbx
    .         .cfi_restore	%rbx
   52 (0.0%)  	movq	40(%rsp),%rbp
    .         .cfi_restore	%rbp
  104 (0.0%)  	leaq	48(%rsp),%rsp
    .         .cfi_adjust_cfa_offset	-48
    .         .Lmul_epilogue:
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	ecp_nistz256_mul_mont,.-ecp_nistz256_mul_mont
    .         
    .         .type	__ecp_nistz256_mul_montq,@function
    .         .align	32
    .         __ecp_nistz256_mul_montq:
    .         .cfi_startproc	
    .         
    .         
4,124 (0.0%)  	movq	%rax,%rbp
4,124 (0.0%)  	mulq	%r9
4,124 (0.0%)  	movq	.Lpoly+8(%rip),%r14
4,124 (0.0%)  	movq	%rax,%r8
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	movq	%rdx,%r9
    .         
4,124 (0.0%)  	mulq	%r10
4,124 (0.0%)  	movq	.Lpoly+24(%rip),%r15
4,124 (0.0%)  	addq	%rax,%r9
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%r10
    .         
4,124 (0.0%)  	mulq	%r11
4,124 (0.0%)  	addq	%rax,%r10
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%r11
    .         
4,124 (0.0%)  	mulq	%r12
4,124 (0.0%)  	addq	%rax,%r11
4,124 (0.0%)  	movq	%r8,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	xorq	%r13,%r13
4,124 (0.0%)  	movq	%rdx,%r12
    .         
    .         
    .         
    .         
    .         
    .         
    .         
    .         
    .         
    .         
4,124 (0.0%)  	movq	%r8,%rbp
4,124 (0.0%)  	shlq	$32,%r8
4,124 (0.0%)  	mulq	%r15
4,124 (0.0%)  	shrq	$32,%rbp
4,124 (0.0%)  	addq	%r8,%r9
4,124 (0.0%)  	adcq	%rbp,%r10
4,124 (0.0%)  	adcq	%rax,%r11
4,124 (0.0%)  	movq	8(%rbx),%rax
4,124 (0.0%)  	adcq	%rdx,%r12
4,124 (0.0%)  	adcq	$0,%r13
4,124 (0.0%)  	xorq	%r8,%r8
    .         
    .         
    .         
4,124 (0.0%)  	movq	%rax,%rbp
4,124 (0.0%)  	mulq	0(%rsi)
4,124 (0.0%)  	addq	%rax,%r9
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	8(%rsi)
4,124 (0.0%)  	addq	%rcx,%r10
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r10
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	16(%rsi)
4,124 (0.0%)  	addq	%rcx,%r11
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r11
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	24(%rsi)
4,124 (0.0%)  	addq	%rcx,%r12
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r12
4,124 (0.0%)  	movq	%r9,%rax
4,124 (0.0%)  	adcq	%rdx,%r13
4,124 (0.0%)  	adcq	$0,%r8
    .         
    .         
    .         
4,124 (0.0%)  	movq	%r9,%rbp
4,124 (0.0%)  	shlq	$32,%r9
4,124 (0.0%)  	mulq	%r15
4,124 (0.0%)  	shrq	$32,%rbp
4,124 (0.0%)  	addq	%r9,%r10
4,124 (0.0%)  	adcq	%rbp,%r11
4,124 (0.0%)  	adcq	%rax,%r12
4,124 (0.0%)  	movq	16(%rbx),%rax
4,124 (0.0%)  	adcq	%rdx,%r13
4,124 (0.0%)  	adcq	$0,%r8
4,124 (0.0%)  	xorq	%r9,%r9
    .         
    .         
    .         
4,124 (0.0%)  	movq	%rax,%rbp
4,124 (0.0%)  	mulq	0(%rsi)
4,124 (0.0%)  	addq	%rax,%r10
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	8(%rsi)
4,124 (0.0%)  	addq	%rcx,%r11
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r11
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	16(%rsi)
4,124 (0.0%)  	addq	%rcx,%r12
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r12
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	24(%rsi)
4,124 (0.0%)  	addq	%rcx,%r13
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r13
4,124 (0.0%)  	movq	%r10,%rax
4,124 (0.0%)  	adcq	%rdx,%r8
4,124 (0.0%)  	adcq	$0,%r9
    .         
    .         
    .         
4,124 (0.0%)  	movq	%r10,%rbp
4,124 (0.0%)  	shlq	$32,%r10
4,124 (0.0%)  	mulq	%r15
4,124 (0.0%)  	shrq	$32,%rbp
4,124 (0.0%)  	addq	%r10,%r11
4,124 (0.0%)  	adcq	%rbp,%r12
4,124 (0.0%)  	adcq	%rax,%r13
4,124 (0.0%)  	movq	24(%rbx),%rax
4,124 (0.0%)  	adcq	%rdx,%r8
4,124 (0.0%)  	adcq	$0,%r9
4,124 (0.0%)  	xorq	%r10,%r10
    .         
    .         
    .         
4,124 (0.0%)  	movq	%rax,%rbp
4,124 (0.0%)  	mulq	0(%rsi)
4,124 (0.0%)  	addq	%rax,%r11
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	8(%rsi)
4,124 (0.0%)  	addq	%rcx,%r12
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r12
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	16(%rsi)
4,124 (0.0%)  	addq	%rcx,%r13
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r13
4,124 (0.0%)  	movq	%rbp,%rax
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	movq	%rdx,%rcx
    .         
4,124 (0.0%)  	mulq	24(%rsi)
4,124 (0.0%)  	addq	%rcx,%r8
4,124 (0.0%)  	adcq	$0,%rdx
4,124 (0.0%)  	addq	%rax,%r8
4,124 (0.0%)  	movq	%r11,%rax
4,124 (0.0%)  	adcq	%rdx,%r9
4,124 (0.0%)  	adcq	$0,%r10
    .         
    .         
    .         
4,124 (0.0%)  	movq	%r11,%rbp
4,124 (0.0%)  	shlq	$32,%r11
4,124 (0.0%)  	mulq	%r15
4,124 (0.0%)  	shrq	$32,%rbp
4,124 (0.0%)  	addq	%r11,%r12
4,124 (0.0%)  	adcq	%rbp,%r13
4,124 (0.0%)  	movq	%r12,%rcx
4,124 (0.0%)  	adcq	%rax,%r8
4,124 (0.0%)  	adcq	%rdx,%r9
4,124 (0.0%)  	movq	%r13,%rbp
4,124 (0.0%)  	adcq	$0,%r10
    .         
    .         
    .         
4,124 (0.0%)  	subq	$-1,%r12
4,124 (0.0%)  	movq	%r8,%rbx
4,124 (0.0%)  	sbbq	%r14,%r13
4,124 (0.0%)  	sbbq	$0,%r8
4,124 (0.0%)  	movq	%r9,%rdx
4,124 (0.0%)  	sbbq	%r15,%r9
4,124 (0.0%)  	sbbq	$0,%r10
    .         
4,124 (0.0%)  	cmovcq	%rcx,%r12
4,124 (0.0%)  	cmovcq	%rbp,%r13
4,124 (0.0%)  	movq	%r12,0(%rdi)
4,124 (0.0%)  	cmovcq	%rbx,%r8
4,124 (0.0%)  	movq	%r13,8(%rdi)
4,124 (0.0%)  	cmovcq	%rdx,%r9
4,124 (0.0%)  	movq	%r8,16(%rdi)
8,248 (0.0%)  	movq	%r9,24(%rdi)
    .         
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	__ecp_nistz256_mul_montq,.-__ecp_nistz256_mul_montq
    .         
    .         
    .         
    .         
-- line 1482 ----------------------------------------
-- line 1485 ----------------------------------------
    .         
    .         
    .         .globl	ecp_nistz256_sqr_mont
    .         .hidden ecp_nistz256_sqr_mont
    .         .type	ecp_nistz256_sqr_mont,@function
    .         .align	32
    .         ecp_nistz256_sqr_mont:
    .         .cfi_startproc	
1,022 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
1,022 (0.0%)  	movq	8(%rcx),%rcx
1,022 (0.0%)  	andl	$0x80100,%ecx
1,022 (0.0%)  	pushq	%rbp
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbp,-16
1,022 (0.0%)  	pushq	%rbx
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbx,-24
1,022 (0.0%)  	pushq	%r12
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r12,-32
1,022 (0.0%)  	pushq	%r13
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r13,-40
1,022 (0.0%)  	pushq	%r14
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r14,-48
1,022 (0.0%)  	pushq	%r15
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r15,-56
    .         .Lsqr_body:
1,022 (0.0%)  	cmpl	$0x80100,%ecx
1,022 (0.0%)  	je	.Lsqr_montx
1,022 (0.0%)  	movq	0(%rsi),%rax
1,022 (0.0%)  	movq	8(%rsi),%r14
1,022 (0.0%)  	movq	16(%rsi),%r15
1,022 (0.0%)  	movq	24(%rsi),%r8
    .         
1,022 (0.0%)  	call	__ecp_nistz256_sqr_montq
1,022 (0.0%)  	jmp	.Lsqr_mont_done
    .         
    .         .align	32
    .         .Lsqr_montx:
    .         	movq	0(%rsi),%rdx
    .         	movq	8(%rsi),%r14
    .         	movq	16(%rsi),%r15
    .         	movq	24(%rsi),%r8
    .         	leaq	-128(%rsi),%rsi
    .         
    .         	call	__ecp_nistz256_sqr_montx
    .         .Lsqr_mont_done:
1,022 (0.0%)  	movq	0(%rsp),%r15
    .         .cfi_restore	%r15
1,022 (0.0%)  	movq	8(%rsp),%r14
    .         .cfi_restore	%r14
1,022 (0.0%)  	movq	16(%rsp),%r13
    .         .cfi_restore	%r13
1,022 (0.0%)  	movq	24(%rsp),%r12
    .         .cfi_restore	%r12
1,022 (0.0%)  	movq	32(%rsp),%rbx
    .         .cfi_restore	%rbx
1,022 (0.0%)  	movq	40(%rsp),%rbp
    .         .cfi_restore	%rbp
2,044 (0.0%)  	leaq	48(%rsp),%rsp
    .         .cfi_adjust_cfa_offset	-48
    .         .Lsqr_epilogue:
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	ecp_nistz256_sqr_mont,.-ecp_nistz256_sqr_mont
    .         
    .         .type	__ecp_nistz256_sqr_montq,@function
    .         .align	32
    .         __ecp_nistz256_sqr_montq:
    .         .cfi_startproc	
3,806 (0.0%)  	movq	%rax,%r13
3,806 (0.0%)  	mulq	%r14
3,806 (0.0%)  	movq	%rax,%r9
3,806 (0.0%)  	movq	%r15,%rax
3,806 (0.0%)  	movq	%rdx,%r10
    .         
3,806 (0.0%)  	mulq	%r13
3,806 (0.0%)  	addq	%rax,%r10
3,806 (0.0%)  	movq	%r8,%rax
3,806 (0.0%)  	adcq	$0,%rdx
3,806 (0.0%)  	movq	%rdx,%r11
    .         
3,806 (0.0%)  	mulq	%r13
3,806 (0.0%)  	addq	%rax,%r11
3,806 (0.0%)  	movq	%r15,%rax
3,806 (0.0%)  	adcq	$0,%rdx
3,806 (0.0%)  	movq	%rdx,%r12
    .         
    .         
3,806 (0.0%)  	mulq	%r14
3,806 (0.0%)  	addq	%rax,%r11
3,806 (0.0%)  	movq	%r8,%rax
3,806 (0.0%)  	adcq	$0,%rdx
3,806 (0.0%)  	movq	%rdx,%rbp
    .         
3,806 (0.0%)  	mulq	%r14
3,806 (0.0%)  	addq	%rax,%r12
3,806 (0.0%)  	movq	%r8,%rax
3,806 (0.0%)  	adcq	$0,%rdx
3,806 (0.0%)  	addq	%rbp,%r12
3,806 (0.0%)  	movq	%rdx,%r13
3,806 (0.0%)  	adcq	$0,%r13
    .         
    .         
3,806 (0.0%)  	mulq	%r15
3,806 (0.0%)  	xorq	%r15,%r15
3,806 (0.0%)  	addq	%rax,%r13
3,806 (0.0%)  	movq	0(%rsi),%rax
3,806 (0.0%)  	movq	%rdx,%r14
3,806 (0.0%)  	adcq	$0,%r14
    .         
3,806 (0.0%)  	addq	%r9,%r9
3,806 (0.0%)  	adcq	%r10,%r10
3,806 (0.0%)  	adcq	%r11,%r11
3,806 (0.0%)  	adcq	%r12,%r12
3,806 (0.0%)  	adcq	%r13,%r13
3,806 (0.0%)  	adcq	%r14,%r14
3,806 (0.0%)  	adcq	$0,%r15
    .         
3,806 (0.0%)  	mulq	%rax
3,806 (0.0%)  	movq	%rax,%r8
3,806 (0.0%)  	movq	8(%rsi),%rax
3,806 (0.0%)  	movq	%rdx,%rcx
    .         
3,806 (0.0%)  	mulq	%rax
3,806 (0.0%)  	addq	%rcx,%r9
3,806 (0.0%)  	adcq	%rax,%r10
3,806 (0.0%)  	movq	16(%rsi),%rax
3,806 (0.0%)  	adcq	$0,%rdx
3,806 (0.0%)  	movq	%rdx,%rcx
    .         
3,806 (0.0%)  	mulq	%rax
3,806 (0.0%)  	addq	%rcx,%r11
3,806 (0.0%)  	adcq	%rax,%r12
3,806 (0.0%)  	movq	24(%rsi),%rax
3,806 (0.0%)  	adcq	$0,%rdx
3,806 (0.0%)  	movq	%rdx,%rcx
    .         
3,806 (0.0%)  	mulq	%rax
3,806 (0.0%)  	addq	%rcx,%r13
3,806 (0.0%)  	adcq	%rax,%r14
3,806 (0.0%)  	movq	%r8,%rax
3,806 (0.0%)  	adcq	%rdx,%r15
    .         
3,806 (0.0%)  	movq	.Lpoly+8(%rip),%rsi
3,806 (0.0%)  	movq	.Lpoly+24(%rip),%rbp
    .         
    .         
    .         
    .         
3,806 (0.0%)  	movq	%r8,%rcx
3,806 (0.0%)  	shlq	$32,%r8
3,806 (0.0%)  	mulq	%rbp
3,806 (0.0%)  	shrq	$32,%rcx
3,806 (0.0%)  	addq	%r8,%r9
3,806 (0.0%)  	adcq	%rcx,%r10
3,806 (0.0%)  	adcq	%rax,%r11
3,806 (0.0%)  	movq	%r9,%rax
3,806 (0.0%)  	adcq	$0,%rdx
    .         
    .         
    .         
3,806 (0.0%)  	movq	%r9,%rcx
3,806 (0.0%)  	shlq	$32,%r9
3,806 (0.0%)  	movq	%rdx,%r8
3,806 (0.0%)  	mulq	%rbp
3,806 (0.0%)  	shrq	$32,%rcx
3,806 (0.0%)  	addq	%r9,%r10
3,806 (0.0%)  	adcq	%rcx,%r11
3,806 (0.0%)  	adcq	%rax,%r8
3,806 (0.0%)  	movq	%r10,%rax
3,806 (0.0%)  	adcq	$0,%rdx
    .         
    .         
    .         
3,806 (0.0%)  	movq	%r10,%rcx
3,806 (0.0%)  	shlq	$32,%r10
3,806 (0.0%)  	movq	%rdx,%r9
3,806 (0.0%)  	mulq	%rbp
3,806 (0.0%)  	shrq	$32,%rcx
3,806 (0.0%)  	addq	%r10,%r11
3,806 (0.0%)  	adcq	%rcx,%r8
3,806 (0.0%)  	adcq	%rax,%r9
3,806 (0.0%)  	movq	%r11,%rax
3,806 (0.0%)  	adcq	$0,%rdx
    .         
    .         
    .         
3,806 (0.0%)  	movq	%r11,%rcx
3,806 (0.0%)  	shlq	$32,%r11
3,806 (0.0%)  	movq	%rdx,%r10
3,806 (0.0%)  	mulq	%rbp
3,806 (0.0%)  	shrq	$32,%rcx
3,806 (0.0%)  	addq	%r11,%r8
3,806 (0.0%)  	adcq	%rcx,%r9
3,806 (0.0%)  	adcq	%rax,%r10
3,806 (0.0%)  	adcq	$0,%rdx
3,806 (0.0%)  	xorq	%r11,%r11
    .         
    .         
    .         
3,806 (0.0%)  	addq	%r8,%r12
3,806 (0.0%)  	adcq	%r9,%r13
3,806 (0.0%)  	movq	%r12,%r8
3,806 (0.0%)  	adcq	%r10,%r14
3,806 (0.0%)  	adcq	%rdx,%r15
3,806 (0.0%)  	movq	%r13,%r9
3,806 (0.0%)  	adcq	$0,%r11
    .         
3,806 (0.0%)  	subq	$-1,%r12
3,806 (0.0%)  	movq	%r14,%r10
3,806 (0.0%)  	sbbq	%rsi,%r13
3,806 (0.0%)  	sbbq	$0,%r14
3,806 (0.0%)  	movq	%r15,%rcx
3,806 (0.0%)  	sbbq	%rbp,%r15
3,806 (0.0%)  	sbbq	$0,%r11
    .         
3,806 (0.0%)  	cmovcq	%r8,%r12
3,806 (0.0%)  	cmovcq	%r9,%r13
3,806 (0.0%)  	movq	%r12,0(%rdi)
3,806 (0.0%)  	cmovcq	%r10,%r14
3,806 (0.0%)  	movq	%r13,8(%rdi)
3,806 (0.0%)  	cmovcq	%rcx,%r15
3,806 (0.0%)  	movq	%r14,16(%rdi)
7,612 (0.0%)  	movq	%r15,24(%rdi)
    .         
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	__ecp_nistz256_sqr_montq,.-__ecp_nistz256_sqr_montq
    .         .type	__ecp_nistz256_mul_montx,@function
    .         .align	32
    .         __ecp_nistz256_mul_montx:
    .         .cfi_startproc	
-- line 1720 ----------------------------------------
-- line 2015 ----------------------------------------
    .         
    .         
    .         .globl	ecp_nistz256_select_w5
    .         .hidden ecp_nistz256_select_w5
    .         .type	ecp_nistz256_select_w5,@function
    .         .align	32
    .         ecp_nistz256_select_w5:
    .         .cfi_startproc	
  104 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rax
  104 (0.0%)  	movq	8(%rax),%rax
  104 (0.0%)  	testl	$32,%eax
  104 (0.0%)  	jnz	.Lavx2_select_w5
    .         	movdqa	.LOne(%rip),%xmm0
    .         	movd	%edx,%xmm1
    .         
    .         	pxor	%xmm2,%xmm2
    .         	pxor	%xmm3,%xmm3
    .         	pxor	%xmm4,%xmm4
    .         	pxor	%xmm5,%xmm5
    .         	pxor	%xmm6,%xmm6
-- line 2034 ----------------------------------------
-- line 2082 ----------------------------------------
    .         
    .         
    .         .globl	ecp_nistz256_select_w7
    .         .hidden ecp_nistz256_select_w7
    .         .type	ecp_nistz256_select_w7,@function
    .         .align	32
    .         ecp_nistz256_select_w7:
    .         .cfi_startproc	
   74 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rax
   74 (0.0%)  	movq	8(%rax),%rax
   74 (0.0%)  	testl	$32,%eax
   74 (0.0%)  	jnz	.Lavx2_select_w7
    .         	movdqa	.LOne(%rip),%xmm8
    .         	movd	%edx,%xmm1
    .         
    .         	pxor	%xmm2,%xmm2
    .         	pxor	%xmm3,%xmm3
    .         	pxor	%xmm4,%xmm4
    .         	pxor	%xmm5,%xmm5
    .         
-- line 2101 ----------------------------------------
-- line 2136 ----------------------------------------
    .         .size	ecp_nistz256_select_w7,.-ecp_nistz256_select_w7
    .         
    .         
    .         .type	ecp_nistz256_avx2_select_w5,@function
    .         .align	32
    .         ecp_nistz256_avx2_select_w5:
    .         .cfi_startproc	
    .         .Lavx2_select_w5:
  104 (0.0%)  	vzeroupper
  104 (0.0%)  	vmovdqa	.LTwo(%rip),%ymm0
    .         
  104 (0.0%)  	vpxor	%ymm2,%ymm2,%ymm2
  104 (0.0%)  	vpxor	%ymm3,%ymm3,%ymm3
  104 (0.0%)  	vpxor	%ymm4,%ymm4,%ymm4
    .         
  104 (0.0%)  	vmovdqa	.LOne(%rip),%ymm5
  104 (0.0%)  	vmovdqa	.LTwo(%rip),%ymm10
    .         
  104 (0.0%)  	vmovd	%edx,%xmm1
  104 (0.0%)  	vpermd	%ymm1,%ymm2,%ymm1
    .         
  104 (0.0%)  	movq	$8,%rax
    .         .Lselect_loop_avx2_w5:
    .         
  832 (0.0%)  	vmovdqa	0(%rsi),%ymm6
  832 (0.0%)  	vmovdqa	32(%rsi),%ymm7
  832 (0.0%)  	vmovdqa	64(%rsi),%ymm8
    .         
  832 (0.0%)  	vmovdqa	96(%rsi),%ymm11
  832 (0.0%)  	vmovdqa	128(%rsi),%ymm12
  832 (0.0%)  	vmovdqa	160(%rsi),%ymm13
    .         
  832 (0.0%)  	vpcmpeqd	%ymm1,%ymm5,%ymm9
  832 (0.0%)  	vpcmpeqd	%ymm1,%ymm10,%ymm14
    .         
  832 (0.0%)  	vpaddd	%ymm0,%ymm5,%ymm5
  832 (0.0%)  	vpaddd	%ymm0,%ymm10,%ymm10
  832 (0.0%)  	leaq	192(%rsi),%rsi
    .         
  832 (0.0%)  	vpand	%ymm9,%ymm6,%ymm6
  832 (0.0%)  	vpand	%ymm9,%ymm7,%ymm7
  832 (0.0%)  	vpand	%ymm9,%ymm8,%ymm8
  832 (0.0%)  	vpand	%ymm14,%ymm11,%ymm11
  832 (0.0%)  	vpand	%ymm14,%ymm12,%ymm12
  832 (0.0%)  	vpand	%ymm14,%ymm13,%ymm13
    .         
  832 (0.0%)  	vpxor	%ymm6,%ymm2,%ymm2
  832 (0.0%)  	vpxor	%ymm7,%ymm3,%ymm3
  832 (0.0%)  	vpxor	%ymm8,%ymm4,%ymm4
  832 (0.0%)  	vpxor	%ymm11,%ymm2,%ymm2
  832 (0.0%)  	vpxor	%ymm12,%ymm3,%ymm3
  832 (0.0%)  	vpxor	%ymm13,%ymm4,%ymm4
    .         
  832 (0.0%)  	decq	%rax
  832 (0.0%)  	jnz	.Lselect_loop_avx2_w5
    .         
  104 (0.0%)  	vmovdqu	%ymm2,0(%rdi)
  104 (0.0%)  	vmovdqu	%ymm3,32(%rdi)
  104 (0.0%)  	vmovdqu	%ymm4,64(%rdi)
  208 (0.0%)  	vzeroupper
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .LSEH_end_ecp_nistz256_avx2_select_w5:
    .         .size	ecp_nistz256_avx2_select_w5,.-ecp_nistz256_avx2_select_w5
    .         
    .         
    .         
    .         .globl	ecp_nistz256_avx2_select_w7
    .         .hidden ecp_nistz256_avx2_select_w7
    .         .type	ecp_nistz256_avx2_select_w7,@function
    .         .align	32
    .         ecp_nistz256_avx2_select_w7:
    .         .cfi_startproc	
    .         .Lavx2_select_w7:
   74 (0.0%)  	vzeroupper
   74 (0.0%)  	vmovdqa	.LThree(%rip),%ymm0
    .         
   74 (0.0%)  	vpxor	%ymm2,%ymm2,%ymm2
   74 (0.0%)  	vpxor	%ymm3,%ymm3,%ymm3
    .         
   74 (0.0%)  	vmovdqa	.LOne(%rip),%ymm4
   74 (0.0%)  	vmovdqa	.LTwo(%rip),%ymm8
   74 (0.0%)  	vmovdqa	.LThree(%rip),%ymm12
    .         
   74 (0.0%)  	vmovd	%edx,%xmm1
   74 (0.0%)  	vpermd	%ymm1,%ymm2,%ymm1
    .         
    .         
   74 (0.0%)  	movq	$21,%rax
    .         .Lselect_loop_avx2_w7:
    .         
1,554 (0.0%)  	vmovdqa	0(%rsi),%ymm5
1,554 (0.0%)  	vmovdqa	32(%rsi),%ymm6
    .         
1,554 (0.0%)  	vmovdqa	64(%rsi),%ymm9
1,554 (0.0%)  	vmovdqa	96(%rsi),%ymm10
    .         
1,554 (0.0%)  	vmovdqa	128(%rsi),%ymm13
1,554 (0.0%)  	vmovdqa	160(%rsi),%ymm14
    .         
1,554 (0.0%)  	vpcmpeqd	%ymm1,%ymm4,%ymm7
1,554 (0.0%)  	vpcmpeqd	%ymm1,%ymm8,%ymm11
1,554 (0.0%)  	vpcmpeqd	%ymm1,%ymm12,%ymm15
    .         
1,554 (0.0%)  	vpaddd	%ymm0,%ymm4,%ymm4
1,554 (0.0%)  	vpaddd	%ymm0,%ymm8,%ymm8
1,554 (0.0%)  	vpaddd	%ymm0,%ymm12,%ymm12
1,554 (0.0%)  	leaq	192(%rsi),%rsi
    .         
1,554 (0.0%)  	vpand	%ymm7,%ymm5,%ymm5
1,554 (0.0%)  	vpand	%ymm7,%ymm6,%ymm6
1,554 (0.0%)  	vpand	%ymm11,%ymm9,%ymm9
1,554 (0.0%)  	vpand	%ymm11,%ymm10,%ymm10
1,554 (0.0%)  	vpand	%ymm15,%ymm13,%ymm13
1,554 (0.0%)  	vpand	%ymm15,%ymm14,%ymm14
    .         
1,554 (0.0%)  	vpxor	%ymm5,%ymm2,%ymm2
1,554 (0.0%)  	vpxor	%ymm6,%ymm3,%ymm3
1,554 (0.0%)  	vpxor	%ymm9,%ymm2,%ymm2
1,554 (0.0%)  	vpxor	%ymm10,%ymm3,%ymm3
1,554 (0.0%)  	vpxor	%ymm13,%ymm2,%ymm2
1,554 (0.0%)  	vpxor	%ymm14,%ymm3,%ymm3
    .         
1,554 (0.0%)  	decq	%rax
1,554 (0.0%)  	jnz	.Lselect_loop_avx2_w7
    .         
    .         
   74 (0.0%)  	vmovdqa	0(%rsi),%ymm5
   74 (0.0%)  	vmovdqa	32(%rsi),%ymm6
    .         
   74 (0.0%)  	vpcmpeqd	%ymm1,%ymm4,%ymm7
    .         
   74 (0.0%)  	vpand	%ymm7,%ymm5,%ymm5
   74 (0.0%)  	vpand	%ymm7,%ymm6,%ymm6
    .         
   74 (0.0%)  	vpxor	%ymm5,%ymm2,%ymm2
   74 (0.0%)  	vpxor	%ymm6,%ymm3,%ymm3
    .         
   74 (0.0%)  	vmovdqu	%ymm2,0(%rdi)
   74 (0.0%)  	vmovdqu	%ymm3,32(%rdi)
  148 (0.0%)  	vzeroupper
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .LSEH_end_ecp_nistz256_avx2_select_w7:
    .         .size	ecp_nistz256_avx2_select_w7,.-ecp_nistz256_avx2_select_w7
    .         .type	__ecp_nistz256_add_toq,@function
    .         .align	32
    .         __ecp_nistz256_add_toq:
    .         .cfi_startproc	
1,052 (0.0%)  	xorq	%r11,%r11
1,052 (0.0%)  	addq	0(%rbx),%r12
1,052 (0.0%)  	adcq	8(%rbx),%r13
1,052 (0.0%)  	movq	%r12,%rax
1,052 (0.0%)  	adcq	16(%rbx),%r8
1,052 (0.0%)  	adcq	24(%rbx),%r9
1,052 (0.0%)  	movq	%r13,%rbp
1,052 (0.0%)  	adcq	$0,%r11
    .         
1,052 (0.0%)  	subq	$-1,%r12
1,052 (0.0%)  	movq	%r8,%rcx
1,052 (0.0%)  	sbbq	%r14,%r13
1,052 (0.0%)  	sbbq	$0,%r8
1,052 (0.0%)  	movq	%r9,%r10
1,052 (0.0%)  	sbbq	%r15,%r9
1,052 (0.0%)  	sbbq	$0,%r11
    .         
1,052 (0.0%)  	cmovcq	%rax,%r12
1,052 (0.0%)  	cmovcq	%rbp,%r13
1,052 (0.0%)  	movq	%r12,0(%rdi)
1,052 (0.0%)  	cmovcq	%rcx,%r8
1,052 (0.0%)  	movq	%r13,8(%rdi)
1,052 (0.0%)  	cmovcq	%r10,%r9
1,052 (0.0%)  	movq	%r8,16(%rdi)
2,104 (0.0%)  	movq	%r9,24(%rdi)
    .         
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	__ecp_nistz256_add_toq,.-__ecp_nistz256_add_toq
    .         
    .         .type	__ecp_nistz256_sub_fromq,@function
    .         .align	32
    .         __ecp_nistz256_sub_fromq:
    .         .cfi_startproc	
2,330 (0.0%)  	subq	0(%rbx),%r12
2,330 (0.0%)  	sbbq	8(%rbx),%r13
2,330 (0.0%)  	movq	%r12,%rax
2,330 (0.0%)  	sbbq	16(%rbx),%r8
2,330 (0.0%)  	sbbq	24(%rbx),%r9
2,330 (0.0%)  	movq	%r13,%rbp
2,330 (0.0%)  	sbbq	%r11,%r11
    .         
2,330 (0.0%)  	addq	$-1,%r12
2,330 (0.0%)  	movq	%r8,%rcx
2,330 (0.0%)  	adcq	%r14,%r13
2,330 (0.0%)  	adcq	$0,%r8
2,330 (0.0%)  	movq	%r9,%r10
2,330 (0.0%)  	adcq	%r15,%r9
2,330 (0.0%)  	testq	%r11,%r11
    .         
2,330 (0.0%)  	cmovzq	%rax,%r12
2,330 (0.0%)  	cmovzq	%rbp,%r13
2,330 (0.0%)  	movq	%r12,0(%rdi)
2,330 (0.0%)  	cmovzq	%rcx,%r8
2,330 (0.0%)  	movq	%r13,8(%rdi)
2,330 (0.0%)  	cmovzq	%r10,%r9
2,330 (0.0%)  	movq	%r8,16(%rdi)
4,660 (0.0%)  	movq	%r9,24(%rdi)
    .         
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	__ecp_nistz256_sub_fromq,.-__ecp_nistz256_sub_fromq
    .         
    .         .type	__ecp_nistz256_subq,@function
    .         .align	32
    .         __ecp_nistz256_subq:
    .         .cfi_startproc	
  902 (0.0%)  	subq	%r12,%rax
  902 (0.0%)  	sbbq	%r13,%rbp
  902 (0.0%)  	movq	%rax,%r12
  902 (0.0%)  	sbbq	%r8,%rcx
  902 (0.0%)  	sbbq	%r9,%r10
  902 (0.0%)  	movq	%rbp,%r13
  902 (0.0%)  	sbbq	%r11,%r11
    .         
  902 (0.0%)  	addq	$-1,%rax
  902 (0.0%)  	movq	%rcx,%r8
  902 (0.0%)  	adcq	%r14,%rbp
  902 (0.0%)  	adcq	$0,%rcx
  902 (0.0%)  	movq	%r10,%r9
  902 (0.0%)  	adcq	%r15,%r10
  902 (0.0%)  	testq	%r11,%r11
    .         
  902 (0.0%)  	cmovnzq	%rax,%r12
  902 (0.0%)  	cmovnzq	%rbp,%r13
  902 (0.0%)  	cmovnzq	%rcx,%r8
1,804 (0.0%)  	cmovnzq	%r10,%r9
    .         
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	__ecp_nistz256_subq,.-__ecp_nistz256_subq
    .         
    .         .type	__ecp_nistz256_mul_by_2q,@function
    .         .align	32
    .         __ecp_nistz256_mul_by_2q:
    .         .cfi_startproc	
2,104 (0.0%)  	xorq	%r11,%r11
2,104 (0.0%)  	addq	%r12,%r12
2,104 (0.0%)  	adcq	%r13,%r13
2,104 (0.0%)  	movq	%r12,%rax
2,104 (0.0%)  	adcq	%r8,%r8
2,104 (0.0%)  	adcq	%r9,%r9
2,104 (0.0%)  	movq	%r13,%rbp
2,104 (0.0%)  	adcq	$0,%r11
    .         
2,104 (0.0%)  	subq	$-1,%r12
2,104 (0.0%)  	movq	%r8,%rcx
2,104 (0.0%)  	sbbq	%r14,%r13
2,104 (0.0%)  	sbbq	$0,%r8
2,104 (0.0%)  	movq	%r9,%r10
2,104 (0.0%)  	sbbq	%r15,%r9
2,104 (0.0%)  	sbbq	$0,%r11
    .         
2,104 (0.0%)  	cmovcq	%rax,%r12
2,104 (0.0%)  	cmovcq	%rbp,%r13
2,104 (0.0%)  	movq	%r12,0(%rdi)
2,104 (0.0%)  	cmovcq	%rcx,%r8
2,104 (0.0%)  	movq	%r13,8(%rdi)
2,104 (0.0%)  	cmovcq	%r10,%r9
2,104 (0.0%)  	movq	%r8,16(%rdi)
4,208 (0.0%)  	movq	%r9,24(%rdi)
    .         
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	__ecp_nistz256_mul_by_2q,.-__ecp_nistz256_mul_by_2q
    .         .globl	ecp_nistz256_point_double
    .         .hidden ecp_nistz256_point_double
    .         .type	ecp_nistz256_point_double,@function
    .         .align	32
    .         ecp_nistz256_point_double:
    .         .cfi_startproc	
  526 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
  526 (0.0%)  	movq	8(%rcx),%rcx
  526 (0.0%)  	andl	$0x80100,%ecx
  526 (0.0%)  	cmpl	$0x80100,%ecx
  526 (0.0%)  	je	.Lpoint_doublex
  526 (0.0%)  	pushq	%rbp
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbp,-16
  526 (0.0%)  	pushq	%rbx
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbx,-24
  526 (0.0%)  	pushq	%r12
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r12,-32
  526 (0.0%)  	pushq	%r13
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r13,-40
  526 (0.0%)  	pushq	%r14
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r14,-48
  526 (0.0%)  	pushq	%r15
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r15,-56
  526 (0.0%)  	subq	$160+8,%rsp
    .         .cfi_adjust_cfa_offset	32*5+8
    .         .Lpoint_doubleq_body:
    .         
    .         .Lpoint_double_shortcutq:
  526 (0.0%)  	movdqu	0(%rsi),%xmm0
  526 (0.0%)  	movq	%rsi,%rbx
  526 (0.0%)  	movdqu	16(%rsi),%xmm1
  526 (0.0%)  	movq	32+0(%rsi),%r12
  526 (0.0%)  	movq	32+8(%rsi),%r13
  526 (0.0%)  	movq	32+16(%rsi),%r8
  526 (0.0%)  	movq	32+24(%rsi),%r9
  526 (0.0%)  	movq	.Lpoly+8(%rip),%r14
  526 (0.0%)  	movq	.Lpoly+24(%rip),%r15
  526 (0.0%)  	movdqa	%xmm0,96(%rsp)
  526 (0.0%)  	movdqa	%xmm1,96+16(%rsp)
  526 (0.0%)  	leaq	32(%rdi),%r10
2,104 (0.0%)  	leaq	64(%rdi),%r11
    .         .byte	102,72,15,110,199
    .         .byte	102,73,15,110,202
    .         .byte	102,73,15,110,211
    .         
  526 (0.0%)  	leaq	0(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_mul_by_2q
    .         
  526 (0.0%)  	movq	64+0(%rsi),%rax
  526 (0.0%)  	movq	64+8(%rsi),%r14
  526 (0.0%)  	movq	64+16(%rsi),%r15
  526 (0.0%)  	movq	64+24(%rsi),%r8
  526 (0.0%)  	leaq	64-0(%rsi),%rsi
  526 (0.0%)  	leaq	64(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
  526 (0.0%)  	movq	0+0(%rsp),%rax
  526 (0.0%)  	movq	8+0(%rsp),%r14
  526 (0.0%)  	leaq	0+0(%rsp),%rsi
  526 (0.0%)  	movq	16+0(%rsp),%r15
  526 (0.0%)  	movq	24+0(%rsp),%r8
  526 (0.0%)  	leaq	0(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
  526 (0.0%)  	movq	32(%rbx),%rax
  526 (0.0%)  	movq	64+0(%rbx),%r9
  526 (0.0%)  	movq	64+8(%rbx),%r10
  526 (0.0%)  	movq	64+16(%rbx),%r11
  526 (0.0%)  	movq	64+24(%rbx),%r12
  526 (0.0%)  	leaq	64-0(%rbx),%rsi
1,052 (0.0%)  	leaq	32(%rbx),%rbx
    .         .byte	102,72,15,126,215
  526 (0.0%)  	call	__ecp_nistz256_mul_montq
  526 (0.0%)  	call	__ecp_nistz256_mul_by_2q
    .         
  526 (0.0%)  	movq	96+0(%rsp),%r12
  526 (0.0%)  	movq	96+8(%rsp),%r13
  526 (0.0%)  	leaq	64(%rsp),%rbx
  526 (0.0%)  	movq	96+16(%rsp),%r8
  526 (0.0%)  	movq	96+24(%rsp),%r9
  526 (0.0%)  	leaq	32(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_add_toq
    .         
  526 (0.0%)  	movq	96+0(%rsp),%r12
  526 (0.0%)  	movq	96+8(%rsp),%r13
  526 (0.0%)  	leaq	64(%rsp),%rbx
  526 (0.0%)  	movq	96+16(%rsp),%r8
  526 (0.0%)  	movq	96+24(%rsp),%r9
  526 (0.0%)  	leaq	64(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
  526 (0.0%)  	movq	0+0(%rsp),%rax
  526 (0.0%)  	movq	8+0(%rsp),%r14
  526 (0.0%)  	leaq	0+0(%rsp),%rsi
  526 (0.0%)  	movq	16+0(%rsp),%r15
1,052 (0.0%)  	movq	24+0(%rsp),%r8
    .         .byte	102,72,15,126,207
  526 (0.0%)  	call	__ecp_nistz256_sqr_montq
  526 (0.0%)  	xorq	%r9,%r9
  526 (0.0%)  	movq	%r12,%rax
  526 (0.0%)  	addq	$-1,%r12
  526 (0.0%)  	movq	%r13,%r10
  526 (0.0%)  	adcq	%rsi,%r13
  526 (0.0%)  	movq	%r14,%rcx
  526 (0.0%)  	adcq	$0,%r14
  526 (0.0%)  	movq	%r15,%r8
  526 (0.0%)  	adcq	%rbp,%r15
  526 (0.0%)  	adcq	$0,%r9
  526 (0.0%)  	xorq	%rsi,%rsi
  526 (0.0%)  	testq	$1,%rax
    .         
  526 (0.0%)  	cmovzq	%rax,%r12
  526 (0.0%)  	cmovzq	%r10,%r13
  526 (0.0%)  	cmovzq	%rcx,%r14
  526 (0.0%)  	cmovzq	%r8,%r15
  526 (0.0%)  	cmovzq	%rsi,%r9
    .         
  526 (0.0%)  	movq	%r13,%rax
  526 (0.0%)  	shrq	$1,%r12
  526 (0.0%)  	shlq	$63,%rax
  526 (0.0%)  	movq	%r14,%r10
  526 (0.0%)  	shrq	$1,%r13
  526 (0.0%)  	orq	%rax,%r12
  526 (0.0%)  	shlq	$63,%r10
  526 (0.0%)  	movq	%r15,%rcx
  526 (0.0%)  	shrq	$1,%r14
  526 (0.0%)  	orq	%r10,%r13
  526 (0.0%)  	shlq	$63,%rcx
  526 (0.0%)  	movq	%r12,0(%rdi)
  526 (0.0%)  	shrq	$1,%r15
  526 (0.0%)  	movq	%r13,8(%rdi)
  526 (0.0%)  	shlq	$63,%r9
  526 (0.0%)  	orq	%rcx,%r14
  526 (0.0%)  	orq	%r9,%r15
  526 (0.0%)  	movq	%r14,16(%rdi)
  526 (0.0%)  	movq	%r15,24(%rdi)
  526 (0.0%)  	movq	64(%rsp),%rax
  526 (0.0%)  	leaq	64(%rsp),%rbx
  526 (0.0%)  	movq	0+32(%rsp),%r9
  526 (0.0%)  	movq	8+32(%rsp),%r10
  526 (0.0%)  	leaq	0+32(%rsp),%rsi
  526 (0.0%)  	movq	16+32(%rsp),%r11
  526 (0.0%)  	movq	24+32(%rsp),%r12
  526 (0.0%)  	leaq	32(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  526 (0.0%)  	leaq	128(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_mul_by_2q
    .         
  526 (0.0%)  	leaq	32(%rsp),%rbx
  526 (0.0%)  	leaq	32(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_add_toq
    .         
  526 (0.0%)  	movq	96(%rsp),%rax
  526 (0.0%)  	leaq	96(%rsp),%rbx
  526 (0.0%)  	movq	0+0(%rsp),%r9
  526 (0.0%)  	movq	8+0(%rsp),%r10
  526 (0.0%)  	leaq	0+0(%rsp),%rsi
  526 (0.0%)  	movq	16+0(%rsp),%r11
  526 (0.0%)  	movq	24+0(%rsp),%r12
  526 (0.0%)  	leaq	0(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  526 (0.0%)  	leaq	128(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_mul_by_2q
    .         
  526 (0.0%)  	movq	0+32(%rsp),%rax
  526 (0.0%)  	movq	8+32(%rsp),%r14
  526 (0.0%)  	leaq	0+32(%rsp),%rsi
  526 (0.0%)  	movq	16+32(%rsp),%r15
1,052 (0.0%)  	movq	24+32(%rsp),%r8
    .         .byte	102,72,15,126,199
  526 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
  526 (0.0%)  	leaq	128(%rsp),%rbx
  526 (0.0%)  	movq	%r14,%r8
  526 (0.0%)  	movq	%r15,%r9
  526 (0.0%)  	movq	%rsi,%r14
  526 (0.0%)  	movq	%rbp,%r15
  526 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
  526 (0.0%)  	movq	0+0(%rsp),%rax
  526 (0.0%)  	movq	0+8(%rsp),%rbp
  526 (0.0%)  	movq	0+16(%rsp),%rcx
  526 (0.0%)  	movq	0+24(%rsp),%r10
  526 (0.0%)  	leaq	0(%rsp),%rdi
  526 (0.0%)  	call	__ecp_nistz256_subq
    .         
  526 (0.0%)  	movq	32(%rsp),%rax
  526 (0.0%)  	leaq	32(%rsp),%rbx
  526 (0.0%)  	movq	%r12,%r14
  526 (0.0%)  	xorl	%ecx,%ecx
  526 (0.0%)  	movq	%r12,0+0(%rsp)
  526 (0.0%)  	movq	%r13,%r10
  526 (0.0%)  	movq	%r13,0+8(%rsp)
  526 (0.0%)  	cmovzq	%r8,%r11
  526 (0.0%)  	movq	%r8,0+16(%rsp)
  526 (0.0%)  	leaq	0-0(%rsp),%rsi
  526 (0.0%)  	cmovzq	%r9,%r12
  526 (0.0%)  	movq	%r9,0+24(%rsp)
  526 (0.0%)  	movq	%r14,%r9
  526 (0.0%)  	leaq	0(%rsp),%rdi
1,578 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
    .         .byte	102,72,15,126,203
    .         .byte	102,72,15,126,207
  526 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
  526 (0.0%)  	leaq	160+56(%rsp),%rsi
    .         .cfi_def_cfa	%rsi,8
  526 (0.0%)  	movq	-48(%rsi),%r15
    .         .cfi_restore	%r15
  526 (0.0%)  	movq	-40(%rsi),%r14
    .         .cfi_restore	%r14
  526 (0.0%)  	movq	-32(%rsi),%r13
    .         .cfi_restore	%r13
  526 (0.0%)  	movq	-24(%rsi),%r12
    .         .cfi_restore	%r12
  526 (0.0%)  	movq	-16(%rsi),%rbx
    .         .cfi_restore	%rbx
  526 (0.0%)  	movq	-8(%rsi),%rbp
    .         .cfi_restore	%rbp
1,052 (0.0%)  	leaq	(%rsi),%rsp
    .         .cfi_def_cfa_register	%rsp
    .         .Lpoint_doubleq_epilogue:
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	ecp_nistz256_point_double,.-ecp_nistz256_point_double
    .         .globl	ecp_nistz256_point_add
    .         .hidden ecp_nistz256_point_add
    .         .type	ecp_nistz256_point_add,@function
    .         .align	32
    .         ecp_nistz256_point_add:
    .         .cfi_startproc	
  116 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
  116 (0.0%)  	movq	8(%rcx),%rcx
  116 (0.0%)  	andl	$0x80100,%ecx
  116 (0.0%)  	cmpl	$0x80100,%ecx
  116 (0.0%)  	je	.Lpoint_addx
  116 (0.0%)  	pushq	%rbp
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbp,-16
  116 (0.0%)  	pushq	%rbx
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbx,-24
  116 (0.0%)  	pushq	%r12
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r12,-32
  116 (0.0%)  	pushq	%r13
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r13,-40
  116 (0.0%)  	pushq	%r14
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r14,-48
  116 (0.0%)  	pushq	%r15
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r15,-56
  116 (0.0%)  	subq	$576+8,%rsp
    .         .cfi_adjust_cfa_offset	32*18+8
    .         .Lpoint_addq_body:
    .         
  116 (0.0%)  	movdqu	0(%rsi),%xmm0
  116 (0.0%)  	movdqu	16(%rsi),%xmm1
  116 (0.0%)  	movdqu	32(%rsi),%xmm2
  116 (0.0%)  	movdqu	48(%rsi),%xmm3
  116 (0.0%)  	movdqu	64(%rsi),%xmm4
  116 (0.0%)  	movdqu	80(%rsi),%xmm5
  116 (0.0%)  	movq	%rsi,%rbx
  116 (0.0%)  	movq	%rdx,%rsi
  116 (0.0%)  	movdqa	%xmm0,384(%rsp)
  116 (0.0%)  	movdqa	%xmm1,384+16(%rsp)
  116 (0.0%)  	movdqa	%xmm2,416(%rsp)
  116 (0.0%)  	movdqa	%xmm3,416+16(%rsp)
  116 (0.0%)  	movdqa	%xmm4,448(%rsp)
  116 (0.0%)  	movdqa	%xmm5,448+16(%rsp)
  116 (0.0%)  	por	%xmm4,%xmm5
    .         
  116 (0.0%)  	movdqu	0(%rsi),%xmm0
  116 (0.0%)  	pshufd	$0xb1,%xmm5,%xmm3
  116 (0.0%)  	movdqu	16(%rsi),%xmm1
  116 (0.0%)  	movdqu	32(%rsi),%xmm2
  116 (0.0%)  	por	%xmm3,%xmm5
  116 (0.0%)  	movdqu	48(%rsi),%xmm3
  116 (0.0%)  	movq	64+0(%rsi),%rax
  116 (0.0%)  	movq	64+8(%rsi),%r14
  116 (0.0%)  	movq	64+16(%rsi),%r15
  116 (0.0%)  	movq	64+24(%rsi),%r8
  116 (0.0%)  	movdqa	%xmm0,480(%rsp)
  116 (0.0%)  	pshufd	$0x1e,%xmm5,%xmm4
  116 (0.0%)  	movdqa	%xmm1,480+16(%rsp)
  116 (0.0%)  	movdqu	64(%rsi),%xmm0
  116 (0.0%)  	movdqu	80(%rsi),%xmm1
  116 (0.0%)  	movdqa	%xmm2,512(%rsp)
  116 (0.0%)  	movdqa	%xmm3,512+16(%rsp)
  116 (0.0%)  	por	%xmm4,%xmm5
  116 (0.0%)  	pxor	%xmm4,%xmm4
  232 (0.0%)  	por	%xmm0,%xmm1
    .         .byte	102,72,15,110,199
    .         
  116 (0.0%)  	leaq	64-0(%rsi),%rsi
  116 (0.0%)  	movq	%rax,544+0(%rsp)
  116 (0.0%)  	movq	%r14,544+8(%rsp)
  116 (0.0%)  	movq	%r15,544+16(%rsp)
  116 (0.0%)  	movq	%r8,544+24(%rsp)
  116 (0.0%)  	leaq	96(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
  116 (0.0%)  	pcmpeqd	%xmm4,%xmm5
  116 (0.0%)  	pshufd	$0xb1,%xmm1,%xmm4
  116 (0.0%)  	por	%xmm1,%xmm4
  116 (0.0%)  	pshufd	$0,%xmm5,%xmm5
  116 (0.0%)  	pshufd	$0x1e,%xmm4,%xmm3
  116 (0.0%)  	por	%xmm3,%xmm4
  116 (0.0%)  	pxor	%xmm3,%xmm3
  116 (0.0%)  	pcmpeqd	%xmm3,%xmm4
  116 (0.0%)  	pshufd	$0,%xmm4,%xmm4
  116 (0.0%)  	movq	64+0(%rbx),%rax
  116 (0.0%)  	movq	64+8(%rbx),%r14
  116 (0.0%)  	movq	64+16(%rbx),%r15
  232 (0.0%)  	movq	64+24(%rbx),%r8
    .         .byte	102,72,15,110,203
    .         
  116 (0.0%)  	leaq	64-0(%rbx),%rsi
  116 (0.0%)  	leaq	32(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
  116 (0.0%)  	movq	544(%rsp),%rax
  116 (0.0%)  	leaq	544(%rsp),%rbx
  116 (0.0%)  	movq	0+96(%rsp),%r9
  116 (0.0%)  	movq	8+96(%rsp),%r10
  116 (0.0%)  	leaq	0+96(%rsp),%rsi
  116 (0.0%)  	movq	16+96(%rsp),%r11
  116 (0.0%)  	movq	24+96(%rsp),%r12
  116 (0.0%)  	leaq	224(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	448(%rsp),%rax
  116 (0.0%)  	leaq	448(%rsp),%rbx
  116 (0.0%)  	movq	0+32(%rsp),%r9
  116 (0.0%)  	movq	8+32(%rsp),%r10
  116 (0.0%)  	leaq	0+32(%rsp),%rsi
  116 (0.0%)  	movq	16+32(%rsp),%r11
  116 (0.0%)  	movq	24+32(%rsp),%r12
  116 (0.0%)  	leaq	256(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	416(%rsp),%rax
  116 (0.0%)  	leaq	416(%rsp),%rbx
  116 (0.0%)  	movq	0+224(%rsp),%r9
  116 (0.0%)  	movq	8+224(%rsp),%r10
  116 (0.0%)  	leaq	0+224(%rsp),%rsi
  116 (0.0%)  	movq	16+224(%rsp),%r11
  116 (0.0%)  	movq	24+224(%rsp),%r12
  116 (0.0%)  	leaq	224(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	512(%rsp),%rax
  116 (0.0%)  	leaq	512(%rsp),%rbx
  116 (0.0%)  	movq	0+256(%rsp),%r9
  116 (0.0%)  	movq	8+256(%rsp),%r10
  116 (0.0%)  	leaq	0+256(%rsp),%rsi
  116 (0.0%)  	movq	16+256(%rsp),%r11
  116 (0.0%)  	movq	24+256(%rsp),%r12
  116 (0.0%)  	leaq	256(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	leaq	224(%rsp),%rbx
  116 (0.0%)  	leaq	64(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
  116 (0.0%)  	orq	%r13,%r12
  116 (0.0%)  	movdqa	%xmm4,%xmm2
  116 (0.0%)  	orq	%r8,%r12
  116 (0.0%)  	orq	%r9,%r12
  232 (0.0%)  	por	%xmm5,%xmm2
    .         .byte	102,73,15,110,220
    .         
  116 (0.0%)  	movq	384(%rsp),%rax
  116 (0.0%)  	leaq	384(%rsp),%rbx
  116 (0.0%)  	movq	0+96(%rsp),%r9
  116 (0.0%)  	movq	8+96(%rsp),%r10
  116 (0.0%)  	leaq	0+96(%rsp),%rsi
  116 (0.0%)  	movq	16+96(%rsp),%r11
  116 (0.0%)  	movq	24+96(%rsp),%r12
  116 (0.0%)  	leaq	160(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	480(%rsp),%rax
  116 (0.0%)  	leaq	480(%rsp),%rbx
  116 (0.0%)  	movq	0+32(%rsp),%r9
  116 (0.0%)  	movq	8+32(%rsp),%r10
  116 (0.0%)  	leaq	0+32(%rsp),%rsi
  116 (0.0%)  	movq	16+32(%rsp),%r11
  116 (0.0%)  	movq	24+32(%rsp),%r12
  116 (0.0%)  	leaq	192(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	leaq	160(%rsp),%rbx
  116 (0.0%)  	leaq	0(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
  116 (0.0%)  	orq	%r13,%r12
  116 (0.0%)  	orq	%r8,%r12
  348 (0.0%)  	orq	%r9,%r12
    .         
    .         .byte	102,73,15,126,208
    .         .byte	102,73,15,126,217
  232 (0.0%)  	orq	%r8,%r12
    .         .byte	0x3e
    .         	jnz	.Ladd_proceedq
    .         
    .         
    .         
    .         	testq	%r9,%r9
    .         	jz	.Ladd_doubleq
    .         
-- line 2831 ----------------------------------------
-- line 2850 ----------------------------------------
    .         .byte	102,72,15,126,199
    .         	addq	$416,%rsp
    .         .cfi_adjust_cfa_offset	-416
    .         	jmp	.Lpoint_double_shortcutq
    .         .cfi_adjust_cfa_offset	416
    .         
    .         .align	32
    .         .Ladd_proceedq:
  116 (0.0%)  	movq	0+64(%rsp),%rax
  116 (0.0%)  	movq	8+64(%rsp),%r14
  116 (0.0%)  	leaq	0+64(%rsp),%rsi
  116 (0.0%)  	movq	16+64(%rsp),%r15
  116 (0.0%)  	movq	24+64(%rsp),%r8
  116 (0.0%)  	leaq	96(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
  116 (0.0%)  	movq	448(%rsp),%rax
  116 (0.0%)  	leaq	448(%rsp),%rbx
  116 (0.0%)  	movq	0+0(%rsp),%r9
  116 (0.0%)  	movq	8+0(%rsp),%r10
  116 (0.0%)  	leaq	0+0(%rsp),%rsi
  116 (0.0%)  	movq	16+0(%rsp),%r11
  116 (0.0%)  	movq	24+0(%rsp),%r12
  116 (0.0%)  	leaq	352(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	0+0(%rsp),%rax
  116 (0.0%)  	movq	8+0(%rsp),%r14
  116 (0.0%)  	leaq	0+0(%rsp),%rsi
  116 (0.0%)  	movq	16+0(%rsp),%r15
  116 (0.0%)  	movq	24+0(%rsp),%r8
  116 (0.0%)  	leaq	32(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
  116 (0.0%)  	movq	544(%rsp),%rax
  116 (0.0%)  	leaq	544(%rsp),%rbx
  116 (0.0%)  	movq	0+352(%rsp),%r9
  116 (0.0%)  	movq	8+352(%rsp),%r10
  116 (0.0%)  	leaq	0+352(%rsp),%rsi
  116 (0.0%)  	movq	16+352(%rsp),%r11
  116 (0.0%)  	movq	24+352(%rsp),%r12
  116 (0.0%)  	leaq	352(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	0(%rsp),%rax
  116 (0.0%)  	leaq	0(%rsp),%rbx
  116 (0.0%)  	movq	0+32(%rsp),%r9
  116 (0.0%)  	movq	8+32(%rsp),%r10
  116 (0.0%)  	leaq	0+32(%rsp),%rsi
  116 (0.0%)  	movq	16+32(%rsp),%r11
  116 (0.0%)  	movq	24+32(%rsp),%r12
  116 (0.0%)  	leaq	128(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	160(%rsp),%rax
  116 (0.0%)  	leaq	160(%rsp),%rbx
  116 (0.0%)  	movq	0+32(%rsp),%r9
  116 (0.0%)  	movq	8+32(%rsp),%r10
  116 (0.0%)  	leaq	0+32(%rsp),%rsi
  116 (0.0%)  	movq	16+32(%rsp),%r11
  116 (0.0%)  	movq	24+32(%rsp),%r12
  116 (0.0%)  	leaq	192(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
    .         
    .         
    .         
  116 (0.0%)  	xorq	%r11,%r11
  116 (0.0%)  	addq	%r12,%r12
  116 (0.0%)  	leaq	96(%rsp),%rsi
  116 (0.0%)  	adcq	%r13,%r13
  116 (0.0%)  	movq	%r12,%rax
  116 (0.0%)  	adcq	%r8,%r8
  116 (0.0%)  	adcq	%r9,%r9
  116 (0.0%)  	movq	%r13,%rbp
  116 (0.0%)  	adcq	$0,%r11
    .         
  116 (0.0%)  	subq	$-1,%r12
  116 (0.0%)  	movq	%r8,%rcx
  116 (0.0%)  	sbbq	%r14,%r13
  116 (0.0%)  	sbbq	$0,%r8
  116 (0.0%)  	movq	%r9,%r10
  116 (0.0%)  	sbbq	%r15,%r9
  116 (0.0%)  	sbbq	$0,%r11
    .         
  116 (0.0%)  	cmovcq	%rax,%r12
  116 (0.0%)  	movq	0(%rsi),%rax
  116 (0.0%)  	cmovcq	%rbp,%r13
  116 (0.0%)  	movq	8(%rsi),%rbp
  116 (0.0%)  	cmovcq	%rcx,%r8
  116 (0.0%)  	movq	16(%rsi),%rcx
  116 (0.0%)  	cmovcq	%r10,%r9
  116 (0.0%)  	movq	24(%rsi),%r10
    .         
  116 (0.0%)  	call	__ecp_nistz256_subq
    .         
  116 (0.0%)  	leaq	128(%rsp),%rbx
  116 (0.0%)  	leaq	288(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
  116 (0.0%)  	movq	192+0(%rsp),%rax
  116 (0.0%)  	movq	192+8(%rsp),%rbp
  116 (0.0%)  	movq	192+16(%rsp),%rcx
  116 (0.0%)  	movq	192+24(%rsp),%r10
  116 (0.0%)  	leaq	320(%rsp),%rdi
    .         
  116 (0.0%)  	call	__ecp_nistz256_subq
    .         
  116 (0.0%)  	movq	%r12,0(%rdi)
  116 (0.0%)  	movq	%r13,8(%rdi)
  116 (0.0%)  	movq	%r8,16(%rdi)
  116 (0.0%)  	movq	%r9,24(%rdi)
  116 (0.0%)  	movq	128(%rsp),%rax
  116 (0.0%)  	leaq	128(%rsp),%rbx
  116 (0.0%)  	movq	0+224(%rsp),%r9
  116 (0.0%)  	movq	8+224(%rsp),%r10
  116 (0.0%)  	leaq	0+224(%rsp),%rsi
  116 (0.0%)  	movq	16+224(%rsp),%r11
  116 (0.0%)  	movq	24+224(%rsp),%r12
  116 (0.0%)  	leaq	256(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	movq	320(%rsp),%rax
  116 (0.0%)  	leaq	320(%rsp),%rbx
  116 (0.0%)  	movq	0+64(%rsp),%r9
  116 (0.0%)  	movq	8+64(%rsp),%r10
  116 (0.0%)  	leaq	0+64(%rsp),%rsi
  116 (0.0%)  	movq	16+64(%rsp),%r11
  116 (0.0%)  	movq	24+64(%rsp),%r12
  116 (0.0%)  	leaq	320(%rsp),%rdi
  116 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
  116 (0.0%)  	leaq	256(%rsp),%rbx
  116 (0.0%)  	leaq	320(%rsp),%rdi
  232 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
    .         .byte	102,72,15,126,199
    .         
  116 (0.0%)  	movdqa	%xmm5,%xmm0
  116 (0.0%)  	movdqa	%xmm5,%xmm1
  116 (0.0%)  	pandn	352(%rsp),%xmm0
  116 (0.0%)  	movdqa	%xmm5,%xmm2
  116 (0.0%)  	pandn	352+16(%rsp),%xmm1
  116 (0.0%)  	movdqa	%xmm5,%xmm3
  116 (0.0%)  	pand	544(%rsp),%xmm2
  116 (0.0%)  	pand	544+16(%rsp),%xmm3
  116 (0.0%)  	por	%xmm0,%xmm2
  116 (0.0%)  	por	%xmm1,%xmm3
    .         
  116 (0.0%)  	movdqa	%xmm4,%xmm0
  116 (0.0%)  	movdqa	%xmm4,%xmm1
  116 (0.0%)  	pandn	%xmm2,%xmm0
  116 (0.0%)  	movdqa	%xmm4,%xmm2
  116 (0.0%)  	pandn	%xmm3,%xmm1
  116 (0.0%)  	movdqa	%xmm4,%xmm3
  116 (0.0%)  	pand	448(%rsp),%xmm2
  116 (0.0%)  	pand	448+16(%rsp),%xmm3
  116 (0.0%)  	por	%xmm0,%xmm2
  116 (0.0%)  	por	%xmm1,%xmm3
  116 (0.0%)  	movdqu	%xmm2,64(%rdi)
  116 (0.0%)  	movdqu	%xmm3,80(%rdi)
    .         
  116 (0.0%)  	movdqa	%xmm5,%xmm0
  116 (0.0%)  	movdqa	%xmm5,%xmm1
  116 (0.0%)  	pandn	288(%rsp),%xmm0
  116 (0.0%)  	movdqa	%xmm5,%xmm2
  116 (0.0%)  	pandn	288+16(%rsp),%xmm1
  116 (0.0%)  	movdqa	%xmm5,%xmm3
  116 (0.0%)  	pand	480(%rsp),%xmm2
  116 (0.0%)  	pand	480+16(%rsp),%xmm3
  116 (0.0%)  	por	%xmm0,%xmm2
  116 (0.0%)  	por	%xmm1,%xmm3
    .         
  116 (0.0%)  	movdqa	%xmm4,%xmm0
  116 (0.0%)  	movdqa	%xmm4,%xmm1
  116 (0.0%)  	pandn	%xmm2,%xmm0
  116 (0.0%)  	movdqa	%xmm4,%xmm2
  116 (0.0%)  	pandn	%xmm3,%xmm1
  116 (0.0%)  	movdqa	%xmm4,%xmm3
  116 (0.0%)  	pand	384(%rsp),%xmm2
  116 (0.0%)  	pand	384+16(%rsp),%xmm3
  116 (0.0%)  	por	%xmm0,%xmm2
  116 (0.0%)  	por	%xmm1,%xmm3
  116 (0.0%)  	movdqu	%xmm2,0(%rdi)
  116 (0.0%)  	movdqu	%xmm3,16(%rdi)
    .         
  116 (0.0%)  	movdqa	%xmm5,%xmm0
  116 (0.0%)  	movdqa	%xmm5,%xmm1
  116 (0.0%)  	pandn	320(%rsp),%xmm0
  116 (0.0%)  	movdqa	%xmm5,%xmm2
  116 (0.0%)  	pandn	320+16(%rsp),%xmm1
  116 (0.0%)  	movdqa	%xmm5,%xmm3
  116 (0.0%)  	pand	512(%rsp),%xmm2
  116 (0.0%)  	pand	512+16(%rsp),%xmm3
  116 (0.0%)  	por	%xmm0,%xmm2
  116 (0.0%)  	por	%xmm1,%xmm3
    .         
  116 (0.0%)  	movdqa	%xmm4,%xmm0
  116 (0.0%)  	movdqa	%xmm4,%xmm1
  116 (0.0%)  	pandn	%xmm2,%xmm0
  116 (0.0%)  	movdqa	%xmm4,%xmm2
  116 (0.0%)  	pandn	%xmm3,%xmm1
  116 (0.0%)  	movdqa	%xmm4,%xmm3
  116 (0.0%)  	pand	416(%rsp),%xmm2
  116 (0.0%)  	pand	416+16(%rsp),%xmm3
  116 (0.0%)  	por	%xmm0,%xmm2
  116 (0.0%)  	por	%xmm1,%xmm3
  116 (0.0%)  	movdqu	%xmm2,32(%rdi)
  116 (0.0%)  	movdqu	%xmm3,48(%rdi)
    .         
    .         .Ladd_doneq:
  116 (0.0%)  	leaq	576+56(%rsp),%rsi
    .         .cfi_def_cfa	%rsi,8
  116 (0.0%)  	movq	-48(%rsi),%r15
    .         .cfi_restore	%r15
  116 (0.0%)  	movq	-40(%rsi),%r14
    .         .cfi_restore	%r14
  116 (0.0%)  	movq	-32(%rsi),%r13
    .         .cfi_restore	%r13
  116 (0.0%)  	movq	-24(%rsi),%r12
    .         .cfi_restore	%r12
  116 (0.0%)  	movq	-16(%rsi),%rbx
    .         .cfi_restore	%rbx
  116 (0.0%)  	movq	-8(%rsi),%rbp
    .         .cfi_restore	%rbp
  232 (0.0%)  	leaq	(%rsi),%rsp
    .         .cfi_def_cfa_register	%rsp
    .         .Lpoint_addq_epilogue:
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	ecp_nistz256_point_add,.-ecp_nistz256_point_add
    .         .globl	ecp_nistz256_point_add_affine
    .         .hidden ecp_nistz256_point_add_affine
    .         .type	ecp_nistz256_point_add_affine,@function
    .         .align	32
    .         ecp_nistz256_point_add_affine:
    .         .cfi_startproc	
   72 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
   72 (0.0%)  	movq	8(%rcx),%rcx
   72 (0.0%)  	andl	$0x80100,%ecx
   72 (0.0%)  	cmpl	$0x80100,%ecx
   72 (0.0%)  	je	.Lpoint_add_affinex
   72 (0.0%)  	pushq	%rbp
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbp,-16
   72 (0.0%)  	pushq	%rbx
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%rbx,-24
   72 (0.0%)  	pushq	%r12
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r12,-32
   72 (0.0%)  	pushq	%r13
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r13,-40
   72 (0.0%)  	pushq	%r14
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r14,-48
   72 (0.0%)  	pushq	%r15
    .         .cfi_adjust_cfa_offset	8
    .         .cfi_offset	%r15,-56
   72 (0.0%)  	subq	$480+8,%rsp
    .         .cfi_adjust_cfa_offset	32*15+8
    .         .Ladd_affineq_body:
    .         
   72 (0.0%)  	movdqu	0(%rsi),%xmm0
   72 (0.0%)  	movq	%rdx,%rbx
   72 (0.0%)  	movdqu	16(%rsi),%xmm1
   72 (0.0%)  	movdqu	32(%rsi),%xmm2
   72 (0.0%)  	movdqu	48(%rsi),%xmm3
   72 (0.0%)  	movdqu	64(%rsi),%xmm4
   72 (0.0%)  	movdqu	80(%rsi),%xmm5
   72 (0.0%)  	movq	64+0(%rsi),%rax
   72 (0.0%)  	movq	64+8(%rsi),%r14
   72 (0.0%)  	movq	64+16(%rsi),%r15
   72 (0.0%)  	movq	64+24(%rsi),%r8
   72 (0.0%)  	movdqa	%xmm0,320(%rsp)
   72 (0.0%)  	movdqa	%xmm1,320+16(%rsp)
   72 (0.0%)  	movdqa	%xmm2,352(%rsp)
   72 (0.0%)  	movdqa	%xmm3,352+16(%rsp)
   72 (0.0%)  	movdqa	%xmm4,384(%rsp)
   72 (0.0%)  	movdqa	%xmm5,384+16(%rsp)
   72 (0.0%)  	por	%xmm4,%xmm5
    .         
   72 (0.0%)  	movdqu	0(%rbx),%xmm0
   72 (0.0%)  	pshufd	$0xb1,%xmm5,%xmm3
   72 (0.0%)  	movdqu	16(%rbx),%xmm1
   72 (0.0%)  	movdqu	32(%rbx),%xmm2
   72 (0.0%)  	por	%xmm3,%xmm5
   72 (0.0%)  	movdqu	48(%rbx),%xmm3
   72 (0.0%)  	movdqa	%xmm0,416(%rsp)
   72 (0.0%)  	pshufd	$0x1e,%xmm5,%xmm4
   72 (0.0%)  	movdqa	%xmm1,416+16(%rsp)
  144 (0.0%)  	por	%xmm0,%xmm1
    .         .byte	102,72,15,110,199
   72 (0.0%)  	movdqa	%xmm2,448(%rsp)
   72 (0.0%)  	movdqa	%xmm3,448+16(%rsp)
   72 (0.0%)  	por	%xmm2,%xmm3
   72 (0.0%)  	por	%xmm4,%xmm5
   72 (0.0%)  	pxor	%xmm4,%xmm4
   72 (0.0%)  	por	%xmm1,%xmm3
    .         
   72 (0.0%)  	leaq	64-0(%rsi),%rsi
   72 (0.0%)  	leaq	32(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
   72 (0.0%)  	pcmpeqd	%xmm4,%xmm5
   72 (0.0%)  	pshufd	$0xb1,%xmm3,%xmm4
   72 (0.0%)  	movq	0(%rbx),%rax
    .         
   72 (0.0%)  	movq	%r12,%r9
   72 (0.0%)  	por	%xmm3,%xmm4
   72 (0.0%)  	pshufd	$0,%xmm5,%xmm5
   72 (0.0%)  	pshufd	$0x1e,%xmm4,%xmm3
   72 (0.0%)  	movq	%r13,%r10
   72 (0.0%)  	por	%xmm3,%xmm4
   72 (0.0%)  	pxor	%xmm3,%xmm3
   72 (0.0%)  	movq	%r14,%r11
   72 (0.0%)  	pcmpeqd	%xmm3,%xmm4
   72 (0.0%)  	pshufd	$0,%xmm4,%xmm4
    .         
   72 (0.0%)  	leaq	32-0(%rsp),%rsi
   72 (0.0%)  	movq	%r15,%r12
   72 (0.0%)  	leaq	0(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
   72 (0.0%)  	leaq	320(%rsp),%rbx
   72 (0.0%)  	leaq	64(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
   72 (0.0%)  	movq	384(%rsp),%rax
   72 (0.0%)  	leaq	384(%rsp),%rbx
   72 (0.0%)  	movq	0+32(%rsp),%r9
   72 (0.0%)  	movq	8+32(%rsp),%r10
   72 (0.0%)  	leaq	0+32(%rsp),%rsi
   72 (0.0%)  	movq	16+32(%rsp),%r11
   72 (0.0%)  	movq	24+32(%rsp),%r12
   72 (0.0%)  	leaq	32(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
   72 (0.0%)  	movq	384(%rsp),%rax
   72 (0.0%)  	leaq	384(%rsp),%rbx
   72 (0.0%)  	movq	0+64(%rsp),%r9
   72 (0.0%)  	movq	8+64(%rsp),%r10
   72 (0.0%)  	leaq	0+64(%rsp),%rsi
   72 (0.0%)  	movq	16+64(%rsp),%r11
   72 (0.0%)  	movq	24+64(%rsp),%r12
   72 (0.0%)  	leaq	288(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
   72 (0.0%)  	movq	448(%rsp),%rax
   72 (0.0%)  	leaq	448(%rsp),%rbx
   72 (0.0%)  	movq	0+32(%rsp),%r9
   72 (0.0%)  	movq	8+32(%rsp),%r10
   72 (0.0%)  	leaq	0+32(%rsp),%rsi
   72 (0.0%)  	movq	16+32(%rsp),%r11
   72 (0.0%)  	movq	24+32(%rsp),%r12
   72 (0.0%)  	leaq	32(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
   72 (0.0%)  	leaq	352(%rsp),%rbx
   72 (0.0%)  	leaq	96(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
   72 (0.0%)  	movq	0+64(%rsp),%rax
   72 (0.0%)  	movq	8+64(%rsp),%r14
   72 (0.0%)  	leaq	0+64(%rsp),%rsi
   72 (0.0%)  	movq	16+64(%rsp),%r15
   72 (0.0%)  	movq	24+64(%rsp),%r8
   72 (0.0%)  	leaq	128(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
   72 (0.0%)  	movq	0+96(%rsp),%rax
   72 (0.0%)  	movq	8+96(%rsp),%r14
   72 (0.0%)  	leaq	0+96(%rsp),%rsi
   72 (0.0%)  	movq	16+96(%rsp),%r15
   72 (0.0%)  	movq	24+96(%rsp),%r8
   72 (0.0%)  	leaq	192(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_sqr_montq
    .         
   72 (0.0%)  	movq	128(%rsp),%rax
   72 (0.0%)  	leaq	128(%rsp),%rbx
   72 (0.0%)  	movq	0+64(%rsp),%r9
   72 (0.0%)  	movq	8+64(%rsp),%r10
   72 (0.0%)  	leaq	0+64(%rsp),%rsi
   72 (0.0%)  	movq	16+64(%rsp),%r11
   72 (0.0%)  	movq	24+64(%rsp),%r12
   72 (0.0%)  	leaq	160(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
   72 (0.0%)  	movq	320(%rsp),%rax
   72 (0.0%)  	leaq	320(%rsp),%rbx
   72 (0.0%)  	movq	0+128(%rsp),%r9
   72 (0.0%)  	movq	8+128(%rsp),%r10
   72 (0.0%)  	leaq	0+128(%rsp),%rsi
   72 (0.0%)  	movq	16+128(%rsp),%r11
   72 (0.0%)  	movq	24+128(%rsp),%r12
   72 (0.0%)  	leaq	0(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
    .         
    .         
    .         
   72 (0.0%)  	xorq	%r11,%r11
   72 (0.0%)  	addq	%r12,%r12
   72 (0.0%)  	leaq	192(%rsp),%rsi
   72 (0.0%)  	adcq	%r13,%r13
   72 (0.0%)  	movq	%r12,%rax
   72 (0.0%)  	adcq	%r8,%r8
   72 (0.0%)  	adcq	%r9,%r9
   72 (0.0%)  	movq	%r13,%rbp
   72 (0.0%)  	adcq	$0,%r11
    .         
   72 (0.0%)  	subq	$-1,%r12
   72 (0.0%)  	movq	%r8,%rcx
   72 (0.0%)  	sbbq	%r14,%r13
   72 (0.0%)  	sbbq	$0,%r8
   72 (0.0%)  	movq	%r9,%r10
   72 (0.0%)  	sbbq	%r15,%r9
   72 (0.0%)  	sbbq	$0,%r11
    .         
   72 (0.0%)  	cmovcq	%rax,%r12
   72 (0.0%)  	movq	0(%rsi),%rax
   72 (0.0%)  	cmovcq	%rbp,%r13
   72 (0.0%)  	movq	8(%rsi),%rbp
   72 (0.0%)  	cmovcq	%rcx,%r8
   72 (0.0%)  	movq	16(%rsi),%rcx
   72 (0.0%)  	cmovcq	%r10,%r9
   72 (0.0%)  	movq	24(%rsi),%r10
    .         
   72 (0.0%)  	call	__ecp_nistz256_subq
    .         
   72 (0.0%)  	leaq	160(%rsp),%rbx
   72 (0.0%)  	leaq	224(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
   72 (0.0%)  	movq	0+0(%rsp),%rax
   72 (0.0%)  	movq	0+8(%rsp),%rbp
   72 (0.0%)  	movq	0+16(%rsp),%rcx
   72 (0.0%)  	movq	0+24(%rsp),%r10
   72 (0.0%)  	leaq	64(%rsp),%rdi
    .         
   72 (0.0%)  	call	__ecp_nistz256_subq
    .         
   72 (0.0%)  	movq	%r12,0(%rdi)
   72 (0.0%)  	movq	%r13,8(%rdi)
   72 (0.0%)  	movq	%r8,16(%rdi)
   72 (0.0%)  	movq	%r9,24(%rdi)
   72 (0.0%)  	movq	352(%rsp),%rax
   72 (0.0%)  	leaq	352(%rsp),%rbx
   72 (0.0%)  	movq	0+160(%rsp),%r9
   72 (0.0%)  	movq	8+160(%rsp),%r10
   72 (0.0%)  	leaq	0+160(%rsp),%rsi
   72 (0.0%)  	movq	16+160(%rsp),%r11
   72 (0.0%)  	movq	24+160(%rsp),%r12
   72 (0.0%)  	leaq	32(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
   72 (0.0%)  	movq	96(%rsp),%rax
   72 (0.0%)  	leaq	96(%rsp),%rbx
   72 (0.0%)  	movq	0+64(%rsp),%r9
   72 (0.0%)  	movq	8+64(%rsp),%r10
   72 (0.0%)  	leaq	0+64(%rsp),%rsi
   72 (0.0%)  	movq	16+64(%rsp),%r11
   72 (0.0%)  	movq	24+64(%rsp),%r12
   72 (0.0%)  	leaq	64(%rsp),%rdi
   72 (0.0%)  	call	__ecp_nistz256_mul_montq
    .         
   72 (0.0%)  	leaq	32(%rsp),%rbx
   72 (0.0%)  	leaq	256(%rsp),%rdi
  144 (0.0%)  	call	__ecp_nistz256_sub_fromq
    .         
    .         .byte	102,72,15,126,199
    .         
   72 (0.0%)  	movdqa	%xmm5,%xmm0
   72 (0.0%)  	movdqa	%xmm5,%xmm1
   72 (0.0%)  	pandn	288(%rsp),%xmm0
   72 (0.0%)  	movdqa	%xmm5,%xmm2
   72 (0.0%)  	pandn	288+16(%rsp),%xmm1
   72 (0.0%)  	movdqa	%xmm5,%xmm3
   72 (0.0%)  	pand	.LONE_mont(%rip),%xmm2
   72 (0.0%)  	pand	.LONE_mont+16(%rip),%xmm3
   72 (0.0%)  	por	%xmm0,%xmm2
   72 (0.0%)  	por	%xmm1,%xmm3
    .         
   72 (0.0%)  	movdqa	%xmm4,%xmm0
   72 (0.0%)  	movdqa	%xmm4,%xmm1
   72 (0.0%)  	pandn	%xmm2,%xmm0
   72 (0.0%)  	movdqa	%xmm4,%xmm2
   72 (0.0%)  	pandn	%xmm3,%xmm1
   72 (0.0%)  	movdqa	%xmm4,%xmm3
   72 (0.0%)  	pand	384(%rsp),%xmm2
   72 (0.0%)  	pand	384+16(%rsp),%xmm3
   72 (0.0%)  	por	%xmm0,%xmm2
   72 (0.0%)  	por	%xmm1,%xmm3
   72 (0.0%)  	movdqu	%xmm2,64(%rdi)
   72 (0.0%)  	movdqu	%xmm3,80(%rdi)
    .         
   72 (0.0%)  	movdqa	%xmm5,%xmm0
   72 (0.0%)  	movdqa	%xmm5,%xmm1
   72 (0.0%)  	pandn	224(%rsp),%xmm0
   72 (0.0%)  	movdqa	%xmm5,%xmm2
   72 (0.0%)  	pandn	224+16(%rsp),%xmm1
   72 (0.0%)  	movdqa	%xmm5,%xmm3
   72 (0.0%)  	pand	416(%rsp),%xmm2
   72 (0.0%)  	pand	416+16(%rsp),%xmm3
   72 (0.0%)  	por	%xmm0,%xmm2
   72 (0.0%)  	por	%xmm1,%xmm3
    .         
   72 (0.0%)  	movdqa	%xmm4,%xmm0
   72 (0.0%)  	movdqa	%xmm4,%xmm1
   72 (0.0%)  	pandn	%xmm2,%xmm0
   72 (0.0%)  	movdqa	%xmm4,%xmm2
   72 (0.0%)  	pandn	%xmm3,%xmm1
   72 (0.0%)  	movdqa	%xmm4,%xmm3
   72 (0.0%)  	pand	320(%rsp),%xmm2
   72 (0.0%)  	pand	320+16(%rsp),%xmm3
   72 (0.0%)  	por	%xmm0,%xmm2
   72 (0.0%)  	por	%xmm1,%xmm3
   72 (0.0%)  	movdqu	%xmm2,0(%rdi)
   72 (0.0%)  	movdqu	%xmm3,16(%rdi)
    .         
   72 (0.0%)  	movdqa	%xmm5,%xmm0
   72 (0.0%)  	movdqa	%xmm5,%xmm1
   72 (0.0%)  	pandn	256(%rsp),%xmm0
   72 (0.0%)  	movdqa	%xmm5,%xmm2
   72 (0.0%)  	pandn	256+16(%rsp),%xmm1
   72 (0.0%)  	movdqa	%xmm5,%xmm3
   72 (0.0%)  	pand	448(%rsp),%xmm2
   72 (0.0%)  	pand	448+16(%rsp),%xmm3
   72 (0.0%)  	por	%xmm0,%xmm2
   72 (0.0%)  	por	%xmm1,%xmm3
    .         
   72 (0.0%)  	movdqa	%xmm4,%xmm0
   72 (0.0%)  	movdqa	%xmm4,%xmm1
   72 (0.0%)  	pandn	%xmm2,%xmm0
   72 (0.0%)  	movdqa	%xmm4,%xmm2
   72 (0.0%)  	pandn	%xmm3,%xmm1
   72 (0.0%)  	movdqa	%xmm4,%xmm3
   72 (0.0%)  	pand	352(%rsp),%xmm2
   72 (0.0%)  	pand	352+16(%rsp),%xmm3
   72 (0.0%)  	por	%xmm0,%xmm2
   72 (0.0%)  	por	%xmm1,%xmm3
   72 (0.0%)  	movdqu	%xmm2,32(%rdi)
   72 (0.0%)  	movdqu	%xmm3,48(%rdi)
    .         
   72 (0.0%)  	leaq	480+56(%rsp),%rsi
    .         .cfi_def_cfa	%rsi,8
   72 (0.0%)  	movq	-48(%rsi),%r15
    .         .cfi_restore	%r15
   72 (0.0%)  	movq	-40(%rsi),%r14
    .         .cfi_restore	%r14
   72 (0.0%)  	movq	-32(%rsi),%r13
    .         .cfi_restore	%r13
   72 (0.0%)  	movq	-24(%rsi),%r12
    .         .cfi_restore	%r12
   72 (0.0%)  	movq	-16(%rsi),%rbx
    .         .cfi_restore	%rbx
   72 (0.0%)  	movq	-8(%rsi),%rbp
    .         .cfi_restore	%rbp
  144 (0.0%)  	leaq	(%rsi),%rsp
    .         .cfi_def_cfa_register	%rsp
    .         .Ladd_affineq_epilogue:
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	ecp_nistz256_point_add_affine,.-ecp_nistz256_point_add_affine
    .         .type	__ecp_nistz256_add_tox,@function
    .         .align	32
    .         __ecp_nistz256_add_tox:
-- line 3417 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha256-x86_64.S
--------------------------------------------------------------------------------
Ir__________ 

-- line 9 ----------------------------------------
    .         .extern	OPENSSL_ia32cap_P
    .         .hidden OPENSSL_ia32cap_P
    .         .globl	sha256_block_data_order
    .         .hidden sha256_block_data_order
    .         .type	sha256_block_data_order,@function
    .         .align	16
    .         sha256_block_data_order:
    .         .cfi_startproc	
  283 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r11
  283 (0.0%)  	movl	0(%r11),%r9d
  283 (0.0%)  	movl	4(%r11),%r10d
  283 (0.0%)  	movl	8(%r11),%r11d
  283 (0.0%)  	testl	$536870912,%r11d
  283 (0.0%)  	jnz	.Lshaext_shortcut
  283 (0.0%)  	andl	$1073741824,%r9d
  283 (0.0%)  	andl	$268435968,%r10d
  283 (0.0%)  	orl	%r9d,%r10d
  283 (0.0%)  	cmpl	$1342177792,%r10d
  283 (0.0%)  	je	.Lavx_shortcut
    .         	testl	$512,%r10d
    .         	jnz	.Lssse3_shortcut
    .         	movq	%rsp,%rax
    .         .cfi_def_cfa_register	%rax
    .         	pushq	%rbx
    .         .cfi_offset	%rbx,-16
    .         	pushq	%rbp
    .         .cfi_offset	%rbp,-24
-- line 35 ----------------------------------------
-- line 3105 ----------------------------------------
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	sha256_block_data_order_ssse3,.-sha256_block_data_order_ssse3
    .         .type	sha256_block_data_order_avx,@function
    .         .align	64
    .         sha256_block_data_order_avx:
    .         .cfi_startproc	
    .         .Lavx_shortcut:
  283 (0.0%)  	movq	%rsp,%rax
    .         .cfi_def_cfa_register	%rax
  283 (0.0%)  	pushq	%rbx
    .         .cfi_offset	%rbx,-16
  283 (0.0%)  	pushq	%rbp
    .         .cfi_offset	%rbp,-24
  283 (0.0%)  	pushq	%r12
    .         .cfi_offset	%r12,-32
  283 (0.0%)  	pushq	%r13
    .         .cfi_offset	%r13,-40
  283 (0.0%)  	pushq	%r14
    .         .cfi_offset	%r14,-48
  283 (0.0%)  	pushq	%r15
    .         .cfi_offset	%r15,-56
  283 (0.0%)  	shlq	$4,%rdx
  283 (0.0%)  	subq	$96,%rsp
  283 (0.0%)  	leaq	(%rsi,%rdx,4),%rdx
  283 (0.0%)  	andq	$-64,%rsp
  283 (0.0%)  	movq	%rdi,64+0(%rsp)
  283 (0.0%)  	movq	%rsi,64+8(%rsp)
  283 (0.0%)  	movq	%rdx,64+16(%rsp)
  283 (0.0%)  	movq	%rax,88(%rsp)
    .         .cfi_escape	0x0f,0x06,0x77,0xd8,0x00,0x06,0x23,0x08
    .         .Lprologue_avx:
    .         
  283 (0.0%)  	vzeroupper
  283 (0.0%)  	movl	0(%rdi),%eax
  283 (0.0%)  	movl	4(%rdi),%ebx
  283 (0.0%)  	movl	8(%rdi),%ecx
  283 (0.0%)  	movl	12(%rdi),%edx
  283 (0.0%)  	movl	16(%rdi),%r8d
  283 (0.0%)  	movl	20(%rdi),%r9d
  283 (0.0%)  	movl	24(%rdi),%r10d
  283 (0.0%)  	movl	28(%rdi),%r11d
  283 (0.0%)  	vmovdqa	K256+512+32(%rip),%xmm8
  283 (0.0%)  	vmovdqa	K256+512+64(%rip),%xmm9
  283 (0.0%)  	jmp	.Lloop_avx
    .         .align	16
    .         .Lloop_avx:
  414 (0.0%)  	vmovdqa	K256+512(%rip),%xmm7
  414 (0.0%)  	vmovdqu	0(%rsi),%xmm0
  414 (0.0%)  	vmovdqu	16(%rsi),%xmm1
  414 (0.0%)  	vmovdqu	32(%rsi),%xmm2
  414 (0.0%)  	vmovdqu	48(%rsi),%xmm3
  414 (0.0%)  	vpshufb	%xmm7,%xmm0,%xmm0
  414 (0.0%)  	leaq	K256(%rip),%rbp
  414 (0.0%)  	vpshufb	%xmm7,%xmm1,%xmm1
  414 (0.0%)  	vpshufb	%xmm7,%xmm2,%xmm2
  414 (0.0%)  	vpaddd	0(%rbp),%xmm0,%xmm4
  414 (0.0%)  	vpshufb	%xmm7,%xmm3,%xmm3
  414 (0.0%)  	vpaddd	32(%rbp),%xmm1,%xmm5
  414 (0.0%)  	vpaddd	64(%rbp),%xmm2,%xmm6
  414 (0.0%)  	vpaddd	96(%rbp),%xmm3,%xmm7
  414 (0.0%)  	vmovdqa	%xmm4,0(%rsp)
  414 (0.0%)  	movl	%eax,%r14d
  414 (0.0%)  	vmovdqa	%xmm5,16(%rsp)
  414 (0.0%)  	movl	%ebx,%edi
  414 (0.0%)  	vmovdqa	%xmm6,32(%rsp)
  414 (0.0%)  	xorl	%ecx,%edi
  414 (0.0%)  	vmovdqa	%xmm7,48(%rsp)
  414 (0.0%)  	movl	%r8d,%r13d
  414 (0.0%)  	jmp	.Lavx_00_47
    .         
    .         .align	16
    .         .Lavx_00_47:
1,242 (0.0%)  	subq	$-128,%rbp
1,242 (0.0%)  	vpalignr	$4,%xmm0,%xmm1,%xmm4
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	movl	%r14d,%eax
1,242 (0.0%)  	movl	%r9d,%r12d
1,242 (0.0%)  	vpalignr	$4,%xmm2,%xmm3,%xmm7
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	xorl	%r8d,%r13d
1,242 (0.0%)  	xorl	%r10d,%r12d
1,242 (0.0%)  	vpsrld	$7,%xmm4,%xmm6
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	xorl	%eax,%r14d
1,242 (0.0%)  	andl	%r8d,%r12d
1,242 (0.0%)  	vpaddd	%xmm7,%xmm0,%xmm0
1,242 (0.0%)  	xorl	%r8d,%r13d
1,242 (0.0%)  	addl	0(%rsp),%r11d
1,242 (0.0%)  	movl	%eax,%r15d
1,242 (0.0%)  	vpsrld	$3,%xmm4,%xmm7
1,242 (0.0%)  	xorl	%r10d,%r12d
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	xorl	%ebx,%r15d
1,242 (0.0%)  	vpslld	$14,%xmm4,%xmm5
1,242 (0.0%)  	addl	%r12d,%r11d
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	andl	%r15d,%edi
1,242 (0.0%)  	vpxor	%xmm6,%xmm7,%xmm4
1,242 (0.0%)  	xorl	%eax,%r14d
1,242 (0.0%)  	addl	%r13d,%r11d
1,242 (0.0%)  	xorl	%ebx,%edi
1,242 (0.0%)  	vpshufd	$250,%xmm3,%xmm7
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	addl	%r11d,%edx
1,242 (0.0%)  	addl	%edi,%r11d
1,242 (0.0%)  	vpsrld	$11,%xmm6,%xmm6
1,242 (0.0%)  	movl	%edx,%r13d
1,242 (0.0%)  	addl	%r11d,%r14d
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
1,242 (0.0%)  	movl	%r14d,%r11d
1,242 (0.0%)  	movl	%r8d,%r12d
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	vpslld	$11,%xmm5,%xmm5
1,242 (0.0%)  	xorl	%edx,%r13d
1,242 (0.0%)  	xorl	%r9d,%r12d
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	vpxor	%xmm6,%xmm4,%xmm4
1,242 (0.0%)  	xorl	%r11d,%r14d
1,242 (0.0%)  	andl	%edx,%r12d
1,242 (0.0%)  	xorl	%edx,%r13d
1,242 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
1,242 (0.0%)  	addl	4(%rsp),%r10d
1,242 (0.0%)  	movl	%r11d,%edi
1,242 (0.0%)  	xorl	%r9d,%r12d
1,242 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	xorl	%eax,%edi
1,242 (0.0%)  	addl	%r12d,%r10d
1,242 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	andl	%edi,%r15d
1,242 (0.0%)  	xorl	%r11d,%r14d
1,242 (0.0%)  	vpaddd	%xmm4,%xmm0,%xmm0
1,242 (0.0%)  	addl	%r13d,%r10d
1,242 (0.0%)  	xorl	%eax,%r15d
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	addl	%r10d,%ecx
1,242 (0.0%)  	addl	%r15d,%r10d
1,242 (0.0%)  	movl	%ecx,%r13d
1,242 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
1,242 (0.0%)  	addl	%r10d,%r14d
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	movl	%r14d,%r10d
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	movl	%edx,%r12d
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	xorl	%ecx,%r13d
1,242 (0.0%)  	vpshufb	%xmm8,%xmm6,%xmm6
1,242 (0.0%)  	xorl	%r8d,%r12d
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	xorl	%r10d,%r14d
1,242 (0.0%)  	vpaddd	%xmm6,%xmm0,%xmm0
1,242 (0.0%)  	andl	%ecx,%r12d
1,242 (0.0%)  	xorl	%ecx,%r13d
1,242 (0.0%)  	addl	8(%rsp),%r9d
1,242 (0.0%)  	vpshufd	$80,%xmm0,%xmm7
1,242 (0.0%)  	movl	%r10d,%r15d
1,242 (0.0%)  	xorl	%r8d,%r12d
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
1,242 (0.0%)  	xorl	%r11d,%r15d
1,242 (0.0%)  	addl	%r12d,%r9d
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
1,242 (0.0%)  	andl	%r15d,%edi
1,242 (0.0%)  	xorl	%r10d,%r14d
1,242 (0.0%)  	addl	%r13d,%r9d
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	xorl	%r11d,%edi
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	addl	%r9d,%ebx
1,242 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
1,242 (0.0%)  	addl	%edi,%r9d
1,242 (0.0%)  	movl	%ebx,%r13d
1,242 (0.0%)  	addl	%r9d,%r14d
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	movl	%r14d,%r9d
1,242 (0.0%)  	movl	%ecx,%r12d
1,242 (0.0%)  	vpshufb	%xmm9,%xmm6,%xmm6
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	xorl	%ebx,%r13d
1,242 (0.0%)  	xorl	%edx,%r12d
1,242 (0.0%)  	vpaddd	%xmm6,%xmm0,%xmm0
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	xorl	%r9d,%r14d
1,242 (0.0%)  	andl	%ebx,%r12d
1,242 (0.0%)  	vpaddd	0(%rbp),%xmm0,%xmm6
1,242 (0.0%)  	xorl	%ebx,%r13d
1,242 (0.0%)  	addl	12(%rsp),%r8d
1,242 (0.0%)  	movl	%r9d,%edi
1,242 (0.0%)  	xorl	%edx,%r12d
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	xorl	%r10d,%edi
1,242 (0.0%)  	addl	%r12d,%r8d
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	andl	%edi,%r15d
1,242 (0.0%)  	xorl	%r9d,%r14d
1,242 (0.0%)  	addl	%r13d,%r8d
1,242 (0.0%)  	xorl	%r10d,%r15d
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	addl	%r8d,%eax
1,242 (0.0%)  	addl	%r15d,%r8d
1,242 (0.0%)  	movl	%eax,%r13d
1,242 (0.0%)  	addl	%r8d,%r14d
1,242 (0.0%)  	vmovdqa	%xmm6,0(%rsp)
1,242 (0.0%)  	vpalignr	$4,%xmm1,%xmm2,%xmm4
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	movl	%r14d,%r8d
1,242 (0.0%)  	movl	%ebx,%r12d
1,242 (0.0%)  	vpalignr	$4,%xmm3,%xmm0,%xmm7
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	xorl	%eax,%r13d
1,242 (0.0%)  	xorl	%ecx,%r12d
1,242 (0.0%)  	vpsrld	$7,%xmm4,%xmm6
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	xorl	%r8d,%r14d
1,242 (0.0%)  	andl	%eax,%r12d
1,242 (0.0%)  	vpaddd	%xmm7,%xmm1,%xmm1
1,242 (0.0%)  	xorl	%eax,%r13d
1,242 (0.0%)  	addl	16(%rsp),%edx
1,242 (0.0%)  	movl	%r8d,%r15d
1,242 (0.0%)  	vpsrld	$3,%xmm4,%xmm7
1,242 (0.0%)  	xorl	%ecx,%r12d
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	xorl	%r9d,%r15d
1,242 (0.0%)  	vpslld	$14,%xmm4,%xmm5
1,242 (0.0%)  	addl	%r12d,%edx
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	andl	%r15d,%edi
1,242 (0.0%)  	vpxor	%xmm6,%xmm7,%xmm4
1,242 (0.0%)  	xorl	%r8d,%r14d
1,242 (0.0%)  	addl	%r13d,%edx
1,242 (0.0%)  	xorl	%r9d,%edi
1,242 (0.0%)  	vpshufd	$250,%xmm0,%xmm7
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	addl	%edx,%r11d
1,242 (0.0%)  	addl	%edi,%edx
1,242 (0.0%)  	vpsrld	$11,%xmm6,%xmm6
1,242 (0.0%)  	movl	%r11d,%r13d
1,242 (0.0%)  	addl	%edx,%r14d
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
1,242 (0.0%)  	movl	%r14d,%edx
1,242 (0.0%)  	movl	%eax,%r12d
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	vpslld	$11,%xmm5,%xmm5
1,242 (0.0%)  	xorl	%r11d,%r13d
1,242 (0.0%)  	xorl	%ebx,%r12d
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	vpxor	%xmm6,%xmm4,%xmm4
1,242 (0.0%)  	xorl	%edx,%r14d
1,242 (0.0%)  	andl	%r11d,%r12d
1,242 (0.0%)  	xorl	%r11d,%r13d
1,242 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
1,242 (0.0%)  	addl	20(%rsp),%ecx
1,242 (0.0%)  	movl	%edx,%edi
1,242 (0.0%)  	xorl	%ebx,%r12d
1,242 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	xorl	%r8d,%edi
1,242 (0.0%)  	addl	%r12d,%ecx
1,242 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	andl	%edi,%r15d
1,242 (0.0%)  	xorl	%edx,%r14d
1,242 (0.0%)  	vpaddd	%xmm4,%xmm1,%xmm1
1,242 (0.0%)  	addl	%r13d,%ecx
1,242 (0.0%)  	xorl	%r8d,%r15d
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	addl	%ecx,%r10d
1,242 (0.0%)  	addl	%r15d,%ecx
1,242 (0.0%)  	movl	%r10d,%r13d
1,242 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
1,242 (0.0%)  	addl	%ecx,%r14d
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	movl	%r14d,%ecx
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	movl	%r11d,%r12d
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	xorl	%r10d,%r13d
1,242 (0.0%)  	vpshufb	%xmm8,%xmm6,%xmm6
1,242 (0.0%)  	xorl	%eax,%r12d
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	xorl	%ecx,%r14d
1,242 (0.0%)  	vpaddd	%xmm6,%xmm1,%xmm1
1,242 (0.0%)  	andl	%r10d,%r12d
1,242 (0.0%)  	xorl	%r10d,%r13d
1,242 (0.0%)  	addl	24(%rsp),%ebx
1,242 (0.0%)  	vpshufd	$80,%xmm1,%xmm7
1,242 (0.0%)  	movl	%ecx,%r15d
1,242 (0.0%)  	xorl	%eax,%r12d
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
1,242 (0.0%)  	xorl	%edx,%r15d
1,242 (0.0%)  	addl	%r12d,%ebx
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
1,242 (0.0%)  	andl	%r15d,%edi
1,242 (0.0%)  	xorl	%ecx,%r14d
1,242 (0.0%)  	addl	%r13d,%ebx
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	xorl	%edx,%edi
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	addl	%ebx,%r9d
1,242 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
1,242 (0.0%)  	addl	%edi,%ebx
1,242 (0.0%)  	movl	%r9d,%r13d
1,242 (0.0%)  	addl	%ebx,%r14d
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	movl	%r14d,%ebx
1,242 (0.0%)  	movl	%r10d,%r12d
1,242 (0.0%)  	vpshufb	%xmm9,%xmm6,%xmm6
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	xorl	%r9d,%r13d
1,242 (0.0%)  	xorl	%r11d,%r12d
1,242 (0.0%)  	vpaddd	%xmm6,%xmm1,%xmm1
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	xorl	%ebx,%r14d
1,242 (0.0%)  	andl	%r9d,%r12d
1,242 (0.0%)  	vpaddd	32(%rbp),%xmm1,%xmm6
1,242 (0.0%)  	xorl	%r9d,%r13d
1,242 (0.0%)  	addl	28(%rsp),%eax
1,242 (0.0%)  	movl	%ebx,%edi
1,242 (0.0%)  	xorl	%r11d,%r12d
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	xorl	%ecx,%edi
1,242 (0.0%)  	addl	%r12d,%eax
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	andl	%edi,%r15d
1,242 (0.0%)  	xorl	%ebx,%r14d
1,242 (0.0%)  	addl	%r13d,%eax
1,242 (0.0%)  	xorl	%ecx,%r15d
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	addl	%eax,%r8d
1,242 (0.0%)  	addl	%r15d,%eax
1,242 (0.0%)  	movl	%r8d,%r13d
1,242 (0.0%)  	addl	%eax,%r14d
1,242 (0.0%)  	vmovdqa	%xmm6,16(%rsp)
1,242 (0.0%)  	vpalignr	$4,%xmm2,%xmm3,%xmm4
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	movl	%r14d,%eax
1,242 (0.0%)  	movl	%r9d,%r12d
1,242 (0.0%)  	vpalignr	$4,%xmm0,%xmm1,%xmm7
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	xorl	%r8d,%r13d
1,242 (0.0%)  	xorl	%r10d,%r12d
1,242 (0.0%)  	vpsrld	$7,%xmm4,%xmm6
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	xorl	%eax,%r14d
1,242 (0.0%)  	andl	%r8d,%r12d
1,242 (0.0%)  	vpaddd	%xmm7,%xmm2,%xmm2
1,242 (0.0%)  	xorl	%r8d,%r13d
1,242 (0.0%)  	addl	32(%rsp),%r11d
1,242 (0.0%)  	movl	%eax,%r15d
1,242 (0.0%)  	vpsrld	$3,%xmm4,%xmm7
1,242 (0.0%)  	xorl	%r10d,%r12d
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	xorl	%ebx,%r15d
1,242 (0.0%)  	vpslld	$14,%xmm4,%xmm5
1,242 (0.0%)  	addl	%r12d,%r11d
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	andl	%r15d,%edi
1,242 (0.0%)  	vpxor	%xmm6,%xmm7,%xmm4
1,242 (0.0%)  	xorl	%eax,%r14d
1,242 (0.0%)  	addl	%r13d,%r11d
1,242 (0.0%)  	xorl	%ebx,%edi
1,242 (0.0%)  	vpshufd	$250,%xmm1,%xmm7
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	addl	%r11d,%edx
1,242 (0.0%)  	addl	%edi,%r11d
1,242 (0.0%)  	vpsrld	$11,%xmm6,%xmm6
1,242 (0.0%)  	movl	%edx,%r13d
1,242 (0.0%)  	addl	%r11d,%r14d
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
1,242 (0.0%)  	movl	%r14d,%r11d
1,242 (0.0%)  	movl	%r8d,%r12d
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	vpslld	$11,%xmm5,%xmm5
1,242 (0.0%)  	xorl	%edx,%r13d
1,242 (0.0%)  	xorl	%r9d,%r12d
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	vpxor	%xmm6,%xmm4,%xmm4
1,242 (0.0%)  	xorl	%r11d,%r14d
1,242 (0.0%)  	andl	%edx,%r12d
1,242 (0.0%)  	xorl	%edx,%r13d
1,242 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
1,242 (0.0%)  	addl	36(%rsp),%r10d
1,242 (0.0%)  	movl	%r11d,%edi
1,242 (0.0%)  	xorl	%r9d,%r12d
1,242 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	xorl	%eax,%edi
1,242 (0.0%)  	addl	%r12d,%r10d
1,242 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	andl	%edi,%r15d
1,242 (0.0%)  	xorl	%r11d,%r14d
1,242 (0.0%)  	vpaddd	%xmm4,%xmm2,%xmm2
1,242 (0.0%)  	addl	%r13d,%r10d
1,242 (0.0%)  	xorl	%eax,%r15d
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	addl	%r10d,%ecx
1,242 (0.0%)  	addl	%r15d,%r10d
1,242 (0.0%)  	movl	%ecx,%r13d
1,242 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
1,242 (0.0%)  	addl	%r10d,%r14d
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	movl	%r14d,%r10d
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	movl	%edx,%r12d
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	xorl	%ecx,%r13d
1,242 (0.0%)  	vpshufb	%xmm8,%xmm6,%xmm6
1,242 (0.0%)  	xorl	%r8d,%r12d
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	xorl	%r10d,%r14d
1,242 (0.0%)  	vpaddd	%xmm6,%xmm2,%xmm2
1,242 (0.0%)  	andl	%ecx,%r12d
1,242 (0.0%)  	xorl	%ecx,%r13d
1,242 (0.0%)  	addl	40(%rsp),%r9d
1,242 (0.0%)  	vpshufd	$80,%xmm2,%xmm7
1,242 (0.0%)  	movl	%r10d,%r15d
1,242 (0.0%)  	xorl	%r8d,%r12d
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
1,242 (0.0%)  	xorl	%r11d,%r15d
1,242 (0.0%)  	addl	%r12d,%r9d
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
1,242 (0.0%)  	andl	%r15d,%edi
1,242 (0.0%)  	xorl	%r10d,%r14d
1,242 (0.0%)  	addl	%r13d,%r9d
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	xorl	%r11d,%edi
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	addl	%r9d,%ebx
1,242 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
1,242 (0.0%)  	addl	%edi,%r9d
1,242 (0.0%)  	movl	%ebx,%r13d
1,242 (0.0%)  	addl	%r9d,%r14d
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	movl	%r14d,%r9d
1,242 (0.0%)  	movl	%ecx,%r12d
1,242 (0.0%)  	vpshufb	%xmm9,%xmm6,%xmm6
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	xorl	%ebx,%r13d
1,242 (0.0%)  	xorl	%edx,%r12d
1,242 (0.0%)  	vpaddd	%xmm6,%xmm2,%xmm2
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	xorl	%r9d,%r14d
1,242 (0.0%)  	andl	%ebx,%r12d
1,242 (0.0%)  	vpaddd	64(%rbp),%xmm2,%xmm6
1,242 (0.0%)  	xorl	%ebx,%r13d
1,242 (0.0%)  	addl	44(%rsp),%r8d
1,242 (0.0%)  	movl	%r9d,%edi
1,242 (0.0%)  	xorl	%edx,%r12d
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	xorl	%r10d,%edi
1,242 (0.0%)  	addl	%r12d,%r8d
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	andl	%edi,%r15d
1,242 (0.0%)  	xorl	%r9d,%r14d
1,242 (0.0%)  	addl	%r13d,%r8d
1,242 (0.0%)  	xorl	%r10d,%r15d
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	addl	%r8d,%eax
1,242 (0.0%)  	addl	%r15d,%r8d
1,242 (0.0%)  	movl	%eax,%r13d
1,242 (0.0%)  	addl	%r8d,%r14d
1,242 (0.0%)  	vmovdqa	%xmm6,32(%rsp)
1,242 (0.0%)  	vpalignr	$4,%xmm3,%xmm0,%xmm4
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	movl	%r14d,%r8d
1,242 (0.0%)  	movl	%ebx,%r12d
1,242 (0.0%)  	vpalignr	$4,%xmm1,%xmm2,%xmm7
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	xorl	%eax,%r13d
1,242 (0.0%)  	xorl	%ecx,%r12d
1,242 (0.0%)  	vpsrld	$7,%xmm4,%xmm6
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	xorl	%r8d,%r14d
1,242 (0.0%)  	andl	%eax,%r12d
1,242 (0.0%)  	vpaddd	%xmm7,%xmm3,%xmm3
1,242 (0.0%)  	xorl	%eax,%r13d
1,242 (0.0%)  	addl	48(%rsp),%edx
1,242 (0.0%)  	movl	%r8d,%r15d
1,242 (0.0%)  	vpsrld	$3,%xmm4,%xmm7
1,242 (0.0%)  	xorl	%ecx,%r12d
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	xorl	%r9d,%r15d
1,242 (0.0%)  	vpslld	$14,%xmm4,%xmm5
1,242 (0.0%)  	addl	%r12d,%edx
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	andl	%r15d,%edi
1,242 (0.0%)  	vpxor	%xmm6,%xmm7,%xmm4
1,242 (0.0%)  	xorl	%r8d,%r14d
1,242 (0.0%)  	addl	%r13d,%edx
1,242 (0.0%)  	xorl	%r9d,%edi
1,242 (0.0%)  	vpshufd	$250,%xmm2,%xmm7
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	addl	%edx,%r11d
1,242 (0.0%)  	addl	%edi,%edx
1,242 (0.0%)  	vpsrld	$11,%xmm6,%xmm6
1,242 (0.0%)  	movl	%r11d,%r13d
1,242 (0.0%)  	addl	%edx,%r14d
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
1,242 (0.0%)  	movl	%r14d,%edx
1,242 (0.0%)  	movl	%eax,%r12d
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	vpslld	$11,%xmm5,%xmm5
1,242 (0.0%)  	xorl	%r11d,%r13d
1,242 (0.0%)  	xorl	%ebx,%r12d
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	vpxor	%xmm6,%xmm4,%xmm4
1,242 (0.0%)  	xorl	%edx,%r14d
1,242 (0.0%)  	andl	%r11d,%r12d
1,242 (0.0%)  	xorl	%r11d,%r13d
1,242 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
1,242 (0.0%)  	addl	52(%rsp),%ecx
1,242 (0.0%)  	movl	%edx,%edi
1,242 (0.0%)  	xorl	%ebx,%r12d
1,242 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	xorl	%r8d,%edi
1,242 (0.0%)  	addl	%r12d,%ecx
1,242 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	andl	%edi,%r15d
1,242 (0.0%)  	xorl	%edx,%r14d
1,242 (0.0%)  	vpaddd	%xmm4,%xmm3,%xmm3
1,242 (0.0%)  	addl	%r13d,%ecx
1,242 (0.0%)  	xorl	%r8d,%r15d
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	addl	%ecx,%r10d
1,242 (0.0%)  	addl	%r15d,%ecx
1,242 (0.0%)  	movl	%r10d,%r13d
1,242 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
1,242 (0.0%)  	addl	%ecx,%r14d
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	movl	%r14d,%ecx
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	movl	%r11d,%r12d
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	xorl	%r10d,%r13d
1,242 (0.0%)  	vpshufb	%xmm8,%xmm6,%xmm6
1,242 (0.0%)  	xorl	%eax,%r12d
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	xorl	%ecx,%r14d
1,242 (0.0%)  	vpaddd	%xmm6,%xmm3,%xmm3
1,242 (0.0%)  	andl	%r10d,%r12d
1,242 (0.0%)  	xorl	%r10d,%r13d
1,242 (0.0%)  	addl	56(%rsp),%ebx
1,242 (0.0%)  	vpshufd	$80,%xmm3,%xmm7
1,242 (0.0%)  	movl	%ecx,%r15d
1,242 (0.0%)  	xorl	%eax,%r12d
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
1,242 (0.0%)  	xorl	%edx,%r15d
1,242 (0.0%)  	addl	%r12d,%ebx
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
1,242 (0.0%)  	andl	%r15d,%edi
1,242 (0.0%)  	xorl	%ecx,%r14d
1,242 (0.0%)  	addl	%r13d,%ebx
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	xorl	%edx,%edi
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	addl	%ebx,%r9d
1,242 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
1,242 (0.0%)  	addl	%edi,%ebx
1,242 (0.0%)  	movl	%r9d,%r13d
1,242 (0.0%)  	addl	%ebx,%r14d
1,242 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
1,242 (0.0%)  	shrdl	$14,%r13d,%r13d
1,242 (0.0%)  	movl	%r14d,%ebx
1,242 (0.0%)  	movl	%r10d,%r12d
1,242 (0.0%)  	vpshufb	%xmm9,%xmm6,%xmm6
1,242 (0.0%)  	shrdl	$9,%r14d,%r14d
1,242 (0.0%)  	xorl	%r9d,%r13d
1,242 (0.0%)  	xorl	%r11d,%r12d
1,242 (0.0%)  	vpaddd	%xmm6,%xmm3,%xmm3
1,242 (0.0%)  	shrdl	$5,%r13d,%r13d
1,242 (0.0%)  	xorl	%ebx,%r14d
1,242 (0.0%)  	andl	%r9d,%r12d
1,242 (0.0%)  	vpaddd	96(%rbp),%xmm3,%xmm6
1,242 (0.0%)  	xorl	%r9d,%r13d
1,242 (0.0%)  	addl	60(%rsp),%eax
1,242 (0.0%)  	movl	%ebx,%edi
1,242 (0.0%)  	xorl	%r11d,%r12d
1,242 (0.0%)  	shrdl	$11,%r14d,%r14d
1,242 (0.0%)  	xorl	%ecx,%edi
1,242 (0.0%)  	addl	%r12d,%eax
1,242 (0.0%)  	shrdl	$6,%r13d,%r13d
1,242 (0.0%)  	andl	%edi,%r15d
1,242 (0.0%)  	xorl	%ebx,%r14d
1,242 (0.0%)  	addl	%r13d,%eax
1,242 (0.0%)  	xorl	%ecx,%r15d
1,242 (0.0%)  	shrdl	$2,%r14d,%r14d
1,242 (0.0%)  	addl	%eax,%r8d
1,242 (0.0%)  	addl	%r15d,%eax
1,242 (0.0%)  	movl	%r8d,%r13d
1,242 (0.0%)  	addl	%eax,%r14d
1,242 (0.0%)  	vmovdqa	%xmm6,48(%rsp)
1,242 (0.0%)  	cmpb	$0,131(%rbp)
1,242 (0.0%)  	jne	.Lavx_00_47
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%eax
  414 (0.0%)  	movl	%r9d,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%r8d,%r13d
  414 (0.0%)  	xorl	%r10d,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%eax,%r14d
  414 (0.0%)  	andl	%r8d,%r12d
  414 (0.0%)  	xorl	%r8d,%r13d
  414 (0.0%)  	addl	0(%rsp),%r11d
  414 (0.0%)  	movl	%eax,%r15d
  414 (0.0%)  	xorl	%r10d,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%ebx,%r15d
  414 (0.0%)  	addl	%r12d,%r11d
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%r15d,%edi
  414 (0.0%)  	xorl	%eax,%r14d
  414 (0.0%)  	addl	%r13d,%r11d
  414 (0.0%)  	xorl	%ebx,%edi
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%r11d,%edx
  414 (0.0%)  	addl	%edi,%r11d
  414 (0.0%)  	movl	%edx,%r13d
  414 (0.0%)  	addl	%r11d,%r14d
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%r11d
  414 (0.0%)  	movl	%r8d,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%edx,%r13d
  414 (0.0%)  	xorl	%r9d,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%r11d,%r14d
  414 (0.0%)  	andl	%edx,%r12d
  414 (0.0%)  	xorl	%edx,%r13d
  414 (0.0%)  	addl	4(%rsp),%r10d
  414 (0.0%)  	movl	%r11d,%edi
  414 (0.0%)  	xorl	%r9d,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%eax,%edi
  414 (0.0%)  	addl	%r12d,%r10d
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%edi,%r15d
  414 (0.0%)  	xorl	%r11d,%r14d
  414 (0.0%)  	addl	%r13d,%r10d
  414 (0.0%)  	xorl	%eax,%r15d
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%r10d,%ecx
  414 (0.0%)  	addl	%r15d,%r10d
  414 (0.0%)  	movl	%ecx,%r13d
  414 (0.0%)  	addl	%r10d,%r14d
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%r10d
  414 (0.0%)  	movl	%edx,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%ecx,%r13d
  414 (0.0%)  	xorl	%r8d,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%r10d,%r14d
  414 (0.0%)  	andl	%ecx,%r12d
  414 (0.0%)  	xorl	%ecx,%r13d
  414 (0.0%)  	addl	8(%rsp),%r9d
  414 (0.0%)  	movl	%r10d,%r15d
  414 (0.0%)  	xorl	%r8d,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%r11d,%r15d
  414 (0.0%)  	addl	%r12d,%r9d
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%r15d,%edi
  414 (0.0%)  	xorl	%r10d,%r14d
  414 (0.0%)  	addl	%r13d,%r9d
  414 (0.0%)  	xorl	%r11d,%edi
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%r9d,%ebx
  414 (0.0%)  	addl	%edi,%r9d
  414 (0.0%)  	movl	%ebx,%r13d
  414 (0.0%)  	addl	%r9d,%r14d
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%r9d
  414 (0.0%)  	movl	%ecx,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%ebx,%r13d
  414 (0.0%)  	xorl	%edx,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%r9d,%r14d
  414 (0.0%)  	andl	%ebx,%r12d
  414 (0.0%)  	xorl	%ebx,%r13d
  414 (0.0%)  	addl	12(%rsp),%r8d
  414 (0.0%)  	movl	%r9d,%edi
  414 (0.0%)  	xorl	%edx,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%r10d,%edi
  414 (0.0%)  	addl	%r12d,%r8d
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%edi,%r15d
  414 (0.0%)  	xorl	%r9d,%r14d
  414 (0.0%)  	addl	%r13d,%r8d
  414 (0.0%)  	xorl	%r10d,%r15d
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%r8d,%eax
  414 (0.0%)  	addl	%r15d,%r8d
  414 (0.0%)  	movl	%eax,%r13d
  414 (0.0%)  	addl	%r8d,%r14d
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%r8d
  414 (0.0%)  	movl	%ebx,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%eax,%r13d
  414 (0.0%)  	xorl	%ecx,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%r8d,%r14d
  414 (0.0%)  	andl	%eax,%r12d
  414 (0.0%)  	xorl	%eax,%r13d
  414 (0.0%)  	addl	16(%rsp),%edx
  414 (0.0%)  	movl	%r8d,%r15d
  414 (0.0%)  	xorl	%ecx,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%r9d,%r15d
  414 (0.0%)  	addl	%r12d,%edx
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%r15d,%edi
  414 (0.0%)  	xorl	%r8d,%r14d
  414 (0.0%)  	addl	%r13d,%edx
  414 (0.0%)  	xorl	%r9d,%edi
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%edx,%r11d
  414 (0.0%)  	addl	%edi,%edx
  414 (0.0%)  	movl	%r11d,%r13d
  414 (0.0%)  	addl	%edx,%r14d
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%edx
  414 (0.0%)  	movl	%eax,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%r11d,%r13d
  414 (0.0%)  	xorl	%ebx,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%edx,%r14d
  414 (0.0%)  	andl	%r11d,%r12d
  414 (0.0%)  	xorl	%r11d,%r13d
  414 (0.0%)  	addl	20(%rsp),%ecx
  414 (0.0%)  	movl	%edx,%edi
  414 (0.0%)  	xorl	%ebx,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%r8d,%edi
  414 (0.0%)  	addl	%r12d,%ecx
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%edi,%r15d
  414 (0.0%)  	xorl	%edx,%r14d
  414 (0.0%)  	addl	%r13d,%ecx
  414 (0.0%)  	xorl	%r8d,%r15d
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%ecx,%r10d
  414 (0.0%)  	addl	%r15d,%ecx
  414 (0.0%)  	movl	%r10d,%r13d
  414 (0.0%)  	addl	%ecx,%r14d
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%ecx
  414 (0.0%)  	movl	%r11d,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%r10d,%r13d
  414 (0.0%)  	xorl	%eax,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%ecx,%r14d
  414 (0.0%)  	andl	%r10d,%r12d
  414 (0.0%)  	xorl	%r10d,%r13d
  414 (0.0%)  	addl	24(%rsp),%ebx
  414 (0.0%)  	movl	%ecx,%r15d
  414 (0.0%)  	xorl	%eax,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%edx,%r15d
  414 (0.0%)  	addl	%r12d,%ebx
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%r15d,%edi
  414 (0.0%)  	xorl	%ecx,%r14d
  414 (0.0%)  	addl	%r13d,%ebx
  414 (0.0%)  	xorl	%edx,%edi
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%ebx,%r9d
  414 (0.0%)  	addl	%edi,%ebx
  414 (0.0%)  	movl	%r9d,%r13d
  414 (0.0%)  	addl	%ebx,%r14d
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%ebx
  414 (0.0%)  	movl	%r10d,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%r9d,%r13d
  414 (0.0%)  	xorl	%r11d,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%ebx,%r14d
  414 (0.0%)  	andl	%r9d,%r12d
  414 (0.0%)  	xorl	%r9d,%r13d
  414 (0.0%)  	addl	28(%rsp),%eax
  414 (0.0%)  	movl	%ebx,%edi
  414 (0.0%)  	xorl	%r11d,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%ecx,%edi
  414 (0.0%)  	addl	%r12d,%eax
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%edi,%r15d
  414 (0.0%)  	xorl	%ebx,%r14d
  414 (0.0%)  	addl	%r13d,%eax
  414 (0.0%)  	xorl	%ecx,%r15d
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%eax,%r8d
  414 (0.0%)  	addl	%r15d,%eax
  414 (0.0%)  	movl	%r8d,%r13d
  414 (0.0%)  	addl	%eax,%r14d
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%eax
  414 (0.0%)  	movl	%r9d,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%r8d,%r13d
  414 (0.0%)  	xorl	%r10d,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%eax,%r14d
  414 (0.0%)  	andl	%r8d,%r12d
  414 (0.0%)  	xorl	%r8d,%r13d
  414 (0.0%)  	addl	32(%rsp),%r11d
  414 (0.0%)  	movl	%eax,%r15d
  414 (0.0%)  	xorl	%r10d,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%ebx,%r15d
  414 (0.0%)  	addl	%r12d,%r11d
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%r15d,%edi
  414 (0.0%)  	xorl	%eax,%r14d
  414 (0.0%)  	addl	%r13d,%r11d
  414 (0.0%)  	xorl	%ebx,%edi
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%r11d,%edx
  414 (0.0%)  	addl	%edi,%r11d
  414 (0.0%)  	movl	%edx,%r13d
  414 (0.0%)  	addl	%r11d,%r14d
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%r11d
  414 (0.0%)  	movl	%r8d,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%edx,%r13d
  414 (0.0%)  	xorl	%r9d,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%r11d,%r14d
  414 (0.0%)  	andl	%edx,%r12d
  414 (0.0%)  	xorl	%edx,%r13d
  414 (0.0%)  	addl	36(%rsp),%r10d
  414 (0.0%)  	movl	%r11d,%edi
  414 (0.0%)  	xorl	%r9d,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%eax,%edi
  414 (0.0%)  	addl	%r12d,%r10d
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%edi,%r15d
  414 (0.0%)  	xorl	%r11d,%r14d
  414 (0.0%)  	addl	%r13d,%r10d
  414 (0.0%)  	xorl	%eax,%r15d
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%r10d,%ecx
  414 (0.0%)  	addl	%r15d,%r10d
  414 (0.0%)  	movl	%ecx,%r13d
  414 (0.0%)  	addl	%r10d,%r14d
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%r10d
  414 (0.0%)  	movl	%edx,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%ecx,%r13d
  414 (0.0%)  	xorl	%r8d,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%r10d,%r14d
  414 (0.0%)  	andl	%ecx,%r12d
  414 (0.0%)  	xorl	%ecx,%r13d
  414 (0.0%)  	addl	40(%rsp),%r9d
  414 (0.0%)  	movl	%r10d,%r15d
  414 (0.0%)  	xorl	%r8d,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%r11d,%r15d
  414 (0.0%)  	addl	%r12d,%r9d
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%r15d,%edi
  414 (0.0%)  	xorl	%r10d,%r14d
  414 (0.0%)  	addl	%r13d,%r9d
  414 (0.0%)  	xorl	%r11d,%edi
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%r9d,%ebx
  414 (0.0%)  	addl	%edi,%r9d
  414 (0.0%)  	movl	%ebx,%r13d
  414 (0.0%)  	addl	%r9d,%r14d
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%r9d
  414 (0.0%)  	movl	%ecx,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%ebx,%r13d
  414 (0.0%)  	xorl	%edx,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%r9d,%r14d
  414 (0.0%)  	andl	%ebx,%r12d
  414 (0.0%)  	xorl	%ebx,%r13d
  414 (0.0%)  	addl	44(%rsp),%r8d
  414 (0.0%)  	movl	%r9d,%edi
  414 (0.0%)  	xorl	%edx,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%r10d,%edi
  414 (0.0%)  	addl	%r12d,%r8d
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%edi,%r15d
  414 (0.0%)  	xorl	%r9d,%r14d
  414 (0.0%)  	addl	%r13d,%r8d
  414 (0.0%)  	xorl	%r10d,%r15d
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%r8d,%eax
  414 (0.0%)  	addl	%r15d,%r8d
  414 (0.0%)  	movl	%eax,%r13d
  414 (0.0%)  	addl	%r8d,%r14d
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%r8d
  414 (0.0%)  	movl	%ebx,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%eax,%r13d
  414 (0.0%)  	xorl	%ecx,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%r8d,%r14d
  414 (0.0%)  	andl	%eax,%r12d
  414 (0.0%)  	xorl	%eax,%r13d
  414 (0.0%)  	addl	48(%rsp),%edx
  414 (0.0%)  	movl	%r8d,%r15d
  414 (0.0%)  	xorl	%ecx,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%r9d,%r15d
  414 (0.0%)  	addl	%r12d,%edx
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%r15d,%edi
  414 (0.0%)  	xorl	%r8d,%r14d
  414 (0.0%)  	addl	%r13d,%edx
  414 (0.0%)  	xorl	%r9d,%edi
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%edx,%r11d
  414 (0.0%)  	addl	%edi,%edx
  414 (0.0%)  	movl	%r11d,%r13d
  414 (0.0%)  	addl	%edx,%r14d
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%edx
  414 (0.0%)  	movl	%eax,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%r11d,%r13d
  414 (0.0%)  	xorl	%ebx,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%edx,%r14d
  414 (0.0%)  	andl	%r11d,%r12d
  414 (0.0%)  	xorl	%r11d,%r13d
  414 (0.0%)  	addl	52(%rsp),%ecx
  414 (0.0%)  	movl	%edx,%edi
  414 (0.0%)  	xorl	%ebx,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%r8d,%edi
  414 (0.0%)  	addl	%r12d,%ecx
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%edi,%r15d
  414 (0.0%)  	xorl	%edx,%r14d
  414 (0.0%)  	addl	%r13d,%ecx
  414 (0.0%)  	xorl	%r8d,%r15d
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%ecx,%r10d
  414 (0.0%)  	addl	%r15d,%ecx
  414 (0.0%)  	movl	%r10d,%r13d
  414 (0.0%)  	addl	%ecx,%r14d
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%ecx
  414 (0.0%)  	movl	%r11d,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%r10d,%r13d
  414 (0.0%)  	xorl	%eax,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%ecx,%r14d
  414 (0.0%)  	andl	%r10d,%r12d
  414 (0.0%)  	xorl	%r10d,%r13d
  414 (0.0%)  	addl	56(%rsp),%ebx
  414 (0.0%)  	movl	%ecx,%r15d
  414 (0.0%)  	xorl	%eax,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%edx,%r15d
  414 (0.0%)  	addl	%r12d,%ebx
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%r15d,%edi
  414 (0.0%)  	xorl	%ecx,%r14d
  414 (0.0%)  	addl	%r13d,%ebx
  414 (0.0%)  	xorl	%edx,%edi
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%ebx,%r9d
  414 (0.0%)  	addl	%edi,%ebx
  414 (0.0%)  	movl	%r9d,%r13d
  414 (0.0%)  	addl	%ebx,%r14d
  414 (0.0%)  	shrdl	$14,%r13d,%r13d
  414 (0.0%)  	movl	%r14d,%ebx
  414 (0.0%)  	movl	%r10d,%r12d
  414 (0.0%)  	shrdl	$9,%r14d,%r14d
  414 (0.0%)  	xorl	%r9d,%r13d
  414 (0.0%)  	xorl	%r11d,%r12d
  414 (0.0%)  	shrdl	$5,%r13d,%r13d
  414 (0.0%)  	xorl	%ebx,%r14d
  414 (0.0%)  	andl	%r9d,%r12d
  414 (0.0%)  	xorl	%r9d,%r13d
  414 (0.0%)  	addl	60(%rsp),%eax
  414 (0.0%)  	movl	%ebx,%edi
  414 (0.0%)  	xorl	%r11d,%r12d
  414 (0.0%)  	shrdl	$11,%r14d,%r14d
  414 (0.0%)  	xorl	%ecx,%edi
  414 (0.0%)  	addl	%r12d,%eax
  414 (0.0%)  	shrdl	$6,%r13d,%r13d
  414 (0.0%)  	andl	%edi,%r15d
  414 (0.0%)  	xorl	%ebx,%r14d
  414 (0.0%)  	addl	%r13d,%eax
  414 (0.0%)  	xorl	%ecx,%r15d
  414 (0.0%)  	shrdl	$2,%r14d,%r14d
  414 (0.0%)  	addl	%eax,%r8d
  414 (0.0%)  	addl	%r15d,%eax
  414 (0.0%)  	movl	%r8d,%r13d
  414 (0.0%)  	addl	%eax,%r14d
  414 (0.0%)  	movq	64+0(%rsp),%rdi
  414 (0.0%)  	movl	%r14d,%eax
    .         
  414 (0.0%)  	addl	0(%rdi),%eax
  414 (0.0%)  	leaq	64(%rsi),%rsi
  414 (0.0%)  	addl	4(%rdi),%ebx
  414 (0.0%)  	addl	8(%rdi),%ecx
  414 (0.0%)  	addl	12(%rdi),%edx
  414 (0.0%)  	addl	16(%rdi),%r8d
  414 (0.0%)  	addl	20(%rdi),%r9d
  414 (0.0%)  	addl	24(%rdi),%r10d
  414 (0.0%)  	addl	28(%rdi),%r11d
    .         
  414 (0.0%)  	cmpq	64+16(%rsp),%rsi
    .         
  414 (0.0%)  	movl	%eax,0(%rdi)
  414 (0.0%)  	movl	%ebx,4(%rdi)
  414 (0.0%)  	movl	%ecx,8(%rdi)
  414 (0.0%)  	movl	%edx,12(%rdi)
  414 (0.0%)  	movl	%r8d,16(%rdi)
  414 (0.0%)  	movl	%r9d,20(%rdi)
  414 (0.0%)  	movl	%r10d,24(%rdi)
  414 (0.0%)  	movl	%r11d,28(%rdi)
  414 (0.0%)  	jb	.Lloop_avx
    .         
  283 (0.0%)  	movq	88(%rsp),%rsi
    .         .cfi_def_cfa	%rsi,8
  283 (0.0%)  	vzeroupper
  283 (0.0%)  	movq	-48(%rsi),%r15
    .         .cfi_restore	%r15
  283 (0.0%)  	movq	-40(%rsi),%r14
    .         .cfi_restore	%r14
  283 (0.0%)  	movq	-32(%rsi),%r13
    .         .cfi_restore	%r13
  283 (0.0%)  	movq	-24(%rsi),%r12
    .         .cfi_restore	%r12
  283 (0.0%)  	movq	-16(%rsi),%rbp
    .         .cfi_restore	%rbp
  283 (0.0%)  	movq	-8(%rsi),%rbx
    .         .cfi_restore	%rbx
  566 (0.0%)  	leaq	(%rsi),%rsp
    .         .cfi_def_cfa_register	%rsp
    .         .Lepilogue_avx:
    .         	.byte	0xf3,0xc3
    .         .cfi_endproc	
    .         .size	sha256_block_data_order_avx,.-sha256_block_data_order_avx
    .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont.S
--------------------------------------------------------------------------------
Ir___________ 

-- line 10 ----------------------------------------
     .         .hidden OPENSSL_ia32cap_P
     .         
     .         .globl	bn_mul_mont
     .         .hidden bn_mul_mont
     .         .type	bn_mul_mont,@function
     .         .align	16
     .         bn_mul_mont:
     .         .cfi_startproc	
   634 (0.0%)  	movl	%r9d,%r9d
   634 (0.0%)  	movq	%rsp,%rax
     .         .cfi_def_cfa_register	%rax
   634 (0.0%)  	testl	$3,%r9d
   634 (0.0%)  	jnz	.Lmul_enter
   310 (0.0%)  	cmpl	$8,%r9d
   310 (0.0%)  	jb	.Lmul_enter
   184 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r11
   184 (0.0%)  	movl	8(%r11),%r11d
   184 (0.0%)  	cmpq	%rsi,%rdx
   184 (0.0%)  	jne	.Lmul4x_enter
   154 (0.0%)  	testl	$7,%r9d
   154 (0.0%)  	jz	.Lsqr8x_enter
     .         	jmp	.Lmul4x_enter
     .         
     .         .align	16
     .         .Lmul_enter:
   450 (0.0%)  	pushq	%rbx
     .         .cfi_offset	%rbx,-16
   450 (0.0%)  	pushq	%rbp
     .         .cfi_offset	%rbp,-24
   450 (0.0%)  	pushq	%r12
     .         .cfi_offset	%r12,-32
   450 (0.0%)  	pushq	%r13
     .         .cfi_offset	%r13,-40
   450 (0.0%)  	pushq	%r14
     .         .cfi_offset	%r14,-48
   450 (0.0%)  	pushq	%r15
     .         .cfi_offset	%r15,-56
     .         
   450 (0.0%)  	negq	%r9
   450 (0.0%)  	movq	%rsp,%r11
   450 (0.0%)  	leaq	-16(%rsp,%r9,8),%r10
   450 (0.0%)  	negq	%r9
   450 (0.0%)  	andq	$-1024,%r10
     .         
     .         
     .         
     .         
     .         
     .         
     .         
     .         
     .         
   450 (0.0%)  	subq	%r10,%r11
   450 (0.0%)  	andq	$-4096,%r11
   450 (0.0%)  	leaq	(%r10,%r11,1),%rsp
   450 (0.0%)  	movq	(%rsp),%r11
   450 (0.0%)  	cmpq	%r10,%rsp
   450 (0.0%)  	ja	.Lmul_page_walk
   450 (0.0%)  	jmp	.Lmul_page_walk_done
     .         
     .         .align	16
     .         .Lmul_page_walk:
     .         	leaq	-4096(%rsp),%rsp
     .         	movq	(%rsp),%r11
     .         	cmpq	%r10,%rsp
     .         	ja	.Lmul_page_walk
     .         .Lmul_page_walk_done:
     .         
   450 (0.0%)  	movq	%rax,8(%rsp,%r9,8)
     .         .cfi_escape	0x0f,0x0a,0x77,0x08,0x79,0x00,0x38,0x1e,0x22,0x06,0x23,0x08
     .         .Lmul_body:
   450 (0.0%)  	movq	%rdx,%r12
   450 (0.0%)  	movq	(%r8),%r8
   450 (0.0%)  	movq	(%r12),%rbx
   450 (0.0%)  	movq	(%rsi),%rax
     .         
   450 (0.0%)  	xorq	%r14,%r14
   450 (0.0%)  	xorq	%r15,%r15
     .         
   450 (0.0%)  	movq	%r8,%rbp
   450 (0.0%)  	mulq	%rbx
   450 (0.0%)  	movq	%rax,%r10
   450 (0.0%)  	movq	(%rcx),%rax
     .         
   450 (0.0%)  	imulq	%r10,%rbp
   450 (0.0%)  	movq	%rdx,%r11
     .         
   450 (0.0%)  	mulq	%rbp
   450 (0.0%)  	addq	%rax,%r10
   450 (0.0%)  	movq	8(%rsi),%rax
   450 (0.0%)  	adcq	$0,%rdx
   450 (0.0%)  	movq	%rdx,%r13
     .         
   450 (0.0%)  	leaq	1(%r15),%r15
   450 (0.0%)  	jmp	.L1st_enter
     .         
     .         .align	16
     .         .L1st:
 1,548 (0.0%)  	addq	%rax,%r13
 1,548 (0.0%)  	movq	(%rsi,%r15,8),%rax
 1,548 (0.0%)  	adcq	$0,%rdx
 1,548 (0.0%)  	addq	%r11,%r13
 1,548 (0.0%)  	movq	%r10,%r11
 1,548 (0.0%)  	adcq	$0,%rdx
 1,548 (0.0%)  	movq	%r13,-16(%rsp,%r15,8)
 1,548 (0.0%)  	movq	%rdx,%r13
     .         
     .         .L1st_enter:
 1,998 (0.0%)  	mulq	%rbx
 1,998 (0.0%)  	addq	%rax,%r11
 1,998 (0.0%)  	movq	(%rcx,%r15,8),%rax
 1,998 (0.0%)  	adcq	$0,%rdx
 1,998 (0.0%)  	leaq	1(%r15),%r15
 1,998 (0.0%)  	movq	%rdx,%r10
     .         
 1,998 (0.0%)  	mulq	%rbp
 1,998 (0.0%)  	cmpq	%r9,%r15
 1,998 (0.0%)  	jne	.L1st
     .         
   450 (0.0%)  	addq	%rax,%r13
   450 (0.0%)  	movq	(%rsi),%rax
   450 (0.0%)  	adcq	$0,%rdx
   450 (0.0%)  	addq	%r11,%r13
   450 (0.0%)  	adcq	$0,%rdx
   450 (0.0%)  	movq	%r13,-16(%rsp,%r15,8)
   450 (0.0%)  	movq	%rdx,%r13
   450 (0.0%)  	movq	%r10,%r11
     .         
   450 (0.0%)  	xorq	%rdx,%rdx
   450 (0.0%)  	addq	%r11,%r13
   450 (0.0%)  	adcq	$0,%rdx
   450 (0.0%)  	movq	%r13,-8(%rsp,%r9,8)
   450 (0.0%)  	movq	%rdx,(%rsp,%r9,8)
     .         
   450 (0.0%)  	leaq	1(%r14),%r14
   450 (0.0%)  	jmp	.Louter
     .         .align	16
     .         .Louter:
 1,998 (0.0%)  	movq	(%r12,%r14,8),%rbx
 1,998 (0.0%)  	xorq	%r15,%r15
 1,998 (0.0%)  	movq	%r8,%rbp
 1,998 (0.0%)  	movq	(%rsp),%r10
 1,998 (0.0%)  	mulq	%rbx
 1,998 (0.0%)  	addq	%rax,%r10
 1,998 (0.0%)  	movq	(%rcx),%rax
 1,998 (0.0%)  	adcq	$0,%rdx
     .         
 1,998 (0.0%)  	imulq	%r10,%rbp
 1,998 (0.0%)  	movq	%rdx,%r11
     .         
 1,998 (0.0%)  	mulq	%rbp
 1,998 (0.0%)  	addq	%rax,%r10
 1,998 (0.0%)  	movq	8(%rsi),%rax
 1,998 (0.0%)  	adcq	$0,%rdx
 1,998 (0.0%)  	movq	8(%rsp),%r10
 1,998 (0.0%)  	movq	%rdx,%r13
     .         
 1,998 (0.0%)  	leaq	1(%r15),%r15
 1,998 (0.0%)  	jmp	.Linner_enter
     .         
     .         .align	16
     .         .Linner:
 7,236 (0.0%)  	addq	%rax,%r13
 7,236 (0.0%)  	movq	(%rsi,%r15,8),%rax
 7,236 (0.0%)  	adcq	$0,%rdx
 7,236 (0.0%)  	addq	%r10,%r13
 7,236 (0.0%)  	movq	(%rsp,%r15,8),%r10
 7,236 (0.0%)  	adcq	$0,%rdx
 7,236 (0.0%)  	movq	%r13,-16(%rsp,%r15,8)
 7,236 (0.0%)  	movq	%rdx,%r13
     .         
     .         .Linner_enter:
 9,234 (0.0%)  	mulq	%rbx
 9,234 (0.0%)  	addq	%rax,%r11
 9,234 (0.0%)  	movq	(%rcx,%r15,8),%rax
 9,234 (0.0%)  	adcq	$0,%rdx
 9,234 (0.0%)  	addq	%r11,%r10
 9,234 (0.0%)  	movq	%rdx,%r11
 9,234 (0.0%)  	adcq	$0,%r11
 9,234 (0.0%)  	leaq	1(%r15),%r15
     .         
 9,234 (0.0%)  	mulq	%rbp
 9,234 (0.0%)  	cmpq	%r9,%r15
 9,234 (0.0%)  	jne	.Linner
     .         
 1,998 (0.0%)  	addq	%rax,%r13
 1,998 (0.0%)  	movq	(%rsi),%rax
 1,998 (0.0%)  	adcq	$0,%rdx
 1,998 (0.0%)  	addq	%r10,%r13
 1,998 (0.0%)  	movq	(%rsp,%r15,8),%r10
 1,998 (0.0%)  	adcq	$0,%rdx
 1,998 (0.0%)  	movq	%r13,-16(%rsp,%r15,8)
 1,998 (0.0%)  	movq	%rdx,%r13
     .         
 1,998 (0.0%)  	xorq	%rdx,%rdx
 1,998 (0.0%)  	addq	%r11,%r13
 1,998 (0.0%)  	adcq	$0,%rdx
 1,998 (0.0%)  	addq	%r10,%r13
 1,998 (0.0%)  	adcq	$0,%rdx
 1,998 (0.0%)  	movq	%r13,-8(%rsp,%r9,8)
 1,998 (0.0%)  	movq	%rdx,(%rsp,%r9,8)
     .         
 1,998 (0.0%)  	leaq	1(%r14),%r14
 1,998 (0.0%)  	cmpq	%r9,%r14
 1,998 (0.0%)  	jb	.Louter
     .         
   450 (0.0%)  	xorq	%r14,%r14
   450 (0.0%)  	movq	(%rsp),%rax
   450 (0.0%)  	movq	%r9,%r15
     .         
     .         .align	16
 2,448 (0.0%)  .Lsub:	sbbq	(%rcx,%r14,8),%rax
 2,448 (0.0%)  	movq	%rax,(%rdi,%r14,8)
 2,448 (0.0%)  	movq	8(%rsp,%r14,8),%rax
 2,448 (0.0%)  	leaq	1(%r14),%r14
 2,448 (0.0%)  	decq	%r15
 2,448 (0.0%)  	jnz	.Lsub
     .         
   450 (0.0%)  	sbbq	$0,%rax
   450 (0.0%)  	movq	$-1,%rbx
   450 (0.0%)  	xorq	%rax,%rbx
   450 (0.0%)  	xorq	%r14,%r14
   450 (0.0%)  	movq	%r9,%r15
     .         
     .         .Lcopy:
 2,448 (0.0%)  	movq	(%rdi,%r14,8),%rcx
 2,448 (0.0%)  	movq	(%rsp,%r14,8),%rdx
 2,448 (0.0%)  	andq	%rbx,%rcx
 2,448 (0.0%)  	andq	%rax,%rdx
 2,448 (0.0%)  	movq	%r9,(%rsp,%r14,8)
 2,448 (0.0%)  	orq	%rcx,%rdx
 2,448 (0.0%)  	movq	%rdx,(%rdi,%r14,8)
 2,448 (0.0%)  	leaq	1(%r14),%r14
 2,448 (0.0%)  	subq	$1,%r15
 2,448 (0.0%)  	jnz	.Lcopy
     .         
   450 (0.0%)  	movq	8(%rsp,%r9,8),%rsi
     .         .cfi_def_cfa	%rsi,8
   450 (0.0%)  	movq	$1,%rax
   450 (0.0%)  	movq	-48(%rsi),%r15
     .         .cfi_restore	%r15
   450 (0.0%)  	movq	-40(%rsi),%r14
     .         .cfi_restore	%r14
   450 (0.0%)  	movq	-32(%rsi),%r13
     .         .cfi_restore	%r13
   450 (0.0%)  	movq	-24(%rsi),%r12
     .         .cfi_restore	%r12
   450 (0.0%)  	movq	-16(%rsi),%rbp
     .         .cfi_restore	%rbp
   450 (0.0%)  	movq	-8(%rsi),%rbx
     .         .cfi_restore	%rbx
   900 (0.0%)  	leaq	(%rsi),%rsp
     .         .cfi_def_cfa_register	%rsp
     .         .Lmul_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	bn_mul_mont,.-bn_mul_mont
     .         .type	bn_mul4x_mont,@function
     .         .align	16
     .         bn_mul4x_mont:
     .         .cfi_startproc	
     .         	movl	%r9d,%r9d
     .         	movq	%rsp,%rax
     .         .cfi_def_cfa_register	%rax
     .         .Lmul4x_enter:
    30 (0.0%)  	andl	$0x80100,%r11d
    30 (0.0%)  	cmpl	$0x80100,%r11d
    30 (0.0%)  	je	.Lmulx4x_enter
    30 (0.0%)  	pushq	%rbx
     .         .cfi_offset	%rbx,-16
    30 (0.0%)  	pushq	%rbp
     .         .cfi_offset	%rbp,-24
    30 (0.0%)  	pushq	%r12
     .         .cfi_offset	%r12,-32
    30 (0.0%)  	pushq	%r13
     .         .cfi_offset	%r13,-40
    30 (0.0%)  	pushq	%r14
     .         .cfi_offset	%r14,-48
    30 (0.0%)  	pushq	%r15
     .         .cfi_offset	%r15,-56
     .         
    30 (0.0%)  	negq	%r9
    30 (0.0%)  	movq	%rsp,%r11
    30 (0.0%)  	leaq	-32(%rsp,%r9,8),%r10
    30 (0.0%)  	negq	%r9
    30 (0.0%)  	andq	$-1024,%r10
     .         
    30 (0.0%)  	subq	%r10,%r11
    30 (0.0%)  	andq	$-4096,%r11
    30 (0.0%)  	leaq	(%r10,%r11,1),%rsp
    30 (0.0%)  	movq	(%rsp),%r11
    30 (0.0%)  	cmpq	%r10,%rsp
    30 (0.0%)  	ja	.Lmul4x_page_walk
    30 (0.0%)  	jmp	.Lmul4x_page_walk_done
     .         
     .         .Lmul4x_page_walk:
     .         	leaq	-4096(%rsp),%rsp
     .         	movq	(%rsp),%r11
     .         	cmpq	%r10,%rsp
     .         	ja	.Lmul4x_page_walk
     .         .Lmul4x_page_walk_done:
     .         
    30 (0.0%)  	movq	%rax,8(%rsp,%r9,8)
     .         .cfi_escape	0x0f,0x0a,0x77,0x08,0x79,0x00,0x38,0x1e,0x22,0x06,0x23,0x08
     .         .Lmul4x_body:
    30 (0.0%)  	movq	%rdi,16(%rsp,%r9,8)
    30 (0.0%)  	movq	%rdx,%r12
    30 (0.0%)  	movq	(%r8),%r8
    30 (0.0%)  	movq	(%r12),%rbx
    30 (0.0%)  	movq	(%rsi),%rax
     .         
    30 (0.0%)  	xorq	%r14,%r14
    30 (0.0%)  	xorq	%r15,%r15
     .         
    30 (0.0%)  	movq	%r8,%rbp
    30 (0.0%)  	mulq	%rbx
    30 (0.0%)  	movq	%rax,%r10
    30 (0.0%)  	movq	(%rcx),%rax
     .         
    30 (0.0%)  	imulq	%r10,%rbp
    30 (0.0%)  	movq	%rdx,%r11
     .         
    30 (0.0%)  	mulq	%rbp
    30 (0.0%)  	addq	%rax,%r10
    30 (0.0%)  	movq	8(%rsi),%rax
    30 (0.0%)  	adcq	$0,%rdx
    30 (0.0%)  	movq	%rdx,%rdi
     .         
    30 (0.0%)  	mulq	%rbx
    30 (0.0%)  	addq	%rax,%r11
    30 (0.0%)  	movq	8(%rcx),%rax
    30 (0.0%)  	adcq	$0,%rdx
    30 (0.0%)  	movq	%rdx,%r10
     .         
    30 (0.0%)  	mulq	%rbp
    30 (0.0%)  	addq	%rax,%rdi
    30 (0.0%)  	movq	16(%rsi),%rax
    30 (0.0%)  	adcq	$0,%rdx
    30 (0.0%)  	addq	%r11,%rdi
    30 (0.0%)  	leaq	4(%r15),%r15
    30 (0.0%)  	adcq	$0,%rdx
    30 (0.0%)  	movq	%rdi,(%rsp)
    30 (0.0%)  	movq	%rdx,%r13
    30 (0.0%)  	jmp	.L1st4x
     .         .align	16
     .         .L1st4x:
   346 (0.0%)  	mulq	%rbx
   346 (0.0%)  	addq	%rax,%r10
   346 (0.0%)  	movq	-16(%rcx,%r15,8),%rax
   346 (0.0%)  	adcq	$0,%rdx
   346 (0.0%)  	movq	%rdx,%r11
     .         
   346 (0.0%)  	mulq	%rbp
   346 (0.0%)  	addq	%rax,%r13
   346 (0.0%)  	movq	-8(%rsi,%r15,8),%rax
   346 (0.0%)  	adcq	$0,%rdx
   346 (0.0%)  	addq	%r10,%r13
   346 (0.0%)  	adcq	$0,%rdx
   346 (0.0%)  	movq	%r13,-24(%rsp,%r15,8)
   346 (0.0%)  	movq	%rdx,%rdi
     .         
   346 (0.0%)  	mulq	%rbx
   346 (0.0%)  	addq	%rax,%r11
   346 (0.0%)  	movq	-8(%rcx,%r15,8),%rax
   346 (0.0%)  	adcq	$0,%rdx
   346 (0.0%)  	movq	%rdx,%r10
     .         
   346 (0.0%)  	mulq	%rbp
   346 (0.0%)  	addq	%rax,%rdi
   346 (0.0%)  	movq	(%rsi,%r15,8),%rax
   346 (0.0%)  	adcq	$0,%rdx
   346 (0.0%)  	addq	%r11,%rdi
   346 (0.0%)  	adcq	$0,%rdx
   346 (0.0%)  	movq	%rdi,-16(%rsp,%r15,8)
   346 (0.0%)  	movq	%rdx,%r13
     .         
   346 (0.0%)  	mulq	%rbx
   346 (0.0%)  	addq	%rax,%r10
   346 (0.0%)  	movq	(%rcx,%r15,8),%rax
   346 (0.0%)  	adcq	$0,%rdx
   346 (0.0%)  	movq	%rdx,%r11
     .         
   346 (0.0%)  	mulq	%rbp
   346 (0.0%)  	addq	%rax,%r13
   346 (0.0%)  	movq	8(%rsi,%r15,8),%rax
   346 (0.0%)  	adcq	$0,%rdx
   346 (0.0%)  	addq	%r10,%r13
   346 (0.0%)  	adcq	$0,%rdx
   346 (0.0%)  	movq	%r13,-8(%rsp,%r15,8)
   346 (0.0%)  	movq	%rdx,%rdi
     .         
   346 (0.0%)  	mulq	%rbx
   346 (0.0%)  	addq	%rax,%r11
   346 (0.0%)  	movq	8(%rcx,%r15,8),%rax
   346 (0.0%)  	adcq	$0,%rdx
   346 (0.0%)  	leaq	4(%r15),%r15
   346 (0.0%)  	movq	%rdx,%r10
     .         
   346 (0.0%)  	mulq	%rbp
   346 (0.0%)  	addq	%rax,%rdi
   346 (0.0%)  	movq	-16(%rsi,%r15,8),%rax
   346 (0.0%)  	adcq	$0,%rdx
   346 (0.0%)  	addq	%r11,%rdi
   346 (0.0%)  	adcq	$0,%rdx
   346 (0.0%)  	movq	%rdi,-32(%rsp,%r15,8)
   346 (0.0%)  	movq	%rdx,%r13
   346 (0.0%)  	cmpq	%r9,%r15
   346 (0.0%)  	jb	.L1st4x
     .         
    30 (0.0%)  	mulq	%rbx
    30 (0.0%)  	addq	%rax,%r10
    30 (0.0%)  	movq	-16(%rcx,%r15,8),%rax
    30 (0.0%)  	adcq	$0,%rdx
    30 (0.0%)  	movq	%rdx,%r11
     .         
    30 (0.0%)  	mulq	%rbp
    30 (0.0%)  	addq	%rax,%r13
    30 (0.0%)  	movq	-8(%rsi,%r15,8),%rax
    30 (0.0%)  	adcq	$0,%rdx
    30 (0.0%)  	addq	%r10,%r13
    30 (0.0%)  	adcq	$0,%rdx
    30 (0.0%)  	movq	%r13,-24(%rsp,%r15,8)
    30 (0.0%)  	movq	%rdx,%rdi
     .         
    30 (0.0%)  	mulq	%rbx
    30 (0.0%)  	addq	%rax,%r11
    30 (0.0%)  	movq	-8(%rcx,%r15,8),%rax
    30 (0.0%)  	adcq	$0,%rdx
    30 (0.0%)  	movq	%rdx,%r10
     .         
    30 (0.0%)  	mulq	%rbp
    30 (0.0%)  	addq	%rax,%rdi
    30 (0.0%)  	movq	(%rsi),%rax
    30 (0.0%)  	adcq	$0,%rdx
    30 (0.0%)  	addq	%r11,%rdi
    30 (0.0%)  	adcq	$0,%rdx
    30 (0.0%)  	movq	%rdi,-16(%rsp,%r15,8)
    30 (0.0%)  	movq	%rdx,%r13
     .         
    30 (0.0%)  	xorq	%rdi,%rdi
    30 (0.0%)  	addq	%r10,%r13
    30 (0.0%)  	adcq	$0,%rdi
    30 (0.0%)  	movq	%r13,-8(%rsp,%r15,8)
    30 (0.0%)  	movq	%rdi,(%rsp,%r15,8)
     .         
    30 (0.0%)  	leaq	1(%r14),%r14
     .         .align	4
     .         .Louter4x:
 1,474 (0.0%)  	movq	(%r12,%r14,8),%rbx
 1,474 (0.0%)  	xorq	%r15,%r15
 1,474 (0.0%)  	movq	(%rsp),%r10
 1,474 (0.0%)  	movq	%r8,%rbp
 1,474 (0.0%)  	mulq	%rbx
 1,474 (0.0%)  	addq	%rax,%r10
 1,474 (0.0%)  	movq	(%rcx),%rax
 1,474 (0.0%)  	adcq	$0,%rdx
     .         
 1,474 (0.0%)  	imulq	%r10,%rbp
 1,474 (0.0%)  	movq	%rdx,%r11
     .         
 1,474 (0.0%)  	mulq	%rbp
 1,474 (0.0%)  	addq	%rax,%r10
 1,474 (0.0%)  	movq	8(%rsi),%rax
 1,474 (0.0%)  	adcq	$0,%rdx
 1,474 (0.0%)  	movq	%rdx,%rdi
     .         
 1,474 (0.0%)  	mulq	%rbx
 1,474 (0.0%)  	addq	%rax,%r11
 1,474 (0.0%)  	movq	8(%rcx),%rax
 1,474 (0.0%)  	adcq	$0,%rdx
 1,474 (0.0%)  	addq	8(%rsp),%r11
 1,474 (0.0%)  	adcq	$0,%rdx
 1,474 (0.0%)  	movq	%rdx,%r10
     .         
 1,474 (0.0%)  	mulq	%rbp
 1,474 (0.0%)  	addq	%rax,%rdi
 1,474 (0.0%)  	movq	16(%rsi),%rax
 1,474 (0.0%)  	adcq	$0,%rdx
 1,474 (0.0%)  	addq	%r11,%rdi
 1,474 (0.0%)  	leaq	4(%r15),%r15
 1,474 (0.0%)  	adcq	$0,%rdx
 1,474 (0.0%)  	movq	%rdi,(%rsp)
 1,474 (0.0%)  	movq	%rdx,%r13
 1,474 (0.0%)  	jmp	.Linner4x
     .         .align	16
     .         .Linner4x:
18,886 (0.0%)  	mulq	%rbx
18,886 (0.0%)  	addq	%rax,%r10
18,886 (0.0%)  	movq	-16(%rcx,%r15,8),%rax
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	addq	-16(%rsp,%r15,8),%r10
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	movq	%rdx,%r11
     .         
18,886 (0.0%)  	mulq	%rbp
18,886 (0.0%)  	addq	%rax,%r13
18,886 (0.0%)  	movq	-8(%rsi,%r15,8),%rax
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	addq	%r10,%r13
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	movq	%r13,-24(%rsp,%r15,8)
18,886 (0.0%)  	movq	%rdx,%rdi
     .         
18,886 (0.0%)  	mulq	%rbx
18,886 (0.0%)  	addq	%rax,%r11
18,886 (0.0%)  	movq	-8(%rcx,%r15,8),%rax
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	addq	-8(%rsp,%r15,8),%r11
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	movq	%rdx,%r10
     .         
18,886 (0.0%)  	mulq	%rbp
18,886 (0.0%)  	addq	%rax,%rdi
18,886 (0.0%)  	movq	(%rsi,%r15,8),%rax
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	addq	%r11,%rdi
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	movq	%rdi,-16(%rsp,%r15,8)
18,886 (0.0%)  	movq	%rdx,%r13
     .         
18,886 (0.0%)  	mulq	%rbx
18,886 (0.0%)  	addq	%rax,%r10
18,886 (0.0%)  	movq	(%rcx,%r15,8),%rax
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	addq	(%rsp,%r15,8),%r10
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	movq	%rdx,%r11
     .         
18,886 (0.0%)  	mulq	%rbp
18,886 (0.0%)  	addq	%rax,%r13
18,886 (0.0%)  	movq	8(%rsi,%r15,8),%rax
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	addq	%r10,%r13
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	movq	%r13,-8(%rsp,%r15,8)
18,886 (0.0%)  	movq	%rdx,%rdi
     .         
18,886 (0.0%)  	mulq	%rbx
18,886 (0.0%)  	addq	%rax,%r11
18,886 (0.0%)  	movq	8(%rcx,%r15,8),%rax
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	addq	8(%rsp,%r15,8),%r11
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	leaq	4(%r15),%r15
18,886 (0.0%)  	movq	%rdx,%r10
     .         
18,886 (0.0%)  	mulq	%rbp
18,886 (0.0%)  	addq	%rax,%rdi
18,886 (0.0%)  	movq	-16(%rsi,%r15,8),%rax
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	addq	%r11,%rdi
18,886 (0.0%)  	adcq	$0,%rdx
18,886 (0.0%)  	movq	%rdi,-32(%rsp,%r15,8)
18,886 (0.0%)  	movq	%rdx,%r13
18,886 (0.0%)  	cmpq	%r9,%r15
18,886 (0.0%)  	jb	.Linner4x
     .         
 1,474 (0.0%)  	mulq	%rbx
 1,474 (0.0%)  	addq	%rax,%r10
 1,474 (0.0%)  	movq	-16(%rcx,%r15,8),%rax
 1,474 (0.0%)  	adcq	$0,%rdx
 1,474 (0.0%)  	addq	-16(%rsp,%r15,8),%r10
 1,474 (0.0%)  	adcq	$0,%rdx
 1,474 (0.0%)  	movq	%rdx,%r11
     .         
 1,474 (0.0%)  	mulq	%rbp
 1,474 (0.0%)  	addq	%rax,%r13
 1,474 (0.0%)  	movq	-8(%rsi,%r15,8),%rax
 1,474 (0.0%)  	adcq	$0,%rdx
 1,474 (0.0%)  	addq	%r10,%r13
 1,474 (0.0%)  	adcq	$0,%rdx
 1,474 (0.0%)  	movq	%r13,-24(%rsp,%r15,8)
 1,474 (0.0%)  	movq	%rdx,%rdi
     .         
 1,474 (0.0%)  	mulq	%rbx
 1,474 (0.0%)  	addq	%rax,%r11
 1,474 (0.0%)  	movq	-8(%rcx,%r15,8),%rax
 1,474 (0.0%)  	adcq	$0,%rdx
 1,474 (0.0%)  	addq	-8(%rsp,%r15,8),%r11
 1,474 (0.0%)  	adcq	$0,%rdx
 1,474 (0.0%)  	leaq	1(%r14),%r14
 1,474 (0.0%)  	movq	%rdx,%r10
     .         
 1,474 (0.0%)  	mulq	%rbp
 1,474 (0.0%)  	addq	%rax,%rdi
 1,474 (0.0%)  	movq	(%rsi),%rax
 1,474 (0.0%)  	adcq	$0,%rdx
 1,474 (0.0%)  	addq	%r11,%rdi
 1,474 (0.0%)  	adcq	$0,%rdx
 1,474 (0.0%)  	movq	%rdi,-16(%rsp,%r15,8)
 1,474 (0.0%)  	movq	%rdx,%r13
     .         
 1,474 (0.0%)  	xorq	%rdi,%rdi
 1,474 (0.0%)  	addq	%r10,%r13
 1,474 (0.0%)  	adcq	$0,%rdi
 1,474 (0.0%)  	addq	(%rsp,%r9,8),%r13
 1,474 (0.0%)  	adcq	$0,%rdi
 1,474 (0.0%)  	movq	%r13,-8(%rsp,%r15,8)
 1,474 (0.0%)  	movq	%rdi,(%rsp,%r15,8)
     .         
 1,474 (0.0%)  	cmpq	%r9,%r14
 1,474 (0.0%)  	jb	.Louter4x
    30 (0.0%)  	movq	16(%rsp,%r9,8),%rdi
    30 (0.0%)  	leaq	-4(%r9),%r15
    30 (0.0%)  	movq	0(%rsp),%rax
    30 (0.0%)  	movq	8(%rsp),%rdx
    30 (0.0%)  	shrq	$2,%r15
    30 (0.0%)  	leaq	(%rsp),%rsi
    30 (0.0%)  	xorq	%r14,%r14
     .         
    30 (0.0%)  	subq	0(%rcx),%rax
    30 (0.0%)  	movq	16(%rsi),%rbx
    30 (0.0%)  	movq	24(%rsi),%rbp
    30 (0.0%)  	sbbq	8(%rcx),%rdx
     .         
     .         .Lsub4x:
   346 (0.0%)  	movq	%rax,0(%rdi,%r14,8)
   346 (0.0%)  	movq	%rdx,8(%rdi,%r14,8)
   346 (0.0%)  	sbbq	16(%rcx,%r14,8),%rbx
   346 (0.0%)  	movq	32(%rsi,%r14,8),%rax
   346 (0.0%)  	movq	40(%rsi,%r14,8),%rdx
   346 (0.0%)  	sbbq	24(%rcx,%r14,8),%rbp
   346 (0.0%)  	movq	%rbx,16(%rdi,%r14,8)
   346 (0.0%)  	movq	%rbp,24(%rdi,%r14,8)
   346 (0.0%)  	sbbq	32(%rcx,%r14,8),%rax
   346 (0.0%)  	movq	48(%rsi,%r14,8),%rbx
   346 (0.0%)  	movq	56(%rsi,%r14,8),%rbp
   346 (0.0%)  	sbbq	40(%rcx,%r14,8),%rdx
   346 (0.0%)  	leaq	4(%r14),%r14
   346 (0.0%)  	decq	%r15
   346 (0.0%)  	jnz	.Lsub4x
     .         
    30 (0.0%)  	movq	%rax,0(%rdi,%r14,8)
    30 (0.0%)  	movq	32(%rsi,%r14,8),%rax
    30 (0.0%)  	sbbq	16(%rcx,%r14,8),%rbx
    30 (0.0%)  	movq	%rdx,8(%rdi,%r14,8)
    30 (0.0%)  	sbbq	24(%rcx,%r14,8),%rbp
    30 (0.0%)  	movq	%rbx,16(%rdi,%r14,8)
     .         
    30 (0.0%)  	sbbq	$0,%rax
    30 (0.0%)  	movq	%rbp,24(%rdi,%r14,8)
    60 (0.0%)  	pxor	%xmm0,%xmm0
     .         .byte	102,72,15,110,224
    30 (0.0%)  	pcmpeqd	%xmm5,%xmm5
    30 (0.0%)  	pshufd	$0,%xmm4,%xmm4
    30 (0.0%)  	movq	%r9,%r15
    30 (0.0%)  	pxor	%xmm4,%xmm5
    30 (0.0%)  	shrq	$2,%r15
    30 (0.0%)  	xorl	%eax,%eax
     .         
    30 (0.0%)  	jmp	.Lcopy4x
     .         .align	16
     .         .Lcopy4x:
   376 (0.0%)  	movdqa	(%rsp,%rax,1),%xmm1
   376 (0.0%)  	movdqu	(%rdi,%rax,1),%xmm2
   376 (0.0%)  	pand	%xmm4,%xmm1
   376 (0.0%)  	pand	%xmm5,%xmm2
   376 (0.0%)  	movdqa	16(%rsp,%rax,1),%xmm3
   376 (0.0%)  	movdqa	%xmm0,(%rsp,%rax,1)
   376 (0.0%)  	por	%xmm2,%xmm1
   376 (0.0%)  	movdqu	16(%rdi,%rax,1),%xmm2
   376 (0.0%)  	movdqu	%xmm1,(%rdi,%rax,1)
   376 (0.0%)  	pand	%xmm4,%xmm3
   376 (0.0%)  	pand	%xmm5,%xmm2
   376 (0.0%)  	movdqa	%xmm0,16(%rsp,%rax,1)
   376 (0.0%)  	por	%xmm2,%xmm3
   376 (0.0%)  	movdqu	%xmm3,16(%rdi,%rax,1)
   376 (0.0%)  	leaq	32(%rax),%rax
   376 (0.0%)  	decq	%r15
   376 (0.0%)  	jnz	.Lcopy4x
    30 (0.0%)  	movq	8(%rsp,%r9,8),%rsi
     .         .cfi_def_cfa	%rsi, 8
    30 (0.0%)  	movq	$1,%rax
    30 (0.0%)  	movq	-48(%rsi),%r15
     .         .cfi_restore	%r15
    30 (0.0%)  	movq	-40(%rsi),%r14
     .         .cfi_restore	%r14
    30 (0.0%)  	movq	-32(%rsi),%r13
     .         .cfi_restore	%r13
    30 (0.0%)  	movq	-24(%rsi),%r12
     .         .cfi_restore	%r12
    30 (0.0%)  	movq	-16(%rsi),%rbp
     .         .cfi_restore	%rbp
    30 (0.0%)  	movq	-8(%rsi),%rbx
     .         .cfi_restore	%rbx
    60 (0.0%)  	leaq	(%rsi),%rsp
     .         .cfi_def_cfa_register	%rsp
     .         .Lmul4x_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	bn_mul4x_mont,.-bn_mul4x_mont
     .         .extern	bn_sqrx8x_internal
     .         .hidden bn_sqrx8x_internal
     .         .extern	bn_sqr8x_internal
-- line 703 ----------------------------------------
-- line 705 ----------------------------------------
     .         
     .         .type	bn_sqr8x_mont,@function
     .         .align	32
     .         bn_sqr8x_mont:
     .         .cfi_startproc	
     .         	movq	%rsp,%rax
     .         .cfi_def_cfa_register	%rax
     .         .Lsqr8x_enter:
   154 (0.0%)  	pushq	%rbx
     .         .cfi_offset	%rbx,-16
   154 (0.0%)  	pushq	%rbp
     .         .cfi_offset	%rbp,-24
   154 (0.0%)  	pushq	%r12
     .         .cfi_offset	%r12,-32
   154 (0.0%)  	pushq	%r13
     .         .cfi_offset	%r13,-40
   154 (0.0%)  	pushq	%r14
     .         .cfi_offset	%r14,-48
   154 (0.0%)  	pushq	%r15
     .         .cfi_offset	%r15,-56
     .         .Lsqr8x_prologue:
     .         
   154 (0.0%)  	movl	%r9d,%r10d
   154 (0.0%)  	shll	$3,%r9d
   154 (0.0%)  	shlq	$3+2,%r10
   154 (0.0%)  	negq	%r9
     .         
     .         
     .         
     .         
     .         
     .         
   154 (0.0%)  	leaq	-64(%rsp,%r9,2),%r11
   154 (0.0%)  	movq	%rsp,%rbp
   154 (0.0%)  	movq	(%r8),%r8
   154 (0.0%)  	subq	%rsi,%r11
   154 (0.0%)  	andq	$4095,%r11
   154 (0.0%)  	cmpq	%r11,%r10
   154 (0.0%)  	jb	.Lsqr8x_sp_alt
   101 (0.0%)  	subq	%r11,%rbp
   101 (0.0%)  	leaq	-64(%rbp,%r9,2),%rbp
   101 (0.0%)  	jmp	.Lsqr8x_sp_done
     .         
     .         .align	32
     .         .Lsqr8x_sp_alt:
    53 (0.0%)  	leaq	4096-64(,%r9,2),%r10
    53 (0.0%)  	leaq	-64(%rbp,%r9,2),%rbp
    53 (0.0%)  	subq	%r10,%r11
    53 (0.0%)  	movq	$0,%r10
    53 (0.0%)  	cmovcq	%r10,%r11
    53 (0.0%)  	subq	%r11,%rbp
     .         .Lsqr8x_sp_done:
   154 (0.0%)  	andq	$-64,%rbp
   154 (0.0%)  	movq	%rsp,%r11
   154 (0.0%)  	subq	%rbp,%r11
   154 (0.0%)  	andq	$-4096,%r11
   154 (0.0%)  	leaq	(%r11,%rbp,1),%rsp
   154 (0.0%)  	movq	(%rsp),%r10
   154 (0.0%)  	cmpq	%rbp,%rsp
   154 (0.0%)  	ja	.Lsqr8x_page_walk
   154 (0.0%)  	jmp	.Lsqr8x_page_walk_done
     .         
     .         .align	16
     .         .Lsqr8x_page_walk:
     .         	leaq	-4096(%rsp),%rsp
     .         	movq	(%rsp),%r10
     .         	cmpq	%rbp,%rsp
     .         	ja	.Lsqr8x_page_walk
     .         .Lsqr8x_page_walk_done:
     .         
   154 (0.0%)  	movq	%r9,%r10
   154 (0.0%)  	negq	%r9
     .         
   154 (0.0%)  	movq	%r8,32(%rsp)
   308 (0.0%)  	movq	%rax,40(%rsp)
     .         .cfi_escape	0x0f,0x05,0x77,0x28,0x06,0x23,0x08
     .         .Lsqr8x_body:
     .         
     .         .byte	102,72,15,110,209
   462 (0.0%)  	pxor	%xmm0,%xmm0
     .         .byte	102,72,15,110,207
     .         .byte	102,73,15,110,218
   154 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rax
   154 (0.0%)  	movl	8(%rax),%eax
   154 (0.0%)  	andl	$0x80100,%eax
   154 (0.0%)  	cmpl	$0x80100,%eax
   154 (0.0%)  	jne	.Lsqr8x_nox
     .         
     .         	call	bn_sqrx8x_internal
     .         
     .         
     .         
     .         
     .         	leaq	(%r8,%rcx,1),%rbx
     .         	movq	%rcx,%r9
     .         	movq	%rcx,%rdx
     .         .byte	102,72,15,126,207
     .         	sarq	$3+2,%rcx
     .         	jmp	.Lsqr8x_sub
     .         
     .         .align	32
     .         .Lsqr8x_nox:
   154 (0.0%)  	call	bn_sqr8x_internal
     .         
     .         
     .         
     .         
   154 (0.0%)  	leaq	(%rdi,%r9,1),%rbx
   154 (0.0%)  	movq	%r9,%rcx
   308 (0.0%)  	movq	%r9,%rdx
     .         .byte	102,72,15,126,207
   154 (0.0%)  	sarq	$3+2,%rcx
   154 (0.0%)  	jmp	.Lsqr8x_sub
     .         
     .         .align	32
     .         .Lsqr8x_sub:
 1,888 (0.0%)  	movq	0(%rbx),%r12
 1,888 (0.0%)  	movq	8(%rbx),%r13
 1,888 (0.0%)  	movq	16(%rbx),%r14
 1,888 (0.0%)  	movq	24(%rbx),%r15
 1,888 (0.0%)  	leaq	32(%rbx),%rbx
 1,888 (0.0%)  	sbbq	0(%rbp),%r12
 1,888 (0.0%)  	sbbq	8(%rbp),%r13
 1,888 (0.0%)  	sbbq	16(%rbp),%r14
 1,888 (0.0%)  	sbbq	24(%rbp),%r15
 1,888 (0.0%)  	leaq	32(%rbp),%rbp
 1,888 (0.0%)  	movq	%r12,0(%rdi)
 1,888 (0.0%)  	movq	%r13,8(%rdi)
 1,888 (0.0%)  	movq	%r14,16(%rdi)
 1,888 (0.0%)  	movq	%r15,24(%rdi)
 1,888 (0.0%)  	leaq	32(%rdi),%rdi
 1,888 (0.0%)  	incq	%rcx
 1,888 (0.0%)  	jnz	.Lsqr8x_sub
     .         
   154 (0.0%)  	sbbq	$0,%rax
   154 (0.0%)  	leaq	(%rbx,%r9,1),%rbx
   308 (0.0%)  	leaq	(%rdi,%r9,1),%rdi
     .         
     .         .byte	102,72,15,110,200
   154 (0.0%)  	pxor	%xmm0,%xmm0
   154 (0.0%)  	pshufd	$0,%xmm1,%xmm1
   154 (0.0%)  	movq	40(%rsp),%rsi
     .         .cfi_def_cfa	%rsi,8
   154 (0.0%)  	jmp	.Lsqr8x_cond_copy
     .         
     .         .align	32
     .         .Lsqr8x_cond_copy:
 1,888 (0.0%)  	movdqa	0(%rbx),%xmm2
 1,888 (0.0%)  	movdqa	16(%rbx),%xmm3
 1,888 (0.0%)  	leaq	32(%rbx),%rbx
 1,888 (0.0%)  	movdqu	0(%rdi),%xmm4
 1,888 (0.0%)  	movdqu	16(%rdi),%xmm5
 1,888 (0.0%)  	leaq	32(%rdi),%rdi
 1,888 (0.0%)  	movdqa	%xmm0,-32(%rbx)
 1,888 (0.0%)  	movdqa	%xmm0,-16(%rbx)
 1,888 (0.0%)  	movdqa	%xmm0,-32(%rbx,%rdx,1)
 1,888 (0.0%)  	movdqa	%xmm0,-16(%rbx,%rdx,1)
 1,888 (0.0%)  	pcmpeqd	%xmm1,%xmm0
 1,888 (0.0%)  	pand	%xmm1,%xmm2
 1,888 (0.0%)  	pand	%xmm1,%xmm3
 1,888 (0.0%)  	pand	%xmm0,%xmm4
 1,888 (0.0%)  	pand	%xmm0,%xmm5
 1,888 (0.0%)  	pxor	%xmm0,%xmm0
 1,888 (0.0%)  	por	%xmm2,%xmm4
 1,888 (0.0%)  	por	%xmm3,%xmm5
 1,888 (0.0%)  	movdqu	%xmm4,-32(%rdi)
 1,888 (0.0%)  	movdqu	%xmm5,-16(%rdi)
 1,888 (0.0%)  	addq	$32,%r9
 1,888 (0.0%)  	jnz	.Lsqr8x_cond_copy
     .         
   154 (0.0%)  	movq	$1,%rax
   154 (0.0%)  	movq	-48(%rsi),%r15
     .         .cfi_restore	%r15
   154 (0.0%)  	movq	-40(%rsi),%r14
     .         .cfi_restore	%r14
   154 (0.0%)  	movq	-32(%rsi),%r13
     .         .cfi_restore	%r13
   154 (0.0%)  	movq	-24(%rsi),%r12
     .         .cfi_restore	%r12
   154 (0.0%)  	movq	-16(%rsi),%rbp
     .         .cfi_restore	%rbp
   154 (0.0%)  	movq	-8(%rsi),%rbx
     .         .cfi_restore	%rbx
   308 (0.0%)  	leaq	(%rsi),%rsp
     .         .cfi_def_cfa_register	%rsp
     .         .Lsqr8x_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	bn_sqr8x_mont,.-bn_sqr8x_mont
     .         .type	bn_mulx4x_mont,@function
     .         .align	32
     .         bn_mulx4x_mont:
-- line 896 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont5.S
--------------------------------------------------------------------------------
Ir______________ 

-- line 10 ----------------------------------------
        .         .hidden OPENSSL_ia32cap_P
        .         
        .         .globl	bn_mul_mont_gather5
        .         .hidden bn_mul_mont_gather5
        .         .type	bn_mul_mont_gather5,@function
        .         .align	64
        .         bn_mul_mont_gather5:
        .         .cfi_startproc	
       60 (0.0%)  	movl	%r9d,%r9d
       60 (0.0%)  	movq	%rsp,%rax
        .         .cfi_def_cfa_register	%rax
       60 (0.0%)  	testl	$7,%r9d
       60 (0.0%)  	jnz	.Lmul_enter
       60 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r11
       60 (0.0%)  	movl	8(%r11),%r11d
       60 (0.0%)  	jmp	.Lmul4x_enter
        .         
        .         .align	16
        .         .Lmul_enter:
        .         	movd	8(%rsp),%xmm5
        .         	pushq	%rbx
        .         .cfi_offset	%rbx,-16
        .         	pushq	%rbp
        .         .cfi_offset	%rbp,-24
-- line 33 ----------------------------------------
-- line 455 ----------------------------------------
        .         .type	bn_mul4x_mont_gather5,@function
        .         .align	32
        .         bn_mul4x_mont_gather5:
        .         .cfi_startproc	
        .         .byte	0x67
        .         	movq	%rsp,%rax
        .         .cfi_def_cfa_register	%rax
        .         .Lmul4x_enter:
       60 (0.0%)  	andl	$0x80108,%r11d
       60 (0.0%)  	cmpl	$0x80108,%r11d
       60 (0.0%)  	je	.Lmulx4x_enter
       60 (0.0%)  	pushq	%rbx
        .         .cfi_offset	%rbx,-16
       60 (0.0%)  	pushq	%rbp
        .         .cfi_offset	%rbp,-24
       60 (0.0%)  	pushq	%r12
        .         .cfi_offset	%r12,-32
       60 (0.0%)  	pushq	%r13
        .         .cfi_offset	%r13,-40
       60 (0.0%)  	pushq	%r14
        .         .cfi_offset	%r14,-48
      120 (0.0%)  	pushq	%r15
        .         .cfi_offset	%r15,-56
        .         .Lmul4x_prologue:
        .         
        .         .byte	0x67
        .         	shll	$3,%r9d
       60 (0.0%)  	leaq	(%r9,%r9,2),%r10
       60 (0.0%)  	negq	%r9
        .         
        .         
        .         
        .         
        .         
        .         
        .         
        .         
        .         
        .         
       60 (0.0%)  	leaq	-320(%rsp,%r9,2),%r11
       60 (0.0%)  	movq	%rsp,%rbp
       60 (0.0%)  	subq	%rdi,%r11
       60 (0.0%)  	andq	$4095,%r11
       60 (0.0%)  	cmpq	%r11,%r10
       60 (0.0%)  	jb	.Lmul4xsp_alt
       30 (0.0%)  	subq	%r11,%rbp
       30 (0.0%)  	leaq	-320(%rbp,%r9,2),%rbp
       30 (0.0%)  	jmp	.Lmul4xsp_done
        .         
        .         .align	32
        .         .Lmul4xsp_alt:
       30 (0.0%)  	leaq	4096-320(,%r9,2),%r10
       30 (0.0%)  	leaq	-320(%rbp,%r9,2),%rbp
       30 (0.0%)  	subq	%r10,%r11
       30 (0.0%)  	movq	$0,%r10
       30 (0.0%)  	cmovcq	%r10,%r11
       30 (0.0%)  	subq	%r11,%rbp
        .         .Lmul4xsp_done:
       60 (0.0%)  	andq	$-64,%rbp
       60 (0.0%)  	movq	%rsp,%r11
       60 (0.0%)  	subq	%rbp,%r11
       60 (0.0%)  	andq	$-4096,%r11
       60 (0.0%)  	leaq	(%r11,%rbp,1),%rsp
       60 (0.0%)  	movq	(%rsp),%r10
       60 (0.0%)  	cmpq	%rbp,%rsp
       60 (0.0%)  	ja	.Lmul4x_page_walk
       60 (0.0%)  	jmp	.Lmul4x_page_walk_done
        .         
        .         .Lmul4x_page_walk:
        .         	leaq	-4096(%rsp),%rsp
        .         	movq	(%rsp),%r10
        .         	cmpq	%rbp,%rsp
        .         	ja	.Lmul4x_page_walk
        .         .Lmul4x_page_walk_done:
        .         
       60 (0.0%)  	negq	%r9
        .         
       60 (0.0%)  	movq	%rax,40(%rsp)
        .         .cfi_escape	0x0f,0x05,0x77,0x28,0x06,0x23,0x08
        .         .Lmul4x_body:
        .         
       60 (0.0%)  	call	mul4x_internal
        .         
       60 (0.0%)  	movq	40(%rsp),%rsi
        .         .cfi_def_cfa	%rsi,8
       60 (0.0%)  	movq	$1,%rax
        .         
       60 (0.0%)  	movq	-48(%rsi),%r15
        .         .cfi_restore	%r15
       60 (0.0%)  	movq	-40(%rsi),%r14
        .         .cfi_restore	%r14
       60 (0.0%)  	movq	-32(%rsi),%r13
        .         .cfi_restore	%r13
       60 (0.0%)  	movq	-24(%rsi),%r12
        .         .cfi_restore	%r12
       60 (0.0%)  	movq	-16(%rsi),%rbp
        .         .cfi_restore	%rbp
       60 (0.0%)  	movq	-8(%rsi),%rbx
        .         .cfi_restore	%rbx
      120 (0.0%)  	leaq	(%rsi),%rsp
        .         .cfi_def_cfa_register	%rsp
        .         .Lmul4x_epilogue:
        .         	.byte	0xf3,0xc3
        .         .cfi_endproc	
        .         .size	bn_mul4x_mont_gather5,.-bn_mul4x_mont_gather5
        .         
        .         .type	mul4x_internal,@function
        .         .align	32
        .         mul4x_internal:
        .         .cfi_startproc	
    1,696 (0.0%)  	shlq	$5,%r9
    1,696 (0.0%)  	movd	8(%rax),%xmm5
    1,696 (0.0%)  	leaq	.Linc(%rip),%rax
    1,696 (0.0%)  	leaq	128(%rdx,%r9,1),%r13
    1,696 (0.0%)  	shrq	$5,%r9
    1,696 (0.0%)  	movdqa	0(%rax),%xmm0
    1,696 (0.0%)  	movdqa	16(%rax),%xmm1
    1,696 (0.0%)  	leaq	88-112(%rsp,%r9,1),%r10
    1,696 (0.0%)  	leaq	128(%rdx),%r12
        .         
    1,696 (0.0%)  	pshufd	$0,%xmm5,%xmm5
    3,392 (0.0%)  	movdqa	%xmm1,%xmm4
        .         .byte	0x67,0x67
        .         	movdqa	%xmm1,%xmm2
    1,696 (0.0%)  	paddd	%xmm0,%xmm1
    3,392 (0.0%)  	pcmpeqd	%xmm5,%xmm0
        .         .byte	0x67
        .         	movdqa	%xmm4,%xmm3
    1,696 (0.0%)  	paddd	%xmm1,%xmm2
    1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm1
    1,696 (0.0%)  	movdqa	%xmm0,112(%r10)
    1,696 (0.0%)  	movdqa	%xmm4,%xmm0
        .         
    1,696 (0.0%)  	paddd	%xmm2,%xmm3
    1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm2
    1,696 (0.0%)  	movdqa	%xmm1,128(%r10)
    1,696 (0.0%)  	movdqa	%xmm4,%xmm1
        .         
    1,696 (0.0%)  	paddd	%xmm3,%xmm0
    1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm3
    1,696 (0.0%)  	movdqa	%xmm2,144(%r10)
    1,696 (0.0%)  	movdqa	%xmm4,%xmm2
        .         
    1,696 (0.0%)  	paddd	%xmm0,%xmm1
    1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm0
    1,696 (0.0%)  	movdqa	%xmm3,160(%r10)
    1,696 (0.0%)  	movdqa	%xmm4,%xmm3
    1,696 (0.0%)  	paddd	%xmm1,%xmm2
    1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm1
    1,696 (0.0%)  	movdqa	%xmm0,176(%r10)
    1,696 (0.0%)  	movdqa	%xmm4,%xmm0
        .         
    1,696 (0.0%)  	paddd	%xmm2,%xmm3
    1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm2
    1,696 (0.0%)  	movdqa	%xmm1,192(%r10)
    1,696 (0.0%)  	movdqa	%xmm4,%xmm1
        .         
    1,696 (0.0%)  	paddd	%xmm3,%xmm0
    1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm3
    1,696 (0.0%)  	movdqa	%xmm2,208(%r10)
    1,696 (0.0%)  	movdqa	%xmm4,%xmm2
        .         
    1,696 (0.0%)  	paddd	%xmm0,%xmm1
    1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm0
    1,696 (0.0%)  	movdqa	%xmm3,224(%r10)
    1,696 (0.0%)  	movdqa	%xmm4,%xmm3
    1,696 (0.0%)  	paddd	%xmm1,%xmm2
    1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm1
    1,696 (0.0%)  	movdqa	%xmm0,240(%r10)
    1,696 (0.0%)  	movdqa	%xmm4,%xmm0
        .         
    1,696 (0.0%)  	paddd	%xmm2,%xmm3
    1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm2
    1,696 (0.0%)  	movdqa	%xmm1,256(%r10)
    1,696 (0.0%)  	movdqa	%xmm4,%xmm1
        .         
    1,696 (0.0%)  	paddd	%xmm3,%xmm0
    1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm3
    1,696 (0.0%)  	movdqa	%xmm2,272(%r10)
    1,696 (0.0%)  	movdqa	%xmm4,%xmm2
        .         
    1,696 (0.0%)  	paddd	%xmm0,%xmm1
    1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm0
    1,696 (0.0%)  	movdqa	%xmm3,288(%r10)
    1,696 (0.0%)  	movdqa	%xmm4,%xmm3
    1,696 (0.0%)  	paddd	%xmm1,%xmm2
    1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm1
    1,696 (0.0%)  	movdqa	%xmm0,304(%r10)
        .         
    3,392 (0.0%)  	paddd	%xmm2,%xmm3
        .         .byte	0x67
        .         	pcmpeqd	%xmm5,%xmm2
    1,696 (0.0%)  	movdqa	%xmm1,320(%r10)
        .         
    1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm3
    1,696 (0.0%)  	movdqa	%xmm2,336(%r10)
    1,696 (0.0%)  	pand	64(%r12),%xmm0
        .         
    1,696 (0.0%)  	pand	80(%r12),%xmm1
    1,696 (0.0%)  	pand	96(%r12),%xmm2
    1,696 (0.0%)  	movdqa	%xmm3,352(%r10)
    1,696 (0.0%)  	pand	112(%r12),%xmm3
    1,696 (0.0%)  	por	%xmm2,%xmm0
    1,696 (0.0%)  	por	%xmm3,%xmm1
    1,696 (0.0%)  	movdqa	-128(%r12),%xmm4
    1,696 (0.0%)  	movdqa	-112(%r12),%xmm5
    1,696 (0.0%)  	movdqa	-96(%r12),%xmm2
    1,696 (0.0%)  	pand	112(%r10),%xmm4
    1,696 (0.0%)  	movdqa	-80(%r12),%xmm3
    1,696 (0.0%)  	pand	128(%r10),%xmm5
    1,696 (0.0%)  	por	%xmm4,%xmm0
    1,696 (0.0%)  	pand	144(%r10),%xmm2
    1,696 (0.0%)  	por	%xmm5,%xmm1
    1,696 (0.0%)  	pand	160(%r10),%xmm3
    1,696 (0.0%)  	por	%xmm2,%xmm0
    1,696 (0.0%)  	por	%xmm3,%xmm1
    1,696 (0.0%)  	movdqa	-64(%r12),%xmm4
    1,696 (0.0%)  	movdqa	-48(%r12),%xmm5
    1,696 (0.0%)  	movdqa	-32(%r12),%xmm2
    1,696 (0.0%)  	pand	176(%r10),%xmm4
    1,696 (0.0%)  	movdqa	-16(%r12),%xmm3
    1,696 (0.0%)  	pand	192(%r10),%xmm5
    1,696 (0.0%)  	por	%xmm4,%xmm0
    1,696 (0.0%)  	pand	208(%r10),%xmm2
    1,696 (0.0%)  	por	%xmm5,%xmm1
    1,696 (0.0%)  	pand	224(%r10),%xmm3
    1,696 (0.0%)  	por	%xmm2,%xmm0
    1,696 (0.0%)  	por	%xmm3,%xmm1
    1,696 (0.0%)  	movdqa	0(%r12),%xmm4
    1,696 (0.0%)  	movdqa	16(%r12),%xmm5
    1,696 (0.0%)  	movdqa	32(%r12),%xmm2
    1,696 (0.0%)  	pand	240(%r10),%xmm4
    1,696 (0.0%)  	movdqa	48(%r12),%xmm3
    1,696 (0.0%)  	pand	256(%r10),%xmm5
    1,696 (0.0%)  	por	%xmm4,%xmm0
    1,696 (0.0%)  	pand	272(%r10),%xmm2
    1,696 (0.0%)  	por	%xmm5,%xmm1
    1,696 (0.0%)  	pand	288(%r10),%xmm3
    1,696 (0.0%)  	por	%xmm2,%xmm0
    1,696 (0.0%)  	por	%xmm3,%xmm1
    1,696 (0.0%)  	por	%xmm1,%xmm0
        .         
    1,696 (0.0%)  	pshufd	$0x4e,%xmm0,%xmm1
    1,696 (0.0%)  	por	%xmm1,%xmm0
    3,392 (0.0%)  	leaq	256(%r12),%r12
        .         .byte	102,72,15,126,195
        .         
    1,696 (0.0%)  	movq	%r13,16+8(%rsp)
    1,696 (0.0%)  	movq	%rdi,56+8(%rsp)
        .         
    1,696 (0.0%)  	movq	(%r8),%r8
    1,696 (0.0%)  	movq	(%rsi),%rax
    1,696 (0.0%)  	leaq	(%rsi,%r9,1),%rsi
    1,696 (0.0%)  	negq	%r9
        .         
    1,696 (0.0%)  	movq	%r8,%rbp
    1,696 (0.0%)  	mulq	%rbx
    1,696 (0.0%)  	movq	%rax,%r10
    1,696 (0.0%)  	movq	(%rcx),%rax
        .         
    1,696 (0.0%)  	imulq	%r10,%rbp
    1,696 (0.0%)  	leaq	64+8(%rsp),%r14
    1,696 (0.0%)  	movq	%rdx,%r11
        .         
    1,696 (0.0%)  	mulq	%rbp
    1,696 (0.0%)  	addq	%rax,%r10
    1,696 (0.0%)  	movq	8(%rsi,%r9,1),%rax
    1,696 (0.0%)  	adcq	$0,%rdx
    1,696 (0.0%)  	movq	%rdx,%rdi
        .         
    1,696 (0.0%)  	mulq	%rbx
    1,696 (0.0%)  	addq	%rax,%r11
    1,696 (0.0%)  	movq	8(%rcx),%rax
    1,696 (0.0%)  	adcq	$0,%rdx
    1,696 (0.0%)  	movq	%rdx,%r10
        .         
    1,696 (0.0%)  	mulq	%rbp
    1,696 (0.0%)  	addq	%rax,%rdi
    1,696 (0.0%)  	movq	16(%rsi,%r9,1),%rax
    1,696 (0.0%)  	adcq	$0,%rdx
    1,696 (0.0%)  	addq	%r11,%rdi
    1,696 (0.0%)  	leaq	32(%r9),%r15
    1,696 (0.0%)  	leaq	32(%rcx),%rcx
    1,696 (0.0%)  	adcq	$0,%rdx
    1,696 (0.0%)  	movq	%rdi,(%r14)
    1,696 (0.0%)  	movq	%rdx,%r13
    1,696 (0.0%)  	jmp	.L1st4x
        .         
        .         .align	32
        .         .L1st4x:
   11,872 (0.0%)  	mulq	%rbx
   11,872 (0.0%)  	addq	%rax,%r10
   11,872 (0.0%)  	movq	-16(%rcx),%rax
   11,872 (0.0%)  	leaq	32(%r14),%r14
   11,872 (0.0%)  	adcq	$0,%rdx
   11,872 (0.0%)  	movq	%rdx,%r11
        .         
   11,872 (0.0%)  	mulq	%rbp
   11,872 (0.0%)  	addq	%rax,%r13
   11,872 (0.0%)  	movq	-8(%rsi,%r15,1),%rax
   11,872 (0.0%)  	adcq	$0,%rdx
   11,872 (0.0%)  	addq	%r10,%r13
   11,872 (0.0%)  	adcq	$0,%rdx
   11,872 (0.0%)  	movq	%r13,-24(%r14)
   11,872 (0.0%)  	movq	%rdx,%rdi
        .         
   11,872 (0.0%)  	mulq	%rbx
   11,872 (0.0%)  	addq	%rax,%r11
   11,872 (0.0%)  	movq	-8(%rcx),%rax
   11,872 (0.0%)  	adcq	$0,%rdx
   11,872 (0.0%)  	movq	%rdx,%r10
        .         
   11,872 (0.0%)  	mulq	%rbp
   11,872 (0.0%)  	addq	%rax,%rdi
   11,872 (0.0%)  	movq	(%rsi,%r15,1),%rax
   11,872 (0.0%)  	adcq	$0,%rdx
   11,872 (0.0%)  	addq	%r11,%rdi
   11,872 (0.0%)  	adcq	$0,%rdx
   11,872 (0.0%)  	movq	%rdi,-16(%r14)
   11,872 (0.0%)  	movq	%rdx,%r13
        .         
   11,872 (0.0%)  	mulq	%rbx
   11,872 (0.0%)  	addq	%rax,%r10
   11,872 (0.0%)  	movq	0(%rcx),%rax
   11,872 (0.0%)  	adcq	$0,%rdx
   11,872 (0.0%)  	movq	%rdx,%r11
        .         
   11,872 (0.0%)  	mulq	%rbp
   11,872 (0.0%)  	addq	%rax,%r13
   11,872 (0.0%)  	movq	8(%rsi,%r15,1),%rax
   11,872 (0.0%)  	adcq	$0,%rdx
   11,872 (0.0%)  	addq	%r10,%r13
   11,872 (0.0%)  	adcq	$0,%rdx
   11,872 (0.0%)  	movq	%r13,-8(%r14)
   11,872 (0.0%)  	movq	%rdx,%rdi
        .         
   11,872 (0.0%)  	mulq	%rbx
   11,872 (0.0%)  	addq	%rax,%r11
   11,872 (0.0%)  	movq	8(%rcx),%rax
   11,872 (0.0%)  	adcq	$0,%rdx
   11,872 (0.0%)  	movq	%rdx,%r10
        .         
   11,872 (0.0%)  	mulq	%rbp
   11,872 (0.0%)  	addq	%rax,%rdi
   11,872 (0.0%)  	movq	16(%rsi,%r15,1),%rax
   11,872 (0.0%)  	adcq	$0,%rdx
   11,872 (0.0%)  	addq	%r11,%rdi
   11,872 (0.0%)  	leaq	32(%rcx),%rcx
   11,872 (0.0%)  	adcq	$0,%rdx
   11,872 (0.0%)  	movq	%rdi,(%r14)
   11,872 (0.0%)  	movq	%rdx,%r13
        .         
   11,872 (0.0%)  	addq	$32,%r15
   11,872 (0.0%)  	jnz	.L1st4x
        .         
    1,696 (0.0%)  	mulq	%rbx
    1,696 (0.0%)  	addq	%rax,%r10
    1,696 (0.0%)  	movq	-16(%rcx),%rax
    1,696 (0.0%)  	leaq	32(%r14),%r14
    1,696 (0.0%)  	adcq	$0,%rdx
    1,696 (0.0%)  	movq	%rdx,%r11
        .         
    1,696 (0.0%)  	mulq	%rbp
    1,696 (0.0%)  	addq	%rax,%r13
    1,696 (0.0%)  	movq	-8(%rsi),%rax
    1,696 (0.0%)  	adcq	$0,%rdx
    1,696 (0.0%)  	addq	%r10,%r13
    1,696 (0.0%)  	adcq	$0,%rdx
    1,696 (0.0%)  	movq	%r13,-24(%r14)
    1,696 (0.0%)  	movq	%rdx,%rdi
        .         
    1,696 (0.0%)  	mulq	%rbx
    1,696 (0.0%)  	addq	%rax,%r11
    1,696 (0.0%)  	movq	-8(%rcx),%rax
    1,696 (0.0%)  	adcq	$0,%rdx
    1,696 (0.0%)  	movq	%rdx,%r10
        .         
    1,696 (0.0%)  	mulq	%rbp
    1,696 (0.0%)  	addq	%rax,%rdi
    1,696 (0.0%)  	movq	(%rsi,%r9,1),%rax
    1,696 (0.0%)  	adcq	$0,%rdx
    1,696 (0.0%)  	addq	%r11,%rdi
    1,696 (0.0%)  	adcq	$0,%rdx
    1,696 (0.0%)  	movq	%rdi,-16(%r14)
    1,696 (0.0%)  	movq	%rdx,%r13
        .         
    1,696 (0.0%)  	leaq	(%rcx,%r9,1),%rcx
        .         
    1,696 (0.0%)  	xorq	%rdi,%rdi
    1,696 (0.0%)  	addq	%r10,%r13
    1,696 (0.0%)  	adcq	$0,%rdi
    1,696 (0.0%)  	movq	%r13,-8(%r14)
        .         
    1,696 (0.0%)  	jmp	.Louter4x
        .         
        .         .align	32
        .         .Louter4x:
   52,576 (0.0%)  	leaq	16+128(%r14),%rdx
   52,576 (0.0%)  	pxor	%xmm4,%xmm4
   52,576 (0.0%)  	pxor	%xmm5,%xmm5
   52,576 (0.0%)  	movdqa	-128(%r12),%xmm0
   52,576 (0.0%)  	movdqa	-112(%r12),%xmm1
   52,576 (0.0%)  	movdqa	-96(%r12),%xmm2
   52,576 (0.0%)  	movdqa	-80(%r12),%xmm3
   52,576 (0.0%)  	pand	-128(%rdx),%xmm0
   52,576 (0.0%)  	pand	-112(%rdx),%xmm1
   52,576 (0.0%)  	por	%xmm0,%xmm4
   52,576 (0.0%)  	pand	-96(%rdx),%xmm2
   52,576 (0.0%)  	por	%xmm1,%xmm5
   52,576 (0.0%)  	pand	-80(%rdx),%xmm3
   52,576 (0.0%)  	por	%xmm2,%xmm4
   52,576 (0.0%)  	por	%xmm3,%xmm5
   52,576 (0.0%)  	movdqa	-64(%r12),%xmm0
   52,576 (0.0%)  	movdqa	-48(%r12),%xmm1
   52,576 (0.0%)  	movdqa	-32(%r12),%xmm2
   52,576 (0.0%)  	movdqa	-16(%r12),%xmm3
   52,576 (0.0%)  	pand	-64(%rdx),%xmm0
   52,576 (0.0%)  	pand	-48(%rdx),%xmm1
   52,576 (0.0%)  	por	%xmm0,%xmm4
   52,576 (0.0%)  	pand	-32(%rdx),%xmm2
   52,576 (0.0%)  	por	%xmm1,%xmm5
   52,576 (0.0%)  	pand	-16(%rdx),%xmm3
   52,576 (0.0%)  	por	%xmm2,%xmm4
   52,576 (0.0%)  	por	%xmm3,%xmm5
   52,576 (0.0%)  	movdqa	0(%r12),%xmm0
   52,576 (0.0%)  	movdqa	16(%r12),%xmm1
   52,576 (0.0%)  	movdqa	32(%r12),%xmm2
   52,576 (0.0%)  	movdqa	48(%r12),%xmm3
   52,576 (0.0%)  	pand	0(%rdx),%xmm0
   52,576 (0.0%)  	pand	16(%rdx),%xmm1
   52,576 (0.0%)  	por	%xmm0,%xmm4
   52,576 (0.0%)  	pand	32(%rdx),%xmm2
   52,576 (0.0%)  	por	%xmm1,%xmm5
   52,576 (0.0%)  	pand	48(%rdx),%xmm3
   52,576 (0.0%)  	por	%xmm2,%xmm4
   52,576 (0.0%)  	por	%xmm3,%xmm5
   52,576 (0.0%)  	movdqa	64(%r12),%xmm0
   52,576 (0.0%)  	movdqa	80(%r12),%xmm1
   52,576 (0.0%)  	movdqa	96(%r12),%xmm2
   52,576 (0.0%)  	movdqa	112(%r12),%xmm3
   52,576 (0.0%)  	pand	64(%rdx),%xmm0
   52,576 (0.0%)  	pand	80(%rdx),%xmm1
   52,576 (0.0%)  	por	%xmm0,%xmm4
   52,576 (0.0%)  	pand	96(%rdx),%xmm2
   52,576 (0.0%)  	por	%xmm1,%xmm5
   52,576 (0.0%)  	pand	112(%rdx),%xmm3
   52,576 (0.0%)  	por	%xmm2,%xmm4
   52,576 (0.0%)  	por	%xmm3,%xmm5
   52,576 (0.0%)  	por	%xmm5,%xmm4
        .         
   52,576 (0.0%)  	pshufd	$0x4e,%xmm4,%xmm0
   52,576 (0.0%)  	por	%xmm4,%xmm0
  105,152 (0.0%)  	leaq	256(%r12),%r12
        .         .byte	102,72,15,126,195
        .         
   52,576 (0.0%)  	movq	(%r14,%r9,1),%r10
   52,576 (0.0%)  	movq	%r8,%rbp
   52,576 (0.0%)  	mulq	%rbx
   52,576 (0.0%)  	addq	%rax,%r10
   52,576 (0.0%)  	movq	(%rcx),%rax
   52,576 (0.0%)  	adcq	$0,%rdx
        .         
   52,576 (0.0%)  	imulq	%r10,%rbp
   52,576 (0.0%)  	movq	%rdx,%r11
   52,576 (0.0%)  	movq	%rdi,(%r14)
        .         
   52,576 (0.0%)  	leaq	(%r14,%r9,1),%r14
        .         
   52,576 (0.0%)  	mulq	%rbp
   52,576 (0.0%)  	addq	%rax,%r10
   52,576 (0.0%)  	movq	8(%rsi,%r9,1),%rax
   52,576 (0.0%)  	adcq	$0,%rdx
   52,576 (0.0%)  	movq	%rdx,%rdi
        .         
   52,576 (0.0%)  	mulq	%rbx
   52,576 (0.0%)  	addq	%rax,%r11
   52,576 (0.0%)  	movq	8(%rcx),%rax
   52,576 (0.0%)  	adcq	$0,%rdx
   52,576 (0.0%)  	addq	8(%r14),%r11
   52,576 (0.0%)  	adcq	$0,%rdx
   52,576 (0.0%)  	movq	%rdx,%r10
        .         
   52,576 (0.0%)  	mulq	%rbp
   52,576 (0.0%)  	addq	%rax,%rdi
   52,576 (0.0%)  	movq	16(%rsi,%r9,1),%rax
   52,576 (0.0%)  	adcq	$0,%rdx
   52,576 (0.0%)  	addq	%r11,%rdi
   52,576 (0.0%)  	leaq	32(%r9),%r15
   52,576 (0.0%)  	leaq	32(%rcx),%rcx
   52,576 (0.0%)  	adcq	$0,%rdx
   52,576 (0.0%)  	movq	%rdx,%r13
   52,576 (0.0%)  	jmp	.Linner4x
        .         
        .         .align	32
        .         .Linner4x:
  368,032 (0.1%)  	mulq	%rbx
  368,032 (0.1%)  	addq	%rax,%r10
  368,032 (0.1%)  	movq	-16(%rcx),%rax
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	addq	16(%r14),%r10
  368,032 (0.1%)  	leaq	32(%r14),%r14
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	movq	%rdx,%r11
        .         
  368,032 (0.1%)  	mulq	%rbp
  368,032 (0.1%)  	addq	%rax,%r13
  368,032 (0.1%)  	movq	-8(%rsi,%r15,1),%rax
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	addq	%r10,%r13
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	movq	%rdi,-32(%r14)
  368,032 (0.1%)  	movq	%rdx,%rdi
        .         
  368,032 (0.1%)  	mulq	%rbx
  368,032 (0.1%)  	addq	%rax,%r11
  368,032 (0.1%)  	movq	-8(%rcx),%rax
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	addq	-8(%r14),%r11
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	movq	%rdx,%r10
        .         
  368,032 (0.1%)  	mulq	%rbp
  368,032 (0.1%)  	addq	%rax,%rdi
  368,032 (0.1%)  	movq	(%rsi,%r15,1),%rax
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	addq	%r11,%rdi
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	movq	%r13,-24(%r14)
  368,032 (0.1%)  	movq	%rdx,%r13
        .         
  368,032 (0.1%)  	mulq	%rbx
  368,032 (0.1%)  	addq	%rax,%r10
  368,032 (0.1%)  	movq	0(%rcx),%rax
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	addq	(%r14),%r10
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	movq	%rdx,%r11
        .         
  368,032 (0.1%)  	mulq	%rbp
  368,032 (0.1%)  	addq	%rax,%r13
  368,032 (0.1%)  	movq	8(%rsi,%r15,1),%rax
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	addq	%r10,%r13
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	movq	%rdi,-16(%r14)
  368,032 (0.1%)  	movq	%rdx,%rdi
        .         
  368,032 (0.1%)  	mulq	%rbx
  368,032 (0.1%)  	addq	%rax,%r11
  368,032 (0.1%)  	movq	8(%rcx),%rax
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	addq	8(%r14),%r11
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	movq	%rdx,%r10
        .         
  368,032 (0.1%)  	mulq	%rbp
  368,032 (0.1%)  	addq	%rax,%rdi
  368,032 (0.1%)  	movq	16(%rsi,%r15,1),%rax
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	addq	%r11,%rdi
  368,032 (0.1%)  	leaq	32(%rcx),%rcx
  368,032 (0.1%)  	adcq	$0,%rdx
  368,032 (0.1%)  	movq	%r13,-8(%r14)
  368,032 (0.1%)  	movq	%rdx,%r13
        .         
  368,032 (0.1%)  	addq	$32,%r15
  368,032 (0.1%)  	jnz	.Linner4x
        .         
   52,576 (0.0%)  	mulq	%rbx
   52,576 (0.0%)  	addq	%rax,%r10
   52,576 (0.0%)  	movq	-16(%rcx),%rax
   52,576 (0.0%)  	adcq	$0,%rdx
   52,576 (0.0%)  	addq	16(%r14),%r10
   52,576 (0.0%)  	leaq	32(%r14),%r14
   52,576 (0.0%)  	adcq	$0,%rdx
   52,576 (0.0%)  	movq	%rdx,%r11
        .         
   52,576 (0.0%)  	mulq	%rbp
   52,576 (0.0%)  	addq	%rax,%r13
   52,576 (0.0%)  	movq	-8(%rsi),%rax
   52,576 (0.0%)  	adcq	$0,%rdx
   52,576 (0.0%)  	addq	%r10,%r13
   52,576 (0.0%)  	adcq	$0,%rdx
   52,576 (0.0%)  	movq	%rdi,-32(%r14)
   52,576 (0.0%)  	movq	%rdx,%rdi
        .         
   52,576 (0.0%)  	mulq	%rbx
   52,576 (0.0%)  	addq	%rax,%r11
   52,576 (0.0%)  	movq	%rbp,%rax
   52,576 (0.0%)  	movq	-8(%rcx),%rbp
   52,576 (0.0%)  	adcq	$0,%rdx
   52,576 (0.0%)  	addq	-8(%r14),%r11
   52,576 (0.0%)  	adcq	$0,%rdx
   52,576 (0.0%)  	movq	%rdx,%r10
        .         
   52,576 (0.0%)  	mulq	%rbp
   52,576 (0.0%)  	addq	%rax,%rdi
   52,576 (0.0%)  	movq	(%rsi,%r9,1),%rax
   52,576 (0.0%)  	adcq	$0,%rdx
   52,576 (0.0%)  	addq	%r11,%rdi
   52,576 (0.0%)  	adcq	$0,%rdx
   52,576 (0.0%)  	movq	%r13,-24(%r14)
   52,576 (0.0%)  	movq	%rdx,%r13
        .         
   52,576 (0.0%)  	movq	%rdi,-16(%r14)
   52,576 (0.0%)  	leaq	(%rcx,%r9,1),%rcx
        .         
   52,576 (0.0%)  	xorq	%rdi,%rdi
   52,576 (0.0%)  	addq	%r10,%r13
   52,576 (0.0%)  	adcq	$0,%rdi
   52,576 (0.0%)  	addq	(%r14),%r13
   52,576 (0.0%)  	adcq	$0,%rdi
   52,576 (0.0%)  	movq	%r13,-8(%r14)
        .         
   52,576 (0.0%)  	cmpq	16+8(%rsp),%r12
   52,576 (0.0%)  	jb	.Louter4x
    1,696 (0.0%)  	xorq	%rax,%rax
    1,696 (0.0%)  	subq	%r13,%rbp
    1,696 (0.0%)  	adcq	%r15,%r15
    1,696 (0.0%)  	orq	%r15,%rdi
    1,696 (0.0%)  	subq	%rdi,%rax
    1,696 (0.0%)  	leaq	(%r14,%r9,1),%rbx
    1,696 (0.0%)  	movq	(%rcx),%r12
    1,696 (0.0%)  	leaq	(%rcx),%rbp
    1,696 (0.0%)  	movq	%r9,%rcx
    1,696 (0.0%)  	sarq	$3+2,%rcx
    1,696 (0.0%)  	movq	56+8(%rsp),%rdi
    1,696 (0.0%)  	decq	%r12
    1,696 (0.0%)  	xorq	%r10,%r10
    1,696 (0.0%)  	movq	8(%rbp),%r13
    1,696 (0.0%)  	movq	16(%rbp),%r14
    1,696 (0.0%)  	movq	24(%rbp),%r15
    1,696 (0.0%)  	jmp	.Lsqr4x_sub_entry
        .         .cfi_endproc	
        .         .size	mul4x_internal,.-mul4x_internal
        .         .globl	bn_power5
        .         .hidden bn_power5
        .         .type	bn_power5,@function
        .         .align	32
        .         bn_power5:
        .         .cfi_startproc	
    1,636 (0.0%)  	movq	%rsp,%rax
        .         .cfi_def_cfa_register	%rax
    1,636 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r11
    1,636 (0.0%)  	movl	8(%r11),%r11d
    1,636 (0.0%)  	andl	$0x80108,%r11d
    1,636 (0.0%)  	cmpl	$0x80108,%r11d
    1,636 (0.0%)  	je	.Lpowerx5_enter
    1,636 (0.0%)  	pushq	%rbx
        .         .cfi_offset	%rbx,-16
    1,636 (0.0%)  	pushq	%rbp
        .         .cfi_offset	%rbp,-24
    1,636 (0.0%)  	pushq	%r12
        .         .cfi_offset	%r12,-32
    1,636 (0.0%)  	pushq	%r13
        .         .cfi_offset	%r13,-40
    1,636 (0.0%)  	pushq	%r14
        .         .cfi_offset	%r14,-48
    1,636 (0.0%)  	pushq	%r15
        .         .cfi_offset	%r15,-56
        .         .Lpower5_prologue:
        .         
    1,636 (0.0%)  	shll	$3,%r9d
    1,636 (0.0%)  	leal	(%r9,%r9,2),%r10d
    1,636 (0.0%)  	negq	%r9
    1,636 (0.0%)  	movq	(%r8),%r8
        .         
        .         
        .         
        .         
        .         
        .         
        .         
        .         
    1,636 (0.0%)  	leaq	-320(%rsp,%r9,2),%r11
    1,636 (0.0%)  	movq	%rsp,%rbp
    1,636 (0.0%)  	subq	%rdi,%r11
    1,636 (0.0%)  	andq	$4095,%r11
    1,636 (0.0%)  	cmpq	%r11,%r10
    1,636 (0.0%)  	jb	.Lpwr_sp_alt
      818 (0.0%)  	subq	%r11,%rbp
      818 (0.0%)  	leaq	-320(%rbp,%r9,2),%rbp
      818 (0.0%)  	jmp	.Lpwr_sp_done
        .         
        .         .align	32
        .         .Lpwr_sp_alt:
      818 (0.0%)  	leaq	4096-320(,%r9,2),%r10
      818 (0.0%)  	leaq	-320(%rbp,%r9,2),%rbp
      818 (0.0%)  	subq	%r10,%r11
      818 (0.0%)  	movq	$0,%r10
      818 (0.0%)  	cmovcq	%r10,%r11
      818 (0.0%)  	subq	%r11,%rbp
        .         .Lpwr_sp_done:
    1,636 (0.0%)  	andq	$-64,%rbp
    1,636 (0.0%)  	movq	%rsp,%r11
    1,636 (0.0%)  	subq	%rbp,%r11
    1,636 (0.0%)  	andq	$-4096,%r11
    1,636 (0.0%)  	leaq	(%r11,%rbp,1),%rsp
    1,636 (0.0%)  	movq	(%rsp),%r10
    1,636 (0.0%)  	cmpq	%rbp,%rsp
    1,636 (0.0%)  	ja	.Lpwr_page_walk
    1,636 (0.0%)  	jmp	.Lpwr_page_walk_done
        .         
        .         .Lpwr_page_walk:
        .         	leaq	-4096(%rsp),%rsp
        .         	movq	(%rsp),%r10
        .         	cmpq	%rbp,%rsp
        .         	ja	.Lpwr_page_walk
        .         .Lpwr_page_walk_done:
        .         
    1,636 (0.0%)  	movq	%r9,%r10
    1,636 (0.0%)  	negq	%r9
        .         
        .         
        .         
        .         
        .         
        .         
        .         
        .         
        .         
        .         
    1,636 (0.0%)  	movq	%r8,32(%rsp)
    8,180 (0.0%)  	movq	%rax,40(%rsp)
        .         .cfi_escape	0x0f,0x05,0x77,0x28,0x06,0x23,0x08
        .         .Lpower5_body:
        .         .byte	102,72,15,110,207
        .         .byte	102,72,15,110,209
        .         .byte	102,73,15,110,218
        .         .byte	102,72,15,110,226
        .         
    1,636 (0.0%)  	call	__bn_sqr8x_internal
    1,636 (0.0%)  	call	__bn_post4x_internal
    1,636 (0.0%)  	call	__bn_sqr8x_internal
    1,636 (0.0%)  	call	__bn_post4x_internal
    1,636 (0.0%)  	call	__bn_sqr8x_internal
    1,636 (0.0%)  	call	__bn_post4x_internal
    1,636 (0.0%)  	call	__bn_sqr8x_internal
    1,636 (0.0%)  	call	__bn_post4x_internal
    1,636 (0.0%)  	call	__bn_sqr8x_internal
    4,908 (0.0%)  	call	__bn_post4x_internal
        .         
        .         .byte	102,72,15,126,209
        .         .byte	102,72,15,126,226
    1,636 (0.0%)  	movq	%rsi,%rdi
    1,636 (0.0%)  	movq	40(%rsp),%rax
    1,636 (0.0%)  	leaq	32(%rsp),%r8
        .         
    1,636 (0.0%)  	call	mul4x_internal
        .         
    1,636 (0.0%)  	movq	40(%rsp),%rsi
        .         .cfi_def_cfa	%rsi,8
    1,636 (0.0%)  	movq	$1,%rax
    1,636 (0.0%)  	movq	-48(%rsi),%r15
        .         .cfi_restore	%r15
    1,636 (0.0%)  	movq	-40(%rsi),%r14
        .         .cfi_restore	%r14
    1,636 (0.0%)  	movq	-32(%rsi),%r13
        .         .cfi_restore	%r13
    1,636 (0.0%)  	movq	-24(%rsi),%r12
        .         .cfi_restore	%r12
    1,636 (0.0%)  	movq	-16(%rsi),%rbp
        .         .cfi_restore	%rbp
    1,636 (0.0%)  	movq	-8(%rsi),%rbx
        .         .cfi_restore	%rbx
    3,272 (0.0%)  	leaq	(%rsi),%rsp
        .         .cfi_def_cfa_register	%rsp
        .         .Lpower5_epilogue:
        .         	.byte	0xf3,0xc3
        .         .cfi_endproc	
        .         .size	bn_power5,.-bn_power5
        .         
        .         .globl	bn_sqr8x_internal
        .         .hidden bn_sqr8x_internal
-- line 1228 ----------------------------------------
-- line 1300 ----------------------------------------
        .         
        .         
        .         
        .         
        .         
        .         
        .         
        .         
    8,334 (0.0%)  	leaq	32(%r10),%rbp
    8,334 (0.0%)  	leaq	(%rsi,%r9,1),%rsi
        .         
    8,334 (0.0%)  	movq	%r9,%rcx
        .         
        .         
    8,334 (0.0%)  	movq	-32(%rsi,%rbp,1),%r14
    8,334 (0.0%)  	leaq	48+8(%rsp,%r9,2),%rdi
    8,334 (0.0%)  	movq	-24(%rsi,%rbp,1),%rax
    8,334 (0.0%)  	leaq	-32(%rdi,%rbp,1),%rdi
    8,334 (0.0%)  	movq	-16(%rsi,%rbp,1),%rbx
    8,334 (0.0%)  	movq	%rax,%r15
        .         
    8,334 (0.0%)  	mulq	%r14
    8,334 (0.0%)  	movq	%rax,%r10
    8,334 (0.0%)  	movq	%rbx,%rax
    8,334 (0.0%)  	movq	%rdx,%r11
    8,334 (0.0%)  	movq	%r10,-24(%rdi,%rbp,1)
        .         
    8,334 (0.0%)  	mulq	%r14
    8,334 (0.0%)  	addq	%rax,%r11
    8,334 (0.0%)  	movq	%rbx,%rax
    8,334 (0.0%)  	adcq	$0,%rdx
    8,334 (0.0%)  	movq	%r11,-16(%rdi,%rbp,1)
    8,334 (0.0%)  	movq	%rdx,%r10
        .         
        .         
    8,334 (0.0%)  	movq	-8(%rsi,%rbp,1),%rbx
    8,334 (0.0%)  	mulq	%r15
    8,334 (0.0%)  	movq	%rax,%r12
    8,334 (0.0%)  	movq	%rbx,%rax
    8,334 (0.0%)  	movq	%rdx,%r13
        .         
    8,334 (0.0%)  	leaq	(%rbp),%rcx
    8,334 (0.0%)  	mulq	%r14
    8,334 (0.0%)  	addq	%rax,%r10
    8,334 (0.0%)  	movq	%rbx,%rax
    8,334 (0.0%)  	movq	%rdx,%r11
    8,334 (0.0%)  	adcq	$0,%r11
    8,334 (0.0%)  	addq	%r12,%r10
    8,334 (0.0%)  	adcq	$0,%r11
    8,334 (0.0%)  	movq	%r10,-8(%rdi,%rcx,1)
    8,334 (0.0%)  	jmp	.Lsqr4x_1st
        .         
        .         .align	32
        .         .Lsqr4x_1st:
   58,994 (0.0%)  	movq	(%rsi,%rcx,1),%rbx
   58,994 (0.0%)  	mulq	%r15
   58,994 (0.0%)  	addq	%rax,%r13
   58,994 (0.0%)  	movq	%rbx,%rax
   58,994 (0.0%)  	movq	%rdx,%r12
   58,994 (0.0%)  	adcq	$0,%r12
        .         
   58,994 (0.0%)  	mulq	%r14
   58,994 (0.0%)  	addq	%rax,%r11
   58,994 (0.0%)  	movq	%rbx,%rax
   58,994 (0.0%)  	movq	8(%rsi,%rcx,1),%rbx
   58,994 (0.0%)  	movq	%rdx,%r10
   58,994 (0.0%)  	adcq	$0,%r10
   58,994 (0.0%)  	addq	%r13,%r11
   58,994 (0.0%)  	adcq	$0,%r10
        .         
        .         
   58,994 (0.0%)  	mulq	%r15
   58,994 (0.0%)  	addq	%rax,%r12
   58,994 (0.0%)  	movq	%rbx,%rax
   58,994 (0.0%)  	movq	%r11,(%rdi,%rcx,1)
   58,994 (0.0%)  	movq	%rdx,%r13
   58,994 (0.0%)  	adcq	$0,%r13
        .         
   58,994 (0.0%)  	mulq	%r14
   58,994 (0.0%)  	addq	%rax,%r10
   58,994 (0.0%)  	movq	%rbx,%rax
   58,994 (0.0%)  	movq	16(%rsi,%rcx,1),%rbx
   58,994 (0.0%)  	movq	%rdx,%r11
   58,994 (0.0%)  	adcq	$0,%r11
   58,994 (0.0%)  	addq	%r12,%r10
   58,994 (0.0%)  	adcq	$0,%r11
        .         
   58,994 (0.0%)  	mulq	%r15
   58,994 (0.0%)  	addq	%rax,%r13
   58,994 (0.0%)  	movq	%rbx,%rax
   58,994 (0.0%)  	movq	%r10,8(%rdi,%rcx,1)
   58,994 (0.0%)  	movq	%rdx,%r12
   58,994 (0.0%)  	adcq	$0,%r12
        .         
   58,994 (0.0%)  	mulq	%r14
   58,994 (0.0%)  	addq	%rax,%r11
   58,994 (0.0%)  	movq	%rbx,%rax
   58,994 (0.0%)  	movq	24(%rsi,%rcx,1),%rbx
   58,994 (0.0%)  	movq	%rdx,%r10
   58,994 (0.0%)  	adcq	$0,%r10
   58,994 (0.0%)  	addq	%r13,%r11
   58,994 (0.0%)  	adcq	$0,%r10
        .         
        .         
   58,994 (0.0%)  	mulq	%r15
   58,994 (0.0%)  	addq	%rax,%r12
   58,994 (0.0%)  	movq	%rbx,%rax
   58,994 (0.0%)  	movq	%r11,16(%rdi,%rcx,1)
   58,994 (0.0%)  	movq	%rdx,%r13
   58,994 (0.0%)  	adcq	$0,%r13
   58,994 (0.0%)  	leaq	32(%rcx),%rcx
        .         
   58,994 (0.0%)  	mulq	%r14
   58,994 (0.0%)  	addq	%rax,%r10
   58,994 (0.0%)  	movq	%rbx,%rax
   58,994 (0.0%)  	movq	%rdx,%r11
   58,994 (0.0%)  	adcq	$0,%r11
   58,994 (0.0%)  	addq	%r12,%r10
   58,994 (0.0%)  	adcq	$0,%r11
   58,994 (0.0%)  	movq	%r10,-8(%rdi,%rcx,1)
        .         
   58,994 (0.0%)  	cmpq	$0,%rcx
   58,994 (0.0%)  	jne	.Lsqr4x_1st
        .         
    8,334 (0.0%)  	mulq	%r15
    8,334 (0.0%)  	addq	%rax,%r13
    8,334 (0.0%)  	leaq	16(%rbp),%rbp
    8,334 (0.0%)  	adcq	$0,%rdx
    8,334 (0.0%)  	addq	%r11,%r13
    8,334 (0.0%)  	adcq	$0,%rdx
        .         
    8,334 (0.0%)  	movq	%r13,(%rdi)
    8,334 (0.0%)  	movq	%rdx,%r12
    8,334 (0.0%)  	movq	%rdx,8(%rdi)
    8,334 (0.0%)  	jmp	.Lsqr4x_outer
        .         
        .         .align	32
        .         .Lsqr4x_outer:
  109,654 (0.0%)  	movq	-32(%rsi,%rbp,1),%r14
  109,654 (0.0%)  	leaq	48+8(%rsp,%r9,2),%rdi
  109,654 (0.0%)  	movq	-24(%rsi,%rbp,1),%rax
  109,654 (0.0%)  	leaq	-32(%rdi,%rbp,1),%rdi
  109,654 (0.0%)  	movq	-16(%rsi,%rbp,1),%rbx
  109,654 (0.0%)  	movq	%rax,%r15
        .         
  109,654 (0.0%)  	mulq	%r14
  109,654 (0.0%)  	movq	-24(%rdi,%rbp,1),%r10
  109,654 (0.0%)  	addq	%rax,%r10
  109,654 (0.0%)  	movq	%rbx,%rax
  109,654 (0.0%)  	adcq	$0,%rdx
  109,654 (0.0%)  	movq	%r10,-24(%rdi,%rbp,1)
  109,654 (0.0%)  	movq	%rdx,%r11
        .         
  109,654 (0.0%)  	mulq	%r14
  109,654 (0.0%)  	addq	%rax,%r11
  109,654 (0.0%)  	movq	%rbx,%rax
  109,654 (0.0%)  	adcq	$0,%rdx
  109,654 (0.0%)  	addq	-16(%rdi,%rbp,1),%r11
  109,654 (0.0%)  	movq	%rdx,%r10
  109,654 (0.0%)  	adcq	$0,%r10
  109,654 (0.0%)  	movq	%r11,-16(%rdi,%rbp,1)
        .         
  109,654 (0.0%)  	xorq	%r12,%r12
        .         
  109,654 (0.0%)  	movq	-8(%rsi,%rbp,1),%rbx
  109,654 (0.0%)  	mulq	%r15
  109,654 (0.0%)  	addq	%rax,%r12
  109,654 (0.0%)  	movq	%rbx,%rax
  109,654 (0.0%)  	adcq	$0,%rdx
  109,654 (0.0%)  	addq	-8(%rdi,%rbp,1),%r12
  109,654 (0.0%)  	movq	%rdx,%r13
  109,654 (0.0%)  	adcq	$0,%r13
        .         
  109,654 (0.0%)  	mulq	%r14
  109,654 (0.0%)  	addq	%rax,%r10
  109,654 (0.0%)  	movq	%rbx,%rax
  109,654 (0.0%)  	adcq	$0,%rdx
  109,654 (0.0%)  	addq	%r12,%r10
  109,654 (0.0%)  	movq	%rdx,%r11
  109,654 (0.0%)  	adcq	$0,%r11
  109,654 (0.0%)  	movq	%r10,-8(%rdi,%rbp,1)
        .         
  109,654 (0.0%)  	leaq	(%rbp),%rcx
  109,654 (0.0%)  	jmp	.Lsqr4x_inner
        .         
        .         .align	32
        .         .Lsqr4x_inner:
  786,602 (0.1%)  	movq	(%rsi,%rcx,1),%rbx
  786,602 (0.1%)  	mulq	%r15
  786,602 (0.1%)  	addq	%rax,%r13
  786,602 (0.1%)  	movq	%rbx,%rax
  786,602 (0.1%)  	movq	%rdx,%r12
  786,602 (0.1%)  	adcq	$0,%r12
  786,602 (0.1%)  	addq	(%rdi,%rcx,1),%r13
1,573,204 (0.2%)  	adcq	$0,%r12
        .         
        .         .byte	0x67
        .         	mulq	%r14
  786,602 (0.1%)  	addq	%rax,%r11
  786,602 (0.1%)  	movq	%rbx,%rax
  786,602 (0.1%)  	movq	8(%rsi,%rcx,1),%rbx
  786,602 (0.1%)  	movq	%rdx,%r10
  786,602 (0.1%)  	adcq	$0,%r10
  786,602 (0.1%)  	addq	%r13,%r11
  786,602 (0.1%)  	adcq	$0,%r10
        .         
  786,602 (0.1%)  	mulq	%r15
  786,602 (0.1%)  	addq	%rax,%r12
  786,602 (0.1%)  	movq	%r11,(%rdi,%rcx,1)
  786,602 (0.1%)  	movq	%rbx,%rax
  786,602 (0.1%)  	movq	%rdx,%r13
  786,602 (0.1%)  	adcq	$0,%r13
  786,602 (0.1%)  	addq	8(%rdi,%rcx,1),%r12
  786,602 (0.1%)  	leaq	16(%rcx),%rcx
  786,602 (0.1%)  	adcq	$0,%r13
        .         
  786,602 (0.1%)  	mulq	%r14
  786,602 (0.1%)  	addq	%rax,%r10
  786,602 (0.1%)  	movq	%rbx,%rax
  786,602 (0.1%)  	adcq	$0,%rdx
  786,602 (0.1%)  	addq	%r12,%r10
  786,602 (0.1%)  	movq	%rdx,%r11
  786,602 (0.1%)  	adcq	$0,%r11
  786,602 (0.1%)  	movq	%r10,-8(%rdi,%rcx,1)
        .         
  786,602 (0.1%)  	cmpq	$0,%rcx
  896,256 (0.1%)  	jne	.Lsqr4x_inner
        .         
        .         .byte	0x67
        .         	mulq	%r15
  109,654 (0.0%)  	addq	%rax,%r13
  109,654 (0.0%)  	adcq	$0,%rdx
  109,654 (0.0%)  	addq	%r11,%r13
  109,654 (0.0%)  	adcq	$0,%rdx
        .         
  109,654 (0.0%)  	movq	%r13,(%rdi)
  109,654 (0.0%)  	movq	%rdx,%r12
  109,654 (0.0%)  	movq	%rdx,8(%rdi)
        .         
  109,654 (0.0%)  	addq	$16,%rbp
  109,654 (0.0%)  	jnz	.Lsqr4x_outer
        .         
        .         
    8,334 (0.0%)  	movq	-32(%rsi),%r14
    8,334 (0.0%)  	leaq	48+8(%rsp,%r9,2),%rdi
    8,334 (0.0%)  	movq	-24(%rsi),%rax
    8,334 (0.0%)  	leaq	-32(%rdi,%rbp,1),%rdi
    8,334 (0.0%)  	movq	-16(%rsi),%rbx
    8,334 (0.0%)  	movq	%rax,%r15
        .         
    8,334 (0.0%)  	mulq	%r14
    8,334 (0.0%)  	addq	%rax,%r10
    8,334 (0.0%)  	movq	%rbx,%rax
    8,334 (0.0%)  	movq	%rdx,%r11
    8,334 (0.0%)  	adcq	$0,%r11
        .         
    8,334 (0.0%)  	mulq	%r14
    8,334 (0.0%)  	addq	%rax,%r11
    8,334 (0.0%)  	movq	%rbx,%rax
    8,334 (0.0%)  	movq	%r10,-24(%rdi)
    8,334 (0.0%)  	movq	%rdx,%r10
    8,334 (0.0%)  	adcq	$0,%r10
    8,334 (0.0%)  	addq	%r13,%r11
    8,334 (0.0%)  	movq	-8(%rsi),%rbx
    8,334 (0.0%)  	adcq	$0,%r10
        .         
    8,334 (0.0%)  	mulq	%r15
    8,334 (0.0%)  	addq	%rax,%r12
    8,334 (0.0%)  	movq	%rbx,%rax
    8,334 (0.0%)  	movq	%r11,-16(%rdi)
    8,334 (0.0%)  	movq	%rdx,%r13
    8,334 (0.0%)  	adcq	$0,%r13
        .         
    8,334 (0.0%)  	mulq	%r14
    8,334 (0.0%)  	addq	%rax,%r10
    8,334 (0.0%)  	movq	%rbx,%rax
    8,334 (0.0%)  	movq	%rdx,%r11
    8,334 (0.0%)  	adcq	$0,%r11
    8,334 (0.0%)  	addq	%r12,%r10
    8,334 (0.0%)  	adcq	$0,%r11
    8,334 (0.0%)  	movq	%r10,-8(%rdi)
        .         
    8,334 (0.0%)  	mulq	%r15
    8,334 (0.0%)  	addq	%rax,%r13
    8,334 (0.0%)  	movq	-16(%rsi),%rax
    8,334 (0.0%)  	adcq	$0,%rdx
    8,334 (0.0%)  	addq	%r11,%r13
    8,334 (0.0%)  	adcq	$0,%rdx
        .         
    8,334 (0.0%)  	movq	%r13,(%rdi)
    8,334 (0.0%)  	movq	%rdx,%r12
    8,334 (0.0%)  	movq	%rdx,8(%rdi)
        .         
    8,334 (0.0%)  	mulq	%rbx
    8,334 (0.0%)  	addq	$16,%rbp
    8,334 (0.0%)  	xorq	%r14,%r14
    8,334 (0.0%)  	subq	%r9,%rbp
    8,334 (0.0%)  	xorq	%r15,%r15
        .         
    8,334 (0.0%)  	addq	%r12,%rax
    8,334 (0.0%)  	adcq	$0,%rdx
    8,334 (0.0%)  	movq	%rax,8(%rdi)
    8,334 (0.0%)  	movq	%rdx,16(%rdi)
    8,334 (0.0%)  	movq	%r15,24(%rdi)
        .         
    8,334 (0.0%)  	movq	-16(%rsi,%rbp,1),%rax
    8,334 (0.0%)  	leaq	48+8(%rsp),%rdi
    8,334 (0.0%)  	xorq	%r10,%r10
    8,334 (0.0%)  	movq	8(%rdi),%r11
        .         
    8,334 (0.0%)  	leaq	(%r14,%r10,2),%r12
    8,334 (0.0%)  	shrq	$63,%r10
    8,334 (0.0%)  	leaq	(%rcx,%r11,2),%r13
    8,334 (0.0%)  	shrq	$63,%r11
    8,334 (0.0%)  	orq	%r10,%r13
    8,334 (0.0%)  	movq	16(%rdi),%r10
    8,334 (0.0%)  	movq	%r11,%r14
    8,334 (0.0%)  	mulq	%rax
    8,334 (0.0%)  	negq	%r15
    8,334 (0.0%)  	movq	24(%rdi),%r11
    8,334 (0.0%)  	adcq	%rax,%r12
    8,334 (0.0%)  	movq	-8(%rsi,%rbp,1),%rax
    8,334 (0.0%)  	movq	%r12,(%rdi)
    8,334 (0.0%)  	adcq	%rdx,%r13
        .         
    8,334 (0.0%)  	leaq	(%r14,%r10,2),%rbx
    8,334 (0.0%)  	movq	%r13,8(%rdi)
    8,334 (0.0%)  	sbbq	%r15,%r15
    8,334 (0.0%)  	shrq	$63,%r10
    8,334 (0.0%)  	leaq	(%rcx,%r11,2),%r8
    8,334 (0.0%)  	shrq	$63,%r11
    8,334 (0.0%)  	orq	%r10,%r8
    8,334 (0.0%)  	movq	32(%rdi),%r10
    8,334 (0.0%)  	movq	%r11,%r14
    8,334 (0.0%)  	mulq	%rax
    8,334 (0.0%)  	negq	%r15
    8,334 (0.0%)  	movq	40(%rdi),%r11
    8,334 (0.0%)  	adcq	%rax,%rbx
    8,334 (0.0%)  	movq	0(%rsi,%rbp,1),%rax
    8,334 (0.0%)  	movq	%rbx,16(%rdi)
    8,334 (0.0%)  	adcq	%rdx,%r8
    8,334 (0.0%)  	leaq	16(%rbp),%rbp
    8,334 (0.0%)  	movq	%r8,24(%rdi)
    8,334 (0.0%)  	sbbq	%r15,%r15
    8,334 (0.0%)  	leaq	64(%rdi),%rdi
    8,334 (0.0%)  	jmp	.Lsqr4x_shift_n_add
        .         
        .         .align	32
        .         .Lsqr4x_shift_n_add:
   58,994 (0.0%)  	leaq	(%r14,%r10,2),%r12
   58,994 (0.0%)  	shrq	$63,%r10
   58,994 (0.0%)  	leaq	(%rcx,%r11,2),%r13
   58,994 (0.0%)  	shrq	$63,%r11
   58,994 (0.0%)  	orq	%r10,%r13
   58,994 (0.0%)  	movq	-16(%rdi),%r10
   58,994 (0.0%)  	movq	%r11,%r14
   58,994 (0.0%)  	mulq	%rax
   58,994 (0.0%)  	negq	%r15
   58,994 (0.0%)  	movq	-8(%rdi),%r11
   58,994 (0.0%)  	adcq	%rax,%r12
   58,994 (0.0%)  	movq	-8(%rsi,%rbp,1),%rax
   58,994 (0.0%)  	movq	%r12,-32(%rdi)
   58,994 (0.0%)  	adcq	%rdx,%r13
        .         
   58,994 (0.0%)  	leaq	(%r14,%r10,2),%rbx
   58,994 (0.0%)  	movq	%r13,-24(%rdi)
   58,994 (0.0%)  	sbbq	%r15,%r15
   58,994 (0.0%)  	shrq	$63,%r10
   58,994 (0.0%)  	leaq	(%rcx,%r11,2),%r8
   58,994 (0.0%)  	shrq	$63,%r11
   58,994 (0.0%)  	orq	%r10,%r8
   58,994 (0.0%)  	movq	0(%rdi),%r10
   58,994 (0.0%)  	movq	%r11,%r14
   58,994 (0.0%)  	mulq	%rax
   58,994 (0.0%)  	negq	%r15
   58,994 (0.0%)  	movq	8(%rdi),%r11
   58,994 (0.0%)  	adcq	%rax,%rbx
   58,994 (0.0%)  	movq	0(%rsi,%rbp,1),%rax
   58,994 (0.0%)  	movq	%rbx,-16(%rdi)
   58,994 (0.0%)  	adcq	%rdx,%r8
        .         
   58,994 (0.0%)  	leaq	(%r14,%r10,2),%r12
   58,994 (0.0%)  	movq	%r8,-8(%rdi)
   58,994 (0.0%)  	sbbq	%r15,%r15
   58,994 (0.0%)  	shrq	$63,%r10
   58,994 (0.0%)  	leaq	(%rcx,%r11,2),%r13
   58,994 (0.0%)  	shrq	$63,%r11
   58,994 (0.0%)  	orq	%r10,%r13
   58,994 (0.0%)  	movq	16(%rdi),%r10
   58,994 (0.0%)  	movq	%r11,%r14
   58,994 (0.0%)  	mulq	%rax
   58,994 (0.0%)  	negq	%r15
   58,994 (0.0%)  	movq	24(%rdi),%r11
   58,994 (0.0%)  	adcq	%rax,%r12
   58,994 (0.0%)  	movq	8(%rsi,%rbp,1),%rax
   58,994 (0.0%)  	movq	%r12,0(%rdi)
   58,994 (0.0%)  	adcq	%rdx,%r13
        .         
   58,994 (0.0%)  	leaq	(%r14,%r10,2),%rbx
   58,994 (0.0%)  	movq	%r13,8(%rdi)
   58,994 (0.0%)  	sbbq	%r15,%r15
   58,994 (0.0%)  	shrq	$63,%r10
   58,994 (0.0%)  	leaq	(%rcx,%r11,2),%r8
   58,994 (0.0%)  	shrq	$63,%r11
   58,994 (0.0%)  	orq	%r10,%r8
   58,994 (0.0%)  	movq	32(%rdi),%r10
   58,994 (0.0%)  	movq	%r11,%r14
   58,994 (0.0%)  	mulq	%rax
   58,994 (0.0%)  	negq	%r15
   58,994 (0.0%)  	movq	40(%rdi),%r11
   58,994 (0.0%)  	adcq	%rax,%rbx
   58,994 (0.0%)  	movq	16(%rsi,%rbp,1),%rax
   58,994 (0.0%)  	movq	%rbx,16(%rdi)
   58,994 (0.0%)  	adcq	%rdx,%r8
   58,994 (0.0%)  	movq	%r8,24(%rdi)
   58,994 (0.0%)  	sbbq	%r15,%r15
   58,994 (0.0%)  	leaq	64(%rdi),%rdi
   58,994 (0.0%)  	addq	$32,%rbp
   58,994 (0.0%)  	jnz	.Lsqr4x_shift_n_add
        .         
   16,668 (0.0%)  	leaq	(%r14,%r10,2),%r12
        .         .byte	0x67
        .         	shrq	$63,%r10
    8,334 (0.0%)  	leaq	(%rcx,%r11,2),%r13
    8,334 (0.0%)  	shrq	$63,%r11
    8,334 (0.0%)  	orq	%r10,%r13
    8,334 (0.0%)  	movq	-16(%rdi),%r10
    8,334 (0.0%)  	movq	%r11,%r14
    8,334 (0.0%)  	mulq	%rax
    8,334 (0.0%)  	negq	%r15
    8,334 (0.0%)  	movq	-8(%rdi),%r11
    8,334 (0.0%)  	adcq	%rax,%r12
    8,334 (0.0%)  	movq	-8(%rsi),%rax
    8,334 (0.0%)  	movq	%r12,-32(%rdi)
    8,334 (0.0%)  	adcq	%rdx,%r13
        .         
    8,334 (0.0%)  	leaq	(%r14,%r10,2),%rbx
    8,334 (0.0%)  	movq	%r13,-24(%rdi)
    8,334 (0.0%)  	sbbq	%r15,%r15
    8,334 (0.0%)  	shrq	$63,%r10
    8,334 (0.0%)  	leaq	(%rcx,%r11,2),%r8
    8,334 (0.0%)  	shrq	$63,%r11
    8,334 (0.0%)  	orq	%r10,%r8
    8,334 (0.0%)  	mulq	%rax
    8,334 (0.0%)  	negq	%r15
    8,334 (0.0%)  	adcq	%rax,%rbx
    8,334 (0.0%)  	adcq	%rdx,%r8
    8,334 (0.0%)  	movq	%rbx,-16(%rdi)
   16,668 (0.0%)  	movq	%r8,-8(%rdi)
        .         .byte	102,72,15,126,213
        .         __bn_sqr8x_reduction:
    8,334 (0.0%)  	xorq	%rax,%rax
    8,334 (0.0%)  	leaq	(%r9,%rbp,1),%rcx
    8,334 (0.0%)  	leaq	48+8(%rsp,%r9,2),%rdx
    8,334 (0.0%)  	movq	%rcx,0+8(%rsp)
    8,334 (0.0%)  	leaq	48+8(%rsp,%r9,1),%rdi
    8,334 (0.0%)  	movq	%rdx,8+8(%rsp)
    8,334 (0.0%)  	negq	%r9
    8,334 (0.0%)  	jmp	.L8x_reduction_loop
        .         
        .         .align	32
        .         .L8x_reduction_loop:
   67,328 (0.0%)  	leaq	(%rdi,%r9,1),%rdi
        .         .byte	0x66
        .         	movq	0(%rdi),%rbx
   33,664 (0.0%)  	movq	8(%rdi),%r9
   33,664 (0.0%)  	movq	16(%rdi),%r10
   33,664 (0.0%)  	movq	24(%rdi),%r11
   33,664 (0.0%)  	movq	32(%rdi),%r12
   33,664 (0.0%)  	movq	40(%rdi),%r13
   33,664 (0.0%)  	movq	48(%rdi),%r14
   33,664 (0.0%)  	movq	56(%rdi),%r15
   33,664 (0.0%)  	movq	%rax,(%rdx)
   67,328 (0.0%)  	leaq	64(%rdi),%rdi
        .         
        .         .byte	0x67
        .         	movq	%rbx,%r8
   33,664 (0.0%)  	imulq	32+8(%rsp),%rbx
   33,664 (0.0%)  	movq	0(%rbp),%rax
   33,664 (0.0%)  	movl	$8,%ecx
   33,664 (0.0%)  	jmp	.L8x_reduce
        .         
        .         .align	32
        .         .L8x_reduce:
  269,312 (0.0%)  	mulq	%rbx
  269,312 (0.0%)  	movq	8(%rbp),%rax
  269,312 (0.0%)  	negq	%r8
  269,312 (0.0%)  	movq	%rdx,%r8
  269,312 (0.0%)  	adcq	$0,%r8
        .         
  269,312 (0.0%)  	mulq	%rbx
  269,312 (0.0%)  	addq	%rax,%r9
  269,312 (0.0%)  	movq	16(%rbp),%rax
  269,312 (0.0%)  	adcq	$0,%rdx
  269,312 (0.0%)  	addq	%r9,%r8
  269,312 (0.0%)  	movq	%rbx,48-8+8(%rsp,%rcx,8)
  269,312 (0.0%)  	movq	%rdx,%r9
  269,312 (0.0%)  	adcq	$0,%r9
        .         
  269,312 (0.0%)  	mulq	%rbx
  269,312 (0.0%)  	addq	%rax,%r10
  269,312 (0.0%)  	movq	24(%rbp),%rax
  269,312 (0.0%)  	adcq	$0,%rdx
  269,312 (0.0%)  	addq	%r10,%r9
  269,312 (0.0%)  	movq	32+8(%rsp),%rsi
  269,312 (0.0%)  	movq	%rdx,%r10
  269,312 (0.0%)  	adcq	$0,%r10
        .         
  269,312 (0.0%)  	mulq	%rbx
  269,312 (0.0%)  	addq	%rax,%r11
  269,312 (0.0%)  	movq	32(%rbp),%rax
  269,312 (0.0%)  	adcq	$0,%rdx
  269,312 (0.0%)  	imulq	%r8,%rsi
  269,312 (0.0%)  	addq	%r11,%r10
  269,312 (0.0%)  	movq	%rdx,%r11
  269,312 (0.0%)  	adcq	$0,%r11
        .         
  269,312 (0.0%)  	mulq	%rbx
  269,312 (0.0%)  	addq	%rax,%r12
  269,312 (0.0%)  	movq	40(%rbp),%rax
  269,312 (0.0%)  	adcq	$0,%rdx
  269,312 (0.0%)  	addq	%r12,%r11
  269,312 (0.0%)  	movq	%rdx,%r12
  269,312 (0.0%)  	adcq	$0,%r12
        .         
  269,312 (0.0%)  	mulq	%rbx
  269,312 (0.0%)  	addq	%rax,%r13
  269,312 (0.0%)  	movq	48(%rbp),%rax
  269,312 (0.0%)  	adcq	$0,%rdx
  269,312 (0.0%)  	addq	%r13,%r12
  269,312 (0.0%)  	movq	%rdx,%r13
  269,312 (0.0%)  	adcq	$0,%r13
        .         
  269,312 (0.0%)  	mulq	%rbx
  269,312 (0.0%)  	addq	%rax,%r14
  269,312 (0.0%)  	movq	56(%rbp),%rax
  269,312 (0.0%)  	adcq	$0,%rdx
  269,312 (0.0%)  	addq	%r14,%r13
  269,312 (0.0%)  	movq	%rdx,%r14
  269,312 (0.0%)  	adcq	$0,%r14
        .         
  269,312 (0.0%)  	mulq	%rbx
  269,312 (0.0%)  	movq	%rsi,%rbx
  269,312 (0.0%)  	addq	%rax,%r15
  269,312 (0.0%)  	movq	0(%rbp),%rax
  269,312 (0.0%)  	adcq	$0,%rdx
  269,312 (0.0%)  	addq	%r15,%r14
  269,312 (0.0%)  	movq	%rdx,%r15
  269,312 (0.0%)  	adcq	$0,%r15
        .         
  269,312 (0.0%)  	decl	%ecx
  269,312 (0.0%)  	jnz	.L8x_reduce
        .         
   33,664 (0.0%)  	leaq	64(%rbp),%rbp
   33,664 (0.0%)  	xorq	%rax,%rax
   33,664 (0.0%)  	movq	8+8(%rsp),%rdx
   33,664 (0.0%)  	cmpq	0+8(%rsp),%rbp
   67,328 (0.0%)  	jae	.L8x_no_tail
        .         
        .         .byte	0x66
        .         	addq	0(%rdi),%r8
   33,664 (0.0%)  	adcq	8(%rdi),%r9
   33,664 (0.0%)  	adcq	16(%rdi),%r10
   33,664 (0.0%)  	adcq	24(%rdi),%r11
   33,664 (0.0%)  	adcq	32(%rdi),%r12
   33,664 (0.0%)  	adcq	40(%rdi),%r13
   33,664 (0.0%)  	adcq	48(%rdi),%r14
   33,664 (0.0%)  	adcq	56(%rdi),%r15
   33,664 (0.0%)  	sbbq	%rsi,%rsi
        .         
   33,664 (0.0%)  	movq	48+56+8(%rsp),%rbx
   33,664 (0.0%)  	movl	$8,%ecx
   33,664 (0.0%)  	movq	0(%rbp),%rax
   33,664 (0.0%)  	jmp	.L8x_tail
        .         
        .         .align	32
        .         .L8x_tail:
  828,928 (0.1%)  	mulq	%rbx
  828,928 (0.1%)  	addq	%rax,%r8
  828,928 (0.1%)  	movq	8(%rbp),%rax
  828,928 (0.1%)  	movq	%r8,(%rdi)
  828,928 (0.1%)  	movq	%rdx,%r8
  828,928 (0.1%)  	adcq	$0,%r8
        .         
  828,928 (0.1%)  	mulq	%rbx
  828,928 (0.1%)  	addq	%rax,%r9
  828,928 (0.1%)  	movq	16(%rbp),%rax
  828,928 (0.1%)  	adcq	$0,%rdx
  828,928 (0.1%)  	addq	%r9,%r8
  828,928 (0.1%)  	leaq	8(%rdi),%rdi
  828,928 (0.1%)  	movq	%rdx,%r9
  828,928 (0.1%)  	adcq	$0,%r9
        .         
  828,928 (0.1%)  	mulq	%rbx
  828,928 (0.1%)  	addq	%rax,%r10
  828,928 (0.1%)  	movq	24(%rbp),%rax
  828,928 (0.1%)  	adcq	$0,%rdx
  828,928 (0.1%)  	addq	%r10,%r9
  828,928 (0.1%)  	movq	%rdx,%r10
  828,928 (0.1%)  	adcq	$0,%r10
        .         
  828,928 (0.1%)  	mulq	%rbx
  828,928 (0.1%)  	addq	%rax,%r11
  828,928 (0.1%)  	movq	32(%rbp),%rax
  828,928 (0.1%)  	adcq	$0,%rdx
  828,928 (0.1%)  	addq	%r11,%r10
  828,928 (0.1%)  	movq	%rdx,%r11
  828,928 (0.1%)  	adcq	$0,%r11
        .         
  828,928 (0.1%)  	mulq	%rbx
  828,928 (0.1%)  	addq	%rax,%r12
  828,928 (0.1%)  	movq	40(%rbp),%rax
  828,928 (0.1%)  	adcq	$0,%rdx
  828,928 (0.1%)  	addq	%r12,%r11
  828,928 (0.1%)  	movq	%rdx,%r12
  828,928 (0.1%)  	adcq	$0,%r12
        .         
  828,928 (0.1%)  	mulq	%rbx
  828,928 (0.1%)  	addq	%rax,%r13
  828,928 (0.1%)  	movq	48(%rbp),%rax
  828,928 (0.1%)  	adcq	$0,%rdx
  828,928 (0.1%)  	addq	%r13,%r12
  828,928 (0.1%)  	movq	%rdx,%r13
  828,928 (0.1%)  	adcq	$0,%r13
        .         
  828,928 (0.1%)  	mulq	%rbx
  828,928 (0.1%)  	addq	%rax,%r14
  828,928 (0.1%)  	movq	56(%rbp),%rax
  828,928 (0.1%)  	adcq	$0,%rdx
  828,928 (0.1%)  	addq	%r14,%r13
  828,928 (0.1%)  	movq	%rdx,%r14
  828,928 (0.1%)  	adcq	$0,%r14
        .         
  828,928 (0.1%)  	mulq	%rbx
  828,928 (0.1%)  	movq	48-16+8(%rsp,%rcx,8),%rbx
  828,928 (0.1%)  	addq	%rax,%r15
  828,928 (0.1%)  	adcq	$0,%rdx
  828,928 (0.1%)  	addq	%r15,%r14
  828,928 (0.1%)  	movq	0(%rbp),%rax
  828,928 (0.1%)  	movq	%rdx,%r15
  828,928 (0.1%)  	adcq	$0,%r15
        .         
  828,928 (0.1%)  	decl	%ecx
  828,928 (0.1%)  	jnz	.L8x_tail
        .         
  103,616 (0.0%)  	leaq	64(%rbp),%rbp
  103,616 (0.0%)  	movq	8+8(%rsp),%rdx
  103,616 (0.0%)  	cmpq	0+8(%rsp),%rbp
  103,616 (0.0%)  	jae	.L8x_tail_done
        .         
   69,952 (0.0%)  	movq	48+56+8(%rsp),%rbx
   69,952 (0.0%)  	negq	%rsi
   69,952 (0.0%)  	movq	0(%rbp),%rax
   69,952 (0.0%)  	adcq	0(%rdi),%r8
   69,952 (0.0%)  	adcq	8(%rdi),%r9
   69,952 (0.0%)  	adcq	16(%rdi),%r10
   69,952 (0.0%)  	adcq	24(%rdi),%r11
   69,952 (0.0%)  	adcq	32(%rdi),%r12
   69,952 (0.0%)  	adcq	40(%rdi),%r13
   69,952 (0.0%)  	adcq	48(%rdi),%r14
   69,952 (0.0%)  	adcq	56(%rdi),%r15
   69,952 (0.0%)  	sbbq	%rsi,%rsi
        .         
   69,952 (0.0%)  	movl	$8,%ecx
   69,952 (0.0%)  	jmp	.L8x_tail
        .         
        .         .align	32
        .         .L8x_tail_done:
   33,664 (0.0%)  	xorq	%rax,%rax
   33,664 (0.0%)  	addq	(%rdx),%r8
   33,664 (0.0%)  	adcq	$0,%r9
   33,664 (0.0%)  	adcq	$0,%r10
   33,664 (0.0%)  	adcq	$0,%r11
   33,664 (0.0%)  	adcq	$0,%r12
   33,664 (0.0%)  	adcq	$0,%r13
   33,664 (0.0%)  	adcq	$0,%r14
   33,664 (0.0%)  	adcq	$0,%r15
   33,664 (0.0%)  	adcq	$0,%rax
        .         
   33,664 (0.0%)  	negq	%rsi
        .         .L8x_no_tail:
   33,664 (0.0%)  	adcq	0(%rdi),%r8
   33,664 (0.0%)  	adcq	8(%rdi),%r9
   33,664 (0.0%)  	adcq	16(%rdi),%r10
   33,664 (0.0%)  	adcq	24(%rdi),%r11
   33,664 (0.0%)  	adcq	32(%rdi),%r12
   33,664 (0.0%)  	adcq	40(%rdi),%r13
   33,664 (0.0%)  	adcq	48(%rdi),%r14
   33,664 (0.0%)  	adcq	56(%rdi),%r15
   33,664 (0.0%)  	adcq	$0,%rax
   33,664 (0.0%)  	movq	-8(%rbp),%rcx
   67,328 (0.0%)  	xorq	%rsi,%rsi
        .         
        .         .byte	102,72,15,126,213
        .         
   33,664 (0.0%)  	movq	%r8,0(%rdi)
   67,328 (0.0%)  	movq	%r9,8(%rdi)
        .         .byte	102,73,15,126,217
   33,664 (0.0%)  	movq	%r10,16(%rdi)
   33,664 (0.0%)  	movq	%r11,24(%rdi)
   33,664 (0.0%)  	movq	%r12,32(%rdi)
   33,664 (0.0%)  	movq	%r13,40(%rdi)
   33,664 (0.0%)  	movq	%r14,48(%rdi)
   33,664 (0.0%)  	movq	%r15,56(%rdi)
   33,664 (0.0%)  	leaq	64(%rdi),%rdi
        .         
   33,664 (0.0%)  	cmpq	%rdx,%rdi
   41,998 (0.0%)  	jb	.L8x_reduction_loop
        .         	.byte	0xf3,0xc3
        .         .cfi_endproc	
        .         .size	bn_sqr8x_internal,.-bn_sqr8x_internal
        .         .type	__bn_post4x_internal,@function
        .         .align	32
        .         __bn_post4x_internal:
        .         .cfi_startproc	
    8,180 (0.0%)  	movq	0(%rbp),%r12
    8,180 (0.0%)  	leaq	(%rdi,%r9,1),%rbx
   16,360 (0.0%)  	movq	%r9,%rcx
        .         .byte	102,72,15,126,207
   16,360 (0.0%)  	negq	%rax
        .         .byte	102,72,15,126,206
    8,180 (0.0%)  	sarq	$3+2,%rcx
    8,180 (0.0%)  	decq	%r12
    8,180 (0.0%)  	xorq	%r10,%r10
    8,180 (0.0%)  	movq	8(%rbp),%r13
    8,180 (0.0%)  	movq	16(%rbp),%r14
    8,180 (0.0%)  	movq	24(%rbp),%r15
    8,180 (0.0%)  	jmp	.Lsqr4x_sub_entry
        .         
        .         .align	16
        .         .Lsqr4x_sub:
   69,132 (0.0%)  	movq	0(%rbp),%r12
   69,132 (0.0%)  	movq	8(%rbp),%r13
   69,132 (0.0%)  	movq	16(%rbp),%r14
   69,132 (0.0%)  	movq	24(%rbp),%r15
        .         .Lsqr4x_sub_entry:
   79,008 (0.0%)  	leaq	32(%rbp),%rbp
   79,008 (0.0%)  	notq	%r12
   79,008 (0.0%)  	notq	%r13
   79,008 (0.0%)  	notq	%r14
   79,008 (0.0%)  	notq	%r15
   79,008 (0.0%)  	andq	%rax,%r12
   79,008 (0.0%)  	andq	%rax,%r13
   79,008 (0.0%)  	andq	%rax,%r14
   79,008 (0.0%)  	andq	%rax,%r15
        .         
   79,008 (0.0%)  	negq	%r10
   79,008 (0.0%)  	adcq	0(%rbx),%r12
   79,008 (0.0%)  	adcq	8(%rbx),%r13
   79,008 (0.0%)  	adcq	16(%rbx),%r14
   79,008 (0.0%)  	adcq	24(%rbx),%r15
   79,008 (0.0%)  	movq	%r12,0(%rdi)
   79,008 (0.0%)  	leaq	32(%rbx),%rbx
   79,008 (0.0%)  	movq	%r13,8(%rdi)
   79,008 (0.0%)  	sbbq	%r10,%r10
   79,008 (0.0%)  	movq	%r14,16(%rdi)
   79,008 (0.0%)  	movq	%r15,24(%rdi)
   79,008 (0.0%)  	leaq	32(%rdi),%rdi
        .         
   79,008 (0.0%)  	incq	%rcx
   79,008 (0.0%)  	jnz	.Lsqr4x_sub
        .         
    9,876 (0.0%)  	movq	%r9,%r10
   19,752 (0.0%)  	negq	%r9
        .         	.byte	0xf3,0xc3
        .         .cfi_endproc	
        .         .size	__bn_post4x_internal,.-__bn_post4x_internal
        .         .type	bn_mulx4x_mont_gather5,@function
        .         .align	32
        .         bn_mulx4x_mont_gather5:
        .         .cfi_startproc	
        .         	movq	%rsp,%rax
-- line 2071 ----------------------------------------
-- line 3411 ----------------------------------------
        .         .cfi_endproc	
        .         .size	__bn_postx4x_internal,.-__bn_postx4x_internal
        .         .globl	bn_scatter5
        .         .hidden bn_scatter5
        .         .type	bn_scatter5,@function
        .         .align	16
        .         bn_scatter5:
        .         .cfi_startproc	
      128 (0.0%)  	cmpl	$0,%esi
      128 (0.0%)  	jz	.Lscatter_epilogue
        .         
        .         
        .         
        .         
        .         
        .         
        .         
        .         
        .         
      128 (0.0%)  	leaq	(%rdx,%rcx,8),%rdx
        .         .Lscatter:
    4,096 (0.0%)  	movq	(%rdi),%rax
    4,096 (0.0%)  	leaq	8(%rdi),%rdi
    4,096 (0.0%)  	movq	%rax,(%rdx)
    4,096 (0.0%)  	leaq	256(%rdx),%rdx
    4,096 (0.0%)  	subl	$1,%esi
    4,232 (0.0%)  	jnz	.Lscatter
        .         .Lscatter_epilogue:
        .         	.byte	0xf3,0xc3
        .         .cfi_endproc	
        .         .size	bn_scatter5,.-bn_scatter5
        .         
        .         .globl	bn_gather5
        .         .hidden bn_gather5
        .         .type	bn_gather5,@function
-- line 3445 ----------------------------------------
-- line 3446 ----------------------------------------
        .         .align	32
        .         bn_gather5:
        .         .cfi_startproc	
        .         .LSEH_begin_bn_gather5:
        .         
        .         .byte	0x4c,0x8d,0x14,0x24
        .         .cfi_def_cfa_register	%r10
        .         .byte	0x48,0x81,0xec,0x08,0x01,0x00,0x00
        4 (0.0%)  	leaq	.Linc(%rip),%rax
        4 (0.0%)  	andq	$-16,%rsp
        .         
        4 (0.0%)  	movd	%ecx,%xmm5
        4 (0.0%)  	movdqa	0(%rax),%xmm0
        4 (0.0%)  	movdqa	16(%rax),%xmm1
        4 (0.0%)  	leaq	128(%rdx),%r11
        4 (0.0%)  	leaq	128(%rsp),%rax
        .         
        4 (0.0%)  	pshufd	$0,%xmm5,%xmm5
        4 (0.0%)  	movdqa	%xmm1,%xmm4
        4 (0.0%)  	movdqa	%xmm1,%xmm2
        4 (0.0%)  	paddd	%xmm0,%xmm1
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm0
        4 (0.0%)  	movdqa	%xmm4,%xmm3
        .         
        4 (0.0%)  	paddd	%xmm1,%xmm2
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm1
        4 (0.0%)  	movdqa	%xmm0,-128(%rax)
        4 (0.0%)  	movdqa	%xmm4,%xmm0
        .         
        4 (0.0%)  	paddd	%xmm2,%xmm3
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm2
        4 (0.0%)  	movdqa	%xmm1,-112(%rax)
        4 (0.0%)  	movdqa	%xmm4,%xmm1
        .         
        4 (0.0%)  	paddd	%xmm3,%xmm0
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm3
        4 (0.0%)  	movdqa	%xmm2,-96(%rax)
        4 (0.0%)  	movdqa	%xmm4,%xmm2
        4 (0.0%)  	paddd	%xmm0,%xmm1
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm0
        4 (0.0%)  	movdqa	%xmm3,-80(%rax)
        4 (0.0%)  	movdqa	%xmm4,%xmm3
        .         
        4 (0.0%)  	paddd	%xmm1,%xmm2
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm1
        4 (0.0%)  	movdqa	%xmm0,-64(%rax)
        4 (0.0%)  	movdqa	%xmm4,%xmm0
        .         
        4 (0.0%)  	paddd	%xmm2,%xmm3
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm2
        4 (0.0%)  	movdqa	%xmm1,-48(%rax)
        4 (0.0%)  	movdqa	%xmm4,%xmm1
        .         
        4 (0.0%)  	paddd	%xmm3,%xmm0
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm3
        4 (0.0%)  	movdqa	%xmm2,-32(%rax)
        4 (0.0%)  	movdqa	%xmm4,%xmm2
        4 (0.0%)  	paddd	%xmm0,%xmm1
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm0
        4 (0.0%)  	movdqa	%xmm3,-16(%rax)
        4 (0.0%)  	movdqa	%xmm4,%xmm3
        .         
        4 (0.0%)  	paddd	%xmm1,%xmm2
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm1
        4 (0.0%)  	movdqa	%xmm0,0(%rax)
        4 (0.0%)  	movdqa	%xmm4,%xmm0
        .         
        4 (0.0%)  	paddd	%xmm2,%xmm3
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm2
        4 (0.0%)  	movdqa	%xmm1,16(%rax)
        4 (0.0%)  	movdqa	%xmm4,%xmm1
        .         
        4 (0.0%)  	paddd	%xmm3,%xmm0
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm3
        4 (0.0%)  	movdqa	%xmm2,32(%rax)
        4 (0.0%)  	movdqa	%xmm4,%xmm2
        4 (0.0%)  	paddd	%xmm0,%xmm1
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm0
        4 (0.0%)  	movdqa	%xmm3,48(%rax)
        4 (0.0%)  	movdqa	%xmm4,%xmm3
        .         
        4 (0.0%)  	paddd	%xmm1,%xmm2
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm1
        4 (0.0%)  	movdqa	%xmm0,64(%rax)
        4 (0.0%)  	movdqa	%xmm4,%xmm0
        .         
        4 (0.0%)  	paddd	%xmm2,%xmm3
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm2
        4 (0.0%)  	movdqa	%xmm1,80(%rax)
        4 (0.0%)  	movdqa	%xmm4,%xmm1
        .         
        4 (0.0%)  	paddd	%xmm3,%xmm0
        4 (0.0%)  	pcmpeqd	%xmm5,%xmm3
        4 (0.0%)  	movdqa	%xmm2,96(%rax)
        4 (0.0%)  	movdqa	%xmm4,%xmm2
        4 (0.0%)  	movdqa	%xmm3,112(%rax)
        4 (0.0%)  	jmp	.Lgather
        .         
        .         .align	32
        .         .Lgather:
      128 (0.0%)  	pxor	%xmm4,%xmm4
      128 (0.0%)  	pxor	%xmm5,%xmm5
      128 (0.0%)  	movdqa	-128(%r11),%xmm0
      128 (0.0%)  	movdqa	-112(%r11),%xmm1
      128 (0.0%)  	movdqa	-96(%r11),%xmm2
      128 (0.0%)  	pand	-128(%rax),%xmm0
      128 (0.0%)  	movdqa	-80(%r11),%xmm3
      128 (0.0%)  	pand	-112(%rax),%xmm1
      128 (0.0%)  	por	%xmm0,%xmm4
      128 (0.0%)  	pand	-96(%rax),%xmm2
      128 (0.0%)  	por	%xmm1,%xmm5
      128 (0.0%)  	pand	-80(%rax),%xmm3
      128 (0.0%)  	por	%xmm2,%xmm4
      128 (0.0%)  	por	%xmm3,%xmm5
      128 (0.0%)  	movdqa	-64(%r11),%xmm0
      128 (0.0%)  	movdqa	-48(%r11),%xmm1
      128 (0.0%)  	movdqa	-32(%r11),%xmm2
      128 (0.0%)  	pand	-64(%rax),%xmm0
      128 (0.0%)  	movdqa	-16(%r11),%xmm3
      128 (0.0%)  	pand	-48(%rax),%xmm1
      128 (0.0%)  	por	%xmm0,%xmm4
      128 (0.0%)  	pand	-32(%rax),%xmm2
      128 (0.0%)  	por	%xmm1,%xmm5
      128 (0.0%)  	pand	-16(%rax),%xmm3
      128 (0.0%)  	por	%xmm2,%xmm4
      128 (0.0%)  	por	%xmm3,%xmm5
      128 (0.0%)  	movdqa	0(%r11),%xmm0
      128 (0.0%)  	movdqa	16(%r11),%xmm1
      128 (0.0%)  	movdqa	32(%r11),%xmm2
      128 (0.0%)  	pand	0(%rax),%xmm0
      128 (0.0%)  	movdqa	48(%r11),%xmm3
      128 (0.0%)  	pand	16(%rax),%xmm1
      128 (0.0%)  	por	%xmm0,%xmm4
      128 (0.0%)  	pand	32(%rax),%xmm2
      128 (0.0%)  	por	%xmm1,%xmm5
      128 (0.0%)  	pand	48(%rax),%xmm3
      128 (0.0%)  	por	%xmm2,%xmm4
      128 (0.0%)  	por	%xmm3,%xmm5
      128 (0.0%)  	movdqa	64(%r11),%xmm0
      128 (0.0%)  	movdqa	80(%r11),%xmm1
      128 (0.0%)  	movdqa	96(%r11),%xmm2
      128 (0.0%)  	pand	64(%rax),%xmm0
      128 (0.0%)  	movdqa	112(%r11),%xmm3
      128 (0.0%)  	pand	80(%rax),%xmm1
      128 (0.0%)  	por	%xmm0,%xmm4
      128 (0.0%)  	pand	96(%rax),%xmm2
      128 (0.0%)  	por	%xmm1,%xmm5
      128 (0.0%)  	pand	112(%rax),%xmm3
      128 (0.0%)  	por	%xmm2,%xmm4
      128 (0.0%)  	por	%xmm3,%xmm5
      128 (0.0%)  	por	%xmm5,%xmm4
      128 (0.0%)  	leaq	256(%r11),%r11
        .         
      128 (0.0%)  	pshufd	$0x4e,%xmm4,%xmm0
      128 (0.0%)  	por	%xmm4,%xmm0
      128 (0.0%)  	movq	%xmm0,(%rdi)
      128 (0.0%)  	leaq	8(%rdi),%rdi
      128 (0.0%)  	subl	$1,%esi
      128 (0.0%)  	jnz	.Lgather
        .         
        8 (0.0%)  	leaq	(%r10),%rsp
        .         .cfi_def_cfa_register	%rsp
        .         	.byte	0xf3,0xc3
        .         .LSEH_end_bn_gather5:
        .         .cfi_endproc	
        .         .size	bn_gather5,.-bn_gather5
        .         .section	.rodata
        .         .align	64
        .         .Linc:
-- line 3614 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 18 ----------------------------------------
      .         #include <sys/param.h>
      .         
      .         #include "error/s2n_errno.h"
      .         #include "utils/s2n_blob.h"
      .         #include "utils/s2n_mem.h"
      .         #include "utils/s2n_safety.h"
      .         
      .         S2N_RESULT s2n_stuffer_validate(const struct s2n_stuffer *stuffer)
342,570 (0.1%)  {
      .             /**
      .              * Note that we do not assert any properties on the tainted field,
      .              * as any boolean value in that field is valid.
      .              */
114,190 (0.0%)      RESULT_ENSURE_REF(stuffer);
456,760 (0.1%)      RESULT_GUARD(s2n_blob_validate(&stuffer->blob));
526,688 (0.1%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(stuffer->growable, stuffer->alloced), S2N_ERR_SAFETY);
      .         
      .             /* <= is valid because we can have a fully written/read stuffer */
513,855 (0.1%)      RESULT_DEBUG_ENSURE(stuffer->high_water_mark <= stuffer->blob.size, S2N_ERR_SAFETY);
513,855 (0.1%)      RESULT_DEBUG_ENSURE(stuffer->write_cursor <= stuffer->high_water_mark, S2N_ERR_SAFETY);
513,855 (0.1%)      RESULT_DEBUG_ENSURE(stuffer->read_cursor <= stuffer->write_cursor, S2N_ERR_SAFETY);
 57,095 (0.0%)      return S2N_RESULT_OK;
171,285 (0.0%)  }
      .         
      .         S2N_RESULT s2n_stuffer_reservation_validate(const struct s2n_stuffer_reservation *reservation)
    396 (0.0%)  {
      .             /**
      .              * Note that we need two dereferences here to decrease proof complexity
      .              * for CBMC (see https://github.com/awslabs/s2n/issues/2290). We can roll back
      .              * this change once CBMC can handle common subexpression elimination.
      .              */
    132 (0.0%)      RESULT_ENSURE_REF(reservation);
    330 (0.0%)      const struct s2n_stuffer_reservation reserve_obj = *reservation;
    528 (0.0%)      RESULT_GUARD(s2n_stuffer_validate(reserve_obj.stuffer));
    726 (0.0%)      const struct s2n_stuffer stuffer_obj = *(reserve_obj.stuffer);
      .         
      .             /* Verify that write_cursor + length can be represented as a uint32_t without overflow */
    396 (0.0%)      RESULT_ENSURE_LTE(reserve_obj.write_cursor, UINT32_MAX - reserve_obj.length);
      .             /* The entire reservation must fit between the stuffer read and write cursors */
    462 (0.0%)      RESULT_ENSURE_LTE(reserve_obj.write_cursor + reserve_obj.length, stuffer_obj.write_cursor);
    264 (0.0%)      RESULT_ENSURE_GTE(reserve_obj.write_cursor, stuffer_obj.read_cursor);
      .         
     66 (0.0%)      return S2N_RESULT_OK;
    198 (0.0%)  }
      .         
      .         int s2n_stuffer_init(struct s2n_stuffer *stuffer, struct s2n_blob *in)
    798 (0.0%)  {
    228 (0.0%)      POSIX_ENSURE_MUT(stuffer);
  1,710 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(in));
    912 (0.0%)      stuffer->blob = *in;
    228 (0.0%)      stuffer->read_cursor = 0;
    228 (0.0%)      stuffer->write_cursor = 0;
    228 (0.0%)      stuffer->high_water_mark = 0;
    456 (0.0%)      stuffer->alloced = 0;
    456 (0.0%)      stuffer->growable = 0;
    456 (0.0%)      stuffer->tainted = 0;
  1,710 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    114 (0.0%)      return S2N_SUCCESS;
    342 (0.0%)  }
      .         
      .         int s2n_stuffer_init_written(struct s2n_stuffer *stuffer, struct s2n_blob *in)
      7 (0.0%)  {
      2 (0.0%)      POSIX_ENSURE_REF(in);
      7 (0.0%)      POSIX_GUARD(s2n_stuffer_init(stuffer, in));
      8 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(stuffer, in->size));
      1 (0.0%)      return S2N_SUCCESS;
      3 (0.0%)  }
      .         
      .         int s2n_stuffer_alloc(struct s2n_stuffer *stuffer, const uint32_t size)
    126 (0.0%)  {
     36 (0.0%)      POSIX_ENSURE_REF(stuffer);
     90 (0.0%)      *stuffer = (struct s2n_stuffer){ 0 };
    126 (0.0%)      POSIX_GUARD(s2n_alloc(&stuffer->blob, size));
    126 (0.0%)      POSIX_GUARD(s2n_stuffer_init(stuffer, &stuffer->blob));
      .         
     72 (0.0%)      stuffer->alloced = 1;
      .         
    270 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     18 (0.0%)      return S2N_SUCCESS;
     54 (0.0%)  }
      .         
      .         int s2n_stuffer_growable_alloc(struct s2n_stuffer *stuffer, const uint32_t size)
     78 (0.0%)  {
     91 (0.0%)      POSIX_GUARD(s2n_stuffer_alloc(stuffer, size));
      .         
     52 (0.0%)      stuffer->growable = 1;
      .         
    195 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     13 (0.0%)      return S2N_SUCCESS;
     26 (0.0%)  }
      .         
      .         int s2n_stuffer_free(struct s2n_stuffer *stuffer)
    210 (0.0%)  {
    630 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    210 (0.0%)      if (stuffer->alloced) {
     80 (0.0%)          POSIX_GUARD(s2n_free(&stuffer->blob));
      .             }
    210 (0.0%)      *stuffer = (struct s2n_stuffer){ 0 };
     42 (0.0%)      return S2N_SUCCESS;
     84 (0.0%)  }
      .         
      .         int s2n_stuffer_free_without_wipe(struct s2n_stuffer *stuffer)
      .         {
      .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
      .             if (stuffer->alloced) {
      .                 POSIX_GUARD(s2n_free_without_wipe(&stuffer->blob));
      .             }
      .             *stuffer = (struct s2n_stuffer){ 0 };
      .             return S2N_SUCCESS;
      .         }
      .         
      .         int s2n_stuffer_resize(struct s2n_stuffer *stuffer, const uint32_t size)
     70 (0.0%)  {
    150 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
     50 (0.0%)      POSIX_ENSURE(!stuffer->tainted, S2N_ERR_RESIZE_TAINTED_STUFFER);
     50 (0.0%)      POSIX_ENSURE(stuffer->growable, S2N_ERR_RESIZE_STATIC_STUFFER);
      .         
     40 (0.0%)      if (size == stuffer->blob.size) {
     12 (0.0%)          return S2N_SUCCESS;
      .             }
      .         
      8 (0.0%)      if (size == 0) {
      6 (0.0%)          s2n_stuffer_wipe(stuffer);
      8 (0.0%)          return s2n_free(&stuffer->blob);
      .             }
      .         
      8 (0.0%)      if (size < stuffer->blob.size) {
      .                 POSIX_CHECKED_MEMSET(stuffer->blob.data + size, S2N_WIPE_PATTERN, (stuffer->blob.size - size));
      .                 if (stuffer->read_cursor > size) {
      .                     stuffer->read_cursor = size;
      .                 }
      .                 if (stuffer->write_cursor > size) {
      .                     stuffer->write_cursor = size;
      .                 }
      .                 if (stuffer->high_water_mark > size) {
      .                     stuffer->high_water_mark = size;
      .                 }
      .                 stuffer->blob.size = size;
      .                 POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
      .                 return S2N_SUCCESS;
      .             }
      .         
     14 (0.0%)      POSIX_GUARD(s2n_realloc(&stuffer->blob, size));
     30 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
      2 (0.0%)      return S2N_SUCCESS;
     30 (0.0%)  }
      .         
      .         int s2n_stuffer_resize_if_empty(struct s2n_stuffer *stuffer, const uint32_t size)
    140 (0.0%)  {
    300 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
     80 (0.0%)      if (stuffer->blob.data == NULL) {
     10 (0.0%)          POSIX_ENSURE(!stuffer->tainted, S2N_ERR_RESIZE_TAINTED_STUFFER);
     10 (0.0%)          POSIX_ENSURE(stuffer->growable, S2N_ERR_RESIZE_STATIC_STUFFER);
     14 (0.0%)          POSIX_GUARD(s2n_realloc(&stuffer->blob, size));
      .             }
    300 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     20 (0.0%)      return S2N_SUCCESS;
     60 (0.0%)  }
      .         
      .         int s2n_stuffer_rewrite(struct s2n_stuffer *stuffer)
    820 (0.0%)  {
  2,460 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    328 (0.0%)      stuffer->write_cursor = 0;
    328 (0.0%)      stuffer->read_cursor = 0;
  2,460 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    164 (0.0%)      return S2N_SUCCESS;
    328 (0.0%)  }
      .         
      .         int s2n_stuffer_rewind_read(struct s2n_stuffer *stuffer, const uint32_t size)
    168 (0.0%)  {
    360 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
     96 (0.0%)      POSIX_ENSURE(stuffer->read_cursor >= size, S2N_ERR_STUFFER_OUT_OF_DATA);
    144 (0.0%)      stuffer->read_cursor -= size;
    360 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     24 (0.0%)      return S2N_SUCCESS;
     72 (0.0%)  }
      .         
      .         int s2n_stuffer_reread(struct s2n_stuffer *stuffer)
    355 (0.0%)  {
  1,065 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    142 (0.0%)      stuffer->read_cursor = 0;
     71 (0.0%)      return S2N_SUCCESS;
    142 (0.0%)  }
      .         
      .         int s2n_stuffer_wipe_n(struct s2n_stuffer *stuffer, const uint32_t size)
     98 (0.0%)  {
    210 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
     84 (0.0%)      uint32_t wipe_size = MIN(size, stuffer->write_cursor);
      .         
     84 (0.0%)      stuffer->write_cursor -= wipe_size;
    112 (0.0%)      stuffer->read_cursor = MIN(stuffer->read_cursor, stuffer->write_cursor);
    238 (0.0%)      POSIX_CHECKED_MEMSET(stuffer->blob.data + stuffer->write_cursor, S2N_WIPE_PATTERN, wipe_size);
      .         
    210 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     14 (0.0%)      return S2N_SUCCESS;
     42 (0.0%)  }
      .         
      .         bool s2n_stuffer_is_consumed(struct s2n_stuffer *stuffer)
     36 (0.0%)  {
    144 (0.0%)      return stuffer && (stuffer->read_cursor == stuffer->write_cursor) && !stuffer->tainted;
     18 (0.0%)  }
      .         
      .         int s2n_stuffer_wipe(struct s2n_stuffer *stuffer)
    390 (0.0%)  {
    975 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    260 (0.0%)      if (!s2n_stuffer_is_wiped(stuffer)) {
    828 (0.0%)          POSIX_CHECKED_MEMSET(stuffer->blob.data, S2N_WIPE_PATTERN, stuffer->high_water_mark);
      .             }
      .         
    260 (0.0%)      stuffer->tainted = 0;
    130 (0.0%)      stuffer->write_cursor = 0;
    130 (0.0%)      stuffer->read_cursor = 0;
    130 (0.0%)      stuffer->high_water_mark = 0;
    975 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     65 (0.0%)      return S2N_SUCCESS;
    195 (0.0%)  }
      .         
      .         int s2n_stuffer_skip_read(struct s2n_stuffer *stuffer, uint32_t n)
 14,105 (0.0%)  {
 30,225 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 14,105 (0.0%)      POSIX_ENSURE(s2n_stuffer_data_available(stuffer) >= n, S2N_ERR_STUFFER_OUT_OF_DATA);
      .         
 12,090 (0.0%)      stuffer->read_cursor += n;
  2,015 (0.0%)      return S2N_SUCCESS;
  6,045 (0.0%)  }
      .         
      .         void *s2n_stuffer_raw_read(struct s2n_stuffer *stuffer, uint32_t data_len)
    450 (0.0%)  {
    525 (0.0%)      PTR_GUARD_POSIX(s2n_stuffer_skip_read(stuffer, data_len));
      .         
    300 (0.0%)      stuffer->tainted = 1;
      .         
    975 (0.0%)      return (stuffer->blob.data) ? (stuffer->blob.data + stuffer->read_cursor - data_len) : NULL;
    150 (0.0%)  }
      .         
      .         int s2n_stuffer_read(struct s2n_stuffer *stuffer, struct s2n_blob *out)
 12,145 (0.0%)  {
  3,470 (0.0%)      POSIX_ENSURE_REF(out);
      .         
 13,880 (0.0%)      return s2n_stuffer_read_bytes(stuffer, out->data, out->size);
  5,205 (0.0%)  }
      .         
      .         int s2n_stuffer_erase_and_read(struct s2n_stuffer *stuffer, struct s2n_blob *out)
      .         {
      .             POSIX_GUARD(s2n_stuffer_skip_read(stuffer, out->size));
      .         
      .             void *ptr = (stuffer->blob.data) ? (stuffer->blob.data + stuffer->read_cursor - out->size) : NULL;
      .             POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, out->size), S2N_ERR_NULL);
      .         
      .             POSIX_CHECKED_MEMCPY(out->data, ptr, out->size);
      .             POSIX_CHECKED_MEMSET(ptr, 0, out->size);
      .         
      .             return S2N_SUCCESS;
      .         }
      .         
      .         int s2n_stuffer_read_bytes(struct s2n_stuffer *stuffer, uint8_t *data, uint32_t size)
 15,048 (0.0%)  {
  3,762 (0.0%)      POSIX_ENSURE_REF(data);
 28,215 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 13,167 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_read(stuffer, size));
  7,524 (0.0%)      POSIX_ENSURE_REF(stuffer->blob.data);
 16,929 (0.0%)      void *ptr = stuffer->blob.data + stuffer->read_cursor - size;
      .         
 30,096 (0.0%)      POSIX_CHECKED_MEMCPY(data, ptr, size);
      .         
  1,881 (0.0%)      return S2N_SUCCESS;
  5,643 (0.0%)  }
      .         
      .         int s2n_stuffer_erase_and_read_bytes(struct s2n_stuffer *stuffer, uint8_t *data, uint32_t size)
      8 (0.0%)  {
      7 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_read(stuffer, size));
      4 (0.0%)      POSIX_ENSURE_REF(stuffer->blob.data);
      9 (0.0%)      void *ptr = stuffer->blob.data + stuffer->read_cursor - size;
      .         
     16 (0.0%)      POSIX_CHECKED_MEMCPY(data, ptr, size);
     16 (0.0%)      POSIX_CHECKED_MEMSET(ptr, 0, size);
      .         
      1 (0.0%)      return S2N_SUCCESS;
      3 (0.0%)  }
      .         
      .         int s2n_stuffer_skip_write(struct s2n_stuffer *stuffer, const uint32_t n)
 55,650 (0.0%)  {
139,125 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 64,925 (0.0%)      POSIX_GUARD(s2n_stuffer_reserve_space(stuffer, n));
 55,650 (0.0%)      stuffer->write_cursor += n;
 74,200 (0.0%)      stuffer->high_water_mark = MAX(stuffer->write_cursor, stuffer->high_water_mark);
139,125 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  9,275 (0.0%)      return S2N_SUCCESS;
 18,550 (0.0%)  }
      .         
      .         void *s2n_stuffer_raw_write(struct s2n_stuffer *stuffer, const uint32_t data_len)
    138 (0.0%)  {
    161 (0.0%)      PTR_GUARD_POSIX(s2n_stuffer_skip_write(stuffer, data_len));
      .         
     92 (0.0%)      stuffer->tainted = 1;
      .         
    299 (0.0%)      return (stuffer->blob.data) ? (stuffer->blob.data + stuffer->write_cursor - data_len) : NULL;
     46 (0.0%)  }
      .         
      .         int s2n_stuffer_write(struct s2n_stuffer *stuffer, const struct s2n_blob *in)
    486 (0.0%)  {
  1,215 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
  1,215 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(in));
    648 (0.0%)      return s2n_stuffer_write_bytes(stuffer, in->data, in->size);
    162 (0.0%)  }
      .         
      .         int s2n_stuffer_write_bytes(struct s2n_stuffer *stuffer, const uint8_t *data, const uint32_t size)
 58,096 (0.0%)  {
 29,006 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_SAFETY);
108,930 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 50,834 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(stuffer, size));
      .         
 65,358 (0.0%)      void *ptr = stuffer->blob.data + stuffer->write_cursor - size;
 29,006 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, size), S2N_ERR_NULL);
      .         
 21,786 (0.0%)      if (ptr == data) {
     30 (0.0%)          POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
      4 (0.0%)          return S2N_SUCCESS;
      .             }
      .         
115,971 (0.0%)      POSIX_CHECKED_MEMCPY(ptr, data, size);
      .         
108,900 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  7,260 (0.0%)      return S2N_SUCCESS;
 21,786 (0.0%)  }
      .         
      .         int s2n_stuffer_writev_bytes(struct s2n_stuffer *stuffer, const struct iovec *iov, size_t iov_count, uint32_t offs,
      .                 uint32_t size)
    100 (0.0%)  {
    150 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
     20 (0.0%)      POSIX_ENSURE_REF(iov);
     60 (0.0%)      void *ptr = s2n_stuffer_raw_write(stuffer, size);
     40 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, size), S2N_ERR_NULL);
      .         
     40 (0.0%)      size_t size_left = size, to_skip = offs;
     50 (0.0%)      for (size_t i = 0; i < iov_count; i++) {
     80 (0.0%)          if (to_skip >= iov[i].iov_len) {
      .                     to_skip -= iov[i].iov_len;
      .                     continue;
      .                 }
     80 (0.0%)          size_t iov_len_op = iov[i].iov_len - to_skip;
     30 (0.0%)          POSIX_ENSURE_LTE(iov_len_op, UINT32_MAX);
     20 (0.0%)          uint32_t iov_len = (uint32_t) iov_len_op;
     50 (0.0%)          uint32_t iov_size_to_take = MIN(size_left, iov_len);
     80 (0.0%)          POSIX_ENSURE_REF(iov[i].iov_base);
     80 (0.0%)          POSIX_ENSURE_LT(to_skip, iov[i].iov_len);
    230 (0.0%)          POSIX_CHECKED_MEMCPY(ptr, ((uint8_t *) (iov[i].iov_base)) + to_skip, iov_size_to_take);
     20 (0.0%)          size_left -= iov_size_to_take;
     20 (0.0%)          if (size_left == 0) {
     10 (0.0%)              break;
      .                 }
      .                 ptr = (void *) ((uint8_t *) ptr + iov_size_to_take);
      .                 to_skip = 0;
      .             }
      .         
     10 (0.0%)      return S2N_SUCCESS;
     30 (0.0%)  }
      .         
      .         static int s2n_stuffer_copy_impl(struct s2n_stuffer *from, struct s2n_stuffer *to, const uint32_t len)
    216 (0.0%)  {
    189 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_read(from, len));
    189 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(to, len));
      .         
    378 (0.0%)      uint8_t *from_ptr = (from->blob.data) ? (from->blob.data + from->read_cursor - len) : NULL;
    378 (0.0%)      uint8_t *to_ptr = (to->blob.data) ? (to->blob.data + to->write_cursor - len) : NULL;
      .         
    414 (0.0%)      POSIX_CHECKED_MEMCPY(to_ptr, from_ptr, len);
      .         
     27 (0.0%)      return S2N_SUCCESS;
     81 (0.0%)  }
      .         
      .         int s2n_stuffer_reserve_space(struct s2n_stuffer *stuffer, uint32_t n)
 92,950 (0.0%)  {
139,425 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 65,065 (0.0%)      if (s2n_stuffer_space_remaining(stuffer) < n) {
      .                 POSIX_ENSURE(stuffer->growable, S2N_ERR_STUFFER_IS_FULL);
      .                 /* Always grow a stuffer by at least 1k */
      .                 const uint32_t growth = MAX(n - s2n_stuffer_space_remaining(stuffer), S2N_MIN_STUFFER_GROWTH_IN_BYTES);
      .                 uint32_t new_size = 0;
      .                 POSIX_GUARD(s2n_add_overflow(stuffer->blob.size, growth, &new_size));
      .                 POSIX_GUARD(s2n_stuffer_resize(stuffer, new_size));
      .             }
139,425 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  9,295 (0.0%)      return S2N_SUCCESS;
 55,770 (0.0%)  }
      .         
      .         /* Copies "len" bytes from "from" to "to".
      .          * If the copy cannot succeed (i.e. there are either not enough bytes available, or there is not enough space to write them
      .          * restore the old value of the stuffer */
      .         int s2n_stuffer_copy(struct s2n_stuffer *from, struct s2n_stuffer *to, const uint32_t len)
    189 (0.0%)  {
     81 (0.0%)      const uint32_t orig_read_cursor = from->read_cursor;
     81 (0.0%)      const uint32_t orig_write_cursor = to->write_cursor;
      .         
    216 (0.0%)      if (s2n_stuffer_copy_impl(from, to, len) < 0) {
      .                 from->read_cursor = orig_read_cursor;
      .                 to->write_cursor = orig_write_cursor;
      .                 S2N_ERROR_PRESERVE_ERRNO();
      .             }
      .         
     27 (0.0%)      return S2N_SUCCESS;
     54 (0.0%)  }
      .         
      .         int s2n_stuffer_extract_blob(struct s2n_stuffer *stuffer, struct s2n_blob *out)
      .         {
      .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
      .             POSIX_ENSURE_REF(out);
      .             POSIX_GUARD(s2n_realloc(out, s2n_stuffer_data_available(stuffer)));
      .         
      .             if (s2n_stuffer_data_available(stuffer) > 0) {
-- line 427 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 19 ----------------------------------------
      .         #include <string.h>
      .         #include <sys/param.h>
      .         
      .         #include "api/s2n.h"
      .         #include "error/s2n_errno.h"
      .         #include "utils/s2n_safety.h"
      .         
      .         S2N_RESULT s2n_blob_validate(const struct s2n_blob *b)
351,168 (0.1%)  {
117,056 (0.0%)      RESULT_ENSURE_REF(b);
413,315 (0.1%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->data == NULL, b->size == 0), S2N_ERR_SAFETY);
413,315 (0.1%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->data == NULL, b->allocated == 0), S2N_ERR_SAFETY);
813,100 (0.1%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->growable == 0, b->allocated == 0), S2N_ERR_SAFETY);
551,564 (0.1%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->growable != 0, b->size <= b->allocated), S2N_ERR_SAFETY);
474,516 (0.1%)      RESULT_DEBUG_ENSURE(S2N_MEM_IS_READABLE(b->data, b->allocated), S2N_ERR_SAFETY);
815,528 (0.1%)      RESULT_DEBUG_ENSURE(S2N_MEM_IS_READABLE(b->data, b->size), S2N_ERR_SAFETY);
 58,528 (0.0%)      return S2N_RESULT_OK;
175,584 (0.0%)  }
      .         
      .         int s2n_blob_init(struct s2n_blob *b, uint8_t *data, uint32_t size)
  3,424 (0.0%)  {
    856 (0.0%)      POSIX_ENSURE_REF(b);
  1,698 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_SAFETY);
  5,136 (0.0%)      *b = (struct s2n_blob){ .data = data, .size = size, .allocated = 0, .growable = 0 };
  6,420 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(b));
    428 (0.0%)      return S2N_SUCCESS;
  1,284 (0.0%)  }
      .         
      .         int s2n_blob_zero(struct s2n_blob *b)
  1,584 (0.0%)  {
  3,960 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(b));
  4,358 (0.0%)      POSIX_CHECKED_MEMSET(b->data, 0, MAX(b->allocated, b->size));
  3,960 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(b));
    264 (0.0%)      return S2N_SUCCESS;
    792 (0.0%)  }
      .         
      .         int s2n_blob_slice(const struct s2n_blob *b, struct s2n_blob *slice, uint32_t offset, uint32_t size)
    192 (0.0%)  {
    240 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(b));
    240 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(slice));
      .         
     16 (0.0%)      uint32_t slice_size = 0;
    128 (0.0%)      POSIX_GUARD(s2n_add_overflow(offset, size, &slice_size));
     80 (0.0%)      POSIX_ENSURE(b->size >= slice_size, S2N_ERR_SIZE_MISMATCH);
    176 (0.0%)      slice->data = (b->data) ? (b->data + offset) : NULL;
     48 (0.0%)      slice->size = size;
     64 (0.0%)      slice->growable = 0;
     32 (0.0%)      slice->allocated = 0;
      .         
    240 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(slice));
     16 (0.0%)      return S2N_SUCCESS;
     96 (0.0%)  }
      .         
      .         int s2n_blob_char_to_lower(struct s2n_blob *b)
     10 (0.0%)  {
     30 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(b));
    122 (0.0%)      for (size_t i = 0; i < b->size; i++) {
    270 (0.0%)          b->data[i] = tolower(b->data[i]);
      .             }
     30 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(b));
      2 (0.0%)      return S2N_SUCCESS;
      4 (0.0%)  }
      .         
      .         /* An inverse map from an ascii value to a hexidecimal nibble value
      .          * accounts for all possible char values, where 255 is invalid value */
      .         static const uint8_t hex_inverse[256] = {
      .             /* clang-format off */
      .             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      .             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      .             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-- line 88 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 79 ----------------------------------------
      .         #include "utils/s2n_result.h"
      .         
      .         #include <stdbool.h>
      .         
      .         #include "api/s2n.h"
      .         
      .         /* returns true when the result is S2N_RESULT_OK */
      .         inline bool s2n_result_is_ok(s2n_result result)
730,148 (0.1%)  {
547,611 (0.1%)      return result.__error_signal == S2N_SUCCESS;
365,074 (0.1%)  }
      .         
      .         /* returns true when the result is S2N_RESULT_ERROR */
      .         inline bool s2n_result_is_error(s2n_result result)
     88 (0.0%)  {
     66 (0.0%)      return result.__error_signal == S2N_FAILURE;
     44 (0.0%)  }
      .         
      .         /* ignores the returned result of a function */
      .         inline void s2n_result_ignore(s2n_result result)
    240 (0.0%)  {
      .             /* noop */
    180 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir_________________ 

617,492,378 (93.1%)    annotated: files known & above threshold & readable, line numbers known
          0            annotated: files known & above threshold & readable, line numbers unknown
          0          unannotated: files known & above threshold & two or more non-identical
 29,261,830  (4.4%)  unannotated: files known & above threshold & unreadable 
 16,111,358  (2.4%)  unannotated: files known & below threshold
    644,688  (0.1%)  unannotated: files unknown

