--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate cachegrind.out.139484
Command:          target/debug/config_configure
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir__________________ 

304,644,065 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir_______________________  file:function

< 72,660,230 (23.9%, 23.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont5.S:
  55,770,284 (18.3%)           aws_lc_0_19_0_bn_sqr8x_internal
  15,699,024  (5.2%)           mul4x_internal
   1,114,840  (0.4%)           __bn_post4x_internal

< 56,600,061 (18.6%, 42.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c:
  19,148,880  (6.3%)           base64_ascii_to_bin
  13,737,240  (4.5%)           constant_time_in_range_8
  10,615,140  (3.5%)           constant_time_lt_args_8
   7,474,924  (2.5%)           aws_lc_0_19_0_EVP_DecodeUpdate
   5,619,205  (1.8%)           base64_decode_quad

< 31,847,756 (10.5%, 52.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h:
   8,741,880  (2.9%)           constant_time_msb_w
   8,741,880  (2.9%)           constant_time_is_zero_w
   7,493,040  (2.5%)           constant_time_eq_8
   6,868,620  (2.3%)           constant_time_eq_w

< 29,717,854  (9.8%, 62.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h:
  11,612,328  (3.8%)           constant_time_select_w
   8,847,488  (2.9%)           value_barrier_w
   3,104,800  (1.0%)           constant_time_select_int
   1,648,388  (0.5%)           constant_time_lt_w
   1,359,260  (0.4%)           constant_time_is_zero_w
   1,358,378  (0.4%)           constant_time_msb_w
   1,066,582  (0.4%)           constant_time_eq_w

< 13,640,455  (4.5%, 67.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c:
   9,711,812  (3.2%)           aws_lc_0_19_0_bn_rshift1_words
   3,030,349  (1.0%)           aws_lc_0_19_0_bn_rshift_words

< 10,954,173  (3.6%, 70.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c:
   8,474,088  (2.8%)           aws_lc_0_19_0_bn_select_words
   1,311,552  (0.4%)           aws_lc_0_19_0_bn_fits_in_words
     494,184  (0.2%)           aws_lc_0_19_0_bn_minimal_width

<  9,742,930  (3.2%, 73.9%)  ./malloc/./malloc/malloc.c:
   3,094,320  (1.0%)           _int_free
   2,547,993  (0.8%)           _int_malloc
   1,328,870  (0.4%)           malloc
   1,256,792  (0.4%)           free
     890,549  (0.3%)           malloc_consolidate
     353,379  (0.1%)           unlink_chunk.isra.0

<  9,082,232  (3.0%, 76.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c:
   2,773,227  (0.9%)           cbs_get
   1,876,419  (0.6%)           aws_lc_0_19_0_CBS_get_u8
   1,121,165  (0.4%)           cbs_get_any_asn1_element
     667,472  (0.2%)           aws_lc_0_19_0_CBS_len
     541,342  (0.2%)           parse_asn1_tag
     440,265  (0.1%)           aws_lc_0_19_0_CBS_init
     389,664  (0.1%)           aws_lc_0_19_0_CBS_get_any_ber_asn1_element
     386,640  (0.1%)           aws_lc_0_19_0_CBS_get_bytes

<  8,754,657  (2.9%, 79.8%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c:
   4,838,015  (1.6%)           aws_lc_0_19_0_bn_add_words
   3,160,777  (1.0%)           aws_lc_0_19_0_bn_sub_words
     514,080  (0.2%)           aws_lc_0_19_0_bn_mul_add_words

<  5,289,555  (1.7%, 81.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c:
   1,824,466  (0.6%)           aws_lc_0_19_0_OPENSSL_free
     944,416  (0.3%)           aws_lc_0_19_0_OPENSSL_malloc
     666,810  (0.2%)           aws_lc_0_19_0_OPENSSL_cleanse
     390,992  (0.1%)           aws_lc_0_19_0_OPENSSL_isspace
     376,504  (0.1%)           aws_lc_0_19_0_OPENSSL_zalloc
     363,760  (0.1%)           __asan_unpoison_memory_region

<  4,747,996  (1.6%, 83.1%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c:
   2,949,394  (1.0%)           s2n_stuffer_validate
     589,475  (0.2%)           s2n_stuffer_write_bytes
     520,020  (0.2%)           s2n_stuffer_skip_write
     468,018  (0.2%)           s2n_stuffer_reserve_space

<  4,556,297  (1.5%, 84.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/cmp.c:
   4,355,654  (1.4%)           bn_cmp_words_consttime

<  4,384,740  (1.4%, 86.0%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c:
   1,538,488  (0.5%)           asn1_item_ex_i2d_opt
   1,003,492  (0.3%)           asn1_template_ex_i2d
     928,312  (0.3%)           asn1_ex_i2c
     710,792  (0.2%)           asn1_i2d_ex_primitive

<  4,191,300  (1.4%, 87.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c:
   1,464,093  (0.5%)           asn1_item_ex_d2i
     726,000  (0.2%)           asn1_check_tlen
     668,533  (0.2%)           asn1_template_noexp_d2i
     574,853  (0.2%)           asn1_d2i_ex_primitive
     388,703  (0.1%)           asn1_template_ex_d2i
     319,429  (0.1%)           asn1_ex_c2i

<  3,781,275  (1.2%, 88.6%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c:
   3,771,694  (1.2%)           s2n_blob_validate

<  2,828,663  (0.9%, 89.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c:
   1,671,981  (0.5%)           aws_lc_0_19_0_asn1_item_combine_free
     544,182  (0.2%)           aws_lc_0_19_0_ASN1_template_free
     518,735  (0.2%)           aws_lc_0_19_0_ASN1_primitive_free

<  2,468,851  (0.8%, 90.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c:
     819,432  (0.3%)           aws_lc_0_19_0_asn1_get_field_ptr
     542,736  (0.2%)           aws_lc_0_19_0_asn1_do_adb
     424,890  (0.1%)           asn1_get_enc_ptr

<  2,449,309  (0.8%, 91.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c:
     516,516  (0.2%)           cbb_add_u
     420,420  (0.1%)           cbb_buffer_reserve
     312,312  (0.1%)           aws_lc_0_19_0_CBB_add_space
     307,104  (0.1%)           aws_lc_0_19_0_CBB_flush

<  2,128,994  (0.7%, 91.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c:
   1,002,490  (0.3%)           aws_lc_0_19_0_ASN1_get_object
     413,320  (0.1%)           aws_lc_0_19_0_ASN1_object_size

<  1,827,932  (0.6%, 92.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c:
   1,236,396  (0.4%)           aws_lc_0_19_0_X509_NAME_cmp
     591,481  (0.2%)           aws_lc_0_19_0_X509_subject_name_cmp

<  1,525,756  (0.5%, 93.0%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c:
     974,204  (0.3%)           x509_object_cmp
     521,895  (0.2%)           x509_object_cmp_sk

<  1,491,407  (0.5%, 93.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c:
     721,824  (0.2%)           asn1_item_ex_combine_new
     318,881  (0.1%)           ASN1_template_new

<  1,427,157  (0.5%, 93.9%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c:s2n_result_is_ok

<  1,355,716  (0.4%, 94.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c:
     583,856  (0.2%)           aws_lc_0_19_0_cbs_get_latin1

<  1,239,866  (0.4%, 94.8%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms

<  1,126,461  (0.4%, 95.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/div.c:
     776,197  (0.3%)           aws_lc_0_19_0_bn_div_consttime
     327,416  (0.1%)           aws_lc_0_19_0_bn_reduce_once_in_place

<  1,097,512  (0.4%, 95.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_mbstr.c:
   1,072,925  (0.4%)           aws_lc_0_19_0_ASN1_mbstring_ncopy

<  1,085,488  (0.4%, 95.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h:
   1,028,320  (0.3%)           OPENSSL_memset

<  1,072,335  (0.4%, 96.2%)  ./stdlib/./stdlib/qsort.c:
   1,062,187  (0.3%)           msort_with_tmp.part.0

<    989,720  (0.3%, 96.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont.S:
     837,276  (0.3%)           bn_mul4x_mont

<    912,534  (0.3%, 96.8%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x_name.c:
     470,206  (0.2%)           asn1_string_canon

<    819,203  (0.3%, 97.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/add.c:
     451,794  (0.1%)           aws_lc_0_19_0_bn_uadd_consttime

<    783,384  (0.3%, 97.4%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:
     782,823  (0.3%)           __memcpy_avx_unaligned_erms

<    535,900  (0.2%, 97.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_object.c:
     306,604  (0.1%)           aws_lc_0_19_0_ASN1_OBJECT_free

<    337,863  (0.1%, 97.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/pem/pem_lib.c:
     329,103  (0.1%)           aws_lc_0_19_0_PEM_read_bio

<    308,541  (0.1%, 97.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/gcd.c:
     308,461  (0.1%)           aws_lc_0_19_0_BN_mod_inverse_odd

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir_______________________  function:file

> 55,770,284 (18.3%, 18.3%)  aws_lc_0_19_0_bn_sqr8x_internal:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont5.S

> 19,148,880  (6.3%, 24.6%)  base64_ascii_to_bin:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

> 15,699,024  (5.2%, 29.7%)  mul4x_internal:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont5.S

> 13,737,240  (4.5%, 34.3%)  constant_time_in_range_8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

> 11,612,328  (3.8%, 38.1%)  constant_time_select_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

> 10,615,140  (3.5%, 41.6%)  constant_time_lt_args_8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

> 10,101,140  (3.3%, 44.9%)  constant_time_is_zero_w:
   8,741,880  (2.9%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h
   1,359,260  (0.4%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

> 10,100,258  (3.3%, 48.2%)  constant_time_msb_w:
   8,741,880  (2.9%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h
   1,358,378  (0.4%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>  9,711,812  (3.2%, 51.4%)  aws_lc_0_19_0_bn_rshift1_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c

>  8,847,488  (2.9%, 54.3%)  value_barrier_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>  8,474,088  (2.8%, 57.1%)  aws_lc_0_19_0_bn_select_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c

>  7,935,202  (2.6%, 59.7%)  constant_time_eq_w:
   6,868,620  (2.3%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h
   1,066,582  (0.4%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>  7,493,040  (2.5%, 62.1%)  constant_time_eq_8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h

>  7,474,924  (2.5%, 64.6%)  aws_lc_0_19_0_EVP_DecodeUpdate:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

>  5,619,205  (1.8%, 66.4%)  base64_decode_quad:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

>  4,838,015  (1.6%, 68.0%)  aws_lc_0_19_0_bn_add_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c

>  4,355,654  (1.4%, 69.4%)  bn_cmp_words_consttime:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/cmp.c

>  3,771,694  (1.2%, 70.7%)  s2n_blob_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c

>  3,160,777  (1.0%, 71.7%)  aws_lc_0_19_0_bn_sub_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c

>  3,104,800  (1.0%, 72.7%)  constant_time_select_int:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>  3,094,320  (1.0%, 73.7%)  _int_free:./malloc/./malloc/malloc.c

>  3,030,349  (1.0%, 74.7%)  aws_lc_0_19_0_bn_rshift_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c

>  2,949,394  (1.0%, 75.7%)  s2n_stuffer_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>  2,773,227  (0.9%, 76.6%)  cbs_get:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>  2,547,993  (0.8%, 77.5%)  _int_malloc:./malloc/./malloc/malloc.c

>  1,876,419  (0.6%, 78.1%)  aws_lc_0_19_0_CBS_get_u8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>  1,824,466  (0.6%, 78.7%)  aws_lc_0_19_0_OPENSSL_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>  1,671,981  (0.5%, 79.2%)  aws_lc_0_19_0_asn1_item_combine_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c

>  1,648,388  (0.5%, 79.8%)  constant_time_lt_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>  1,538,488  (0.5%, 80.3%)  asn1_item_ex_i2d_opt:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>  1,464,093  (0.5%, 80.7%)  asn1_item_ex_d2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>  1,427,157  (0.5%, 81.2%)  s2n_result_is_ok:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c

>  1,390,355  (0.5%, 81.7%)  free:
   1,256,792  (0.4%)           ./malloc/./malloc/malloc.c

>  1,362,817  (0.4%, 82.1%)  malloc:
   1,328,870  (0.4%)           ./malloc/./malloc/malloc.c

>  1,311,552  (0.4%, 82.5%)  aws_lc_0_19_0_bn_fits_in_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c

>  1,239,866  (0.4%, 83.0%)  __memset_avx2_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

>  1,236,396  (0.4%, 83.4%)  aws_lc_0_19_0_X509_NAME_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c

>  1,213,496  (0.4%, 83.8%)  OPENSSL_memset:
   1,028,320  (0.3%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h

>  1,121,165  (0.4%, 84.1%)  cbs_get_any_asn1_element:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>  1,114,840  (0.4%, 84.5%)  __bn_post4x_internal:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont5.S

>  1,104,941  (0.4%, 84.9%)  msort_with_tmp.part.0:
   1,062,187  (0.3%)           ./stdlib/./stdlib/qsort.c

>  1,072,925  (0.4%, 85.2%)  aws_lc_0_19_0_ASN1_mbstring_ncopy:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_mbstr.c

>  1,003,492  (0.3%, 85.5%)  asn1_template_ex_i2d:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>  1,002,490  (0.3%, 85.9%)  aws_lc_0_19_0_ASN1_get_object:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c

>    974,204  (0.3%, 86.2%)  x509_object_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c

>    944,416  (0.3%, 86.5%)  aws_lc_0_19_0_OPENSSL_malloc:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    928,312  (0.3%, 86.8%)  asn1_ex_i2c:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>    890,549  (0.3%, 87.1%)  malloc_consolidate:./malloc/./malloc/malloc.c

>    837,276  (0.3%, 87.4%)  bn_mul4x_mont:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont.S

>    819,432  (0.3%, 87.6%)  aws_lc_0_19_0_asn1_get_field_ptr:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c

>    782,823  (0.3%, 87.9%)  __memcpy_avx_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

>    776,197  (0.3%, 88.2%)  aws_lc_0_19_0_bn_div_consttime:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/div.c

>    726,000  (0.2%, 88.4%)  asn1_check_tlen:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>    721,824  (0.2%, 88.6%)  asn1_item_ex_combine_new:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c

>    710,792  (0.2%, 88.9%)  asn1_i2d_ex_primitive:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>    668,533  (0.2%, 89.1%)  asn1_template_noexp_d2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>    667,472  (0.2%, 89.3%)  aws_lc_0_19_0_CBS_len:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    666,810  (0.2%, 89.5%)  aws_lc_0_19_0_OPENSSL_cleanse:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    591,481  (0.2%, 89.7%)  aws_lc_0_19_0_X509_subject_name_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c

>    589,475  (0.2%, 89.9%)  s2n_stuffer_write_bytes:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    583,856  (0.2%, 90.1%)  aws_lc_0_19_0_cbs_get_latin1:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c

>    574,853  (0.2%, 90.3%)  asn1_d2i_ex_primitive:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>    544,182  (0.2%, 90.5%)  aws_lc_0_19_0_ASN1_template_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c

>    542,736  (0.2%, 90.6%)  aws_lc_0_19_0_asn1_do_adb:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c

>    541,342  (0.2%, 90.8%)  parse_asn1_tag:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    521,895  (0.2%, 91.0%)  x509_object_cmp_sk:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c

>    520,020  (0.2%, 91.2%)  s2n_stuffer_skip_write:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    518,735  (0.2%, 91.3%)  aws_lc_0_19_0_ASN1_primitive_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c

>    516,516  (0.2%, 91.5%)  cbb_add_u:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    514,080  (0.2%, 91.7%)  aws_lc_0_19_0_bn_mul_add_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c

>    494,184  (0.2%, 91.8%)  aws_lc_0_19_0_bn_minimal_width:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c

>    470,206  (0.2%, 92.0%)  asn1_string_canon:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x_name.c

>    468,018  (0.2%, 92.1%)  s2n_stuffer_reserve_space:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    451,794  (0.1%, 92.3%)  aws_lc_0_19_0_bn_uadd_consttime:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/add.c

>    440,265  (0.1%, 92.4%)  aws_lc_0_19_0_CBS_init:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    424,890  (0.1%, 92.6%)  asn1_get_enc_ptr:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c

>    420,420  (0.1%, 92.7%)  cbb_buffer_reserve:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    413,320  (0.1%, 92.8%)  aws_lc_0_19_0_ASN1_object_size:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c

>    390,992  (0.1%, 93.0%)  aws_lc_0_19_0_OPENSSL_isspace:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    389,664  (0.1%, 93.1%)  aws_lc_0_19_0_CBS_get_any_ber_asn1_element:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    388,703  (0.1%, 93.2%)  asn1_template_ex_d2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>    386,640  (0.1%, 93.4%)  aws_lc_0_19_0_CBS_get_bytes:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    376,504  (0.1%, 93.5%)  aws_lc_0_19_0_OPENSSL_zalloc:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    363,760  (0.1%, 93.6%)  __asan_unpoison_memory_region:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    353,379  (0.1%, 93.7%)  unlink_chunk.isra.0:./malloc/./malloc/malloc.c

>    329,103  (0.1%, 93.8%)  aws_lc_0_19_0_PEM_read_bio:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/pem/pem_lib.c

>    327,416  (0.1%, 93.9%)  aws_lc_0_19_0_bn_reduce_once_in_place:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/div.c

>    319,429  (0.1%, 94.0%)  asn1_ex_c2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>    318,881  (0.1%, 94.1%)  ASN1_template_new:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c

>    312,312  (0.1%, 94.2%)  aws_lc_0_19_0_CBB_add_space:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    308,461  (0.1%, 94.3%)  aws_lc_0_19_0_BN_mod_inverse_odd:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/gcd.c

>    307,104  (0.1%, 94.4%)  aws_lc_0_19_0_CBB_flush:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    306,604  (0.1%, 94.5%)  aws_lc_0_19_0_ASN1_OBJECT_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_object.c

--------------------------------------------------------------------------------
-- Annotated source file: ./malloc/./malloc/malloc.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./malloc/./malloc/malloc.c

--------------------------------------------------------------------------------
-- Annotated source file: ./stdlib/./stdlib/qsort.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdlib/./stdlib/qsort.c

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_mbstr.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 69 ----------------------------------------
      .         // These functions take a string in UTF8, ASCII or multibyte form and a mask
      .         // of permissible ASN1 string types. It then works out the minimal type
      .         // (using the order Printable < IA5 < T61 < BMP < Universal < UTF8) and
      .         // creates a string of the correct type with the supplied data. Yes this is
      .         // horrible: it has to be :-( The 'ncopy' form checks minimum and maximum
      .         // size limits too.
      .         
      .         int ASN1_mbstring_copy(ASN1_STRING **out, const unsigned char *in,
  9,621 (0.0%)                         ossl_ssize_t len, int inform, unsigned long mask) {
 12,828 (0.0%)    return ASN1_mbstring_ncopy(out, in, len, inform, mask, /*minsize=*/0,
      .                                      /*maxsize=*/0);
  2,138 (0.0%)  }
      .         
      .         OPENSSL_DECLARE_ERROR_REASON(ASN1, INVALID_BMPSTRING)
      .         OPENSSL_DECLARE_ERROR_REASON(ASN1, INVALID_UNIVERSALSTRING)
      .         OPENSSL_DECLARE_ERROR_REASON(ASN1, INVALID_UTF8STRING)
      .         
      .         int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in,
      .                                 ossl_ssize_t len, int inform, unsigned long mask,
 13,897 (0.0%)                          ossl_ssize_t minsize, ossl_ssize_t maxsize) {
  2,138 (0.0%)    if (len == -1) {
      .             len = strlen((const char *)in);
      .           }
  2,138 (0.0%)    if (!mask) {
      .             mask = DIRSTRING_TYPE;
      .           }
      .         
      .           int (*decode_func)(CBS *, uint32_t *);
      .           int error;
 12,258 (0.0%)    switch (inform) {
      .             case MBSTRING_BMP:
      .               decode_func = cbs_get_ucs2_be;
      .               error = ASN1_R_INVALID_BMPSTRING;
      .               break;
      .         
      .             case MBSTRING_UNIV:
      .               decode_func = cbs_get_utf32_be;
      .               error = ASN1_R_INVALID_UNIVERSALSTRING;
      .               break;
      .         
      .             case MBSTRING_UTF8:
    570 (0.0%)        decode_func = cbs_get_utf8;
    285 (0.0%)        error = ASN1_R_INVALID_UTF8STRING;
    285 (0.0%)        break;
      .         
      .             case MBSTRING_ASC:
  1,568 (0.0%)        decode_func = cbs_get_latin1;
    784 (0.0%)        error = ERR_R_INTERNAL_ERROR;  // Latin-1 inputs are never invalid.
    784 (0.0%)        break;
      .         
      .             default:
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNKNOWN_FORMAT);
      .               return -1;
      .           }
      .         
      .           // Check |minsize| and |maxsize| and work out the minimal type, if any.
      .           CBS cbs;
  6,414 (0.0%)    CBS_init(&cbs, in, len);
  2,138 (0.0%)    size_t utf8_len = 0, nchar = 0;
 90,139 (0.0%)    while (CBS_len(&cbs) != 0) {
      .             uint32_t c;
133,960 (0.0%)      if (!decode_func(&cbs, &c)) {
      .               OPENSSL_PUT_ERROR(ASN1, error);
      .               return -1;
      .             }
 37,766 (0.0%)      if (nchar == 0 && (inform == MBSTRING_BMP || inform == MBSTRING_UNIV) &&
      .                 c == 0xfeff) {
      .               // Reject byte-order mark. We could drop it but that would mean
      .               // adding ambiguity around whether a BOM was included or not when
      .               // matching strings.
      .               //
      .               // For a little-endian UCS-2 string, the BOM will appear as 0xfffe
      .               // and will be rejected as noncharacter, below.
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_CHARACTERS);
      .               return -1;
      .             }
      .         
      .             // Update which output formats are still possible.
 66,980 (0.0%)      if ((mask & B_ASN1_PRINTABLESTRING) && !asn1_is_printable(c)) {
      .               mask &= ~B_ASN1_PRINTABLESTRING;
      .             }
 66,980 (0.0%)      if ((mask & B_ASN1_IA5STRING) && (c > 127)) {
      .               mask &= ~B_ASN1_IA5STRING;
      .             }
 66,980 (0.0%)      if ((mask & B_ASN1_T61STRING) && (c > 0xff)) {
      .               mask &= ~B_ASN1_T61STRING;
      .             }
 66,980 (0.0%)      if ((mask & B_ASN1_BMPSTRING) && (c > 0xffff)) {
      .               mask &= ~B_ASN1_BMPSTRING;
      .             }
 33,490 (0.0%)      if (!mask) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_CHARACTERS);
      .               return -1;
      .             }
      .         
 16,745 (0.0%)      nchar++;
 66,980 (0.0%)      utf8_len += cbb_get_utf8_len(c);
 33,490 (0.0%)      if (maxsize > 0 && nchar > (size_t)maxsize) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_STRING_TOO_LONG);
      .         #if defined(OPENSSL_WINDOWS)
      .               ERR_add_error_dataf("maxsize=%lu", (unsigned long)maxsize);
      .         #else
      .               ERR_add_error_dataf("maxsize=%zu", (size_t)maxsize);
      .         #endif
      .               return -1;
      .             }
      .           }
      .         
  2,138 (0.0%)    if (minsize > 0 && nchar < (size_t)minsize) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_STRING_TOO_SHORT);
      .         #if defined(OPENSSL_WINDOWS)
      .             ERR_add_error_dataf("minsize=%lu", (unsigned long)minsize);
      .         #else
      .             ERR_add_error_dataf("minsize=%zu", (size_t)minsize);
      .         #endif
      .             return -1;
      .           }
      .         
      .           // Now work out output format and string type
      .           int str_type;
  2,138 (0.0%)    int (*encode_func)(CBB *, uint32_t) = cbb_add_latin1;
  2,138 (0.0%)    size_t size_estimate = nchar;
  1,069 (0.0%)    int outform = MBSTRING_ASC;
  4,276 (0.0%)    if (mask & B_ASN1_PRINTABLESTRING) {
      .             str_type = V_ASN1_PRINTABLESTRING;
  4,276 (0.0%)    } else if (mask & B_ASN1_IA5STRING) {
      .             str_type = V_ASN1_IA5STRING;
  4,276 (0.0%)    } else if (mask & B_ASN1_T61STRING) {
      .             str_type = V_ASN1_T61STRING;
  4,276 (0.0%)    } else if (mask & B_ASN1_BMPSTRING) {
      .             str_type = V_ASN1_BMPSTRING;
      .             outform = MBSTRING_BMP;
      .             encode_func = cbb_add_ucs2_be;
      .             size_estimate = 2 * nchar;
  4,276 (0.0%)    } else if (mask & B_ASN1_UNIVERSALSTRING) {
      .             str_type = V_ASN1_UNIVERSALSTRING;
      .             encode_func = cbb_add_utf32_be;
      .             size_estimate = 4 * nchar;
      .             outform = MBSTRING_UNIV;
  4,276 (0.0%)    } else if (mask & B_ASN1_UTF8STRING) {
  1,069 (0.0%)      str_type = V_ASN1_UTF8STRING;
  1,069 (0.0%)      outform = MBSTRING_UTF8;
  2,138 (0.0%)      encode_func = cbb_add_utf8;
  3,207 (0.0%)      size_estimate = utf8_len;
      .           } else {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_CHARACTERS);
      .             return -1;
      .           }
      .         
  2,138 (0.0%)    if (!out) {
      .             return str_type;
      .           }
      .         
  1,069 (0.0%)    int free_dest = 0;
      .           ASN1_STRING *dest;
  4,276 (0.0%)    if (*out) {
  4,276 (0.0%)      dest = *out;
      .           } else {
      .             free_dest = 1;
      .             dest = ASN1_STRING_type_new(str_type);
      .             if (!dest) {
      .               return -1;
      .             }
      .           }
      .         
      .           CBB cbb;
  3,207 (0.0%)    CBB_zero(&cbb);
      .           // If both the same type just copy across
  3,207 (0.0%)    if (inform == outform) {
  2,280 (0.0%)      if (!ASN1_STRING_set(dest, in, len)) {
      .               goto err;
      .             }
    855 (0.0%)      dest->type = str_type;
    855 (0.0%)      *out = dest;
    570 (0.0%)      return str_type;
      .           }
  6,272 (0.0%)    if (!CBB_init(&cbb, size_estimate + 1)) {
      .             goto err;
      .           }
  4,704 (0.0%)    CBS_init(&cbs, in, len);
 60,844 (0.0%)    while (CBS_len(&cbs) != 0) {
      .             uint32_t c;
179,648 (0.1%)      if (!decode_func(&cbs, &c) || !encode_func(&cbb, c)) {
      .               OPENSSL_PUT_ERROR(ASN1, ERR_R_INTERNAL_ERROR);
      .               goto err;
      .             }
      .           }
    784 (0.0%)    uint8_t *data = NULL;
      .           size_t data_len;
  1,568 (0.0%)    if (// OpenSSL historically NUL-terminated this value with a single byte,
      .               // even for |MBSTRING_BMP| and |MBSTRING_UNIV|.
 10,976 (0.0%)        !CBB_add_u8(&cbb, 0) || !CBB_finish(&cbb, &data, &data_len) ||
  3,920 (0.0%)        data_len < 1 || data_len > INT_MAX) {
      .             OPENSSL_PUT_ERROR(ASN1, ERR_R_INTERNAL_ERROR);
      .             OPENSSL_free(data);
      .             goto err;
      .           }
  2,352 (0.0%)    dest->type = str_type;
  5,488 (0.0%)    ASN1_STRING_set0(dest, data, (int)data_len - 1);
  2,352 (0.0%)    *out = dest;
  1,568 (0.0%)    return str_type;
      .         
      .         err:
      .           if (free_dest) {
      .             ASN1_STRING_free(dest);
      .           }
      .           CBB_cleanup(&cbb);
      .           return -1;
  5,345 (0.0%)  }
      .         
      .         int asn1_is_printable(uint32_t value) {
      .           if (value > 0x7f) {
      .             return 0;
      .           }
      .           return OPENSSL_isalnum(value) || //
      .                  value == ' ' || value == '\'' || value == '(' || value == ')' ||
      .                  value == '+' || value == ',' || value == '-' || value == '.' ||
-- line 285 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_object.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 149 ----------------------------------------
     .             // |c2i_ASN1_OBJECT| should have consumed the entire input.
     .             assert(CBS_data(&cbs) == contents);
     .             *inp = CBS_data(&cbs);
     .           }
     .           return ret;
     .         }
     .         
     .         ASN1_OBJECT *c2i_ASN1_OBJECT(ASN1_OBJECT **out, const unsigned char **inp,
20,610 (0.0%)                               long len) {
 4,122 (0.0%)    if (len < 0) {
     .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_OBJECT_ENCODING);
     .             return NULL;
     .           }
     .         
     .           CBS cbs;
14,427 (0.0%)    CBS_init(&cbs, *inp, (size_t)len);
10,305 (0.0%)    if (!CBS_is_valid_asn1_oid(&cbs)) {
     .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_OBJECT_ENCODING);
     .             return NULL;
     .           }
     .         
18,549 (0.0%)    ASN1_OBJECT *ret = ASN1_OBJECT_create(NID_undef, *inp, (size_t)len,
     .                                                 /*sn=*/NULL, /*ln=*/NULL);
 4,122 (0.0%)    if (ret == NULL) {
     .             return NULL;
     .           }
     .         
 4,122 (0.0%)    if (out != NULL) {
 8,244 (0.0%)      ASN1_OBJECT_free(*out);
 6,183 (0.0%)      *out = ret;
     .           }
12,366 (0.0%)    *inp += len;  // All bytes were consumed.
 2,061 (0.0%)    return ret;
10,305 (0.0%)  }
     .         
12,516 (0.0%)  ASN1_OBJECT *ASN1_OBJECT_new(void) {
     .           ASN1_OBJECT *ret;
     .         
 9,387 (0.0%)    ret = (ASN1_OBJECT *)OPENSSL_zalloc(sizeof(ASN1_OBJECT));
 6,258 (0.0%)    if (ret == NULL) {
     .             return NULL;
     .           }
 6,258 (0.0%)    ret->flags = ASN1_OBJECT_FLAG_DYNAMIC;
 3,129 (0.0%)    return ret;
 6,258 (0.0%)  }
     .         
36,075 (0.0%)  void ASN1_OBJECT_free(ASN1_OBJECT *a) {
14,430 (0.0%)    if (a == NULL) {
    40 (0.0%)      return;
     .           }
35,875 (0.0%)    if (a->flags & ASN1_OBJECT_FLAG_DYNAMIC_STRINGS) {
20,616 (0.0%)      OPENSSL_free((void *)a->sn);
20,616 (0.0%)      OPENSSL_free((void *)a->ln);
30,924 (0.0%)      a->sn = a->ln = NULL;
     .           }
35,875 (0.0%)    if (a->flags & ASN1_OBJECT_FLAG_DYNAMIC_DATA) {
20,616 (0.0%)      OPENSSL_free((void *)a->data);
10,308 (0.0%)      a->data = NULL;
10,308 (0.0%)      a->length = 0;
     .           }
35,875 (0.0%)    if (a->flags & ASN1_OBJECT_FLAG_DYNAMIC) {
20,616 (0.0%)      OPENSSL_free(a);
     .           }
14,430 (0.0%)  }
     .         
     .         ASN1_OBJECT *ASN1_OBJECT_create(int nid, const unsigned char *data, size_t len,
24,732 (0.0%)                                  const char *sn, const char *ln) {
 6,183 (0.0%)    if (len > INT_MAX) {
     .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_STRING_TOO_LONG);
     .             return NULL;
     .           }
     .         
     .           ASN1_OBJECT o;
 4,122 (0.0%)    o.sn = sn;
 4,122 (0.0%)    o.ln = ln;
 4,122 (0.0%)    o.data = data;
 4,122 (0.0%)    o.nid = nid;
 4,122 (0.0%)    o.length = (int)len;
 2,061 (0.0%)    o.flags = ASN1_OBJECT_FLAG_DYNAMIC | ASN1_OBJECT_FLAG_DYNAMIC_STRINGS |
     .                     ASN1_OBJECT_FLAG_DYNAMIC_DATA;
 6,183 (0.0%)    return OBJ_dup(&o);
10,305 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 109 ----------------------------------------
      .         //
      .         // In particular, this limit is small enough that the bit count of a BIT STRING
      .         // comfortably fits in an |int|, with room for arithmetic.
      .         #define ASN1_STRING_MAX (64 * 1024 * 1024)
      .         
      .         static void asn1_put_length(unsigned char **pp, int length);
      .         
      .         int ASN1_get_object(const unsigned char **inp, long *out_len, int *out_tag,
141,696 (0.0%)                      int *out_class, long in_len) {
 23,616 (0.0%)    if (in_len < 0) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_HEADER_TOO_LONG);
      .             return 0x80;
      .           }
      .         
      .           // TODO(https://crbug.com/boringssl/354): This should use |CBS_get_asn1| to
      .           // reject non-minimal lengths, which are only allowed in BER. However,
      .           // Android sometimes needs allow a non-minimal length in certificate
      .           // signature fields (see b/18228011). Make this only apply to that field,
      .           // while requiring DER elsewhere. Better yet, it should be limited to an
      .           // preprocessing step in that part of Android.
      .           CBS_ASN1_TAG tag;
      .           size_t header_len;
      .           int indefinite;
      .           CBS cbs, body;
 82,656 (0.0%)    CBS_init(&cbs, *inp, (size_t)in_len);
129,888 (0.0%)    if (!CBS_get_any_ber_asn1_element(&cbs, &body, &tag, &header_len,
 35,424 (0.0%)                                      /*out_ber_found=*/NULL, &indefinite) ||
106,272 (0.0%)        indefinite || !CBS_skip(&body, header_len) ||
      .               // Bound the length to comfortably fit in an int. Lengths in this
      .               // module often switch between int and long without overflow checks.
 35,424 (0.0%)        CBS_len(&body) > INT_MAX / 2) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_HEADER_TOO_LONG);
      .             return 0x80;
      .           }
      .         
      .           // Convert between tag representations.
 47,232 (0.0%)    int tag_class = (tag & CBS_ASN1_CLASS_MASK) >> CBS_ASN1_TAG_SHIFT;
 47,232 (0.0%)    int constructed = (tag & CBS_ASN1_CONSTRUCTED) >> CBS_ASN1_TAG_SHIFT;
 35,424 (0.0%)    int tag_number = tag & CBS_ASN1_TAG_NUMBER_MASK;
      .         
      .           // To avoid ambiguity with V_ASN1_NEG, impose a limit on universal tags.
 46,042 (0.0%)    if (tag_class == V_ASN1_UNIVERSAL && tag_number > V_ASN1_MAX_UNIVERSAL) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_HEADER_TOO_LONG);
      .             return 0x80;
      .           }
      .         
 59,040 (0.0%)    *inp = CBS_data(&body);
 70,848 (0.0%)    *out_len = CBS_len(&body);
 35,424 (0.0%)    *out_tag = tag_number;
 35,424 (0.0%)    *out_class = tag_class;
 11,808 (0.0%)    return constructed;
 59,040 (0.0%)  }
      .         
      .         // class 0 is constructed constructed == 2 for indefinite length constructed
      .         void ASN1_put_object(unsigned char **pp, int constructed, int length, int tag,
 60,144 (0.0%)                       int xclass) {
 15,036 (0.0%)    unsigned char *p = *pp;
      .           int i, ttag;
      .         
 22,480 (0.0%)    i = (constructed) ? V_ASN1_CONSTRUCTED : 0;
 15,036 (0.0%)    i |= (xclass & V_ASN1_PRIVATE);
 10,024 (0.0%)    if (tag < 31) {
 60,144 (0.0%)      *(p++) = i | (tag & V_ASN1_PRIMITIVE_TAG);
      .           } else {
      .             *(p++) = i | V_ASN1_PRIMITIVE_TAG;
      .             for (i = 0, ttag = tag; ttag > 0; i++) {
      .               ttag >>= 7;
      .             }
      .             ttag = i;
      .             while (i-- > 0) {
      .               p[i] = tag & 0x7f;
      .               if (i != (ttag - 1)) {
      .                 p[i] |= 0x80;
      .               }
      .               tag >>= 7;
      .             }
      .             p += ttag;
      .           }
 10,024 (0.0%)    if (constructed == 2) {
      .             *(p++) = 0x80;
      .           } else {
 25,060 (0.0%)      asn1_put_length(&p, length);
      .           }
 15,036 (0.0%)    *pp = p;
 30,072 (0.0%)  }
      .         
      .         int ASN1_put_eoc(unsigned char **pp) {
      .           // This function is no longer used in the library, but some external code
      .           // uses it.
      .           unsigned char *p = *pp;
      .           *p++ = 0;
      .           *p++ = 0;
      .           *pp = p;
      .           return 2;
      .         }
      .         
 25,060 (0.0%)  static void asn1_put_length(unsigned char **pp, int length) {
 15,036 (0.0%)    unsigned char *p = *pp;
      .           int i, l;
 10,024 (0.0%)    if (length <= 127) {
 28,776 (0.0%)      *(p++) = (unsigned char)length;
      .           } else {
    432 (0.0%)      l = length;
  2,160 (0.0%)      for (i = 0; l > 0; i++) {
    432 (0.0%)        l >>= 8;
      .             }
  1,728 (0.0%)      *(p++) = i | 0x80;
    432 (0.0%)      l = i;
  3,456 (0.0%)      while (i-- > 0) {
  2,592 (0.0%)        p[i] = length & 0xff;
    432 (0.0%)        length >>= 8;
      .             }
    648 (0.0%)      p += l;
      .           }
 15,036 (0.0%)    *pp = p;
 15,036 (0.0%)  }
      .         
 97,512 (0.0%)  int ASN1_object_size(int constructed, int length, int tag) {
 16,252 (0.0%)    int ret = 1;
 32,504 (0.0%)    if (length < 0) {
      .             return -1;
      .           }
 32,504 (0.0%)    if (tag >= 31) {
      .             while (tag > 0) {
      .               tag >>= 7;
      .               ret++;
      .             }
      .           }
 32,504 (0.0%)    if (constructed == 2) {
      .             ret += 3;
      .           } else {
 16,252 (0.0%)      ret++;
 32,504 (0.0%)      if (length > 127) {
  1,080 (0.0%)        int tmplen = length;
  3,780 (0.0%)        while (tmplen > 0) {
  1,080 (0.0%)          tmplen >>= 8;
  1,080 (0.0%)          ret++;
      .               }
      .             }
      .           }
 65,008 (0.0%)    if (ret >= INT_MAX - length) {
      .             return -1;
      .           }
 48,756 (0.0%)    return ret + length;
 32,504 (0.0%)  }
      .         
      .         int ASN1_STRING_copy(ASN1_STRING *dst, const ASN1_STRING *str) {
      .           if (str == NULL) {
      .             return 0;
      .           }
      .           if (!ASN1_STRING_set(dst, str->data, str->length)) {
      .             return 0;
      .           }
-- line 261 ----------------------------------------
-- line 275 ----------------------------------------
      .           }
      .           if (!ASN1_STRING_copy(ret, str)) {
      .             ASN1_STRING_free(ret);
      .             return NULL;
      .           }
      .           return ret;
      .         }
      .         
 17,185 (0.0%)  int ASN1_STRING_set(ASN1_STRING *str, const void *_data, ossl_ssize_t len_s) {
  4,910 (0.0%)    const char *data = _data;
      .           size_t len;
  4,910 (0.0%)    if (len_s < 0) {
      .             if (data == NULL) {
      .               return 0;
      .             }
      .             len = strlen(data);
      .           } else {
  4,910 (0.0%)      len = (size_t)len_s;
      .           }
      .         
      .           OPENSSL_STATIC_ASSERT(ASN1_STRING_MAX < INT_MAX, len_will_not_overflow_int);
  4,910 (0.0%)    if (len > ASN1_STRING_MAX) {
      .             OPENSSL_PUT_ERROR(ASN1, ERR_R_OVERFLOW);
      .             return 0;
      .           }
      .         
 12,275 (0.0%)    if (str->length <= (int)len || str->data == NULL) {
  7,365 (0.0%)      unsigned char *c = str->data;
  4,910 (0.0%)      if (c == NULL) {
 17,185 (0.0%)        str->data = OPENSSL_malloc(len + 1);
      .             } else {
      .               str->data = OPENSSL_realloc(c, len + 1);
      .             }
      .         
  9,820 (0.0%)      if (str->data == NULL) {
      .               str->data = c;
      .               return 0;
      .             }
      .           }
  9,820 (0.0%)    str->length = (int)len;
  4,910 (0.0%)    if (data != NULL) {
 17,185 (0.0%)      OPENSSL_memcpy(str->data, data, len);
      .             // Historically, OpenSSL would NUL-terminate most (but not all)
      .             // |ASN1_STRING|s, in case anyone accidentally passed |str->data| into a
      .             // function expecting a C string. We retain this behavior for compatibility,
      .             // but code must not rely on this. See CVE-2021-3712.
 12,275 (0.0%)      str->data[len] = '\0';
      .           }
  2,455 (0.0%)    return 1;
  4,910 (0.0%)  }
      .         
  5,488 (0.0%)  void ASN1_STRING_set0(ASN1_STRING *str, void *data, int len) {
  3,136 (0.0%)    OPENSSL_free(str->data);
  2,352 (0.0%)    str->data = data;
  2,352 (0.0%)    str->length = len;
  2,352 (0.0%)  }
      .         
      .         ASN1_STRING *ASN1_STRING_new(void) {
      .           return (ASN1_STRING_type_new(V_ASN1_OCTET_STRING));
      .         }
      .         
 17,670 (0.0%)  ASN1_STRING *ASN1_STRING_type_new(int type) {
      .           ASN1_STRING *ret;
      .         
 10,602 (0.0%)    ret = (ASN1_STRING *)OPENSSL_zalloc(sizeof(ASN1_STRING));
  7,068 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
 10,602 (0.0%)    ret->type = type;
  3,534 (0.0%)    return ret;
  7,068 (0.0%)  }
      .         
 37,495 (0.0%)  void ASN1_STRING_free(ASN1_STRING *str) {
 14,998 (0.0%)    if (str == NULL) {
  1,542 (0.0%)      return;
      .           }
 23,828 (0.0%)    OPENSSL_free(str->data);
 23,828 (0.0%)    OPENSSL_free(str);
 14,998 (0.0%)  }
      .         
      .         void ASN1_STRING_clear_free(ASN1_STRING *str) {
      .           ASN1_STRING_free(str);
      .         }
      .         
      .         int ASN1_STRING_cmp(const ASN1_STRING *a, const ASN1_STRING *b) {
      .           // Capture padding bits and implicit truncation in BIT STRINGs.
      .           int a_length = a->length, b_length = b->length;
-- line 361 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 121 ----------------------------------------
      .             B_ASN1_GRAPHICSTRING,
      .             B_ASN1_ISO64STRING,
      .             B_ASN1_GENERALSTRING,
      .             B_ASN1_UNIVERSALSTRING,
      .             B_ASN1_UNKNOWN,  // CHARACTER STRING
      .             B_ASN1_BMPSTRING,
      .         };
      .         
  9,728 (0.0%)  unsigned long ASN1_tag2bit(int tag) {
  9,728 (0.0%)    if (tag < 0 || tag > 30) {
      .             return 0;
      .           }
 12,160 (0.0%)    return tag2bit[tag];
  4,864 (0.0%)  }
      .         
      .         // Macro to initialize and invalidate the cache
      .         
      .         // Decode an ASN1 item, this currently behaves just like a standard 'd2i'
      .         // function. 'in' points to a buffer to read the data from, in future we
      .         // will have more advanced versions that can input data a piece at a time and
      .         // this will simply be a special case.
      .         
      .         ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
  1,639 (0.0%)                            const ASN1_ITEM *it) {
    149 (0.0%)    ASN1_VALUE *ptmpval = NULL;
    298 (0.0%)    if (!pval) {
    298 (0.0%)      pval = &ptmpval;
      .           }
      .         
  1,937 (0.0%)    if (asn1_item_ex_d2i(pval, in, len, it, -1, 0, 0, 0) > 0) {
    447 (0.0%)      return *pval;
      .           }
      .           return NULL;
    745 (0.0%)  }
      .         
      .         // Decode an item, taking care of IMPLICIT tagging, if any. If 'opt' set and
      .         // tag mismatch return -1 to handle OPTIONAL
      .         
      .         static int asn1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in,
      .                                     long len, const ASN1_ITEM *it, int tag, int aclass,
148,995 (0.0%)                              char opt, int depth) {
  9,933 (0.0%)    const ASN1_TEMPLATE *tt, *errtt = NULL;
      .           const ASN1_EXTERN_FUNCS *ef;
  9,933 (0.0%)    const unsigned char *p = NULL, *q;
      .           unsigned char oclass;
      .           char cst, isopt;
      .           int i;
      .           int otag;
  9,933 (0.0%)    int ret = 0;
      .           ASN1_VALUE **pchptr;
 29,799 (0.0%)    int combine = aclass & ASN1_TFLG_COMBINE;
  9,933 (0.0%)    aclass &= ~ASN1_TFLG_COMBINE;
 39,732 (0.0%)    if (pval == NULL || it == NULL) {
      .             return 0;
      .           }
      .         
      .           // Bound |len| to comfortably fit in an int. Lengths in this module often
      .           // switch between int and long without overflow checks.
 29,799 (0.0%)    if (len > INT_MAX / 2) {
      .             len = INT_MAX / 2;
      .           }
      .         
 29,799 (0.0%)    if (++depth > ASN1_MAX_CONSTRUCTED_NEST) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_TOO_DEEP);
      .             goto err;
      .           }
      .         
129,129 (0.0%)    switch (it->itype) {
      .             case ASN1_ITYPE_PRIMITIVE:
 22,632 (0.0%)        if (it->templates) {
      .                 // tagging or OPTIONAL is currently illegal on an item template
      .                 // because the flags can't get passed down. In practice this
      .                 // isn't a problem: we include the relevant flags from the item
      .                 // template in the template itself.
  5,460 (0.0%)          if ((tag != -1) || opt) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
      .                   goto err;
      .                 }
 16,380 (0.0%)          return asn1_template_ex_d2i(pval, in, len, it->templates, opt, depth);
      .               }
 55,809 (0.0%)        return asn1_d2i_ex_primitive(pval, in, len, it, tag, aclass, opt);
      .               break;
      .         
      .             case ASN1_ITYPE_MSTRING:
      .               // It never makes sense for multi-strings to have implicit tagging, so
      .               // if tag != -1, then this looks like an error in the template.
  2,728 (0.0%)        if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 goto err;
      .               }
      .         
  4,092 (0.0%)        p = *in;
      .               // Just read in tag and class
 21,824 (0.0%)        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, &p, len, -1, 0, 1);
  2,728 (0.0%)        if (!ret) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
      .         
      .               // Must be UNIVERSAL class
  4,092 (0.0%)        if (oclass != V_ASN1_UNIVERSAL) {
      .                 // If OPTIONAL, assume this is OK
      .                 if (opt) {
      .                   return -1;
      .                 }
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_MSTRING_NOT_UNIVERSAL);
      .                 goto err;
      .               }
      .               // Check tag matches bit map
 13,640 (0.0%)        if (!(ASN1_tag2bit(otag) & it->utype)) {
      .                 // If OPTIONAL, assume this is OK
      .                 if (opt) {
      .                   return -1;
      .                 }
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_MSTRING_WRONG_TAG);
      .                 goto err;
      .               }
 17,732 (0.0%)        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0);
      .         
      .             case ASN1_ITYPE_EXTERN:
      .               // Use new style d2i
    888 (0.0%)        ef = it->funcs;
  4,440 (0.0%)        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, NULL);
      .         
      .             case ASN1_ITYPE_CHOICE: {
      .               // It never makes sense for CHOICE types to have implicit tagging, so if
      .               // tag != -1, then this looks like an error in the template.
      2 (0.0%)        if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 goto err;
      .               }
      .         
      3 (0.0%)        const ASN1_AUX *aux = it->funcs;
      4 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
      2 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL)) {
      .                 goto auxerr;
      .               }
      .         
      4 (0.0%)        if (*pval) {
      .                 // Free up and zero CHOICE value if initialised
      .                 i = asn1_get_choice_selector(pval, it);
      .                 if ((i >= 0) && (i < it->tcount)) {
      .                   tt = it->templates + i;
      .                   pchptr = asn1_get_field_ptr(pval, tt);
      .                   ASN1_template_free(pchptr, tt);
      .                   asn1_set_choice_selector(pval, -1, it);
      .                 }
      7 (0.0%)        } else if (!ASN1_item_ex_new(pval, it)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
      .               // CHOICE type, try each possibility in turn
      3 (0.0%)        p = *in;
     27 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
     18 (0.0%)          pchptr = asn1_get_field_ptr(pval, tt);
      .                 // We mark field as OPTIONAL so its absence can be recognised.
     30 (0.0%)          ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, depth);
      .                 // If field not present, try the next one
      6 (0.0%)          if (ret == -1) {
      2 (0.0%)            continue;
      .                 }
      .                 // If positive return, read OK, break loop
      2 (0.0%)          if (ret > 0) {
      1 (0.0%)            break;
      .                 }
      .                 // Otherwise must be an ASN1 parsing error
      .                 errtt = tt;
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
      .         
      .               // Did we fall off the end without reading anything?
      6 (0.0%)        if (i == it->tcount) {
      .                 // If OPTIONAL, this is OK
      .                 if (opt) {
      .                   // Free and zero it
      .                   ASN1_item_ex_free(pval, it);
      .                   return -1;
      .                 }
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NO_MATCHING_CHOICE_TYPE);
      .                 goto err;
      .               }
      .         
      6 (0.0%)        asn1_set_choice_selector(pval, i, it);
      2 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL)) {
      .                 goto auxerr;
      .               }
      3 (0.0%)        *in = p;
      2 (0.0%)        return 1;
      .             }
      .         
      .             case ASN1_ITYPE_SEQUENCE: {
  7,842 (0.0%)        p = *in;
      .         
      .               // If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL
  5,228 (0.0%)        if (tag == -1) {
  2,613 (0.0%)          tag = V_ASN1_SEQUENCE;
  2,613 (0.0%)          aclass = V_ASN1_UNIVERSAL;
      .               }
      .               // Get SEQUENCE length and update len, p
 52,280 (0.0%)        ret = asn1_check_tlen(&len, NULL, NULL, &cst, &p, len, tag, aclass, opt);
  5,228 (0.0%)        if (!ret) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
  5,228 (0.0%)        } else if (ret == -1) {
      2 (0.0%)          return -1;
      .               }
  7,839 (0.0%)        if (!cst) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
      .                 goto err;
      .               }
      .         
 22,527 (0.0%)        if (!*pval && !ASN1_item_ex_new(pval, it)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
      .         
  7,839 (0.0%)        const ASN1_AUX *aux = it->funcs;
 11,340 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
  7,890 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL)) {
      .                 goto auxerr;
      .               }
      .         
      .               // Free up and zero any ADB found
 85,279 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
 35,335 (0.0%)          if (tt->flags & ASN1_TFLG_ADB_MASK) {
      .                   const ASN1_TEMPLATE *seqtt;
      .                   ASN1_VALUE **pseqval;
      .                   seqtt = asn1_do_adb(pval, tt, 0);
      .                   if (seqtt == NULL) {
      .                     continue;
      .                   }
      .                   pseqval = asn1_get_field_ptr(pval, seqtt);
      .                   ASN1_template_free(pseqval, seqtt);
      .                 }
      .               }
      .         
      .               // Get each field entry
 87,172 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
      .                 const ASN1_TEMPLATE *seqtt;
      .                 ASN1_VALUE **pseqval;
 49,469 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
 14,134 (0.0%)          if (seqtt == NULL) {
      .                   goto err;
      .                 }
 42,402 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
      .                 // Have we ran out of data?
 21,201 (0.0%)          if (!len) {
     80 (0.0%)            break;
      .                 }
 13,974 (0.0%)          q = p;
      .                 // This determines the OPTIONAL flag value. The field cannot be
      .                 // omitted if it is the last of a SEQUENCE and there is still
      .                 // data to be read. This isn't strictly necessary but it
      .                 // increases efficiency in some cases.
 48,909 (0.0%)          if (i == (it->tcount - 1)) {
  5,066 (0.0%)            isopt = 0;
      .                 } else {
 26,724 (0.0%)            isopt = (seqtt->flags & ASN1_TFLG_OPTIONAL) != 0;
      .                 }
      .                 // attempt to read in field, allowing each to be OPTIONAL
      .         
 76,857 (0.0%)          ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, depth);
 13,974 (0.0%)          if (!ret) {
      .                   errtt = seqtt;
      .                   goto err;
 13,974 (0.0%)          } else if (ret == -1) {
      .                   // OPTIONAL component absent. Free and zero the field.
  2,635 (0.0%)            ASN1_template_free(pseqval, seqtt);
    527 (0.0%)            continue;
      .                 }
      .                 // Update length
 32,300 (0.0%)          len -= p - q;
      .               }
      .         
      .               // Check all data read
  7,839 (0.0%)        if (len) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
      .                 goto err;
      .               }
      .         
      .               // If we get here we've got no more data in the SEQUENCE, however we
      .               // may not have read all fields so check all remaining are OPTIONAL
      .               // and clear any that are.
 16,318 (0.0%)        for (; i < it->tcount; tt++, i++) {
      .                 const ASN1_TEMPLATE *seqtt;
    560 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
    160 (0.0%)          if (seqtt == NULL) {
      .                   goto err;
      .                 }
    400 (0.0%)          if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
      .                   ASN1_VALUE **pseqval;
    480 (0.0%)            pseqval = asn1_get_field_ptr(pval, seqtt);
    480 (0.0%)            ASN1_template_free(pseqval, seqtt);
      .                 } else {
      .                   errtt = seqtt;
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_FIELD_MISSING);
      .                   goto err;
      .                 }
      .               }
      .               // Save encoding
 39,195 (0.0%)        if (!asn1_enc_save(pval, *in, p - *in, it)) {
      .                 goto auxerr;
      .               }
  7,890 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL)) {
      .                 goto auxerr;
      .               }
  7,839 (0.0%)        *in = p;
  5,226 (0.0%)        return 1;
      .             }
      .         
      .             default:
      .               return 0;
      .           }
      .         auxerr:
      .           OPENSSL_PUT_ERROR(ASN1, ASN1_R_AUX_ERROR);
      .         err:
-- line 437 ----------------------------------------
-- line 439 ----------------------------------------
      .             ASN1_item_ex_free(pval, it);
      .           }
      .           if (errtt) {
      .             ERR_add_error_data(4, "Field=", errtt->field_name, ", Type=", it->sname);
      .           } else {
      .             ERR_add_error_data(2, "Type=", it->sname);
      .           }
      .           return 0;
 49,665 (0.0%)  }
      .         
      .         int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
      .                              const ASN1_ITEM *it, int tag, int aclass, char opt,
  3,552 (0.0%)                       ASN1_TLC *ctx) {
  3,552 (0.0%)    return asn1_item_ex_d2i(pval, in, len, it, tag, aclass, opt, 0);
    592 (0.0%)  }
      .         
      .         // Templates are handled with two separate functions. One handles any
      .         // EXPLICIT tag and the other handles the rest.
      .         
      .         static int asn1_template_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                         long inlen, const ASN1_TEMPLATE *tt, char opt,
116,970 (0.0%)                                  int depth) {
      .           int aclass;
      .           int ret;
      .           long len;
      .           const unsigned char *p, *q;
 16,710 (0.0%)    if (!val) {
      .             return 0;
      .           }
 25,065 (0.0%)    uint32_t flags = tt->flags;
 25,065 (0.0%)    aclass = flags & ASN1_TFLG_TAG_CLASS;
      .         
 25,065 (0.0%)    p = *in;
      .         
      .           // Check if EXPLICIT tag expected
 33,420 (0.0%)    if (flags & ASN1_TFLG_EXPTAG) {
      .             char cst;
      .             // Need to work out amount of data available to the inner content and
      .             // where it starts: so read in EXPLICIT header to get the info.
  6,216 (0.0%)      ret = asn1_check_tlen(&len, NULL, NULL, &cst, &p, inlen, tt->tag, aclass,
      .                                   opt);
    592 (0.0%)      q = p;
    592 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
    592 (0.0%)      } else if (ret == -1) {
      .               return -1;
      .             }
    888 (0.0%)      if (!cst) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);
      .               return 0;
      .             }
      .             // We've found the field so it can't be OPTIONAL now
  2,960 (0.0%)      ret = asn1_template_noexp_d2i(val, &p, len, tt, 0, depth);
    592 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
      .             }
      .             // We read the field in OK so update length
  1,480 (0.0%)      len -= p - q;
      .             // Check for trailing data.
    888 (0.0%)      if (len) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_EXPLICIT_LENGTH_MISMATCH);
      .               goto err;
      .             }
      .           } else {
 88,649 (0.0%)      return asn1_template_noexp_d2i(val, in, inlen, tt, opt, depth);
      .           }
      .         
    888 (0.0%)    *in = p;
    296 (0.0%)    return 1;
      .         
      .         err:
      .           ASN1_template_free(val, tt);
      .           return 0;
 41,775 (0.0%)  }
      .         
      .         static int asn1_template_noexp_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                            long len, const ASN1_TEMPLATE *tt, char opt,
116,970 (0.0%)                                     int depth) {
      .           int aclass;
      .           int ret;
      .           const unsigned char *p;
 16,710 (0.0%)    if (!val) {
      .             return 0;
      .           }
 25,065 (0.0%)    uint32_t flags = tt->flags;
 25,065 (0.0%)    aclass = flags & ASN1_TFLG_TAG_CLASS;
      .         
 25,065 (0.0%)    p = *in;
      .         
 33,420 (0.0%)    if (flags & ASN1_TFLG_SK_MASK) {
      .             // SET OF, SEQUENCE OF
      .             int sktag, skaclass;
      .             // First work out expected inner tag value
  6,052 (0.0%)      if (flags & ASN1_TFLG_IMPTAG) {
      .               sktag = tt->tag;
      .               skaclass = aclass;
      .             } else {
  1,513 (0.0%)        skaclass = V_ASN1_UNIVERSAL;
  6,052 (0.0%)        if (flags & ASN1_TFLG_SET_OF) {
  2,136 (0.0%)          sktag = V_ASN1_SET;
      .               } else {
    445 (0.0%)          sktag = V_ASN1_SEQUENCE;
      .               }
      .             }
      .             // Get the tag
      .             ret =
 28,747 (0.0%)          asn1_check_tlen(&len, NULL, NULL, NULL, &p, len, sktag, skaclass, opt);
  3,026 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
  3,026 (0.0%)      } else if (ret == -1) {
      .               return -1;
      .             }
  6,052 (0.0%)      if (!*val) {
  6,052 (0.0%)        *val = (ASN1_VALUE *)sk_ASN1_VALUE_new_null();
      .             } else {
      .               // We've got a valid STACK: free up any items present
      .               STACK_OF(ASN1_VALUE) *sktmp = (STACK_OF(ASN1_VALUE) *)*val;
      .               ASN1_VALUE *vtmp;
      .               while (sk_ASN1_VALUE_num(sktmp) > 0) {
      .                 vtmp = sk_ASN1_VALUE_pop(sktmp);
      .                 ASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item));
      .               }
      .             }
      .         
  6,052 (0.0%)      if (!*val) {
      .               goto err;
      .             }
      .         
      .             // Read as many items as we can
 15,503 (0.0%)      while (len > 0) {
      .               ASN1_VALUE *skfield;
  5,292 (0.0%)        const unsigned char *q = p;
  2,646 (0.0%)        skfield = NULL;
 39,690 (0.0%)        if (!asn1_item_ex_d2i(&skfield, &p, len, ASN1_ITEM_ptr(tt->item), -1, 0,
      .                                     0, depth)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
 13,230 (0.0%)        len -= p - q;
 21,168 (0.0%)        if (!sk_ASN1_VALUE_push((STACK_OF(ASN1_VALUE) *)*val, skfield)) {
      .                 ASN1_item_ex_free(&skfield, ASN1_ITEM_ptr(tt->item));
      .                 goto err;
      .               }
      .             }
 27,368 (0.0%)    } else if (flags & ASN1_TFLG_IMPTAG) {
      .             // IMPLICIT tagging
  5,083 (0.0%)      ret = asn1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), tt->tag,
      .                                    aclass, opt, depth);
    598 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               goto err;
    598 (0.0%)      } else if (ret == -1) {
    596 (0.0%)        return -1;
      .             }
      .           } else {
      .             // Nothing special
104,688 (0.0%)      ret = asn1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), -1,
 13,086 (0.0%)                             tt->flags & ASN1_TFLG_COMBINE, opt, depth);
 13,086 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               goto err;
 13,086 (0.0%)      } else if (ret == -1) {
    462 (0.0%)        return -1;
      .             }
      .           }
      .         
 23,478 (0.0%)    *in = p;
 15,652 (0.0%)    return 1;
      .         
      .         err:
      .           ASN1_template_free(val, tt);
      .           return 0;
 41,775 (0.0%)  }
      .         
      .         static int asn1_d2i_ex_primitive(ASN1_VALUE **pval, const unsigned char **in,
      .                                          long inlen, const ASN1_ITEM *it, int tag,
 84,855 (0.0%)                                   int aclass, char opt) {
  5,657 (0.0%)    int ret = 0, utype;
      .           long plen;
      .           char cst;
      .           const unsigned char *p;
  5,657 (0.0%)    const unsigned char *cont = NULL;
      .           long len;
 11,314 (0.0%)    if (!pval) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_NULL);
      .             return 0;  // Should never happen
      .           }
      .         
 22,628 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
  2,728 (0.0%)      utype = tag;
  2,728 (0.0%)      tag = -1;
      .           } else {
 12,879 (0.0%)      utype = it->utype;
      .           }
      .         
 16,971 (0.0%)    if (utype == V_ASN1_ANY) {
      .             // If type is ANY need to figure out type from tag
      .             unsigned char oclass;
    728 (0.0%)      if (tag >= 0) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_TAGGED_ANY);
      .               return 0;
      .             }
    728 (0.0%)      if (opt) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OPTIONAL_ANY);
      .               return 0;
      .             }
  1,092 (0.0%)      p = *in;
  5,824 (0.0%)      ret = asn1_check_tlen(NULL, &utype, &oclass, NULL, &p, inlen, -1, 0, 0);
    728 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
      .             }
  1,092 (0.0%)      if (oclass != V_ASN1_UNIVERSAL) {
      .               utype = V_ASN1_OTHER;
      .             }
      .           }
 11,314 (0.0%)    if (tag == -1) {
 10,718 (0.0%)      tag = utype;
  5,359 (0.0%)      aclass = V_ASN1_UNIVERSAL;
      .           }
 16,971 (0.0%)    p = *in;
      .           // Check header
113,140 (0.0%)    ret = asn1_check_tlen(&plen, NULL, NULL, &cst, &p, inlen, tag, aclass, opt);
 11,314 (0.0%)    if (!ret) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .             return 0;
 11,314 (0.0%)    } else if (ret == -1) {
  1,056 (0.0%)      return -1;
      .           }
  5,129 (0.0%)    ret = 0;
      .           // SEQUENCE, SET and "OTHER" are left in encoded form
 41,032 (0.0%)    if ((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||
  5,129 (0.0%)        (utype == V_ASN1_OTHER)) {
      .             // SEQUENCE and SET must be constructed
      .             if (utype != V_ASN1_OTHER && !cst) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_TYPE_NOT_CONSTRUCTED);
      .               return 0;
      .             }
      .         
      .             cont = *in;
      .             len = p - cont + plen;
      .             p += plen;
 15,387 (0.0%)    } else if (cst) {
      .             // This parser historically supported BER constructed strings. We no
      .             // longer do and will gradually tighten this parser into a DER
      .             // parser. BER types should use |CBS_asn1_ber_to_der|.
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_TYPE_NOT_PRIMITIVE);
      .             return 0;
      .           } else {
 10,258 (0.0%)      cont = p;
 10,258 (0.0%)      len = plen;
 20,516 (0.0%)      p += plen;
      .           }
      .         
      .           // We now have content length and type: translate into a structure
 51,290 (0.0%)    if (!asn1_ex_c2i(pval, cont, len, utype, it)) {
      .             goto err;
      .           }
      .         
 15,387 (0.0%)    *in = p;
 10,258 (0.0%)    ret = 1;
      .         err:
  5,129 (0.0%)    return ret;
 28,285 (0.0%)  }
      .         
      .         // Translate ASN1 content octets into a structure
      .         
      .         static int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, long len,
 61,548 (0.0%)                         int utype, const ASN1_ITEM *it) {
  5,129 (0.0%)    ASN1_VALUE **opval = NULL;
      .           ASN1_STRING *stmp;
  5,129 (0.0%)    ASN1_TYPE *typ = NULL;
  5,129 (0.0%)    int ret = 0;
      .           ASN1_INTEGER **tint;
      .         
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of callbacks.
 20,516 (0.0%)    assert(it->funcs == NULL);
      .         
      .           // If ANY type clear type and set pointer to internal value
 20,516 (0.0%)    if (it->utype == V_ASN1_ANY) {
  1,456 (0.0%)      if (!*pval) {
    728 (0.0%)        typ = ASN1_TYPE_new();
    728 (0.0%)        if (typ == NULL) {
      .                 goto err;
      .               }
  1,456 (0.0%)        *pval = (ASN1_VALUE *)typ;
      .             } else {
      .               typ = (ASN1_TYPE *)*pval;
      .             }
      .         
  1,456 (0.0%)      if (utype != typ->type) {
  2,184 (0.0%)        ASN1_TYPE_set(typ, utype, NULL);
      .             }
    728 (0.0%)      opval = pval;
  1,092 (0.0%)      pval = &typ->value.asn1_value;
      .           }
 40,370 (0.0%)    switch (utype) {
      .             case V_ASN1_OBJECT:
 16,488 (0.0%)        if (!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, &cont, len)) {
      .                 goto err;
      .               }
  4,122 (0.0%)        break;
      .         
      .             case V_ASN1_NULL:
    648 (0.0%)        if (len) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NULL_IS_WRONG_LENGTH);
      .                 goto err;
      .               }
    648 (0.0%)        *pval = (ASN1_VALUE *)1;
    324 (0.0%)        break;
      .         
      .             case V_ASN1_BOOLEAN:
    556 (0.0%)        if (len != 1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BOOLEAN_IS_WRONG_LENGTH);
      .                 goto err;
      .               } else {
      .                 ASN1_BOOLEAN *tbool;
    556 (0.0%)          tbool = (ASN1_BOOLEAN *)pval;
  1,390 (0.0%)          *tbool = *cont;
      .               }
    278 (0.0%)        break;
      .         
      .             case V_ASN1_BIT_STRING:
  2,368 (0.0%)        if (!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, &cont, len)) {
      .                 goto err;
      .               }
    592 (0.0%)        break;
      .         
      .             case V_ASN1_INTEGER:
      .             case V_ASN1_ENUMERATED:
    592 (0.0%)        tint = (ASN1_INTEGER **)pval;
  2,368 (0.0%)        if (!c2i_ASN1_INTEGER(tint, &cont, len)) {
      .                 goto err;
      .               }
      .               // Fixup type to match the expected form
  2,664 (0.0%)        (*tint)->type = utype | ((*tint)->type & V_ASN1_NEG);
    296 (0.0%)        break;
      .         
      .             case V_ASN1_OCTET_STRING:
      .             case V_ASN1_NUMERICSTRING:
      .             case V_ASN1_PRINTABLESTRING:
      .             case V_ASN1_T61STRING:
      .             case V_ASN1_VIDEOTEXSTRING:
      .             case V_ASN1_IA5STRING:
      .             case V_ASN1_UTCTIME:
-- line 787 ----------------------------------------
-- line 791 ----------------------------------------
      .             case V_ASN1_GENERALSTRING:
      .             case V_ASN1_UNIVERSALSTRING:
      .             case V_ASN1_BMPSTRING:
      .             case V_ASN1_UTF8STRING:
      .             case V_ASN1_OTHER:
      .             case V_ASN1_SET:
      .             case V_ASN1_SEQUENCE:
      .             default:
  3,748 (0.0%)        if (utype == V_ASN1_BMPSTRING && (len & 1)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
      .                 goto err;
      .               }
  3,748 (0.0%)        if (utype == V_ASN1_UNIVERSALSTRING && (len & 3)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
      .                 goto err;
      .               }
  3,748 (0.0%)        if (utype == V_ASN1_UTCTIME) {
      .                 CBS cbs;
  1,752 (0.0%)          CBS_init(&cbs, cont, (size_t)len);
  2,044 (0.0%)          if (!CBS_parse_utc_time(&cbs, NULL, /*allow_timezone_offset=*/1)) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_TIME_FORMAT);
      .                   goto err;
      .                 }
      .               }
  3,748 (0.0%)        if (utype == V_ASN1_GENERALIZEDTIME) {
      .                 CBS cbs;
     24 (0.0%)          CBS_init(&cbs, cont, (size_t)len);
     28 (0.0%)          if (!CBS_parse_generalized_time(&cbs, NULL,
      .                                                 /*allow_timezone_offset=*/0)) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_TIME_FORMAT);
      .                   goto err;
      .                 }
      .               }
      .               // All based on ASN1_STRING and handled the same
  7,496 (0.0%)        if (!*pval) {
      4 (0.0%)          stmp = ASN1_STRING_type_new(utype);
      2 (0.0%)          if (!stmp) {
      .                   goto err;
      .                 }
      4 (0.0%)          *pval = (ASN1_VALUE *)stmp;
      .               } else {
  5,619 (0.0%)          stmp = (ASN1_STRING *)*pval;
  5,619 (0.0%)          stmp->type = utype;
      .               }
 14,992 (0.0%)        if (!ASN1_STRING_set(stmp, cont, len)) {
      .                 ASN1_STRING_free(stmp);
      .                 *pval = NULL;
      .                 goto err;
      .               }
  1,874 (0.0%)        break;
      .           }
      .           // If ASN1_ANY and NULL type fix up value
 10,986 (0.0%)    if (typ && (utype == V_ASN1_NULL)) {
    648 (0.0%)      typ->value.ptr = NULL;
      .           }
      .         
 10,258 (0.0%)    ret = 1;
      .         err:
 10,258 (0.0%)    if (!ret) {
      .             ASN1_TYPE_free(typ);
      .             if (opval) {
      .               *opval = NULL;
      .             }
      .           }
  5,129 (0.0%)    return ret;
 25,645 (0.0%)  }
      .         
      .         // Check an ASN1 tag and length: a bit like ASN1_get_object but it
      .         // checks the expected tag.
      .         
      .         static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,
      .                                    char *cst, const unsigned char **in, long len,
177,120 (0.1%)                             int exptag, int expclass, char opt) {
      .           int i;
      .           int ptag, pclass;
      .           long plen;
      .           const unsigned char *p;
 35,424 (0.0%)    p = *in;
      .         
106,272 (0.0%)    i = ASN1_get_object(&p, &plen, &ptag, &pclass, len);
 47,232 (0.0%)    if (i & 0x80) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_OBJECT_HEADER);
      .             return 0;
      .           }
 23,616 (0.0%)    if (exptag >= 0) {
 58,893 (0.0%)      if ((exptag != ptag) || (expclass != pclass)) {
      .               // If type is OPTIONAL, not an error: indicate missing type.
  1,058 (0.0%)        if (opt) {
  1,058 (0.0%)          return -1;
      .               }
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TAG);
      .               return 0;
      .             }
      .           }
      .         
 22,558 (0.0%)    if (cst) {
 40,190 (0.0%)      *cst = i & V_ASN1_CONSTRUCTED;
      .           }
      .         
 22,558 (0.0%)    if (olen) {
 28,653 (0.0%)      *olen = plen;
      .           }
      .         
 22,558 (0.0%)    if (oclass) {
  6,912 (0.0%)      *oclass = pclass;
      .           }
      .         
 22,558 (0.0%)    if (otag) {
  5,184 (0.0%)      *otag = ptag;
      .           }
      .         
 33,837 (0.0%)    *in = p;
 11,279 (0.0%)    return 1;
 59,040 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 78 ----------------------------------------
      .         static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
      .                                     int skcontlen, const ASN1_ITEM *item, int do_sort);
      .         static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
      .                                         const ASN1_TEMPLATE *tt, int tag, int aclass,
      .                                         int optional);
      .         
      .         // Top level i2d equivalents
      .         
  1,480 (0.0%)  int ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it) {
    888 (0.0%)    if (out && !*out) {
      .             unsigned char *p, *buf;
  1,184 (0.0%)      int len = ASN1_item_ex_i2d(&val, NULL, it, /*tag=*/-1, /*aclass=*/0);
    296 (0.0%)      if (len <= 0) {
      .               return len;
      .             }
    740 (0.0%)      buf = OPENSSL_malloc(len);
    296 (0.0%)      if (!buf) {
      .               return -1;
      .             }
    296 (0.0%)      p = buf;
  1,184 (0.0%)      int len2 = ASN1_item_ex_i2d(&val, &p, it, /*tag=*/-1, /*aclass=*/0);
    296 (0.0%)      if (len2 <= 0) {
      .               OPENSSL_free(buf);
      .               return len2;
      .             }
    444 (0.0%)      assert(len == len2);
    444 (0.0%)      *out = buf;
    296 (0.0%)      return len;
      .           }
      .         
      .           return ASN1_item_ex_i2d(&val, out, it, /*tag=*/-1, /*aclass=*/0);
    740 (0.0%)  }
      .         
      .         // Encode an item, taking care of IMPLICIT tagging (if any). This function
      .         // performs the normal item handling: it can be used in external types.
      .         
      .         int ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
 50,724 (0.0%)                       const ASN1_ITEM *it, int tag, int aclass) {
 56,360 (0.0%)    int ret = asn1_item_ex_i2d_opt(pval, out, it, tag, aclass, /*optional=*/0);
 11,272 (0.0%)    assert(ret != 0);
  5,636 (0.0%)    return ret;
 11,272 (0.0%)  }
      .         
      .         // asn1_item_ex_i2d_opt behaves like |ASN1_item_ex_i2d| but, if |optional| is
      .         // non-zero and |*pval| is omitted, it returns zero and writes no bytes.
      .         int asn1_item_ex_i2d_opt(ASN1_VALUE **pval, unsigned char **out,
      .                                  const ASN1_ITEM *it, int tag, int aclass,
211,276 (0.1%)                           int optional) {
 16,252 (0.0%)    const ASN1_TEMPLATE *tt = NULL;
      .           int i, seqcontlen, seqlen;
      .         
      .           // Historically, |aclass| was repurposed to pass additional flags into the
      .           // encoding process.
 65,008 (0.0%)    assert((aclass & ASN1_TFLG_TAG_CLASS) == aclass);
      .           // If not overridding the tag, |aclass| is ignored and should be zero.
 65,008 (0.0%)    assert(tag != -1 || aclass == 0);
      .         
      .           // All fields are pointers, except for boolean |ASN1_ITYPE_PRIMITIVE|s.
      .           // Optional primitives are handled later.
 97,872 (0.0%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) {
      .             if (optional) {
      .               return 0;
      .             }
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
      .             return -1;
      .           }
      .         
211,276 (0.1%)    switch (it->itype) {
      .             case ASN1_ITYPE_PRIMITIVE:
 32,144 (0.0%)        if (it->templates) {
      .                 // This is an |ASN1_ITEM_TEMPLATE|.
 12,816 (0.0%)          if (it->templates->flags & ASN1_TFLG_OPTIONAL) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                   return -1;
      .                 }
 25,632 (0.0%)          return asn1_template_ex_i2d(pval, out, it->templates, tag, aclass,
      .                                             optional);
      .               }
 64,900 (0.0%)        return asn1_i2d_ex_primitive(pval, out, it, tag, aclass, optional);
      .         
      .             case ASN1_ITYPE_MSTRING:
      .               // It never makes sense for multi-strings to have implicit tagging, so
      .               // if tag != -1, then this looks like an error in the template.
  8,544 (0.0%)        if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 return -1;
      .               }
 42,720 (0.0%)        return asn1_i2d_ex_primitive(pval, out, it, -1, 0, optional);
      .         
      .             case ASN1_ITYPE_CHOICE: {
      .               // It never makes sense for CHOICE types to have implicit tagging, so if
      .               // tag != -1, then this looks like an error in the template.
      .               if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 return -1;
      .               }
-- line 173 ----------------------------------------
-- line 195 ----------------------------------------
      .                 // must be pointers.
      .                 OPENSSL_PUT_ERROR(ASN1, ERR_R_INTERNAL_ERROR);
      .                 return -1;
      .               }
      .               return ret;
      .             }
      .         
      .             case ASN1_ITYPE_SEQUENCE: {
 27,608 (0.0%)        i = asn1_enc_restore(&seqcontlen, out, pval, it);
      .               // An error occurred
  7,888 (0.0%)        if (i < 0) {
      .                 return -1;
      .               }
      .               // We have a valid cached encoding...
  7,888 (0.0%)        if (i > 0) {
      .                 return seqcontlen;
      .               }
      .               // Otherwise carry on
  3,944 (0.0%)        seqcontlen = 0;
      .               // If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL
  7,888 (0.0%)        if (tag == -1) {
  3,944 (0.0%)          tag = V_ASN1_SEQUENCE;
  3,944 (0.0%)          aclass = V_ASN1_UNIVERSAL;
      .               }
      .               // First work out sequence content length
106,488 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
      .                 const ASN1_TEMPLATE *seqtt;
      .                 ASN1_VALUE **pseqval;
      .                 int tmplen;
 55,216 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
 15,776 (0.0%)          if (!seqtt) {
      .                   return -1;
      .                 }
 47,328 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
      .                 tmplen =
 70,992 (0.0%)              asn1_template_ex_i2d(pseqval, NULL, seqtt, -1, 0, /*optional=*/0);
 55,216 (0.0%)          if (tmplen == -1 || (tmplen > INT_MAX - seqcontlen)) {
      .                   return -1;
      .                 }
 31,552 (0.0%)          seqcontlen += tmplen;
      .               }
      .         
 23,664 (0.0%)        seqlen = ASN1_object_size(/*constructed=*/1, seqcontlen, tag);
 10,616 (0.0%)        if (!out || seqlen == -1) {
  5,160 (0.0%)          return seqlen;
      .               }
      .               // Output SEQUENCE header
 10,912 (0.0%)        ASN1_put_object(out, /*constructed=*/1, seqcontlen, tag, aclass);
 36,828 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
      .                 const ASN1_TEMPLATE *seqtt;
      .                 ASN1_VALUE **pseqval;
 19,096 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
  5,456 (0.0%)          if (!seqtt) {
      .                   return -1;
      .                 }
 16,368 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
 27,280 (0.0%)          if (asn1_template_ex_i2d(pseqval, out, seqtt, -1, 0, /*optional=*/0) <
      .                     0) {
      .                   return -1;
      .                 }
      .               }
  2,728 (0.0%)        return seqlen;
      .             }
      .         
      .             default:
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .               return -1;
      .           }
 81,260 (0.0%)  }
      .         
      .         // asn1_template_ex_i2d behaves like |asn1_item_ex_i2d_opt| but uses an
      .         // |ASN1_TEMPLATE| instead of an |ASN1_ITEM|. An |ASN1_TEMPLATE| wraps an
      .         // |ASN1_ITEM| with modifiers such as tagging, SEQUENCE or SET, etc.
      .         static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
      .                                         const ASN1_TEMPLATE *tt, int tag, int iclass,
165,776 (0.1%)                                  int optional) {
      .           int i, ret, ttag, tclass;
      .           size_t j;
 38,256 (0.0%)    uint32_t flags = tt->flags;
      .         
      .           // Historically, |iclass| was repurposed to pass additional flags into the
      .           // encoding process.
 51,008 (0.0%)    assert((iclass & ASN1_TFLG_TAG_CLASS) == iclass);
      .           // If not overridding the tag, |iclass| is ignored and should be zero.
 51,008 (0.0%)    assert(tag != -1 || iclass == 0);
      .         
      .           // Work out tag and class to use: tagging may come either from the
      .           // template or the arguments, not both because this would create
      .           // ambiguity.
 51,008 (0.0%)    if (flags & ASN1_TFLG_TAG_MASK) {
      .             // Error if argument and template tagging
      .             if (tag != -1) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .               return -1;
      .             }
      .             // Get tagging from template
      .             ttag = tt->tag;
      .             tclass = flags & ASN1_TFLG_TAG_CLASS;
 25,504 (0.0%)    } else if (tag != -1) {
      .             // No template tagging, get from arguments
      .             ttag = tag;
      .             tclass = iclass & ASN1_TFLG_TAG_CLASS;
      .           } else {
 12,752 (0.0%)      ttag = -1;
 12,752 (0.0%)      tclass = 0;
      .           }
      .         
      .           // The template may itself by marked as optional, or this may be the template
      .           // of an |ASN1_ITEM_TEMPLATE| type which was contained inside an outer
      .           // optional template. (They cannot both be true because the
      .           // |ASN1_ITEM_TEMPLATE| codepath rejects optional templates.)
 25,504 (0.0%)    assert(!optional || (flags & ASN1_TFLG_OPTIONAL) == 0);
102,608 (0.0%)    optional = optional || (flags & ASN1_TFLG_OPTIONAL) != 0;
      .         
      .           // At this point 'ttag' contains the outer tag to use, and 'tclass' is the
      .           // class.
      .         
 51,008 (0.0%)    if (flags & ASN1_TFLG_SK_MASK) {
      .             // SET OF, SEQUENCE OF
  6,408 (0.0%)      STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;
      .             int isset, sktag, skaclass;
      .             int skcontlen, sklen;
      .             ASN1_VALUE *skitem;
      .         
  8,544 (0.0%)      if (!*pval) {
      .               if (optional) {
      .                 return 0;
      .               }
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
      .               return -1;
      .             }
      .         
  8,544 (0.0%)      if (flags & ASN1_TFLG_SET_OF) {
  2,136 (0.0%)        isset = 1;
      .               // Historically, types with both bits set were mutated when
      .               // serialized to apply the sort. We no longer support this.
  8,544 (0.0%)        assert((flags & ASN1_TFLG_SEQUENCE_OF) == 0);
      .             } else {
      .               isset = 0;
      .             }
      .         
      .             // Work out inner tag value: if EXPLICIT or no tagging use underlying
      .             // type.
  4,272 (0.0%)      if ((ttag != -1) && !(flags & ASN1_TFLG_EXPTAG)) {
      .               sktag = ttag;
      .               skaclass = tclass;
      .             } else {
  2,136 (0.0%)        skaclass = V_ASN1_UNIVERSAL;
  4,272 (0.0%)        if (isset) {
  4,272 (0.0%)          sktag = V_ASN1_SET;
      .               } else {
      .                 sktag = V_ASN1_SEQUENCE;
      .               }
      .             }
      .         
      .             // Determine total length of items
  2,136 (0.0%)      skcontlen = 0;
 27,768 (0.0%)      for (j = 0; j < sk_ASN1_VALUE_num(sk); j++) {
      .               int tmplen;
 12,816 (0.0%)        skitem = sk_ASN1_VALUE_value(sk, j);
 19,224 (0.0%)        tmplen = ASN1_item_ex_i2d(&skitem, NULL, ASN1_ITEM_ptr(tt->item), -1, 0);
 12,816 (0.0%)        if (tmplen == -1 || (skcontlen > INT_MAX - tmplen)) {
      .                 return -1;
      .               }
  4,272 (0.0%)        skcontlen += tmplen;
      .             }
 12,816 (0.0%)      sklen = ASN1_object_size(/*constructed=*/1, skcontlen, sktag);
  4,272 (0.0%)      if (sklen == -1) {
      .               return -1;
      .             }
      .             // If EXPLICIT need length of surrounding tag
  8,544 (0.0%)      if (flags & ASN1_TFLG_EXPTAG) {
      .               ret = ASN1_object_size(/*constructed=*/1, sklen, ttag);
      .             } else {
  4,272 (0.0%)        ret = sklen;
      .             }
      .         
  6,408 (0.0%)      if (!out || ret == -1) {
  2,136 (0.0%)        return ret;
      .             }
      .         
      .             // Now encode this lot...
      .             // EXPLICIT tag
  4,272 (0.0%)      if (flags & ASN1_TFLG_EXPTAG) {
      .               ASN1_put_object(out, /*constructed=*/1, sklen, ttag, tclass);
      .             }
      .             // SET or SEQUENCE and IMPLICIT tag
  8,544 (0.0%)      ASN1_put_object(out, /*constructed=*/1, skcontlen, sktag, skaclass);
      .             // And the stuff itself
 11,748 (0.0%)      if (!asn1_set_seq_out(sk, out, skcontlen, ASN1_ITEM_ptr(tt->item), isset)) {
      .               return -1;
      .             }
  2,136 (0.0%)      return ret;
      .           }
      .         
 42,464 (0.0%)    if (flags & ASN1_TFLG_EXPTAG) {
      .             // EXPLICIT tagging
      .             // Find length of tagged item
      .             i = asn1_item_ex_i2d_opt(pval, NULL, ASN1_ITEM_ptr(tt->item), -1, 0,
      .                                      optional);
      .             if (i <= 0) {
      .               return i;
      .             }
      .             // Find length of EXPLICIT tag
-- line 398 ----------------------------------------
-- line 403 ----------------------------------------
      .               if (ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item), -1, 0) < 0) {
      .                 return -1;
      .               }
      .             }
      .             return ret;
      .           }
      .         
      .           // Either normal or IMPLICIT tagging
116,776 (0.0%)    return asn1_item_ex_i2d_opt(pval, out, ASN1_ITEM_ptr(tt->item), ttag, tclass,
      .                                       optional);
 63,760 (0.0%)  }
      .         
      .         // Temporary structure used to hold DER encoding of items for SET OF
      .         
      .         typedef struct {
      .           unsigned char *data;
      .           int length;
      .         } DER_ENC;
      .         
-- line 421 ----------------------------------------
-- line 431 ----------------------------------------
      .         }
      .         
      .         // asn1_set_seq_out writes |sk| to |out| under the i2d output convention,
      .         // excluding the tag and length. It returns one on success and zero on error.
      .         // |skcontlen| must be the total encoded size. If |do_sort| is non-zero, the
      .         // elements are sorted for a SET OF type. Each element of |sk| has type
      .         // |item|.
      .         static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
 13,884 (0.0%)                              int skcontlen, const ASN1_ITEM *item, int do_sort) {
      .           // No need to sort if there are fewer than two items.
  7,476 (0.0%)    if (!do_sort || sk_ASN1_VALUE_num(sk) < 2) {
 13,884 (0.0%)      for (size_t i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
  6,408 (0.0%)        ASN1_VALUE *skitem = sk_ASN1_VALUE_value(sk, i);
  9,612 (0.0%)        if (ASN1_item_ex_i2d(&skitem, out, item, -1, 0) < 0) {
      .                 return 0;
      .               }
      .             }
  2,136 (0.0%)      return 1;
      .           }
      .         
      .           int ret = 0;
      .           unsigned char *const buf = OPENSSL_malloc(skcontlen);
      .           DER_ENC *encoded = OPENSSL_calloc(sk_ASN1_VALUE_num(sk), sizeof(*encoded));
      .           if (encoded == NULL || buf == NULL) {
      .             goto err;
      .           }
-- line 456 ----------------------------------------
-- line 478 ----------------------------------------
      .           *out = p;
      .         
      .           ret = 1;
      .         
      .         err:
      .           OPENSSL_free(encoded);
      .           OPENSSL_free(buf);
      .           return ret;
  6,408 (0.0%)  }
      .         
      .         // asn1_i2d_ex_primitive behaves like |ASN1_item_ex_i2d| but |item| must be a
      .         // a PRIMITIVE or MSTRING type that is not an |ASN1_ITEM_TEMPLATE|.
      .         static int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out,
      .                                          const ASN1_ITEM *it, int tag, int aclass,
132,236 (0.0%)                                   int optional) {
      .           // Get length of content octets and maybe find out the underlying type.
      .           int omit;
 30,516 (0.0%)    int utype = it->utype;
 91,548 (0.0%)    int len = asn1_ex_i2c(pval, NULL, &omit, &utype, it);
 20,344 (0.0%)    if (len < 0) {
      .             return -1;
      .           }
 30,516 (0.0%)    if (omit) {
      .             if (optional) {
      .               return 0;
      .             }
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
      .             return -1;
      .           }
      .         
      .           // If SEQUENCE, SET or OTHER then header is included in pseudo content
      .           // octets so don't include tag+length. We need to check here because the
      .           // call to asn1_ex_i2c() could change utype.
 10,172 (0.0%)    int usetag =
111,892 (0.0%)        utype != V_ASN1_SEQUENCE && utype != V_ASN1_SET && utype != V_ASN1_OTHER;
      .         
      .           // If not implicitly tagged get tag from underlying type
 20,344 (0.0%)    if (tag == -1) {
 20,344 (0.0%)      tag = utype;
      .           }
      .         
      .           // Output tag+length followed by content octets
 20,344 (0.0%)    if (out) {
  5,160 (0.0%)      if (usetag) {
 20,640 (0.0%)        ASN1_put_object(out, /*constructed=*/0, len, tag, aclass);
      .             }
 25,800 (0.0%)      int len2 = asn1_ex_i2c(pval, *out, &omit, &utype, it);
  5,160 (0.0%)      if (len2 < 0) {
      .               return -1;
      .             }
  7,740 (0.0%)      assert(len == len2);
  7,740 (0.0%)      assert(!omit);
 18,060 (0.0%)      *out += len;
      .           }
      .         
 20,344 (0.0%)    if (usetag) {
 61,032 (0.0%)      return ASN1_object_size(/*constructed=*/0, len, tag);
      .           }
      .           return len;
 50,860 (0.0%)  }
      .         
      .         // asn1_ex_i2c writes the |*pval| to |cout| under the i2d output convention,
      .         // excluding the tag and length. It returns the number of bytes written,
      .         // possibly zero, on success or -1 on error. If |*pval| should be omitted, it
      .         // returns zero and sets |*out_omit| to true.
      .         //
      .         // If |it| is an MSTRING or ANY type, it gets the underlying type from |*pval|,
      .         // which must be an |ASN1_STRING| or |ASN1_TYPE|, respectively. It then updates
-- line 545 ----------------------------------------
-- line 548 ----------------------------------------
      .         // |V_ASN1_OTHER|, it additionally outputs the tag and length, so the caller
      .         // must not do so.
      .         //
      .         // Otherwise, |*putype| must contain |it->utype|.
      .         //
      .         // WARNING: Unlike most functions in this file, |asn1_ex_i2c| can return zero
      .         // without omitting the element. ASN.1 values may have empty contents.
      .         static int asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cout, int *out_omit,
153,024 (0.1%)                         int *putype, const ASN1_ITEM *it) {
 12,752 (0.0%)    ASN1_BOOLEAN *tbool = NULL;
      .           ASN1_STRING *strtmp;
      .           ASN1_OBJECT *otmp;
      .           int utype;
      .           const unsigned char *cont;
      .           unsigned char c;
      .           int len;
      .         
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of callbacks.
 51,008 (0.0%)    assert(it->funcs == NULL);
      .         
 25,504 (0.0%)    *out_omit = 0;
      .         
      .           // Should type be omitted?
 80,656 (0.0%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) || (it->utype != V_ASN1_BOOLEAN)) {
 51,008 (0.0%)      if (!*pval) {
      .               *out_omit = 1;
      .               return 0;
      .             }
      .           }
      .         
 51,008 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
      .             // If MSTRING type set the underlying type
 16,020 (0.0%)      strtmp = (ASN1_STRING *)*pval;
 16,020 (0.0%)      utype = strtmp->type;
 10,680 (0.0%)      if (utype < 0 && utype != V_ASN1_OTHER) {
      .               // MSTRINGs can have type -1 when default-constructed.
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TYPE);
      .               return -1;
      .             }
      .             // Negative INTEGER and ENUMERATED values use |ASN1_STRING| type values
      .             // that do not match their corresponding utype values. INTEGERs cannot
      .             // participate in MSTRING types, but ENUMERATEDs can.
      .             //
      .             // TODO(davidben): Is this a bug? Although arguably one of the MSTRING
      .             // types should contain more values, rather than less. See
      .             // https://crbug.com/boringssl/412. But it is not possible to fit all
      .             // possible ANY values into an |ASN1_STRING|, so matching the spec here
      .             // is somewhat hopeless.
 10,680 (0.0%)      if (utype == V_ASN1_NEG_INTEGER) {
      .               utype = V_ASN1_INTEGER;
 10,680 (0.0%)      } else if (utype == V_ASN1_NEG_ENUMERATED) {
      .               utype = V_ASN1_ENUMERATED;
      .             }
 21,360 (0.0%)      *putype = utype;
 29,648 (0.0%)    } else if (it->utype == V_ASN1_ANY) {
      .             // If ANY set type and pointer to value
      .             ASN1_TYPE *typ;
  2,220 (0.0%)      typ = (ASN1_TYPE *)*pval;
  2,220 (0.0%)      utype = typ->type;
  1,480 (0.0%)      if (utype < 0 && utype != V_ASN1_OTHER) {
      .               // |ASN1_TYPE|s can have type -1 when default-constructed.
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TYPE);
      .               return -1;
      .             }
  2,220 (0.0%)      *putype = utype;
  2,960 (0.0%)      pval = &typ->value.asn1_value;
      .           } else {
 20,016 (0.0%)      utype = *putype;
      .           }
      .         
 84,800 (0.0%)    switch (utype) {
      .             case V_ASN1_OBJECT:
 18,840 (0.0%)        otmp = (ASN1_OBJECT *)*pval;
 18,840 (0.0%)        cont = otmp->data;
 18,840 (0.0%)        len = otmp->length;
 12,560 (0.0%)        if (len == 0) {
      .                 // Some |ASN1_OBJECT|s do not have OIDs and cannot be serialized.
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OBJECT);
      .                 return -1;
      .               }
  6,280 (0.0%)        break;
      .         
      .             case V_ASN1_NULL:
    540 (0.0%)        cont = NULL;
    540 (0.0%)        len = 0;
    540 (0.0%)        break;
      .         
      .             case V_ASN1_BOOLEAN:
      .               tbool = (ASN1_BOOLEAN *)pval;
      .               if (*tbool == ASN1_BOOLEAN_NONE) {
      .                 *out_omit = 1;
      .                 return 0;
      .               }
      .               if (it->utype != V_ASN1_ANY) {
-- line 642 ----------------------------------------
-- line 648 ----------------------------------------
      .               }
      .               c = *tbool ? 0xff : 0x00;
      .               cont = &c;
      .               len = 1;
      .               break;
      .         
      .             case V_ASN1_BIT_STRING: {
      .               int ret =
  6,068 (0.0%)            i2c_ASN1_BIT_STRING((ASN1_BIT_STRING *)*pval, cout ? &cout : NULL);
      .               // |i2c_ASN1_BIT_STRING| returns zero on error instead of -1.
  2,368 (0.0%)        return ret <= 0 ? -1 : ret;
      .             }
      .         
      .             case V_ASN1_INTEGER:
      .             case V_ASN1_ENUMERATED: {
      .               // |i2c_ASN1_INTEGER| also handles ENUMERATED.
      .               int ret = i2c_ASN1_INTEGER((ASN1_INTEGER *)*pval, cout ? &cout : NULL);
      .               // |i2c_ASN1_INTEGER| returns zero on error instead of -1.
      .               return ret <= 0 ? -1 : ret;
-- line 666 ----------------------------------------
-- line 679 ----------------------------------------
      .             case V_ASN1_GENERALSTRING:
      .             case V_ASN1_UNIVERSALSTRING:
      .             case V_ASN1_BMPSTRING:
      .             case V_ASN1_UTF8STRING:
      .             case V_ASN1_SEQUENCE:
      .             case V_ASN1_SET:
      .             default:
      .               // All based on ASN1_STRING and handled the same
 16,020 (0.0%)        strtmp = (ASN1_STRING *)*pval;
 16,020 (0.0%)        cont = strtmp->data;
 16,020 (0.0%)        len = strtmp->length;
      .         
  5,340 (0.0%)        break;
      .           }
 41,344 (0.0%)    if (cout && len) {
 16,268 (0.0%)      OPENSSL_memcpy(cout, cont, len);
      .           }
 12,160 (0.0%)    return len;
 63,760 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 60 ----------------------------------------
      .         
      .         #include <openssl/asn1t.h>
      .         #include <openssl/mem.h>
      .         
      .         #include "internal.h"
      .         
      .         // Free up an ASN1 structure
      .         
 31,428 (0.0%)  void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it) {
 31,428 (0.0%)    asn1_item_combine_free(&val, it, 0);
 15,714 (0.0%)  }
      .         
  6,078 (0.0%)  void ASN1_item_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
  6,078 (0.0%)    asn1_item_combine_free(pval, it, 0);
  3,039 (0.0%)  }
      .         
      .         void asn1_item_combine_free(ASN1_VALUE **pval, const ASN1_ITEM *it,
159,061 (0.1%)                              int combine) {
 22,723 (0.0%)    const ASN1_TEMPLATE *tt = NULL, *seqtt;
      .           const ASN1_EXTERN_FUNCS *ef;
      .           int i;
 90,892 (0.0%)    if (pval == NULL || it == NULL) {
      .             return;
      .           }
138,020 (0.0%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) {
  2,056 (0.0%)      return;
      .           }
      .         
282,035 (0.1%)    switch (it->itype) {
      .             case ASN1_ITYPE_PRIMITIVE:
 43,764 (0.0%)        if (it->templates) {
  3,534 (0.0%)          ASN1_template_free(pval, it->templates);
      .               } else {
 51,760 (0.0%)          ASN1_primitive_free(pval, it);
      .               }
 10,941 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_MSTRING:
 18,840 (0.0%)        ASN1_primitive_free(pval, it);
  3,768 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_CHOICE: {
      3 (0.0%)        const ASN1_AUX *aux = it->funcs;
      4 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
      2 (0.0%)        if (asn1_cb) {
      .                 i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
      .                 if (i == 2) {
      .                   return;
      .                 }
      .               }
      6 (0.0%)        i = asn1_get_choice_selector(pval, it);
      8 (0.0%)        if ((i >= 0) && (i < it->tcount)) {
      .                 ASN1_VALUE **pchval;
      7 (0.0%)          tt = it->templates + i;
      6 (0.0%)          pchval = asn1_get_field_ptr(pval, tt);
      5 (0.0%)          ASN1_template_free(pchval, tt);
      .               }
      2 (0.0%)        if (asn1_cb) {
      .                 asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);
      .               }
      2 (0.0%)        if (!combine) {
      4 (0.0%)          OPENSSL_free(*pval);
      2 (0.0%)          *pval = NULL;
      .               }
      3 (0.0%)        break;
      .             }
      .         
      .             case ASN1_ITYPE_EXTERN:
  1,764 (0.0%)        ef = it->funcs;
  3,528 (0.0%)        if (ef && ef->asn1_ex_free) {
  4,116 (0.0%)          ef->asn1_ex_free(pval, it);
      .               }
  1,764 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_SEQUENCE: {
 44,779 (0.0%)        if (!asn1_refcount_dec_and_test_zero(pval, it)) {
    294 (0.0%)          return;
      .               }
 18,750 (0.0%)        const ASN1_AUX *aux = it->funcs;
 26,764 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
 12,500 (0.0%)        if (asn1_cb) {
  4,704 (0.0%)          i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
  1,176 (0.0%)          if (i == 2) {
      .                   return;
      .                 }
      .               }
 31,250 (0.0%)        asn1_enc_free(pval, it);
      .               // If we free up as normal we will invalidate any ANY DEFINED BY
      .               // field and we wont be able to determine the type of the field it
      .               // defines. So free up in reverse order.
 50,000 (0.0%)        tt = it->templates + it->tcount - 1;
179,264 (0.1%)        for (i = 0; i < it->tcount; tt--, i++) {
      .                 ASN1_VALUE **pseqval;
113,106 (0.0%)          seqtt = asn1_do_adb(pval, tt, 0);
 32,316 (0.0%)          if (!seqtt) {
      .                   continue;
      .                 }
 96,948 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
 96,948 (0.0%)          ASN1_template_free(pseqval, seqtt);
      .               }
 12,500 (0.0%)        if (asn1_cb) {
  4,116 (0.0%)          asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);
      .               }
 12,500 (0.0%)        if (!combine) {
 25,000 (0.0%)          OPENSSL_free(*pval);
 12,500 (0.0%)          *pval = NULL;
      .               }
 12,500 (0.0%)        break;
      .             }
      .           }
 45,446 (0.0%)  }
      .         
156,195 (0.1%)  void ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
 86,775 (0.0%)    if (tt->flags & ASN1_TFLG_SK_MASK) {
  2,649 (0.0%)      STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;
 12,259 (0.0%)      for (size_t i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
  6,078 (0.0%)        ASN1_VALUE *vtmp = sk_ASN1_VALUE_value(sk, i);
  6,078 (0.0%)        ASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item));
      .             }
  2,649 (0.0%)      sk_ASN1_VALUE_free(sk);
  1,766 (0.0%)      *pval = NULL;
      .           } else {
131,776 (0.0%)      asn1_item_combine_free(pval, ASN1_ITEM_ptr(tt->item),
 32,944 (0.0%)                             tt->flags & ASN1_TFLG_COMBINE);
      .           }
105,013 (0.0%)  }
      .         
 84,720 (0.0%)  void ASN1_primitive_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of calbacks.
 56,480 (0.0%)    assert(it->funcs == NULL);
      .         
105,424 (0.0%)    int utype = it->itype == ASN1_ITYPE_MSTRING ? -1 : it->utype;
123,608 (0.0%)    switch (utype) {
      .             case V_ASN1_OBJECT:
 20,296 (0.0%)        ASN1_OBJECT_free((ASN1_OBJECT *)*pval);
  5,074 (0.0%)        break;
      .         
      .             case V_ASN1_BOOLEAN:
  2,486 (0.0%)        if (it) {
  6,215 (0.0%)          *(ASN1_BOOLEAN *)pval = (ASN1_BOOLEAN)it->size;
      .               } else {
      .                 *(ASN1_BOOLEAN *)pval = ASN1_BOOLEAN_NONE;
      .               }
  1,243 (0.0%)        return;
      .         
      .             case V_ASN1_NULL:
      .               break;
      .         
      .             case V_ASN1_ANY:
  3,848 (0.0%)        if (*pval != NULL) {
  2,888 (0.0%)          asn1_type_cleanup((ASN1_TYPE *)*pval);
  2,888 (0.0%)          OPENSSL_free(*pval);
      .               }
  1,684 (0.0%)        break;
      .         
      .             default:
 27,364 (0.0%)        ASN1_STRING_free((ASN1_STRING *)*pval);
 13,682 (0.0%)        *pval = NULL;
  6,841 (0.0%)        break;
      .           }
 25,754 (0.0%)    *pval = NULL;
 28,240 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 70 ----------------------------------------
      .         static int asn1_item_ex_combine_new(ASN1_VALUE **pval, const ASN1_ITEM *it,
      .                                             int combine);
      .         static void asn1_item_clear(ASN1_VALUE **pval, const ASN1_ITEM *it);
      .         static int ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);
      .         static void asn1_template_clear(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);
      .         static int ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it);
      .         static void asn1_primitive_clear(ASN1_VALUE **pval, const ASN1_ITEM *it);
      .         
 11,456 (0.0%)  ASN1_VALUE *ASN1_item_new(const ASN1_ITEM *it) {
  1,432 (0.0%)    ASN1_VALUE *ret = NULL;
 10,024 (0.0%)    if (ASN1_item_ex_new(&ret, it) > 0) {
  2,864 (0.0%)      return ret;
      .           }
      .           return NULL;
  7,160 (0.0%)  }
      .         
      .         // Allocate an ASN1 structure
      .         
 18,948 (0.0%)  int ASN1_item_ex_new(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 18,948 (0.0%)    return asn1_item_ex_combine_new(pval, it, 0);
  6,316 (0.0%)  }
      .         
      .         static int asn1_item_ex_combine_new(ASN1_VALUE **pval, const ASN1_ITEM *it,
 75,712 (0.0%)                                      int combine) {
 10,816 (0.0%)    const ASN1_TEMPLATE *tt = NULL;
      .           const ASN1_EXTERN_FUNCS *ef;
      .           ASN1_VALUE **pseqval;
      .           int i;
      .         
140,608 (0.0%)    switch (it->itype) {
      .             case ASN1_ITYPE_EXTERN:
    888 (0.0%)        ef = it->funcs;
  1,776 (0.0%)        if (ef && ef->asn1_ex_new) {
  2,664 (0.0%)          if (!ef->asn1_ex_new(pval, it)) {
      .                   goto memerr;
      .                 }
      .               }
    592 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_PRIMITIVE:
 17,624 (0.0%)        if (it->templates) {
      .                 if (!ASN1_template_new(pval, it->templates)) {
      .                   goto memerr;
      .                 }
 30,842 (0.0%)        } else if (!ASN1_primitive_new(pval, it)) {
      .                 goto memerr;
      .               }
  8,812 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_MSTRING:
 17,024 (0.0%)        if (!ASN1_primitive_new(pval, it)) {
      .                 goto memerr;
      .               }
  4,864 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_CHOICE: {
      3 (0.0%)        const ASN1_AUX *aux = it->funcs;
      4 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
      2 (0.0%)        if (asn1_cb) {
      .                 i = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);
      .                 if (!i) {
      .                   goto auxerr;
      .                 }
      .                 if (i == 2) {
      .                   return 1;
      .                 }
      .               }
      2 (0.0%)        if (!combine) {
      6 (0.0%)          *pval = OPENSSL_zalloc(it->size);
      4 (0.0%)          if (!*pval) {
      .                   goto memerr;
      .                 }
      .               }
      5 (0.0%)        asn1_set_choice_selector(pval, -1, it);
      2 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL)) {
      .                 goto auxerr2;
      .               }
      2 (0.0%)        break;
      .             }
      .         
      .             case ASN1_ITYPE_SEQUENCE: {
 11,043 (0.0%)        const ASN1_AUX *aux = it->funcs;
 15,612 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
  7,362 (0.0%)        if (asn1_cb) {
  2,368 (0.0%)          i = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);
    592 (0.0%)          if (!i) {
      .                   goto auxerr;
      .                 }
    592 (0.0%)          if (i == 2) {
      .                   return 1;
      .                 }
      .               }
  7,362 (0.0%)        if (!combine) {
 22,086 (0.0%)          *pval = OPENSSL_zalloc(it->size);
 14,724 (0.0%)          if (!*pval) {
      .                   goto memerr;
      .                 }
 18,405 (0.0%)          asn1_refcount_set_one(pval, it);
 18,405 (0.0%)          asn1_enc_init(pval, it);
      .               }
114,115 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
 55,218 (0.0%)          pseqval = asn1_get_field_ptr(pval, tt);
 64,421 (0.0%)          if (!ASN1_template_new(pseqval, tt)) {
      .                   goto memerr2;
      .                 }
      .               }
 10,026 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL)) {
      .                 goto auxerr2;
      .               }
  3,977 (0.0%)        break;
      .             }
      .           }
 21,632 (0.0%)    return 1;
      .         
      .         memerr2:
      .           asn1_item_combine_free(pval, it, combine);
      .         memerr:
      .           return 0;
      .         
      .         auxerr2:
      .           asn1_item_combine_free(pval, it, combine);
      .         auxerr:
      .           OPENSSL_PUT_ERROR(ASN1, ASN1_R_AUX_ERROR);
      .           return 0;
 21,632 (0.0%)  }
      .         
  8,382 (0.0%)  static void asn1_item_clear(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 18,161 (0.0%)    switch (it->itype) {
      .             case ASN1_ITYPE_EXTERN:
      .               *pval = NULL;
      .               break;
      .         
      .             case ASN1_ITYPE_PRIMITIVE:
  5,588 (0.0%)        if (it->templates) {
      .                 asn1_template_clear(pval, it->templates);
      .               } else {
  6,985 (0.0%)          asn1_primitive_clear(pval, it);
      .               }
  1,397 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_MSTRING:
      .               asn1_primitive_clear(pval, it);
      .               break;
      .         
      .             case ASN1_ITYPE_CHOICE:
      .             case ASN1_ITYPE_SEQUENCE:
      .               *pval = NULL;
      .               break;
      .           }
  4,191 (0.0%)  }
      .         
 55,218 (0.0%)  static int ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
 27,609 (0.0%)    const ASN1_ITEM *it = ASN1_ITEM_ptr(tt->item);
      .           int ret;
 46,015 (0.0%)    if (tt->flags & ASN1_TFLG_OPTIONAL) {
  7,725 (0.0%)      asn1_template_clear(pval, tt);
  3,090 (0.0%)      return 1;
      .           }
      .           // If ANY DEFINED BY nothing to do
      .         
 38,290 (0.0%)    if (tt->flags & ASN1_TFLG_ADB_MASK) {
      .             *pval = NULL;
      .             return 1;
      .           }
      .           // If SET OF or SEQUENCE OF, its a STACK
 38,290 (0.0%)    if (tt->flags & ASN1_TFLG_SK_MASK) {
      .             STACK_OF(ASN1_VALUE) *skval;
      .             skval = sk_ASN1_VALUE_new_null();
      .             if (!skval) {
      .               ret = 0;
      .               goto done;
      .             }
      .             *pval = (ASN1_VALUE *)skval;
      .             ret = 1;
      .             goto done;
      .           }
      .           // Otherwise pass it back to the item routine
 76,580 (0.0%)    ret = asn1_item_ex_combine_new(pval, it, tt->flags & ASN1_TFLG_COMBINE);
      .         done:
  7,658 (0.0%)    return ret;
 18,406 (0.0%)  }
      .         
  9,270 (0.0%)  static void asn1_template_clear(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
      .           // If ADB or STACK just NULL the field
  7,725 (0.0%)    if (tt->flags & (ASN1_TFLG_ADB_MASK | ASN1_TFLG_SK_MASK)) {
    296 (0.0%)      *pval = NULL;
      .           } else {
  8,382 (0.0%)      asn1_item_clear(pval, ASN1_ITEM_ptr(tt->item));
      .           }
  4,783 (0.0%)  }
      .         
      .         // NB: could probably combine most of the real XXX_new() behaviour and junk
      .         // all the old functions.
      .         
 41,028 (0.0%)  static int ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 13,676 (0.0%)    if (!it) {
      .             return 0;
      .           }
      .         
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of calbacks.
 27,352 (0.0%)    assert(it->funcs == NULL);
      .         
      .           int utype;
 27,352 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
  4,864 (0.0%)      utype = -1;
      .           } else {
 13,218 (0.0%)      utype = it->utype;
      .           }
 53,823 (0.0%)    switch (utype) {
      .             case V_ASN1_OBJECT:
  9,267 (0.0%)        *pval = (ASN1_VALUE *)OBJ_get_undef();
  6,178 (0.0%)        return 1;
      .         
      .             case V_ASN1_BOOLEAN:
      .               *(ASN1_BOOLEAN *)pval = (ASN1_BOOLEAN)it->size;
      .               return 1;
      .         
      .             case V_ASN1_NULL:
      .               *pval = (ASN1_VALUE *)1;
      .               return 1;
      .         
      .             case V_ASN1_ANY: {
  1,092 (0.0%)        ASN1_TYPE *typ = OPENSSL_zalloc(sizeof(ASN1_TYPE));
    728 (0.0%)        if (!typ) {
      .                 return 0;
      .               }
    728 (0.0%)        typ->type = -1;
  1,092 (0.0%)        *pval = (ASN1_VALUE *)typ;
    364 (0.0%)        break;
      .             }
      .         
      .             default:
 16,925 (0.0%)        *pval = (ASN1_VALUE *)ASN1_STRING_type_new(utype);
  3,385 (0.0%)        break;
      .           }
 14,996 (0.0%)    if (*pval) {
  7,498 (0.0%)      return 1;
      .           }
      .           return 0;
 13,676 (0.0%)  }
      .         
  8,382 (0.0%)  static void asn1_primitive_clear(ASN1_VALUE **pval, const ASN1_ITEM *it) {
      .           int utype;
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of calbacks.
  8,382 (0.0%)    assert(it == NULL || it->funcs == NULL);
  8,382 (0.0%)    if (!it || (it->itype == ASN1_ITYPE_MSTRING)) {
      .             utype = -1;
      .           } else {
  4,191 (0.0%)      utype = it->utype;
      .           }
  2,794 (0.0%)    if (utype == V_ASN1_BOOLEAN) {
  2,545 (0.0%)      *(ASN1_BOOLEAN *)pval = (ASN1_BOOLEAN)it->size;
      .           } else {
  1,776 (0.0%)      *pval = NULL;
      .           }
  4,700 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 70 ----------------------------------------
      .         
      .         
      .         // Utility functions for manipulating fields and offsets
      .         
      .         // Add 'offset' to 'addr'
      .         #define offset2ptr(addr, offset) (void *)(((char *)(addr)) + (offset))
      .         
      .         // Given an ASN1_ITEM CHOICE type return the selector value
      5 (0.0%)  int asn1_get_choice_selector(ASN1_VALUE **pval, const ASN1_ITEM *it) {
      7 (0.0%)    int *sel = offset2ptr(*pval, it->utype);
      2 (0.0%)    return *sel;
      2 (0.0%)  }
      .         
      .         // Given an ASN1_ITEM CHOICE type set the selector value, return old value.
      .         int asn1_set_choice_selector(ASN1_VALUE **pval, int value,
     12 (0.0%)                               const ASN1_ITEM *it) {
      .           int *sel, ret;
     14 (0.0%)    sel = offset2ptr(*pval, it->utype);
      6 (0.0%)    ret = *sel;
      6 (0.0%)    *sel = value;
      2 (0.0%)    return ret;
      4 (0.0%)  }
      .         
      .         static CRYPTO_refcount_t *asn1_get_references(ASN1_VALUE **pval,
 50,390 (0.0%)                                                const ASN1_ITEM *it) {
 40,312 (0.0%)    if (it->itype != ASN1_ITYPE_SEQUENCE) {
      .             return NULL;
      .           }
 30,234 (0.0%)    const ASN1_AUX *aux = it->funcs;
 27,521 (0.0%)    if (!aux || !(aux->flags & ASN1_AFLG_REFCOUNT)) {
 18,978 (0.0%)      return NULL;
      .           }
  3,534 (0.0%)    return offset2ptr(*pval, aux->ref_offset);
 20,156 (0.0%)  }
      .         
 22,086 (0.0%)  void asn1_refcount_set_one(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 22,086 (0.0%)    CRYPTO_refcount_t *references = asn1_get_references(pval, it);
  7,362 (0.0%)    if (references != NULL) {
    296 (0.0%)      *references = 1;
      .           }
 11,043 (0.0%)  }
      .         
 38,382 (0.0%)  int asn1_refcount_dec_and_test_zero(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 38,382 (0.0%)    CRYPTO_refcount_t *references = asn1_get_references(pval, it);
 12,794 (0.0%)    if (references != NULL) {
  1,764 (0.0%)      return CRYPTO_refcount_dec_and_test_zero(references);
      .           }
  5,956 (0.0%)    return 1;
 12,794 (0.0%)  }
      .         
 98,928 (0.0%)  static ASN1_ENCODING *asn1_get_enc_ptr(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 65,952 (0.0%)    assert(it->itype == ASN1_ITYPE_SEQUENCE);
      .           const ASN1_AUX *aux;
 98,928 (0.0%)    if (!pval || !*pval) {
      .             return NULL;
      .           }
 49,464 (0.0%)    aux = it->funcs;
 43,306 (0.0%)    if (!aux || !(aux->flags & ASN1_AFLG_ENCODING)) {
 31,796 (0.0%)      return NULL;
      .           }
  3,540 (0.0%)    return offset2ptr(*pval, aux->enc_offset);
 32,976 (0.0%)  }
      .         
 22,086 (0.0%)  void asn1_enc_init(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 22,086 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
  7,362 (0.0%)    if (enc) {
    296 (0.0%)      enc->enc = NULL;
    296 (0.0%)      enc->len = 0;
    592 (0.0%)      enc->alias_only = 0;
    592 (0.0%)      enc->alias_only_on_next_parse = 0;
      .           }
 11,043 (0.0%)  }
      .         
 37,500 (0.0%)  void asn1_enc_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 37,500 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
 12,500 (0.0%)    if (enc) {
    882 (0.0%)      asn1_encoding_clear(enc);
      .           }
 18,750 (0.0%)  }
      .         
      .         int asn1_enc_save(ASN1_VALUE **pval, const unsigned char *in, int inlen,
 20,904 (0.0%)                    const ASN1_ITEM *it) {
      .           ASN1_ENCODING *enc;
 15,678 (0.0%)    enc = asn1_get_enc_ptr(pval, it);
  5,226 (0.0%)    if (!enc) {
  4,930 (0.0%)      return 1;
      .           }
      .         
    740 (0.0%)    if (!enc->alias_only) {
    592 (0.0%)      OPENSSL_free(enc->enc);
      .           }
      .         
  1,628 (0.0%)    enc->alias_only = enc->alias_only_on_next_parse;
    592 (0.0%)    enc->alias_only_on_next_parse = 0;
      .         
    740 (0.0%)    if (enc->alias_only) {
      .             enc->enc = (uint8_t *)in;
      .           } else {
  1,184 (0.0%)      enc->enc = OPENSSL_memdup(in, inlen);
    592 (0.0%)      if (!enc->enc) {
      .               return 0;
      .             }
      .           }
      .         
    592 (0.0%)    enc->len = inlen;
    148 (0.0%)    return 1;
  5,226 (0.0%)  }
      .         
  1,470 (0.0%)  void asn1_encoding_clear(ASN1_ENCODING *enc) {
  1,470 (0.0%)    if (!enc->alias_only) {
  1,176 (0.0%)      OPENSSL_free(enc->enc);
      .           }
    588 (0.0%)    enc->enc = NULL;
    588 (0.0%)    enc->len = 0;
  1,176 (0.0%)    enc->alias_only = 0;
  1,176 (0.0%)    enc->alias_only_on_next_parse = 0;
    882 (0.0%)  }
      .         
      .         int asn1_enc_restore(int *len, unsigned char **out, ASN1_VALUE **pval,
 31,552 (0.0%)                       const ASN1_ITEM *it) {
 23,664 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
  7,888 (0.0%)    if (!enc || enc->len == 0) {
  7,888 (0.0%)      return 0;
      .           }
      .           if (out) {
      .             OPENSSL_memcpy(*out, enc->enc, enc->len);
      .             *out += enc->len;
      .           }
      .           if (len) {
      .             *len = enc->len;
      .           }
      .           return 1;
  7,888 (0.0%)  }
      .         
      .         // Given an ASN1_TEMPLATE get a pointer to a field
215,640 (0.1%)  ASN1_VALUE **asn1_get_field_ptr(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
      .           ASN1_VALUE **pvaltmp;
215,640 (0.1%)    if (tt->flags & ASN1_TFLG_COMBINE) {
      .             return pval;
      .           }
258,768 (0.1%)    pvaltmp = offset2ptr(*pval, tt->offset);
      .           // NOTE for BOOLEAN types the field is just a plain int so we can't return
      .           // int **, so settle for (int *).
 43,128 (0.0%)    return pvaltmp;
 86,256 (0.0%)  }
      .         
      .         // Handle ANY DEFINED BY template, find the selector, look up the relevant
      .         // ASN1_TEMPLATE in the table and return it.
      .         const ASN1_TEMPLATE *asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt,
237,447 (0.1%)                                   int nullerr) {
      .           const ASN1_ADB *adb;
      .           const ASN1_ADB_TABLE *atbl;
      .           ASN1_VALUE **sfld;
      .           int i;
169,605 (0.1%)    if (!(tt->flags & ASN1_TFLG_ADB_MASK)) {
 67,842 (0.0%)      return tt;
      .           }
      .         
      .           // Else ANY DEFINED BY ... get the table
      .           adb = ASN1_ADB_ptr(tt->item);
      .         
      .           // Get the selector field
      .           sfld = offset2ptr(*pval, adb->offset);
      .         
-- line 233 ----------------------------------------
-- line 265 ----------------------------------------
      .           return adb->default_tt;
      .         
      .         err:
      .           // FIXME: should log the value or OID of unsupported type
      .           if (nullerr) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);
      .           }
      .           return NULL;
 67,842 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h
--------------------------------------------------------------------------------
Ir______________ 

-- line 318 ----------------------------------------
        .         #if defined(__GNUC__) || defined(__clang__)
        .           __asm__("" : "+r"(a) : /* no inputs */);
        .         #endif
        .           return a;
        .         }
        .         
        .         // constant_time_msb_w returns the given value with the MSB copied to all the
        .         // other bits.
3,746,520 (1.2%)  static inline crypto_word_t constant_time_msb_w(crypto_word_t a) {
2,497,680 (0.8%)    return 0u - (a >> (sizeof(a) * 8 - 1));
2,497,680 (0.8%)  }
        .         
        .         // constant_time_lt_w returns 0xff..f if a < b and 0 otherwise.
        .         static inline crypto_word_t constant_time_lt_w(crypto_word_t a,
        .                                                        crypto_word_t b) {
        .           // Consider the two cases of the problem:
        .           //   msb(a) == msb(b): a < b iff the MSB of a - b is set.
        .           //   msb(a) != msb(b): a < b iff the MSB of b is set.
        .           //
-- line 336 ----------------------------------------
-- line 377 ----------------------------------------
        .         
        .         // constant_time_ge_8 acts like |constant_time_ge_w| but returns an 8-bit
        .         // mask.
        .         static inline uint8_t constant_time_ge_8(crypto_word_t a, crypto_word_t b) {
        .           return (uint8_t)(constant_time_ge_w(a, b));
        .         }
        .         
        .         // constant_time_is_zero returns 0xff..f if a == 0 and 0 otherwise.
2,497,680 (0.8%)  static inline crypto_word_t constant_time_is_zero_w(crypto_word_t a) {
        .           // Here is an SMT-LIB verification of this formula:
        .           //
        .           // (define-fun is_zero ((a (_ BitVec 32))) (_ BitVec 32)
        .           //   (bvand (bvnot a) (bvsub a #x00000001))
        .           // )
        .           //
        .           // (declare-fun a () (_ BitVec 32))
        .           //
        .           // (assert (not (= (= #x00000001 (bvlshr (is_zero a) #x0000001f)) (= a #x00000000))))
        .           // (check-sat)
        .           // (get-model)
4,995,360 (1.6%)    return constant_time_msb_w(~a & (a - 1));
1,248,840 (0.4%)  }
        .         
        .         // constant_time_is_zero_8 acts like |constant_time_is_zero_w| but returns an
        .         // 8-bit mask.
        .         static inline uint8_t constant_time_is_zero_8(crypto_word_t a) {
        .           return (uint8_t)(constant_time_is_zero_w(a));
        .         }
        .         
        .         // constant_time_eq_w returns 0xff..f if a == b and 0 otherwise.
        .         static inline crypto_word_t constant_time_eq_w(crypto_word_t a,
3,122,100 (1.0%)                                                 crypto_word_t b) {
2,497,680 (0.8%)    return constant_time_is_zero_w(a ^ b);
1,248,840 (0.4%)  }
        .         
        .         // constant_time_eq_8 acts like |constant_time_eq_w| but returns an 8-bit
        .         // mask.
3,122,100 (1.0%)  static inline uint8_t constant_time_eq_8(crypto_word_t a, crypto_word_t b) {
3,122,100 (1.0%)    return (uint8_t)(constant_time_eq_w(a, b));
1,248,840 (0.4%)  }
        .         
        .         // constant_time_eq_int acts like |constant_time_eq_w| but works on int
        .         // values.
        .         static inline crypto_word_t constant_time_eq_int(int a, int b) {
        .           return constant_time_eq_w((crypto_word_t)(a), (crypto_word_t)(b));
        .         }
        .         
        .         // constant_time_eq_int_8 acts like |constant_time_eq_int| but returns an 8-bit
-- line 424 ----------------------------------------
-- line 882 ----------------------------------------
        .         static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
        .           if (n == 0) {
        .             return dst;
        .           }
        .         
        .           return memmove(dst, src, n);
        .         }
        .         
      876 (0.0%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
      292 (0.0%)    if (n == 0) {
        .             return dst;
        .           }
        .         
      876 (0.0%)    return memset(dst, c, n);
      292 (0.0%)  }
        .         
        .         
        .         // Loads and stores.
        .         //
        .         // The following functions load and store sized integers with the specified
        .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
        .         // requirements on the input and output pointers.
        .         
-- line 904 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 62 ----------------------------------------
        .         
        .         #include <openssl/type_check.h>
        .         
        .         #include "../internal.h"
        .         
        .         
        .         // constant_time_lt_args_8 behaves like |constant_time_lt_8| but takes |uint8_t|
        .         // arguments for a slightly simpler implementation.
4,370,940 (1.4%)  static inline uint8_t constant_time_lt_args_8(uint8_t a, uint8_t b) {
1,248,840 (0.4%)    crypto_word_t aw = a;
1,248,840 (0.4%)    crypto_word_t bw = b;
        .           // |crypto_word_t| is larger than |uint8_t|, so |aw| and |bw| have the same
        .           // MSB. |aw| < |bw| iff MSB(|aw| - |bw|) is 1.
2,497,680 (0.8%)    return constant_time_msb_w(aw - bw);
1,248,840 (0.4%)  }
        .         
        .         // constant_time_in_range_8 returns |CONSTTIME_TRUE_8| if |min| <= |a| <= |max|
        .         // and |CONSTTIME_FALSE_8| otherwise.
        .         static inline uint8_t constant_time_in_range_8(uint8_t a, uint8_t min,
6,244,200 (2.0%)                                                 uint8_t max) {
1,248,840 (0.4%)    a -= min;
4,995,360 (1.6%)    return constant_time_lt_args_8(a, max - min + 1);
1,248,840 (0.4%)  }
        .         
        .         // Encoding.
        .         
        .         static uint8_t conv_bin2ascii(uint8_t a) {
        .           // Since PEM is sometimes used to carry private keys, we encode base64 data
        .           // itself in constant-time.
        .           a &= 0x3f;
        .           uint8_t ret = constant_time_select_8(constant_time_eq_8(a, 62), '+', '/');
-- line 92 ----------------------------------------
-- line 257 ----------------------------------------
        .           if (len % 4 != 0) {
        .             return 0;
        .           }
        .         
        .           *out_len = (len / 4) * 3;
        .           return 1;
        .         }
        .         
      730 (0.0%)  void EVP_DecodeInit(EVP_ENCODE_CTX *ctx) {
      730 (0.0%)    OPENSSL_memset(ctx, 0, sizeof(EVP_ENCODE_CTX));
      438 (0.0%)  }
        .         
1,248,840 (0.4%)  static uint8_t base64_ascii_to_bin(uint8_t a) {
        .           // Since PEM is sometimes used to carry private keys, we decode base64 data
        .           // itself in constant-time.
1,248,840 (0.4%)    const uint8_t is_upper = constant_time_in_range_8(a, 'A', 'Z');
1,248,840 (0.4%)    const uint8_t is_lower = constant_time_in_range_8(a, 'a', 'z');
1,248,840 (0.4%)    const uint8_t is_digit = constant_time_in_range_8(a, '0', '9');
1,040,700 (0.3%)    const uint8_t is_plus = constant_time_eq_8(a, '+');
1,040,700 (0.3%)    const uint8_t is_slash = constant_time_eq_8(a, '/');
1,040,700 (0.3%)    const uint8_t is_equals = constant_time_eq_8(a, '=');
        .         
  208,140 (0.1%)    uint8_t ret = 0;
1,665,120 (0.5%)    ret |= is_upper & (a - 'A');       // [0,26)
1,665,120 (0.5%)    ret |= is_lower & (a - 'a' + 26);  // [26,52)
1,665,120 (0.5%)    ret |= is_digit & (a - '0' + 52);  // [52,62)
1,248,840 (0.4%)    ret |= is_plus & 62;
1,248,840 (0.4%)    ret |= is_slash & 63;
        .           // Invalid inputs, 'A', and '=' have all been mapped to zero. Map invalid
        .           // inputs to 0xff. Note '=' is padding and handled separately by the caller.
1,456,980 (0.5%)    const uint8_t is_valid =
        .               is_upper | is_lower | is_digit | is_plus | is_slash | is_equals;
1,248,840 (0.4%)    ret |= ~is_valid;
  208,140 (0.1%)    return ret;
  416,280 (0.1%)  }
        .         
        .         // base64_decode_quad decodes a single “quad” (i.e. four characters) of base64
        .         // data and writes up to three bytes to |out|. It sets |*out_num_bytes| to the
        .         // number of bytes written, which will be less than three if the quad ended
        .         // with padding.  It returns one on success or zero on error.
        .         static int base64_decode_quad(uint8_t *out, size_t *out_num_bytes,
  364,245 (0.1%)                                const uint8_t *in) {
  312,210 (0.1%)    const uint8_t a = base64_ascii_to_bin(in[0]);
  364,245 (0.1%)    const uint8_t b = base64_ascii_to_bin(in[1]);
  364,245 (0.1%)    const uint8_t c = base64_ascii_to_bin(in[2]);
  364,245 (0.1%)    const uint8_t d = base64_ascii_to_bin(in[3]);
  416,280 (0.1%)    if (a == 0xff || b == 0xff || c == 0xff || d == 0xff) {
        .             return 0;
        .           }
        .         
  468,315 (0.2%)    const uint32_t v = ((uint32_t)a) << 18 | ((uint32_t)b) << 12 |
  156,105 (0.1%)                       ((uint32_t)c) << 6 | (uint32_t)d;
        .         
  364,245 (0.1%)    const unsigned padding_pattern = (in[0] == '=') << 3 |
  364,245 (0.1%)                                     (in[1] == '=') << 2 |
  364,282 (0.1%)                                     (in[2] == '=') << 1 |
  312,210 (0.1%)                                     (in[3] == '=');
        .         
  312,156 (0.1%)    switch (padding_pattern) {
        .             case 0:
        .               // The common case of no padding.
  103,902 (0.0%)        *out_num_bytes = 3;
  259,755 (0.1%)        out[0] = v >> 16;
  311,706 (0.1%)        out[1] = v >> 8;
  207,804 (0.1%)        out[2] = v;
   51,951 (0.0%)        break;
        .         
        .             case 1:  // xxx=
       94 (0.0%)        *out_num_bytes = 2;
      235 (0.0%)        out[0] = v >> 16;
      282 (0.0%)        out[1] = v >> 8;
       47 (0.0%)        break;
        .         
        .             case 3:  // xx==
       74 (0.0%)        *out_num_bytes = 1;
      185 (0.0%)        out[0] = v >> 16;
       37 (0.0%)        break;
        .         
        .             default:
        .               return 0;
        .           }
        .         
   52,035 (0.0%)    return 1;
  104,070 (0.0%)  }
        .         
        .         int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, uint8_t *out, int *out_len,
    1,752 (0.0%)                       const uint8_t *in, size_t in_len) {
      292 (0.0%)    *out_len = 0;
        .         
      584 (0.0%)    if (ctx->error_encountered) {
        .             return -1;
        .           }
        .         
      146 (0.0%)    size_t bytes_out = 0, i;
  846,562 (0.3%)    for (i = 0; i < in_len; i++) {
1,057,290 (0.3%)      const char c = in[i];
1,087,152 (0.4%)      switch (c) {
        .               case ' ':
        .               case '\t':
        .               case '\r':
        .               case '\n':
    3,318 (0.0%)          continue;
        .             }
        .         
  832,560 (0.3%)      if (ctx->eof_seen) {
        .               ctx->error_encountered = 1;
        .               return -1;
        .             }
        .         
1,873,260 (0.6%)      ctx->data[ctx->data_used++] = c;
  832,560 (0.3%)      if (ctx->data_used == 4) {
        .               size_t num_bytes_resulting;
  468,315 (0.2%)        if (!base64_decode_quad(out, &num_bytes_resulting, ctx->data)) {
        .                 ctx->error_encountered = 1;
        .                 return -1;
        .               }
        .         
  104,070 (0.0%)        ctx->data_used = 0;
  104,070 (0.0%)        bytes_out += num_bytes_resulting;
  104,070 (0.0%)        out += num_bytes_resulting;
        .         
  156,105 (0.1%)        if (num_bytes_resulting < 3) {
      252 (0.0%)          ctx->eof_seen = 1;
        .               }
        .             }
        .           }
        .         
      438 (0.0%)    if (bytes_out > INT_MAX) {
        .             ctx->error_encountered = 1;
        .             *out_len = 0;
        .             return -1;
        .           }
      584 (0.0%)    *out_len = (int)bytes_out;
        .         
      584 (0.0%)    if (ctx->eof_seen) {
      168 (0.0%)      return 0;
        .           }
        .         
       62 (0.0%)    return 1;
      730 (0.0%)  }
        .         
      876 (0.0%)  int EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, uint8_t *out, int *out_len) {
      292 (0.0%)    *out_len = 0;
    1,168 (0.0%)    if (ctx->error_encountered || ctx->data_used != 0) {
        .             return -1;
        .           }
        .         
      146 (0.0%)    return 1;
      292 (0.0%)  }
        .         
        .         int EVP_DecodeBase64(uint8_t *out, size_t *out_len, size_t max_out,
        .                              const uint8_t *in, size_t in_len) {
        .           *out_len = 0;
        .         
        .           if (in_len % 4 != 0) {
        .             return 0;
        .           }
-- line 413 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 19 ----------------------------------------
      .         #include <string.h>
      .         
      .         #include <openssl/mem.h>
      .         #include <openssl/err.h>
      .         
      .         #include "../internal.h"
      .         
      .         
  9,265 (0.0%)  void CBB_zero(CBB *cbb) {
  9,265 (0.0%)    OPENSSL_memset(cbb, 0, sizeof(CBB));
  5,559 (0.0%)  }
      .         
  5,488 (0.0%)  static void cbb_init(CBB *cbb, uint8_t *buf, size_t cap, int can_resize) {
  1,568 (0.0%)    cbb->is_child = 0;
  1,568 (0.0%)    cbb->child = NULL;
  2,352 (0.0%)    cbb->u.base.buf = buf;
  1,568 (0.0%)    cbb->u.base.len = 0;
  2,352 (0.0%)    cbb->u.base.cap = cap;
  7,056 (0.0%)    cbb->u.base.can_resize = can_resize;
  3,136 (0.0%)    cbb->u.base.error = 0;
  2,352 (0.0%)  }
      .         
  4,704 (0.0%)  int CBB_init(CBB *cbb, size_t initial_capacity) {
  2,352 (0.0%)    CBB_zero(cbb);
      .         
  3,136 (0.0%)    uint8_t *buf = OPENSSL_malloc(initial_capacity);
  3,136 (0.0%)    if (initial_capacity > 0 && buf == NULL) {
      .             return 0;
      .           }
      .         
  4,704 (0.0%)    cbb_init(cbb, buf, initial_capacity, /*can_resize=*/1);
    784 (0.0%)    return 1;
  1,568 (0.0%)  }
      .         
      .         int CBB_init_fixed(CBB *cbb, uint8_t *buf, size_t len) {
      .           CBB_zero(cbb);
      .           cbb_init(cbb, buf, len, /*can_resize=*/0);
      .           return 1;
      .         }
      .         
  3,920 (0.0%)  void CBB_cleanup(CBB *cbb) {
      .           // Child |CBB|s are non-owning. They are implicitly discarded and should not
      .           // be used with |CBB_cleanup| or |ScopedCBB|.
  3,136 (0.0%)    assert(!cbb->is_child);
  3,136 (0.0%)    if (cbb->is_child) {
      .             return;
      .           }
      .         
  3,920 (0.0%)    if (cbb->u.base.can_resize) {
  3,920 (0.0%)      OPENSSL_free(cbb->u.base.buf);
      .           }
  1,568 (0.0%)  }
      .         
      .         static int cbb_buffer_reserve(struct cbb_buffer_st *base, uint8_t **out,
 84,084 (0.0%)                                size_t len) {
 24,024 (0.0%)    if (base == NULL) {
      .             return 0;
      .           }
      .         
 60,060 (0.0%)    size_t newlen = base->len + len;
 48,048 (0.0%)    if (newlen < base->len) {
      .             // Overflow
      .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
      .             goto err;
      .           }
      .         
 48,048 (0.0%)    if (newlen > base->cap) {
      .             if (!base->can_resize) {
      .               OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
      .               goto err;
      .             }
      .         
      .             size_t newcap = base->cap * 2;
      .             if (newcap < base->cap || newcap < newlen) {
      .               newcap = newlen;
-- line 93 ----------------------------------------
-- line 96 ----------------------------------------
      .             if (newbuf == NULL) {
      .               goto err;
      .             }
      .         
      .             base->buf = newbuf;
      .             base->cap = newcap;
      .           }
      .         
 24,024 (0.0%)    if (out) {
 84,084 (0.0%)      *out = base->buf + base->len;
      .           }
      .         
 24,024 (0.0%)    return 1;
      .         
      .         err:
      .           base->error = 1;
      .           return 0;
 24,024 (0.0%)  }
      .         
      .         static int cbb_buffer_add(struct cbb_buffer_st *base, uint8_t **out,
 84,084 (0.0%)                            size_t len) {
 96,096 (0.0%)    if (!cbb_buffer_reserve(base, out, len)) {
      .             return 0;
      .           }
      .           // This will not overflow or |cbb_buffer_reserve| would have failed.
 72,072 (0.0%)    base->len += len;
 12,012 (0.0%)    return 1;
 24,024 (0.0%)  }
      .         
  5,488 (0.0%)  int CBB_finish(CBB *cbb, uint8_t **out_data, size_t *out_len) {
  3,136 (0.0%)    if (cbb->is_child) {
      .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
      .             return 0;
      .           }
      .         
  3,920 (0.0%)    if (!CBB_flush(cbb)) {
      .             return 0;
      .           }
      .         
  7,056 (0.0%)    if (cbb->u.base.can_resize && (out_data == NULL || out_len == NULL)) {
      .             // |out_data| and |out_len| can only be NULL if the CBB is fixed.
      .             return 0;
      .           }
      .         
  1,568 (0.0%)    if (out_data != NULL) {
  3,136 (0.0%)      *out_data = cbb->u.base.buf;
      .           }
  1,568 (0.0%)    if (out_len != NULL) {
  3,136 (0.0%)      *out_len = cbb->u.base.len;
      .           }
  1,568 (0.0%)    cbb->u.base.buf = NULL;
  2,352 (0.0%)    CBB_cleanup(cbb);
    784 (0.0%)    return 1;
  1,568 (0.0%)  }
      .         
 99,232 (0.0%)  static struct cbb_buffer_st *cbb_get_base(CBB *cbb) {
 99,232 (0.0%)    if (cbb->is_child) {
      .             return cbb->u.child.base;
      .           }
 49,616 (0.0%)    return &cbb->u.base;
 49,616 (0.0%)  }
      .         
      .         static void cbb_on_error(CBB *cbb) {
      .           // Due to C's lack of destructors and |CBB|'s auto-flushing API, a failing
      .           // |CBB|-taking function may leave a dangling pointer to a child |CBB|. As a
      .           // result, the convention is callers may not write to |CBB|s that have failed.
      .           // But, as a safety measure, we lock the |CBB| into an error state. Once the
      .           // error bit is set, |cbb->child| will not be read.
      .           //
-- line 164 ----------------------------------------
-- line 176 ----------------------------------------
      .           // warning does not know |cbb->child| will not be read once |error| is set
      .           // above.
      .           cbb->child = NULL;
      .         }
      .         
      .         // CBB_flush recurses and then writes out any pending length prefix. The
      .         // current length of the underlying base is taken to be the length of the
      .         // length-prefixed data.
 63,980 (0.0%)  int CBB_flush(CBB *cbb) {
      .           // If |base| has hit an error, the buffer is in an undefined state, so
      .           // fail all following calls. In particular, |cbb->child| may point to invalid
      .           // memory.
 51,184 (0.0%)    struct cbb_buffer_st *base = cbb_get_base(cbb);
 89,572 (0.0%)    if (base == NULL || base->error) {
      .             return 0;
      .           }
      .         
 51,184 (0.0%)    if (cbb->child == NULL) {
      .             // Nothing to flush.
 25,592 (0.0%)      return 1;
      .           }
      .         
      .           assert(cbb->child->is_child);
      .           struct cbb_child_st *child = &cbb->child->u.child;
      .           assert(child->base == base);
      .           size_t child_start = child->offset + child->pending_len_len;
      .         
      .           if (!CBB_flush(cbb->child) ||
-- line 203 ----------------------------------------
-- line 264 ----------------------------------------
      .           child->base = NULL;
      .           cbb->child = NULL;
      .         
      .           return 1;
      .         
      .         err:
      .           cbb_on_error(cbb);
      .           return 0;
 25,592 (0.0%)  }
      .         
      .         const uint8_t *CBB_data(const CBB *cbb) {
      .           assert(cbb->child == NULL);
      .           if (cbb->is_child) {
      .             return cbb->u.child.base->buf + cbb->u.child.offset +
      .                    cbb->u.child.pending_len_len;
      .           }
      .           return cbb->u.base.buf;
-- line 280 ----------------------------------------
-- line 397 ----------------------------------------
      .           uint8_t *out;
      .           if (!CBB_add_space(cbb, &out, len)) {
      .             return 0;
      .           }
      .           OPENSSL_memset(out, 0, len);
      .           return 1;
      .         }
      .         
 84,084 (0.0%)  int CBB_add_space(CBB *cbb, uint8_t **out_data, size_t len) {
 84,084 (0.0%)    if (!CBB_flush(cbb) ||
108,108 (0.0%)        !cbb_buffer_add(cbb_get_base(cbb), out_data, len)) {
      .             return 0;
      .           }
 12,012 (0.0%)    return 1;
 24,024 (0.0%)  }
      .         
      .         int CBB_reserve(CBB *cbb, uint8_t **out_data, size_t len) {
      .           if (!CBB_flush(cbb) ||
      .               !cbb_buffer_reserve(cbb_get_base(cbb), out_data, len)) {
      .             return 0;
      .           }
      .           return 1;
      .         }
-- line 419 ----------------------------------------
-- line 425 ----------------------------------------
      .               newlen < base->len ||
      .               newlen > base->cap) {
      .             return 0;
      .           }
      .           base->len = newlen;
      .           return 1;
      .         }
      .         
120,120 (0.0%)  static int cbb_add_u(CBB *cbb, uint64_t v, size_t len_len) {
      .           uint8_t *buf;
 96,096 (0.0%)    if (!CBB_add_space(cbb, &buf, len_len)) {
      .             return 0;
      .           }
      .         
132,132 (0.0%)    for (size_t i = len_len - 1; i < len_len; i--) {
 60,060 (0.0%)      buf[i] = v;
 12,012 (0.0%)      v >>= 8;
      .           }
      .         
      .           // |v| must fit in |len_len| bytes.
 24,024 (0.0%)    if (v != 0) {
      .             cbb_on_error(cbb);
      .             return 0;
      .           }
      .         
 12,012 (0.0%)    return 1;
 60,060 (0.0%)  }
      .         
 84,084 (0.0%)  int CBB_add_u8(CBB *cbb, uint8_t value) {
 72,072 (0.0%)    return cbb_add_u(cbb, value, 1);
 24,024 (0.0%)  }
      .         
      .         int CBB_add_u16(CBB *cbb, uint16_t value) {
      .           return cbb_add_u(cbb, value, 2);
      .         }
      .         
      .         int CBB_add_u16le(CBB *cbb, uint16_t value) {
      .           return CBB_add_u16(cbb, CRYPTO_bswap2(value));
      .         }
-- line 463 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 26 ----------------------------------------
      .         
      .         #include <string.h>
      .         
      .         #include "../asn1/internal.h"
      .         #include "../internal.h"
      .         #include "internal.h"
      .         
      .         
176,106 (0.1%)  void CBS_init(CBS *cbs, const uint8_t *data, size_t len) {
 88,053 (0.0%)    cbs->data = data;
 88,053 (0.0%)    cbs->len = len;
 88,053 (0.0%)  }
      .         
580,698 (0.2%)  static int cbs_get(CBS *cbs, const uint8_t **p, size_t n) {
387,132 (0.1%)    if (cbs->len < n) {
  4,464 (0.0%)      return 0;
      .           }
      .         
378,204 (0.1%)    *p = cbs->data;
567,306 (0.2%)    cbs->data += n;
567,306 (0.2%)    cbs->len -= n;
 94,551 (0.0%)    return 1;
193,566 (0.1%)  }
      .         
116,217 (0.0%)  int CBS_skip(CBS *cbs, size_t len) {
      .           const uint8_t *dummy;
 77,478 (0.0%)    return cbs_get(cbs, &dummy, len);
 64,565 (0.0%)  }
      .         
102,528 (0.0%)  const uint8_t *CBS_data(const CBS *cbs) { return cbs->data; }
      .         
667,472 (0.2%)  size_t CBS_len(const CBS *cbs) { return cbs->len; }
      .         
      .         int CBS_stow(const CBS *cbs, uint8_t **out_ptr, size_t *out_len) {
      .           OPENSSL_free(*out_ptr);
      .           *out_ptr = NULL;
      .           *out_len = 0;
      .         
      .           if (cbs->len == 0) {
      .             return 1;
-- line 65 ----------------------------------------
-- line 79 ----------------------------------------
      .           *out_ptr = OPENSSL_strndup((const char *)cbs->data, cbs->len);
      .           return (*out_ptr != NULL);
      .         }
      .         
      .         int CBS_contains_zero_byte(const CBS *cbs) {
      .           return OPENSSL_memchr(cbs->data, 0, cbs->len) != NULL;
      .         }
      .         
    812 (0.0%)  int CBS_mem_equal(const CBS *cbs, const uint8_t *data, size_t len) {
    464 (0.0%)    if (len != cbs->len) {
     80 (0.0%)      return 0;
      .           }
    760 (0.0%)    return CRYPTO_memcmp(cbs->data, data, len) == 0;
    232 (0.0%)  }
      .         
 12,370 (0.0%)  static int cbs_get_u(CBS *cbs, uint64_t *out, size_t len) {
  1,237 (0.0%)    uint64_t result = 0;
      .           const uint8_t *data;
      .         
  9,896 (0.0%)    if (!cbs_get(cbs, &data, len)) {
      .             return 0;
      .           }
 15,505 (0.0%)    for (size_t i = 0; i < len; i++) {
  2,330 (0.0%)      result <<= 8;
 13,980 (0.0%)      result |= data[i];
      .           }
  3,711 (0.0%)    *out = result;
  1,237 (0.0%)    return 1;
  6,185 (0.0%)  }
      .         
627,705 (0.2%)  int CBS_get_u8(CBS *cbs, uint8_t *out) {
      .           const uint8_t *v;
557,960 (0.2%)    if (!cbs_get(cbs, &v, 1)) {
  4,464 (0.0%)      return 0;
      .           }
270,052 (0.1%)    *out = *v;
 67,513 (0.0%)    return 1;
348,725 (0.1%)  }
      .         
      .         int CBS_get_u16(CBS *cbs, uint16_t *out) {
      .           uint64_t v;
      .           if (!cbs_get_u(cbs, &v, 2)) {
      .             return 0;
      .           }
      .           *out = v;
      .           return 1;
-- line 124 ----------------------------------------
-- line 172 ----------------------------------------
      .           if (cbs->len == 0) {
      .             return 0;
      .           }
      .           *out = cbs->data[cbs->len - 1];
      .           cbs->len--;
      .           return 1;
      .         }
      .         
128,880 (0.0%)  int CBS_get_bytes(CBS *cbs, CBS *out, size_t len) {
      .           const uint8_t *v;
103,104 (0.0%)    if (!cbs_get(cbs, &v, len)) {
      .             return 0;
      .           }
 77,328 (0.0%)    CBS_init(out, v, len);
 12,888 (0.0%)    return 1;
 64,440 (0.0%)  }
      .         
      .         int CBS_copy_bytes(CBS *cbs, uint8_t *out, size_t len) {
      .           const uint8_t *v;
      .           if (!cbs_get(cbs, &v, len)) {
      .             return 0;
      .           }
      .           OPENSSL_memcpy(out, v, len);
      .           return 1;
-- line 195 ----------------------------------------
-- line 272 ----------------------------------------
      .         
      .             // Values end at an octet with the high bit cleared.
      .           } while (b & 0x80);
      .         
      .           *out = v;
      .           return 1;
      .         }
      .         
116,010 (0.0%)  static int parse_asn1_tag(CBS *cbs, CBS_ASN1_TAG *out) {
      .           uint8_t tag_byte;
 90,230 (0.0%)    if (!CBS_get_u8(cbs, &tag_byte)) {
      4 (0.0%)      return 0;
      .           }
      .         
      .           // ITU-T X.690 section 8.1.2.3 specifies the format for identifiers with a tag
      .           // number no greater than 30.
      .           //
      .           // If the number portion is 31 (0x1f, the largest value that fits in the
      .           // allotted bits), then the tag is more than one byte long and the
      .           // continuation bytes contain the tag number.
 64,440 (0.0%)    CBS_ASN1_TAG tag = ((CBS_ASN1_TAG)tag_byte & 0xe0) << CBS_ASN1_TAG_SHIFT;
 51,552 (0.0%)    CBS_ASN1_TAG tag_number = tag_byte & 0x1f;
 25,776 (0.0%)    if (tag_number == 0x1f) {
      .             uint64_t v;
      .             if (!parse_base128_integer(cbs, &v) ||
      .                 // Check the tag number is within our supported bounds.
      .                 v > CBS_ASN1_TAG_NUMBER_MASK ||
      .                 // Small tag numbers should have used low tag number form, even in BER.
      .                 v < 0x1f) {
      .               return 0;
      .             }
      .             tag_number = (CBS_ASN1_TAG)v;
      .           }
      .         
 25,776 (0.0%)    tag |= tag_number;
      .         
      .           // Tag [UNIVERSAL 0] is reserved for use by the encoding. Reject it here to
      .           // avoid some ambiguity around ANY values and BER indefinite-length EOCs. See
      .           // https://crbug.com/boringssl/455.
 51,552 (0.0%)    if ((tag & ~CBS_ASN1_CONSTRUCTED) == 0) {
      .             return 0;
      .           }
      .         
 38,664 (0.0%)    *out = tag;
 12,888 (0.0%)    return 1;
 64,450 (0.0%)  }
      .         
      .         static int cbs_get_any_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
      .                                             size_t *out_header_len, int *out_ber_found,
180,432 (0.1%)                                      int *out_indefinite, int ber_ok) {
 64,440 (0.0%)    CBS header = *cbs;
      .           CBS throwaway;
      .         
 25,776 (0.0%)    if (out == NULL) {
      .             out = &throwaway;
      .           }
 25,776 (0.0%)    if (ber_ok) {
 23,616 (0.0%)      *out_ber_found = 0;
 35,424 (0.0%)      *out_indefinite = 0;
      .           } else {
  2,160 (0.0%)      assert(out_ber_found == NULL);
  2,160 (0.0%)      assert(out_indefinite == NULL);
      .           }
      .         
      .           CBS_ASN1_TAG tag;
 90,216 (0.0%)    if (!parse_asn1_tag(&header, &tag)) {
      .             return 0;
      .           }
 25,776 (0.0%)    if (out_tag != NULL) {
 38,664 (0.0%)      *out_tag = tag;
      .           }
      .         
      .           uint8_t length_byte;
 90,216 (0.0%)    if (!CBS_get_u8(&header, &length_byte)) {
      .             return 0;
      .           }
      .         
128,880 (0.0%)    size_t header_len = CBS_len(cbs) - CBS_len(&header);
      .         
      .           size_t len;
      .           // The format for the length encoding is specified in ITU-T X.690 section
      .           // 8.1.3.
 38,664 (0.0%)    if ((length_byte & 0x80) == 0) {
      .             // Short form length.
 58,255 (0.0%)      len = ((size_t)length_byte) + header_len;
 23,302 (0.0%)      if (out_header_len != NULL) {
 46,604 (0.0%)        *out_header_len = header_len;
      .             }
      .           } else {
      .             // The high bit indicate that this is the long form, while the next 7 bits
      .             // encode the number of subsequent octets used to encode the length (ITU-T
      .             // X.690 clause 8.1.3.5.b).
  4,948 (0.0%)      const size_t num_bytes = length_byte & 0x7f;
      .             uint64_t len64;
      .         
  6,772 (0.0%)      if (ber_ok && (tag & CBS_ASN1_CONSTRUCTED) != 0 && num_bytes == 0) {
      .               // indefinite length
      .               if (out_header_len != NULL) {
      .                 *out_header_len = header_len;
      .               }
      .               *out_ber_found = 1;
      .               *out_indefinite = 1;
      .               return CBS_get_bytes(cbs, out, header_len);
      .             }
      .         
      .             // ITU-T X.690 clause 8.1.3.5.c specifies that the value 0xff shall not be
      .             // used as the first byte of the length. If this parser encounters that
      .             // value, num_bytes will be parsed as 127, which will fail this check.
  4,948 (0.0%)      if (num_bytes == 0 || num_bytes > 4) {
      .               return 0;
      .             }
  9,896 (0.0%)      if (!cbs_get_u(&header, &len64, num_bytes)) {
      .               return 0;
      .             }
      .             // ITU-T X.690 section 10.1 (DER length forms) requires encoding the
      .             // length with the minimum number of octets. BER could, technically, have
      .             // 125 superfluous zero bytes. We do not attempt to handle that and still
      .             // require that the length fit in a |uint32_t| for BER.
  3,711 (0.0%)      if (len64 < 128) {
      .               // Length should have used short-form encoding.
      .               if (ber_ok) {
      .                 *out_ber_found = 1;
      .               } else {
      .                 return 0;
      .               }
      .             }
 11,133 (0.0%)      if ((len64 >> ((num_bytes - 1) * 8)) == 0) {
      .               // Length should have been at least one byte shorter.
      .               if (ber_ok) {
      .                 *out_ber_found = 1;
      .               } else {
      .                 return 0;
      .               }
      .             }
  2,474 (0.0%)      len = len64;
  8,659 (0.0%)      if (len + header_len + num_bytes < len) {
      .               // Overflow.
      .               return 0;
      .             }
  4,948 (0.0%)      len += header_len + num_bytes;
  2,474 (0.0%)      if (out_header_len != NULL) {
  6,185 (0.0%)        *out_header_len = header_len + num_bytes;
      .             }
      .           }
      .         
 77,328 (0.0%)    return CBS_get_bytes(cbs, out, len);
 77,328 (0.0%)  }
      .         
      .         int CBS_get_any_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag) {
      .           size_t header_len;
      .           if (!CBS_get_any_asn1_element(cbs, out, out_tag, &header_len)) {
      .             return 0;
      .           }
      .         
      .           if (!CBS_skip(out, header_len)) {
-- line 426 ----------------------------------------
-- line 427 ----------------------------------------
      .             assert(0);
      .             return 0;
      .           }
      .         
      .           return 1;
      .         }
      .         
      .         int CBS_get_any_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
  8,640 (0.0%)                               size_t *out_header_len) {
 11,880 (0.0%)    return cbs_get_any_asn1_element(cbs, out, out_tag, out_header_len, NULL, NULL,
      .                                           /*ber_ok=*/0);
  2,160 (0.0%)  }
      .         
      .         int CBS_get_any_ber_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
      .                                          size_t *out_header_len, int *out_ber_found,
153,504 (0.1%)                                   int *out_indefinite) {
      .           int ber_found_temp;
177,120 (0.1%)    return cbs_get_any_asn1_element(
      .               cbs, out, out_tag, out_header_len,
      .               out_ber_found ? out_ber_found : &ber_found_temp, out_indefinite,
      .               /*ber_ok=*/1);
 59,040 (0.0%)  }
      .         
      .         static int cbs_get_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value,
 11,880 (0.0%)                          int skip_header) {
      .           size_t header_len;
      .           CBS_ASN1_TAG tag;
      .           CBS throwaway;
      .         
  2,160 (0.0%)    if (out == NULL) {
      .             out = &throwaway;
      .           }
      .         
 10,800 (0.0%)    if (!CBS_get_any_asn1_element(cbs, out, &tag, &header_len) ||
  1,080 (0.0%)        tag != tag_value) {
      .             return 0;
      .           }
      .         
  9,720 (0.0%)    if (skip_header && !CBS_skip(out, header_len)) {
      .             assert(0);
      .             return 0;
      .           }
      .         
  1,080 (0.0%)    return 1;
  5,400 (0.0%)  }
      .         
  7,560 (0.0%)  int CBS_get_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value) {
  6,480 (0.0%)    return cbs_get_asn1(cbs, out, tag_value, 1 /* skip header */);
  2,160 (0.0%)  }
      .         
      .         int CBS_get_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value) {
      .           return cbs_get_asn1(cbs, out, tag_value, 0 /* include header */);
      .         }
      .         
     18 (0.0%)  int CBS_peek_asn1_tag(const CBS *cbs, CBS_ASN1_TAG tag_value) {
     10 (0.0%)    CBS copy = *cbs;
      .           CBS_ASN1_TAG actual_tag;
     16 (0.0%)    return parse_asn1_tag(&copy, &actual_tag) && tag_value == actual_tag;
     10 (0.0%)  }
      .         
     18 (0.0%)  int CBS_get_asn1_uint64(CBS *cbs, uint64_t *out) {
      .           CBS bytes;
     20 (0.0%)    if (!CBS_get_asn1(cbs, &bytes, CBS_ASN1_INTEGER) ||
      6 (0.0%)        !CBS_is_unsigned_asn1_integer(&bytes)) {
      .             return 0;
      .           }
      .         
      4 (0.0%)    *out = 0;
      8 (0.0%)    const uint8_t *data = CBS_data(&bytes);
      8 (0.0%)    size_t len = CBS_len(&bytes);
     18 (0.0%)    for (size_t i = 0; i < len; i++) {
     10 (0.0%)      if ((*out >> 56) != 0) {
      .               // Too large to represent as a uint64_t.
      .               return 0;
      .             }
     12 (0.0%)      *out <<= 8;
     20 (0.0%)      *out |= data[i];
      .           }
      .         
      2 (0.0%)    return 1;
     10 (0.0%)  }
      .         
      .         int CBS_get_asn1_int64(CBS *cbs, int64_t *out) {
      .           int is_negative;
      .           CBS bytes;
      .           if (!CBS_get_asn1(cbs, &bytes, CBS_ASN1_INTEGER) ||
      .               !CBS_is_valid_asn1_integer(&bytes, &is_negative)) {
      .             return 0;
      .           }
-- line 515 ----------------------------------------
-- line 670 ----------------------------------------
      .         
      .           // Unused bits are zero, and this function does not distinguish between
      .           // missing and unset bits. Thus it is sufficient to do a byte-level length
      .           // check.
      .           return byte_num < CBS_len(cbs) &&
      .                  (CBS_data(cbs)[byte_num] & (1 << bit_num)) != 0;
      .         }
      .         
  4,698 (0.0%)  int CBS_is_valid_asn1_integer(const CBS *cbs, int *out_is_negative) {
  2,610 (0.0%)    CBS copy = *cbs;
      .           uint8_t first_byte, second_byte;
  3,654 (0.0%)    if (!CBS_get_u8(&copy, &first_byte)) {
      .             return 0;  // INTEGERs may not be empty.
      .           }
  1,044 (0.0%)    if (out_is_negative != NULL) {
  2,610 (0.0%)      *out_is_negative = (first_byte & 0x80) != 0;
      .           }
  3,654 (0.0%)    if (!CBS_get_u8(&copy, &second_byte)) {
    338 (0.0%)      return 1;  // One byte INTEGERs are always minimal.
      .           }
  2,152 (0.0%)    if ((first_byte == 0x00 && (second_byte & 0x80) == 0) ||
    353 (0.0%)        (first_byte == 0xff && (second_byte & 0x80) != 0)) {
      .             return 0;  // The value is minimal iff the first 9 bits are not all equal.
      .           }
    353 (0.0%)    return 1;
  2,610 (0.0%)  }
      .         
     16 (0.0%)  int CBS_is_unsigned_asn1_integer(const CBS *cbs) {
      .           int is_negative;
     24 (0.0%)    return CBS_is_valid_asn1_integer(cbs, &is_negative) && !is_negative;
     10 (0.0%)  }
      .         
      .         static int add_decimal(CBB *out, uint64_t v) {
      .           char buf[DECIMAL_SIZE(uint64_t) + 1];
      .           snprintf(buf, sizeof(buf), "%" PRIu64, v);
      .           return CBB_add_bytes(out, (const uint8_t *)buf, strlen(buf));
      .         }
      .         
 16,488 (0.0%)  int CBS_is_valid_asn1_oid(const CBS *cbs) {
 10,305 (0.0%)    if (CBS_len(cbs) == 0) {
      .             return 0;  // OID encodings cannot be empty.
      .           }
      .         
 10,305 (0.0%)    CBS copy = *cbs;
  2,061 (0.0%)    uint8_t v, prev = 0;
 78,571 (0.0%)    while (CBS_get_u8(&copy, &v)) {
      .             // OID encodings are a sequence of minimally-encoded base-128 integers (see
      .             // |parse_base128_integer|). If |prev|'s MSB was clear, it was the last byte
      .             // of an integer (or |v| is the first byte). |v| is then the first byte of
      .             // the next integer. If first byte of an integer is 0x80, it is not
      .             // minimally-encoded.
 49,380 (0.0%)      if ((prev & 0x80) == 0 && v == 0x80) {
      .               return 0;
      .             }
 17,738 (0.0%)      prev = v;
      .           }
      .         
      .           // The last byte should must end an integer encoding.
  8,244 (0.0%)    return (prev & 0x80) == 0;
 10,305 (0.0%)  }
      .         
      .         char *CBS_asn1_oid_to_text(const CBS *cbs) {
      .           CBB cbb;
      .           if (!CBB_init(&cbb, 32)) {
      .             goto err;
      .           }
      .         
      .           CBS copy = *cbs;
-- line 737 ----------------------------------------
-- line 766 ----------------------------------------
      .         
      .           return (char *)txt;
      .         
      .         err:
      .           CBB_cleanup(&cbb);
      .           return NULL;
      .         }
      .         
 16,020 (0.0%)  static int cbs_get_two_digits(CBS *cbs, int *out) {
      .           uint8_t first_digit, second_digit;
 12,460 (0.0%)    if (!CBS_get_u8(cbs, &first_digit)) {
      .             return 0;
      .           }
 10,680 (0.0%)    if (!OPENSSL_isdigit(first_digit)) {
      .             return 0;
      .           }
 12,460 (0.0%)    if (!CBS_get_u8(cbs, &second_digit)) {
      .             return 0;
      .           }
 10,680 (0.0%)    if (!OPENSSL_isdigit(second_digit)) {
      .             return 0;
      .           }
 24,920 (0.0%)    *out = (first_digit - '0') * 10 + (second_digit - '0');
  1,780 (0.0%)    return 1;
  8,900 (0.0%)  }
      .         
  1,776 (0.0%)  static int is_valid_day(int year, int month, int day) {
    592 (0.0%)    if (day < 1) {
      .             return 0;
      .           }
  5,240 (0.0%)    switch (month) {
      .             case 1:
      .             case 3:
      .             case 5:
      .             case 7:
      .             case 8:
      .             case 10:
      .             case 12:
    744 (0.0%)        return day <= 31;
      .             case 4:
      .             case 6:
      .             case 9:
      .             case 11:
    328 (0.0%)        return day <= 30;
      .             case 2:
    476 (0.0%)        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
     24 (0.0%)          return day <= 29;
      .               } else {
     88 (0.0%)          return day <= 28;
      .               }
      .             default:
      .               return 0;
      .           }
    592 (0.0%)  }
      .         
      .         static int CBS_parse_rfc5280_time_internal(const CBS *cbs, int is_gentime,
      .                                                    int allow_timezone_offset,
  3,256 (0.0%)                                             struct tm *out_tm) {
      .           int year, month, day, hour, min, sec, tmp;
  1,480 (0.0%)    CBS copy = *cbs;
      .           uint8_t tz;
      .         
    592 (0.0%)    if (is_gentime) {
     28 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
      .               return 0;
      .             }
     12 (0.0%)      year = tmp * 100;
     28 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
      .               return 0;
      .             }
     12 (0.0%)      year += tmp;
      .           } else {
    292 (0.0%)      year = 1900;
  2,044 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
      .               return 0;
      .             }
    584 (0.0%)      year += tmp;
    584 (0.0%)      if (year < 1950) {
    290 (0.0%)        year += 100;
      .             }
    584 (0.0%)      if (year >= 2050) {
      .               return 0;  // A Generalized time must be used.
      .             }
      .           }
  3,552 (0.0%)    if (!cbs_get_two_digits(&copy, &month) || month < 1 ||
    888 (0.0%)        month > 12 ||  // Reject invalid months.
  2,072 (0.0%)        !cbs_get_two_digits(&copy, &day) ||
  2,368 (0.0%)        !is_valid_day(year, month, day) ||  // Reject invalid days.
  2,072 (0.0%)        !cbs_get_two_digits(&copy, &hour) ||
    888 (0.0%)        hour > 23 ||  // Reject invalid hours.
  2,072 (0.0%)        !cbs_get_two_digits(&copy, &min) ||
    888 (0.0%)        min > 59 ||  // Reject invalid minutes.
  4,440 (0.0%)        !cbs_get_two_digits(&copy, &sec) || sec > 59 || !CBS_get_u8(&copy, &tz)) {
      .             return 0;
      .           }
      .         
    296 (0.0%)    int offset_sign = 0;
  1,184 (0.0%)    switch (tz) {
      .             case 'Z':
    296 (0.0%)        break;  // We correctly have 'Z' on the end as per spec.
      .             case '+':
      .               offset_sign = 1;
      .               break;  // Should not be allowed per RFC 5280.
      .             case '-':
      .               offset_sign = -1;
      .               break;  // Should not be allowed per RFC 5280.
      .             default:
      .               return 0;  // Reject anything else after the time.
-- line 873 ----------------------------------------
-- line 880 ----------------------------------------
      .           // are now difficult to change. These certificates were generated with the
      .           // 'openssl' command that permissively allowed the creation of certificates
      .           // with notBefore and notAfter times specified as strings for direct
      .           // certificate inclusion on the command line. For context see cl/237068815.
      .           //
      .           // TODO(bbe): This has been expunged from public web-pki as the ecosystem has
      .           // managed to encourage CA compliance with standards. We should find a way to
      .           // get rid of this or make it off by default.
    296 (0.0%)    int offset_seconds = 0;
    592 (0.0%)    if (offset_sign != 0) {
      .             if (!allow_timezone_offset) {
      .               return 0;
      .             }
      .             int offset_hours, offset_minutes;
      .             if (!cbs_get_two_digits(&copy, &offset_hours) ||
      .                 offset_hours > 23 ||  // Reject invalid hours.
      .                 !cbs_get_two_digits(&copy, &offset_minutes) ||
      .                 offset_minutes > 59) {  // Reject invalid minutes.
      .               return 0;
      .             }
      .             offset_seconds = offset_sign * (offset_hours * 3600 + offset_minutes * 60);
      .           }
      .         
  1,480 (0.0%)    if (CBS_len(&copy) != 0) {
      .             return 0;  // Reject invalid lengths.
      .           }
      .         
    592 (0.0%)    if (out_tm != NULL) {
      .             // Fill in the tm fields corresponding to what we validated.
      .             out_tm->tm_year = year - 1900;
      .             out_tm->tm_mon = month - 1;
      .             out_tm->tm_mday = day;
      .             out_tm->tm_hour = hour;
      .             out_tm->tm_min = min;
      .             out_tm->tm_sec = sec;
      .             if (offset_seconds && !OPENSSL_gmtime_adj(out_tm, 0, offset_seconds)) {
      .               return 0;
      .             }
      .           }
    296 (0.0%)    return 1;
  1,480 (0.0%)  }
      .         
      .         int CBS_parse_generalized_time(const CBS *cbs, struct tm *out_tm,
     28 (0.0%)                                 int allow_timezone_offset) {
     24 (0.0%)    return CBS_parse_rfc5280_time_internal(cbs, 1, allow_timezone_offset, out_tm);
      8 (0.0%)  }
      .         
      .         int CBS_parse_utc_time(const CBS *cbs, struct tm *out_tm,
  2,044 (0.0%)                         int allow_timezone_offset) {
  1,752 (0.0%)    return CBS_parse_rfc5280_time_internal(cbs, 0, allow_timezone_offset, out_tm);
    584 (0.0%)  }
      .         
      .         int CBS_get_optional_asn1_int64(CBS *cbs, int64_t *out, CBS_ASN1_TAG tag,
      .                                         int64_t default_value) {
      .           CBS child;
      .           int present;
      .           if (!CBS_get_optional_asn1(cbs, &child, &present, tag)) {
      .             return 0;
      .           }
-- line 938 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 12 ----------------------------------------
      .          * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
      .          * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
      .         
      .         #include <openssl/bytestring.h>
      .         
      .         #include "internal.h"
      .         
      .         
 44,976 (0.0%)  static int is_valid_code_point(uint32_t v) {
      .           // References in the following are to Unicode 9.0.0.
 22,488 (0.0%)    if (// The Unicode space runs from zero to 0x10ffff (3.4 D9).
 22,488 (0.0%)        v > 0x10ffff ||
      .               // Values 0x...fffe, 0x...ffff, and 0xfdd0-0xfdef are permanently reserved
      .               // (3.4 D14)
 44,976 (0.0%)        (v & 0xfffe) == 0xfffe ||
 22,488 (0.0%)        (v >= 0xfdd0 && v <= 0xfdef) ||
      .               // Surrogate code points are invalid (3.2 C1).
      .               (v >= 0xd800 && v <= 0xdfff)) {
      .             return 0;
      .           }
 11,244 (0.0%)    return 1;
 22,488 (0.0%)  }
      .         
      .         // BOTTOM_BITS returns a byte with the bottom |n| bits set.
      .         #define BOTTOM_BITS(n) (uint8_t)((1u << (n)) - 1)
      .         
      .         // TOP_BITS returns a byte with the top |n| bits set.
      .         #define TOP_BITS(n) ((uint8_t)~BOTTOM_BITS(8 - (n)))
      .         
 49,653 (0.0%)  int cbs_get_utf8(CBS *cbs, uint32_t *out) {
      .           uint8_t c;
 38,619 (0.0%)    if (!CBS_get_u8(cbs, &c)) {
      .             return 0;
      .           }
 16,551 (0.0%)    if (c <= 0x7f) {
 22,004 (0.0%)      *out = c;
 11,002 (0.0%)      return 1;
      .           }
      .           uint32_t v, lower_bound;
      .           size_t len;
     80 (0.0%)    if ((c & TOP_BITS(3)) == TOP_BITS(2)) {
     64 (0.0%)      v = c & BOTTOM_BITS(5);
     16 (0.0%)      len = 1;
     32 (0.0%)      lower_bound = 0x80;
      .           } else if ((c & TOP_BITS(4)) == TOP_BITS(3)) {
      .             v = c & BOTTOM_BITS(4);
      .             len = 2;
      .             lower_bound = 0x800;
      .           } else if ((c & TOP_BITS(5)) == TOP_BITS(4)) {
      .             v = c & BOTTOM_BITS(3);
      .             len = 3;
      .             lower_bound = 0x10000;
      .           } else {
      .             return 0;
      .           }
    144 (0.0%)    for (size_t i = 0; i < len; i++) {
    144 (0.0%)      if (!CBS_get_u8(cbs, &c) ||
     48 (0.0%)          (c & TOP_BITS(2)) != TOP_BITS(1)) {
      .               return 0;
      .             }
     16 (0.0%)      v <<= 6;
     64 (0.0%)      v |= c & BOTTOM_BITS(6);
      .           }
    128 (0.0%)    if (!is_valid_code_point(v) ||
      .               v < lower_bound) {
      .             return 0;
      .           }
     48 (0.0%)    *out = v;
     16 (0.0%)    return 1;
 27,585 (0.0%)  }
      .         
202,104 (0.1%)  int cbs_get_latin1(CBS *cbs, uint32_t *out) {
      .           uint8_t c;
157,192 (0.1%)    if (!CBS_get_u8(cbs, &c)) {
      .             return 0;
      .           }
 89,824 (0.0%)    *out = c;
 22,456 (0.0%)    return 1;
112,280 (0.0%)  }
      .         
      .         int cbs_get_ucs2_be(CBS *cbs, uint32_t *out) {
      .           // Note UCS-2 (used by BMPString) does not support surrogates.
      .           uint16_t c;
      .           if (!CBS_get_u16(cbs, &c) ||
      .               !is_valid_code_point(c)) {
      .             return 0;
      .           }
-- line 98 ----------------------------------------
-- line 99 ----------------------------------------
      .           *out = c;
      .           return 1;
      .         }
      .         
      .         int cbs_get_utf32_be(CBS *cbs, uint32_t *out) {
      .           return CBS_get_u32(cbs, out) && is_valid_code_point(*out);
      .         }
      .         
 66,980 (0.0%)  size_t cbb_get_utf8_len(uint32_t u) {
 33,490 (0.0%)    if (u <= 0x7f) {
 33,458 (0.0%)      return 1;
      .           }
     32 (0.0%)    if (u <= 0x7ff) {
     32 (0.0%)      return 2;
      .           }
      .           if (u <= 0xffff) {
      .             return 3;
      .           }
      .           return 4;
 33,490 (0.0%)  }
      .         
 67,368 (0.0%)  int cbb_add_utf8(CBB *cbb, uint32_t u) {
 56,140 (0.0%)    if (!is_valid_code_point(u)) {
      .             return 0;
      .           }
 22,456 (0.0%)    if (u <= 0x7f) {
 78,596 (0.0%)      return CBB_add_u8(cbb, (uint8_t)u);
      .           }
      .           if (u <= 0x7ff) {
      .             return CBB_add_u8(cbb, TOP_BITS(2) | (u >> 6)) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | (u & BOTTOM_BITS(6)));
      .           }
      .           if (u <= 0xffff) {
      .             return CBB_add_u8(cbb, TOP_BITS(3) | (u >> 12)) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | ((u >> 6) & BOTTOM_BITS(6))) &&
-- line 133 ----------------------------------------
-- line 135 ----------------------------------------
      .           }
      .           if (u <= 0x10ffff) {
      .             return CBB_add_u8(cbb, TOP_BITS(4) | (u >> 18)) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | ((u >> 12) & BOTTOM_BITS(6))) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | ((u >> 6) & BOTTOM_BITS(6))) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | (u & BOTTOM_BITS(6)));
      .           }
      .           return 0;
 22,456 (0.0%)  }
      .         
      .         int cbb_add_latin1(CBB *cbb, uint32_t u) {
      .           return u <= 0xff && CBB_add_u8(cbb, (uint8_t)u);
      .         }
      .         
      .         int cbb_add_ucs2_be(CBB *cbb, uint32_t u) {
      .           return u <= 0xffff && is_valid_code_point(u) && CBB_add_u16(cbb, (uint16_t)u);
      .         }
-- line 151 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h
--------------------------------------------------------------------------------
Ir______________ 

-- line 235 ----------------------------------------
        .         
        .         typedef uint8_t stack_align_type;
        .         OPENSSL_STATIC_ASSERT(sizeof(stack_align_type) == 1,
        .                               stack_align_type_is_not_8_bits_long)
        .         
        .         // align_pointer returns |ptr|, advanced to |alignment|. |alignment| must be a
        .         // power of two, and |ptr| must have at least |alignment - 1| bytes of scratch
        .         // space.
       10 (0.0%)  static inline void *align_pointer(void *ptr, size_t alignment) {
        .           // |alignment| must be a power of two.
       14 (0.0%)    assert(alignment != 0 && (alignment & (alignment - 1)) == 0);
        .           // Instead of aligning |ptr| as a |uintptr_t| and casting back, compute the
        .           // offset and advance in pointer space. C guarantees that casting from pointer
        .           // to |uintptr_t| and back gives the same pointer, but general
        .           // integer-to-pointer conversions are implementation-defined. GCC does define
        .           // it in the useful way, but this makes fewer assumptions.
       14 (0.0%)    uintptr_t offset = (0u - (uintptr_t)ptr) & (alignment - 1);
        4 (0.0%)    ptr = (char *)ptr + offset;
       12 (0.0%)    assert(((uintptr_t)ptr & (alignment - 1)) == 0);
        2 (0.0%)    return ptr;
        4 (0.0%)  }
        .         
        .         
        .         // Constant-time utility functions.
        .         //
        .         // The following methods return a bitmask of all ones (0xff...f) for true and 0
        .         // for false. This is useful for choosing a value based on the result of a
        .         // conditional in constant time. For example,
        .         //
-- line 263 ----------------------------------------
-- line 293 ----------------------------------------
        .         
        .         // value_barrier_w returns |a|, but prevents GCC and Clang from reasoning about
        .         // the returned value. This is used to mitigate compilers undoing constant-time
        .         // code, until we can express our requirements directly in the language.
        .         //
        .         // Note the compiler is aware that |value_barrier_w| has no side effects and
        .         // always has the same output for a given input. This allows it to eliminate
        .         // dead code, move computations across loops, and vectorize.
3,317,808 (1.1%)  static inline crypto_word_t value_barrier_w(crypto_word_t a) {
        .         #if defined(__GNUC__) || defined(__clang__)
2,211,872 (0.7%)    __asm__("" : "+r"(a) : /* no inputs */);
        .         #endif
1,105,936 (0.4%)    return a;
2,211,872 (0.7%)  }
        .         
        .         // value_barrier_u32 behaves like |value_barrier_w| but takes a |uint32_t|.
       12 (0.0%)  static inline uint32_t value_barrier_u32(uint32_t a) {
        .         #if defined(__GNUC__) || defined(__clang__)
        8 (0.0%)    __asm__("" : "+r"(a) : /* no inputs */);
        .         #endif
        4 (0.0%)    return a;
        8 (0.0%)  }
        .         
        .         // value_barrier_u64 behaves like |value_barrier_w| but takes a |uint64_t|.
        .         static inline uint64_t value_barrier_u64(uint64_t a) {
        .         #if defined(__GNUC__) || defined(__clang__)
        .           __asm__("" : "+r"(a) : /* no inputs */);
        .         #endif
        .           return a;
        .         }
        .         
        .         // constant_time_msb_w returns the given value with the MSB copied to all the
        .         // other bits.
  582,162 (0.2%)  static inline crypto_word_t constant_time_msb_w(crypto_word_t a) {
  388,108 (0.1%)    return 0u - (a >> (sizeof(a) * 8 - 1));
  388,108 (0.1%)  }
        .         
        .         // constant_time_lt_w returns 0xff..f if a < b and 0 otherwise.
        .         static inline crypto_word_t constant_time_lt_w(crypto_word_t a,
  484,820 (0.2%)                                                 crypto_word_t b) {
        .           // Consider the two cases of the problem:
        .           //   msb(a) == msb(b): a < b iff the MSB of a - b is set.
        .           //   msb(a) != msb(b): a < b iff the MSB of b is set.
        .           //
        .           // If msb(a) == msb(b) then the following evaluates as:
        .           //   msb(a^((a^b)|((a-b)^a))) ==
        .           //   msb(a^((a-b) ^ a))       ==   (because msb(a^b) == 0)
        .           //   msb(a^a^(a-b))           ==   (rearranging)
-- line 340 ----------------------------------------
-- line 355 ----------------------------------------
        .           // )
        .           //
        .           // (declare-fun a () (_ BitVec 32))
        .           // (declare-fun b () (_ BitVec 32))
        .           //
        .           // (assert (not (= (= #x00000001 (bvlshr (lt a b) #x0000001f)) (bvult a b))))
        .           // (check-sat)
        .           // (get-model)
  969,640 (0.3%)    return constant_time_msb_w(a^((a^b)|((a-b)^a)));
  193,928 (0.1%)  }
        .         
        .         // constant_time_lt_8 acts like |constant_time_lt_w| but returns an 8-bit
        .         // mask.
        .         static inline uint8_t constant_time_lt_8(crypto_word_t a, crypto_word_t b) {
        .           return (uint8_t)(constant_time_lt_w(a, b));
        .         }
        .         
        .         // constant_time_ge_w returns 0xff..f if a >= b and 0 otherwise.
-- line 372 ----------------------------------------
-- line 377 ----------------------------------------
        .         
        .         // constant_time_ge_8 acts like |constant_time_ge_w| but returns an 8-bit
        .         // mask.
        .         static inline uint8_t constant_time_ge_8(crypto_word_t a, crypto_word_t b) {
        .           return (uint8_t)(constant_time_ge_w(a, b));
        .         }
        .         
        .         // constant_time_is_zero returns 0xff..f if a == 0 and 0 otherwise.
  388,360 (0.1%)  static inline crypto_word_t constant_time_is_zero_w(crypto_word_t a) {
        .           // Here is an SMT-LIB verification of this formula:
        .           //
        .           // (define-fun is_zero ((a (_ BitVec 32))) (_ BitVec 32)
        .           //   (bvand (bvnot a) (bvsub a #x00000001))
        .           // )
        .           //
        .           // (declare-fun a () (_ BitVec 32))
        .           //
        .           // (assert (not (= (= #x00000001 (bvlshr (is_zero a) #x0000001f)) (= a #x00000000))))
        .           // (check-sat)
        .           // (get-model)
  776,720 (0.3%)    return constant_time_msb_w(~a & (a - 1));
  194,180 (0.1%)  }
        .         
        .         // constant_time_is_zero_8 acts like |constant_time_is_zero_w| but returns an
        .         // 8-bit mask.
        .         static inline uint8_t constant_time_is_zero_8(crypto_word_t a) {
        .           return (uint8_t)(constant_time_is_zero_w(a));
        .         }
        .         
        .         // constant_time_eq_w returns 0xff..f if a == b and 0 otherwise.
        .         static inline crypto_word_t constant_time_eq_w(crypto_word_t a,
  484,810 (0.2%)                                                 crypto_word_t b) {
  387,848 (0.1%)    return constant_time_is_zero_w(a ^ b);
  193,924 (0.1%)  }
        .         
        .         // constant_time_eq_8 acts like |constant_time_eq_w| but returns an 8-bit
        .         // mask.
        .         static inline uint8_t constant_time_eq_8(crypto_word_t a, crypto_word_t b) {
        .           return (uint8_t)(constant_time_eq_w(a, b));
        .         }
        .         
        .         // constant_time_eq_int acts like |constant_time_eq_w| but works on int
-- line 418 ----------------------------------------
-- line 427 ----------------------------------------
        .           return constant_time_eq_8((crypto_word_t)(a), (crypto_word_t)(b));
        .         }
        .         
        .         // constant_time_select_w returns (mask & a) | (~mask & b). When |mask| is all
        .         // 1s or all 0s (as returned by the methods above), the select methods return
        .         // either |a| (if |mask| is nonzero) or |b| (if |mask| is zero).
        .         static inline crypto_word_t constant_time_select_w(crypto_word_t mask,
        .                                                            crypto_word_t a,
3,870,776 (1.3%)                                                     crypto_word_t b) {
        .           // Clang recognizes this pattern as a select. While it usually transforms it
        .           // to a cmov, it sometimes further transforms it into a branch, which we do
        .           // not want.
        .           //
        .           // Adding barriers to both |mask| and |~mask| breaks the relationship between
        .           // the two, which makes the compiler stick with bitmasks.
6,082,648 (2.0%)    return (value_barrier_w(mask) & a) | (value_barrier_w(~mask) & b);
1,658,904 (0.5%)  }
        .         
        .         // constant_time_select_8 acts like |constant_time_select| but operates on
        .         // 8-bit values.
        .         static inline uint8_t constant_time_select_8(uint8_t mask, uint8_t a,
        .                                                      uint8_t b) {
        .           return (uint8_t)(constant_time_select_w(mask, a, b));
        .         }
        .         
        .         // constant_time_select_int acts like |constant_time_select| but operates on
        .         // ints.
1,164,300 (0.4%)  static inline int constant_time_select_int(crypto_word_t mask, int a, int b) {
1,552,400 (0.5%)    return (int)(constant_time_select_w(mask, (crypto_word_t)(a),
        .                                               (crypto_word_t)(b)));
  388,100 (0.1%)  }
        .         
        .         #if defined(BORINGSSL_CONSTANT_TIME_VALIDATION)
        .         
        .         // CONSTTIME_SECRET takes a pointer and a number of bytes and marks that region
        .         // of memory as secret. Secret data is tracked as it flows to registers and
        .         // other parts of a memory. If secret data is used as a condition for a branch,
        .         // or as a memory index, it will trigger warnings in valgrind.
        .         #define CONSTTIME_SECRET(ptr, len) VALGRIND_MAKE_MEM_UNDEFINED(ptr, len)
-- line 465 ----------------------------------------
-- line 487 ----------------------------------------
        .           // significantly impact optimizations.
        .           //
        .           // Thus, to be safe, stick a value barrier, in hopes of comparably inhibiting
        .           // compiler analysis.
        .           CONSTTIME_DECLASSIFY(&v, sizeof(v));
        .           return value_barrier_w(v);
        .         }
        .         
       16 (0.0%)  static inline int constant_time_declassify_int(int v) {
        .           OPENSSL_STATIC_ASSERT(sizeof(uint32_t) == sizeof(int),
        .                         int_is_not_the_same_size_as_uint32_t);
        .           // See comment above.
        .           CONSTTIME_DECLASSIFY(&v, sizeof(v));
       12 (0.0%)    return value_barrier_u32(v);
        8 (0.0%)  }
        .         
        .         
        .         // Thread-safe initialisation.
        .         
        .         #if !defined(OPENSSL_THREADS)
        .         typedef uint32_t CRYPTO_once_t;
        .         #define CRYPTO_ONCE_INIT 0
        .         #elif defined(OPENSSL_WINDOWS_THREADS)
-- line 509 ----------------------------------------
-- line 800 ----------------------------------------
        .         static inline uint64_t CRYPTO_bswap8(uint64_t x) {
        .           return _byteswap_uint64(x);
        .         }
        .         #else
        .         static inline uint16_t CRYPTO_bswap2(uint16_t x) {
        .           return (x >> 8) | (x << 8);
        .         }
        .         
   38,790 (0.0%)  static inline uint32_t CRYPTO_bswap4(uint32_t x) {
   12,930 (0.0%)    x = (x >> 16) | (x << 16);
  116,370 (0.0%)    x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);
   12,930 (0.0%)    return x;
   25,860 (0.0%)  }
        .         
   32,080 (0.0%)  static inline uint64_t CRYPTO_bswap8(uint64_t x) {
   70,576 (0.0%)    return CRYPTO_bswap4(x >> 32) | (((uint64_t)CRYPTO_bswap4(x)) << 32);
   19,248 (0.0%)  }
        .         #endif
        .         
        .         
        .         // Language bug workarounds.
        .         //
        .         // Most C standard library functions are undefined if passed NULL, even when the
        .         // corresponding length is zero. This gives them (and, in turn, all functions
        .         // which call them) surprising behavior on empty arrays. Some compilers will
-- line 824 ----------------------------------------
-- line 848 ----------------------------------------
        .           }
        .         
        .           return memchr(s, c, n);
        .         }
        .         
        .         }  // extern "C++"
        .         #else  // __cplusplus
        .         
        6 (0.0%)  static inline void *OPENSSL_memchr(const void *s, int c, size_t n) {
        2 (0.0%)    if (n == 0) {
        2 (0.0%)      return NULL;
        .           }
        .         
        .           return memchr(s, c, n);
        2 (0.0%)  }
        .         
        .         #endif  // __cplusplus
        .         
        .         static inline int OPENSSL_memcmp(const void *s1, const void *s2, size_t n) {
        .           if (n == 0) {
        .             return 0;
        .           }
        .         
        .           return memcmp(s1, s2, n);
        .         }
        .         
   46,602 (0.0%)  static inline void *OPENSSL_memcpy(void *dst, const void *src, size_t n) {
   15,534 (0.0%)    if (n == 0) {
      530 (0.0%)      return dst;
        .           }
        .         
   45,012 (0.0%)    return memcpy(dst, src, n);
   15,534 (0.0%)  }
        .         
       18 (0.0%)  static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
        6 (0.0%)    if (n == 0) {
        .             return dst;
        .           }
        .         
       18 (0.0%)    return memmove(dst, src, n);
        6 (0.0%)  }
        .         
   20,856 (0.0%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
    6,952 (0.0%)    if (n == 0) {
    6,348 (0.0%)      return dst;
        .           }
        .         
    1,812 (0.0%)    return memset(dst, c, n);
    6,952 (0.0%)  }
        .         
        .         
        .         // Loads and stores.
        .         //
        .         // The following functions load and store sized integers with the specified
        .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
        .         // requirements on the input and output pointers.
        .         
-- line 904 ----------------------------------------
-- line 949 ----------------------------------------
        .         static inline void CRYPTO_store_u32_le(void *out, uint32_t v) {
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           v = CRYPTO_bswap4(v);
        .         #endif
        .           OPENSSL_memcpy(out, &v, sizeof(v));
        .         
        .         }
        .         
      273 (0.0%)  static inline uint32_t CRYPTO_load_u32_be(const void *in) {
        .           uint32_t v;
      234 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           return v;
        .         #else
      117 (0.0%)    return CRYPTO_bswap4(v);
        .         #endif
      195 (0.0%)  }
        .         
      295 (0.0%)  static inline void CRYPTO_store_u32_be(void *out, uint32_t v) {
        .         
        .         #if !defined(OPENSSL_BIG_ENDIAN)
      236 (0.0%)    v = CRYPTO_bswap4(v);
        .         #endif
      354 (0.0%)    OPENSSL_memcpy(out, &v, sizeof(v));
        .         
      177 (0.0%)  }
        .         
        .         static inline uint64_t CRYPTO_load_u64_le(const void *in) {
        .           uint64_t v;
        .           OPENSSL_memcpy(&v, in, sizeof(v));
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           return CRYPTO_bswap8(v);
        .         #else
        .           return v;
-- line 982 ----------------------------------------
-- line 1026 ----------------------------------------
        .         
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           v = CRYPTO_bswap_word(v);
        .         #endif
        .           OPENSSL_memcpy(out, &v, sizeof(v));
        .         
        .         }
        .         
   44,912 (0.0%)  static inline crypto_word_t CRYPTO_load_word_be(const void *in) {
        .           crypto_word_t v;
   38,496 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
        .         #if defined(OPENSSL_BIG_ENDIAN)
        .           return v;
        .         #else
        .         #if defined(OPENSSL_64_BIT)
        .           assert(sizeof(v) == 8);
   19,248 (0.0%)    return CRYPTO_bswap8(v);
        .         #else
        .           assert(sizeof(v) == 4);
        .           return CRYPTO_bswap4(v);
        .         #endif
        .         #endif
   32,080 (0.0%)  }
        .         
        .         // Bit rotation functions.
        .         //
        .         // Note these functions use |(-shift) & 31|, etc., because shifting by the bit
        .         // width is undefined. Both Clang and GCC recognize this pattern as a rotation,
        .         // but MSVC does not. Instead, we call MSVC's built-in functions.
        .         
        .         static inline uint32_t CRYPTO_rotl_u32(uint32_t value, int shift) {
-- line 1056 ----------------------------------------
-- line 1122 ----------------------------------------
        .           assert(carry <= 1);
        .           uint64_t ret = carry;
        .           ret += (uint64_t)x + y;
        .           *out_carry = (uint32_t)(ret >> 32);
        .           return (uint32_t)ret;
        .         }
        .         
        .         static inline uint64_t CRYPTO_addc_u64(uint64_t x, uint64_t y, uint64_t carry,
   19,216 (0.0%)                                         uint64_t *out_carry) {
    4,804 (0.0%)    assert(carry <= 1);
        .         #if defined(BORINGSSL_HAS_UINT128)
    7,206 (0.0%)    uint128_t ret = carry;
   19,216 (0.0%)    ret += (uint128_t)x + y;
   16,814 (0.0%)    *out_carry = (uint64_t)(ret >> 64);
    2,402 (0.0%)    return (uint64_t)ret;
        .         #else
        .           x += carry;
        .           carry = x < carry;
        .           uint64_t ret = x + y;
        .           carry += ret < x;
        .           *out_carry = carry;
        .           return ret;
        .         #endif
    7,206 (0.0%)  }
        .         #endif
        .         
        .         // CRYPTO_subc_* returns |x - y - borrow|, and sets |*out_borrow| to the borrow
        .         // bit. |borrow| must be zero or one.
        .         #if OPENSSL_HAS_BUILTIN(__builtin_subc)
        .         
        .         #define CRYPTO_GENERIC_SUBC(x, y, borrow, out_borrow) \
        .           (_Generic((x),                                      \
-- line 1153 ----------------------------------------
-- line 1173 ----------------------------------------
        .                                                uint32_t *out_borrow) {
        .           assert(borrow <= 1);
        .           uint32_t ret = x - y - borrow;
        .           *out_borrow = (x < y) | ((x == y) & borrow);
        .           return ret;
        .         }
        .         
        .         static inline uint64_t CRYPTO_subc_u64(uint64_t x, uint64_t y, uint64_t borrow,
    3,010 (0.0%)                                         uint64_t *out_borrow) {
      860 (0.0%)    assert(borrow <= 1);
    1,720 (0.0%)    uint64_t ret = x - y - borrow;
    5,160 (0.0%)    *out_borrow = (x < y) | ((x == y) & borrow);
      430 (0.0%)    return ret;
      860 (0.0%)  }
        .         #endif
        .         
        .         #if defined(OPENSSL_64_BIT)
        .         #define CRYPTO_addc_w CRYPTO_addc_u64
        .         #define CRYPTO_subc_w CRYPTO_subc_u64
        .         #else
        .         #define CRYPTO_addc_w CRYPTO_addc_u32
        .         #define CRYPTO_subc_w CRYPTO_subc_u32
-- line 1194 ----------------------------------------
-- line 1235 ----------------------------------------
        .         // run in this address space. If not, it runs it and crashes the address space
        .         // if unsuccessful.
        .         void boringssl_ensure_ffdh_self_test(void);
        .         
        .         #else
        .         
        .         // Outside of FIPS mode, the lazy tests are no-ops.
        .         
        5 (0.0%)  OPENSSL_INLINE void boringssl_ensure_rsa_self_test(void) {}
        .         OPENSSL_INLINE void boringssl_ensure_ecc_self_test(void) {}
        .         OPENSSL_INLINE void boringssl_ensure_ffdh_self_test(void) {}
        .         
        .         #endif  // FIPS
        .         
        .         // boringssl_self_test_sha256 performs a SHA-256 KAT.
        .         int boringssl_self_test_sha256(void);
        .         
-- line 1251 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/add.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 59 ----------------------------------------
     .         #include <string.h>
     .         
     .         #include <openssl/err.h>
     .         #include <openssl/mem.h>
     .         
     .         #include "internal.h"
     .         
     .         
     7 (0.0%)  int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b) {
     .           const BIGNUM *tmp;
     3 (0.0%)    int a_neg = a->neg, ret;
     .         
     .           //  a +  b	a+b
     .           //  a + -b	a-b
     .           // -a +  b	b-a
     .           // -a + -b	-(a+b)
     4 (0.0%)    if (a_neg ^ b->neg) {
     .             // only one is negative
     2 (0.0%)      if (a_neg) {
     2 (0.0%)        tmp = a;
     2 (0.0%)        a = b;
     2 (0.0%)        b = tmp;
     .             }
     .         
     .             // we are now a - b
     7 (0.0%)      if (BN_ucmp(a, b) < 0) {
     .               if (!BN_usub(r, b, a)) {
     .                 return 0;
     .               }
     .               r->neg = 1;
     .             } else {
     8 (0.0%)        if (!BN_usub(r, a, b)) {
     .                 return 0;
     .               }
     2 (0.0%)        r->neg = 0;
     .             }
     2 (0.0%)      return 1;
     .           }
     .         
     .           ret = BN_uadd(r, a, b);
     .           r->neg = a_neg;
     .           return ret;
     2 (0.0%)  }
     .         
63,899 (0.0%)  int bn_uadd_consttime(BIGNUM *r, const BIGNUM *a, const BIGNUM *b) {
     .           // Widths are public, so we normalize to make |a| the larger one.
34,854 (0.0%)    if (a->width < b->width) {
   512 (0.0%)      const BIGNUM *tmp = a;
   512 (0.0%)      a = b;
   512 (0.0%)      b = tmp;
     .           }
     .         
17,427 (0.0%)    int max = a->width;
17,427 (0.0%)    int min = b->width;
52,281 (0.0%)    if (!bn_wexpand(r, max + 1)) {
     .             return 0;
     .           }
23,236 (0.0%)    r->width = max + 1;
     .         
63,899 (0.0%)    BN_ULONG carry = bn_add_words(r->d, a->d, b->d, min);
44,462 (0.0%)    for (int i = min; i < max; i++) {
45,638 (0.0%)      r->d[i] = CRYPTO_addc_w(a->d[i], 0, carry, &carry);
     .           }
     .         
46,472 (0.0%)    r->d[max] = carry;
 5,809 (0.0%)    return 1;
34,854 (0.0%)  }
     .         
40,656 (0.0%)  int BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b) {
46,464 (0.0%)    if (!bn_uadd_consttime(r, a, b)) {
     .             return 0;
     .           }
17,424 (0.0%)    bn_set_minimal_width(r);
 5,808 (0.0%)    return 1;
11,616 (0.0%)  }
     .         
     .         int BN_add_word(BIGNUM *a, BN_ULONG w) {
     .           BN_ULONG l;
     .           int i;
     .         
     .           // degenerate case: w is zero
     .           if (!w) {
     .             return 1;
-- line 141 ----------------------------------------
-- line 167 ----------------------------------------
     .             }
     .             a->width++;
     .             a->d[i] = w;
     .           }
     .         
     .           return 1;
     .         }
     .         
     7 (0.0%)  int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b) {
     2 (0.0%)    int add = 0, neg = 0;
     .           const BIGNUM *tmp;
     .         
     .           //  a -  b	a-b
     .           //  a - -b	a+b
     .           // -a -  b	-(a+b)
     .           // -a - -b	b-a
     4 (0.0%)    if (a->neg) {
     .             if (b->neg) {
     .               tmp = a;
     .               a = b;
     .               b = tmp;
     .             } else {
     .               add = 1;
     .               neg = 1;
     .             }
     .           } else {
     4 (0.0%)      if (b->neg) {
     .               add = 1;
     .               neg = 0;
     .             }
     .           }
     .         
     2 (0.0%)    if (add) {
     .             if (!BN_uadd(r, a, b)) {
     .               return 0;
     .             }
     .         
     .             r->neg = neg;
     .             return 1;
     .           }
     .         
     7 (0.0%)    if (BN_ucmp(a, b) < 0) {
     8 (0.0%)      if (!BN_usub(r, b, a)) {
     .               return 0;
     .             }
     3 (0.0%)      r->neg = 1;
     .           } else {
     .             if (!BN_usub(r, a, b)) {
     .               return 0;
     .             }
     .             r->neg = 0;
     .           }
     .         
     1 (0.0%)    return 1;
     2 (0.0%)  }
     .         
32,340 (0.0%)  int bn_usub_consttime(BIGNUM *r, const BIGNUM *a, const BIGNUM *b) {
     .           // |b| may have more words than |a| given non-minimal inputs, but all words
     .           // beyond |a->width| must then be zero.
 8,820 (0.0%)    int b_width = b->width;
11,760 (0.0%)    if (b_width > a->width) {
     .             if (!bn_fits_in_words(b, a->width)) {
     .               OPENSSL_PUT_ERROR(BN, BN_R_ARG2_LT_ARG3);
     .               return 0;
     .             }
     .             b_width = a->width;
     .           }
     .         
26,460 (0.0%)    if (!bn_wexpand(r, a->width)) {
     .             return 0;
     .           }
     .         
32,340 (0.0%)    BN_ULONG borrow = bn_sub_words(r->d, a->d, b->d, b_width);
21,480 (0.0%)    for (int i = b_width; i < a->width; i++) {
 3,420 (0.0%)      r->d[i] = CRYPTO_subc_w(a->d[i], 0, borrow, &borrow);
     .           }
     .         
 8,820 (0.0%)    if (borrow) {
     .             OPENSSL_PUT_ERROR(BN, BN_R_ARG2_LT_ARG3);
     .             return 0;
     .           }
     .         
11,760 (0.0%)    r->width = a->width;
 5,880 (0.0%)    r->neg = 0;
 2,940 (0.0%)    return 1;
17,640 (0.0%)  }
     .         
20,566 (0.0%)  int BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b) {
23,504 (0.0%)    if (!bn_usub_consttime(r, a, b)) {
     .             return 0;
     .           }
 8,814 (0.0%)    bn_set_minimal_width(r);
 2,938 (0.0%)    return 1;
 5,876 (0.0%)  }
     .         
     .         int BN_sub_word(BIGNUM *a, BN_ULONG w) {
     .           int i;
     .         
     .           // degenerate case: w is zero
     .           if (!w) {
     .             return 1;
     .           }
-- line 268 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/asm/x86_64-gcc.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 90 ----------------------------------------
        .                     : "cc");                                                       \
        .             (r) = (carry);                                                         \
        .             (carry) = high;                                                        \
        .           } while (0)
        .         #undef sqr
        .         #define sqr(r0, r1, a) __asm__("mulq %2" : "=a"(r0), "=d"(r1) : "a"(a) : "cc");
        .         
        .         BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, size_t num,
    3,744 (0.0%)                            BN_ULONG w) {
      416 (0.0%)    BN_ULONG c1 = 0;
        .         
      832 (0.0%)    if (num == 0) {
        .             return (c1);
        .           }
        .         
   11,584 (0.0%)    while (num & ~3) {
  123,648 (0.0%)      mul_add(rp[0], ap[0], w, c1);
  118,272 (0.0%)      mul_add(rp[1], ap[1], w, c1);
  118,272 (0.0%)      mul_add(rp[2], ap[2], w, c1);
  118,272 (0.0%)      mul_add(rp[3], ap[3], w, c1);
    5,376 (0.0%)      ap += 4;
    5,376 (0.0%)      rp += 4;
    5,376 (0.0%)      num -= 4;
        .           }
      832 (0.0%)    if (num) {
        .             mul_add(rp[0], ap[0], w, c1);
        .             if (--num == 0) {
        .               return c1;
        .             }
        .             mul_add(rp[1], ap[1], w, c1);
        .             if (--num == 0) {
        .               return c1;
        .             }
        .             mul_add(rp[2], ap[2], w, c1);
        .             return c1;
        .           }
        .         
      416 (0.0%)    return c1;
    1,664 (0.0%)  }
        .         
        .         BN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, size_t num,
    1,215 (0.0%)                        BN_ULONG w) {
      135 (0.0%)    BN_ULONG c1 = 0;
        .         
      270 (0.0%)    if (num == 0) {
        .             return c1;
        .           }
        .         
    4,558 (0.0%)    while (num & ~3) {
   38,592 (0.0%)      mul(rp[0], ap[0], w, c1);
   42,880 (0.0%)      mul(rp[1], ap[1], w, c1);
   42,880 (0.0%)      mul(rp[2], ap[2], w, c1);
   42,880 (0.0%)      mul(rp[3], ap[3], w, c1);
    2,144 (0.0%)      ap += 4;
    2,144 (0.0%)      rp += 4;
    2,144 (0.0%)      num -= 4;
        .           }
      270 (0.0%)    if (num) {
    2,412 (0.0%)      mul(rp[0], ap[0], w, c1);
      402 (0.0%)      if (--num == 0) {
      268 (0.0%)        return c1;
        .             }
        .             mul(rp[1], ap[1], w, c1);
        .             if (--num == 0) {
        .               return c1;
        .             }
        .             mul(rp[2], ap[2], w, c1);
        .           }
        1 (0.0%)    return c1;
      540 (0.0%)  }
        .         
        .         void bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, size_t n) {
        .           if (n == 0) {
        .             return;
        .           }
        .         
        .           while (n & ~3) {
        .             sqr(r[0], r[1], a[0]);
-- line 167 ----------------------------------------
-- line 181 ----------------------------------------
        .             if (--n == 0) {
        .               return;
        .             }
        .             sqr(r[4], r[5], a[2]);
        .           }
        .         }
        .         
        .         BN_ULONG bn_add_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,
  117,418 (0.0%)                        size_t n) {
        .           BN_ULONG ret;
   16,774 (0.0%)    size_t i = 0;
        .         
   33,548 (0.0%)    if (n == 0) {
        2 (0.0%)      return 0;
        .           }
        .         
4,603,179 (1.5%)    __asm__ volatile (
        .               "	subq	%0,%0		\n"  // clear carry
        .               "	jmp	1f		\n"
        .               ".p2align 4			\n"
        .               "1:"
        .               "	movq	(%4,%2,8),%0	\n"
        .               "	adcq	(%5,%2,8),%0	\n"
        .               "	movq	%0,(%3,%2,8)	\n"
        .               "	lea	1(%2),%2	\n"
        .               "	dec	%1		\n"
        .               "	jnz	1b		\n"
        .               "	sbbq	%0,%0		\n"
        .               : "=&r"(ret), "+c"(n), "+r"(i)
        .               : "r"(rp), "r"(ap), "r"(bp)
        .               : "cc", "memory");
        .         
   33,546 (0.0%)    return ret & 1;
   33,548 (0.0%)  }
        .         
        .         BN_ULONG bn_sub_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,
   98,637 (0.0%)                        size_t n) {
        .           BN_ULONG ret;
   14,091 (0.0%)    size_t i = 0;
        .         
   28,182 (0.0%)    if (n == 0) {
        4 (0.0%)      return 0;
        .           }
        .         
2,963,503 (1.0%)    __asm__ volatile (
        .               "	subq	%0,%0		\n"  // clear borrow
        .               "	jmp	1f		\n"
        .               ".p2align 4			\n"
        .               "1:"
        .               "	movq	(%4,%2,8),%0	\n"
        .               "	sbbq	(%5,%2,8),%0	\n"
        .               "	movq	%0,(%3,%2,8)	\n"
        .               "	lea	1(%2),%2	\n"
        .               "	dec	%1		\n"
        .               "	jnz	1b		\n"
        .               "	sbbq	%0,%0		\n"
        .               : "=&r"(ret), "+c"(n), "+r"(i)
        .               : "r"(rp), "r"(ap), "r"(bp)
        .               : "cc", "memory");
        .         
   28,178 (0.0%)    return ret & 1;
   28,182 (0.0%)  }
        .         
        .         // mul_add_c(a,b,c0,c1,c2)  -- c+=a*b for three word number c=(c2,c1,c0)
        .         // mul_add_c2(a,b,c0,c1,c2) -- c+=2*a*b for three word number c=(c2,c1,c0)
        .         // sqr_add_c(a,i,c0,c1,c2)  -- c+=a[i]^2 for three word number c=(c2,c1,c0)
        .         // sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0)
        .         
        .         // Keep in mind that carrying into high part of multiplication result can not
        .         // overflow, because it cannot be all-ones.
-- line 250 ----------------------------------------
-- line 279 ----------------------------------------
        .             __asm__("addq %3,%0; adcq %4,%1; adcq %5,%2"                     \
        .                     : "+r"(c0), "+r"(c1), "+r"(c2)                           \
        .                     : "r"(t1), "r"(t2), "g"(0)                               \
        .                     : "cc");                                                 \
        .           } while (0)
        .         
        .         #define sqr_add_c2(a, i, j, c0, c1, c2) mul_add_c2((a)[i], (a)[j], c0, c1, c2)
        .         
      315 (0.0%)  void bn_mul_comba8(BN_ULONG r[16], const BN_ULONG a[8], const BN_ULONG b[8]) {
        .           BN_ULONG c1, c2, c3;
        .         
       45 (0.0%)    c1 = 0;
       45 (0.0%)    c2 = 0;
       45 (0.0%)    c3 = 0;
      765 (0.0%)    mul_add_c(a[0], b[0], c1, c2, c3);
      135 (0.0%)    r[0] = c1;
       45 (0.0%)    c1 = 0;
      810 (0.0%)    mul_add_c(a[0], b[1], c2, c3, c1);
      810 (0.0%)    mul_add_c(a[1], b[0], c2, c3, c1);
      180 (0.0%)    r[1] = c2;
       45 (0.0%)    c2 = 0;
      810 (0.0%)    mul_add_c(a[2], b[0], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[1], b[1], c3, c1, c2);
      810 (0.0%)    mul_add_c(a[0], b[2], c3, c1, c2);
      180 (0.0%)    r[2] = c3;
       45 (0.0%)    c3 = 0;
      810 (0.0%)    mul_add_c(a[0], b[3], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[1], b[2], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[2], b[1], c1, c2, c3);
      810 (0.0%)    mul_add_c(a[3], b[0], c1, c2, c3);
      180 (0.0%)    r[3] = c1;
       45 (0.0%)    c1 = 0;
      810 (0.0%)    mul_add_c(a[4], b[0], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[3], b[1], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[2], b[2], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[1], b[3], c2, c3, c1);
      810 (0.0%)    mul_add_c(a[0], b[4], c2, c3, c1);
      180 (0.0%)    r[4] = c2;
       45 (0.0%)    c2 = 0;
      810 (0.0%)    mul_add_c(a[0], b[5], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[1], b[4], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[2], b[3], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[3], b[2], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[4], b[1], c3, c1, c2);
      810 (0.0%)    mul_add_c(a[5], b[0], c3, c1, c2);
      180 (0.0%)    r[5] = c3;
       45 (0.0%)    c3 = 0;
      810 (0.0%)    mul_add_c(a[6], b[0], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[5], b[1], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[4], b[2], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[3], b[3], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[2], b[4], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[1], b[5], c1, c2, c3);
      810 (0.0%)    mul_add_c(a[0], b[6], c1, c2, c3);
      180 (0.0%)    r[6] = c1;
       45 (0.0%)    c1 = 0;
      810 (0.0%)    mul_add_c(a[0], b[7], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[1], b[6], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[2], b[5], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[3], b[4], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[4], b[3], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[5], b[2], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[6], b[1], c2, c3, c1);
      810 (0.0%)    mul_add_c(a[7], b[0], c2, c3, c1);
      180 (0.0%)    r[7] = c2;
       45 (0.0%)    c2 = 0;
      855 (0.0%)    mul_add_c(a[7], b[1], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[6], b[2], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[5], b[3], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[4], b[4], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[3], b[5], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[2], b[6], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[1], b[7], c3, c1, c2);
      180 (0.0%)    r[8] = c3;
       45 (0.0%)    c3 = 0;
      855 (0.0%)    mul_add_c(a[2], b[7], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[3], b[6], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[4], b[5], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[5], b[4], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[6], b[3], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[7], b[2], c1, c2, c3);
      180 (0.0%)    r[9] = c1;
       45 (0.0%)    c1 = 0;
      855 (0.0%)    mul_add_c(a[7], b[3], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[6], b[4], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[5], b[5], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[4], b[6], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[3], b[7], c2, c3, c1);
      180 (0.0%)    r[10] = c2;
       45 (0.0%)    c2 = 0;
      855 (0.0%)    mul_add_c(a[4], b[7], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[5], b[6], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[6], b[5], c3, c1, c2);
      855 (0.0%)    mul_add_c(a[7], b[4], c3, c1, c2);
      180 (0.0%)    r[11] = c3;
       45 (0.0%)    c3 = 0;
      855 (0.0%)    mul_add_c(a[7], b[5], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[6], b[6], c1, c2, c3);
      855 (0.0%)    mul_add_c(a[5], b[7], c1, c2, c3);
      180 (0.0%)    r[12] = c1;
       45 (0.0%)    c1 = 0;
      855 (0.0%)    mul_add_c(a[6], b[7], c2, c3, c1);
      855 (0.0%)    mul_add_c(a[7], b[6], c2, c3, c1);
      180 (0.0%)    r[13] = c2;
       45 (0.0%)    c2 = 0;
      855 (0.0%)    mul_add_c(a[7], b[7], c3, c1, c2);
      180 (0.0%)    r[14] = c3;
      180 (0.0%)    r[15] = c1;
      135 (0.0%)  }
        .         
        .         void bn_mul_comba4(BN_ULONG r[8], const BN_ULONG a[4], const BN_ULONG b[4]) {
        .           BN_ULONG c1, c2, c3;
        .         
        .           c1 = 0;
        .           c2 = 0;
        .           c3 = 0;
        .           mul_add_c(a[0], b[0], c1, c2, c3);
-- line 395 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 66 ----------------------------------------
        .         #include "../delocate.h"
        .         
        .         
        .         // BN_MAX_WORDS is the maximum number of words allowed in a |BIGNUM|. It is
        .         // sized so byte and bit counts of a |BIGNUM| always fit in |int|, with room to
        .         // spare.
        .         #define BN_MAX_WORDS (INT_MAX / (4 * BN_BITS2))
        .         
      996 (0.0%)  BIGNUM *BN_new(void) {
      747 (0.0%)    BIGNUM *bn = OPENSSL_zalloc(sizeof(BIGNUM));
        .         
      498 (0.0%)    if (bn == NULL) {
        .             return NULL;
        .           }
        .         
      498 (0.0%)    bn->flags = BN_FLG_MALLOCED;
        .         
      249 (0.0%)    return bn;
      498 (0.0%)  }
        .         
        .         BIGNUM *BN_secure_new(void) { return BN_new(); }
        .         
       75 (0.0%)  void BN_init(BIGNUM *bn) {
       75 (0.0%)    OPENSSL_memset(bn, 0, sizeof(BIGNUM));
       45 (0.0%)  }
        .         
   13,080 (0.0%)  void BN_free(BIGNUM *bn) {
    5,232 (0.0%)    if (bn == NULL) {
    2,140 (0.0%)      return;
        .           }
        .         
    2,380 (0.0%)    if ((bn->flags & BN_FLG_STATIC_DATA) == 0) {
    1,904 (0.0%)      OPENSSL_free(bn->d);
        .           }
        .         
    2,380 (0.0%)    if (bn->flags & BN_FLG_MALLOCED) {
    1,844 (0.0%)      OPENSSL_free(bn);
        .           } else {
       45 (0.0%)      bn->d = NULL;
        .           }
    5,232 (0.0%)  }
        .         
        .         void BN_clear_free(BIGNUM *bn) {
        .           BN_free(bn);
        .         }
        .         
       15 (0.0%)  BIGNUM *BN_dup(const BIGNUM *src) {
        .           BIGNUM *copy;
        .         
        6 (0.0%)    if (src == NULL) {
        .             return NULL;
        .           }
        .         
        6 (0.0%)    copy = BN_new();
        6 (0.0%)    if (copy == NULL) {
        .             return NULL;
        .           }
        .         
       21 (0.0%)    if (!BN_copy(copy, src)) {
        .             BN_free(copy);
        .             return NULL;
        .           }
        .         
        3 (0.0%)    return copy;
        6 (0.0%)  }
        .         
      180 (0.0%)  BIGNUM *BN_copy(BIGNUM *dest, const BIGNUM *src) {
       90 (0.0%)    if (src == dest) {
       10 (0.0%)      return dest;
        .           }
        .         
      225 (0.0%)    if (!bn_wexpand(dest, src->width)) {
        .             return NULL;
        .           }
        .         
      275 (0.0%)    OPENSSL_memcpy(dest->d, src->d, sizeof(src->d[0]) * src->width);
        .         
      100 (0.0%)    dest->width = src->width;
      100 (0.0%)    dest->neg = src->neg;
       25 (0.0%)    return dest;
       60 (0.0%)  }
        .         
        .         void BN_clear(BIGNUM *bn) {
        .           if (bn->d != NULL) {
        .             OPENSSL_memset(bn->d, 0, bn->dmax * sizeof(bn->d[0]));
        .           }
        .         
        .           bn->width = 0;
        .           bn->neg = 0;
        .         }
        .         
       90 (0.0%)  DEFINE_METHOD_FUNCTION(BIGNUM, BN_value_one) {
        .           static const BN_ULONG kOneLimbs[1] = { 1 };
        3 (0.0%)    out->d = (BN_ULONG*) kOneLimbs;
        2 (0.0%)    out->width = 1;
        2 (0.0%)    out->dmax = 1;
        2 (0.0%)    out->neg = 0;
        2 (0.0%)    out->flags = BN_FLG_STATIC_DATA;
        3 (0.0%)  }
        .         
        .         // BN_num_bits_word returns the minimum number of bits needed to represent the
        .         // value in |l|.
    1,472 (0.0%)  unsigned BN_num_bits_word(BN_ULONG l) {
        .           // |BN_num_bits| is often called on RSA prime factors. These have public bit
        .           // lengths, but all bits beyond the high bit are secret, so count bits in
        .           // constant time.
        .           BN_ULONG x, mask;
    1,472 (0.0%)    int bits = (l != 0);
        .         
        .         #if BN_BITS2 > 32
        .           // Look at the upper half of |x|. |x| is at most 64 bits long.
    1,104 (0.0%)    x = l >> 32;
        .           // Set |mask| to all ones if |x| (the top 32 bits of |l|) is non-zero and all
        .           // all zeros otherwise.
    1,104 (0.0%)    mask = 0u - x;
    1,104 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
        .           // If |x| is non-zero, the lower half is included in the bit count in full,
        .           // and we count the upper half. Otherwise, we count the lower half.
    2,208 (0.0%)    bits += 32 & mask;
    1,472 (0.0%)    l ^= (x ^ l) & mask;  // |l| is |x| if |mask| and remains |l| otherwise.
        .         #endif
        .         
        .           // The remaining blocks are analogous iterations at lower powers of two.
    1,104 (0.0%)    x = l >> 16;
    1,104 (0.0%)    mask = 0u - x;
    1,104 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
    2,208 (0.0%)    bits += 16 & mask;
    1,472 (0.0%)    l ^= (x ^ l) & mask;
        .         
    1,104 (0.0%)    x = l >> 8;
    1,104 (0.0%)    mask = 0u - x;
    1,104 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
    2,208 (0.0%)    bits += 8 & mask;
    1,472 (0.0%)    l ^= (x ^ l) & mask;
        .         
    1,104 (0.0%)    x = l >> 4;
    1,104 (0.0%)    mask = 0u - x;
    1,104 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
    2,208 (0.0%)    bits += 4 & mask;
    1,472 (0.0%)    l ^= (x ^ l) & mask;
        .         
    1,104 (0.0%)    x = l >> 2;
    1,104 (0.0%)    mask = 0u - x;
    1,104 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
    2,208 (0.0%)    bits += 2 & mask;
    1,472 (0.0%)    l ^= (x ^ l) & mask;
        .         
    1,104 (0.0%)    x = l >> 1;
    1,104 (0.0%)    mask = 0u - x;
    1,104 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
    2,208 (0.0%)    bits += 1 & mask;
        .         
      368 (0.0%)    return bits;
      736 (0.0%)  }
        .         
    2,190 (0.0%)  unsigned BN_num_bits(const BIGNUM *bn) {
    1,460 (0.0%)    const int width = bn_minimal_width(bn);
      730 (0.0%)    if (width == 0) {
        .             return 0;
        .           }
        .         
    5,475 (0.0%)    return (width - 1) * BN_BITS2 + BN_num_bits_word(bn->d[width - 1]);
    1,095 (0.0%)  }
        .         
      645 (0.0%)  unsigned BN_num_bytes(const BIGNUM *bn) {
      645 (0.0%)    return (BN_num_bits(bn) + 7) / 8;
      258 (0.0%)  }
        .         
      240 (0.0%)  void BN_zero(BIGNUM *bn) {
      360 (0.0%)    bn->width = bn->neg = 0;
      180 (0.0%)  }
        .         
        5 (0.0%)  int BN_one(BIGNUM *bn) {
        4 (0.0%)    return BN_set_word(bn, 1);
        2 (0.0%)  }
        .         
        6 (0.0%)  int BN_set_word(BIGNUM *bn, BN_ULONG value) {
        2 (0.0%)    if (value == 0) {
        .             BN_zero(bn);
        .             return 1;
        .           }
        .         
        6 (0.0%)    if (!bn_wexpand(bn, 1)) {
        .             return 0;
        .           }
        .         
        2 (0.0%)    bn->neg = 0;
        4 (0.0%)    bn->d[0] = value;
        2 (0.0%)    bn->width = 1;
        1 (0.0%)    return 1;
        2 (0.0%)  }
        .         
        .         int BN_set_u64(BIGNUM *bn, uint64_t value) {
        .         #if BN_BITS2 == 64
        .           return BN_set_word(bn, value);
        .         #elif BN_BITS2 == 32
        .           if (value <= BN_MASK2) {
        .             return BN_set_word(bn, (BN_ULONG)value);
        .           }
-- line 264 ----------------------------------------
-- line 296 ----------------------------------------
        .         
        .           assert(num <= BN_MAX_WORDS);
        .           bn->width = (int)num;
        .           bn->dmax = (int)num;
        .           bn->neg = 0;
        .           bn->flags |= BN_FLG_STATIC_DATA;
        .         }
        .         
   14,870 (0.0%)  int bn_fits_in_words(const BIGNUM *bn, size_t num) {
        .           // All words beyond |num| must be zero.
    2,974 (0.0%)    BN_ULONG mask = 0;
  603,044 (0.2%)    for (size_t i = num; i < (size_t)bn->width; i++) {
  675,794 (0.2%)      mask |= bn->d[i];
        .           }
    8,922 (0.0%)    return mask == 0;
    5,948 (0.0%)  }
        .         
        .         int bn_copy_words(BN_ULONG *out, size_t num, const BIGNUM *bn) {
        .           if (bn->neg) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_NEGATIVE_NUMBER);
        .             return 0;
        .           }
        .         
        .           size_t width = (size_t)bn->width;
-- line 319 ----------------------------------------
-- line 325 ----------------------------------------
        .             width = num;
        .           }
        .         
        .           OPENSSL_memset(out, 0, sizeof(BN_ULONG) * num);
        .           OPENSSL_memcpy(out, bn->d, sizeof(BN_ULONG) * width);
        .           return 1;
        .         }
        .         
      996 (0.0%)  int BN_is_negative(const BIGNUM *bn) {
    1,245 (0.0%)    return bn->neg != 0;
      498 (0.0%)  }
        .         
        .         void BN_set_negative(BIGNUM *bn, int sign) {
        .           if (sign && !BN_is_zero(bn)) {
        .             bn->neg = 1;
        .           } else {
        .             bn->neg = 0;
        .           }
        .         }
        .         
  107,100 (0.0%)  int bn_wexpand(BIGNUM *bn, size_t words) {
        .           BN_ULONG *a;
        .         
   89,250 (0.0%)    if (words <= (size_t)bn->dmax) {
   35,164 (0.0%)      return 1;
        .           }
        .         
      536 (0.0%)    if (words > BN_MAX_WORDS) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_BIGNUM_TOO_LONG);
        .             return 0;
        .           }
        .         
    1,340 (0.0%)    if (bn->flags & BN_FLG_STATIC_DATA) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);
        .             return 0;
        .           }
        .         
    1,340 (0.0%)    a = OPENSSL_calloc(words, sizeof(BN_ULONG));
      536 (0.0%)    if (a == NULL) {
        .             return 0;
        .           }
        .         
    2,680 (0.0%)    OPENSSL_memcpy(a, bn->d, sizeof(BN_ULONG) * bn->width);
        .         
    1,072 (0.0%)    OPENSSL_free(bn->d);
      804 (0.0%)    bn->d = a;
    1,072 (0.0%)    bn->dmax = (int)words;
        .         
      268 (0.0%)    return 1;
   35,700 (0.0%)  }
        .         
        .         int bn_expand(BIGNUM *bn, size_t bits) {
        .           if (bits + BN_BITS2 - 1 < bits) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_BIGNUM_TOO_LONG);
        .             return 0;
        .           }
        .           return bn_wexpand(bn, (bits+BN_BITS2-1)/BN_BITS2);
        .         }
        .         
      138 (0.0%)  int bn_resize_words(BIGNUM *bn, size_t words) {
        .         #if defined(OPENSSL_PPC64LE)
        .           // This is a workaround for a miscompilation bug in Clang 7.0.1 on POWER.
        .           // The unittests catch the miscompilation, if it occurs, and it manifests
        .           // as a crash in |bn_fits_in_words|.
        .           //
        .           // The bug only triggers if building in FIPS mode and with -O3. Clang 8.0.1
        .           // has the same bug but this workaround is not effective there---I've not
        .           // been able to find a workaround for 8.0.1.
-- line 392 ----------------------------------------
-- line 394 ----------------------------------------
        .           // At the time of writing (2019-08-08), Clang git does *not* have this bug
        .           // and does not need this workaroud. The current git version should go on to
        .           // be Clang 10 thus, once we can depend on that, this can be removed.
        .           if (value_barrier_w((size_t)bn->width == words)) {
        .             return 1;
        .           }
        .         #endif
        .         
      115 (0.0%)    if ((size_t)bn->width <= words) {
      147 (0.0%)      if (!bn_wexpand(bn, words)) {
        .               return 0;
        .             }
      231 (0.0%)      OPENSSL_memset(bn->d + bn->width, 0,
      105 (0.0%)                     (words - bn->width) * sizeof(BN_ULONG));
       84 (0.0%)      bn->width = (int)words;
       42 (0.0%)      return 1;
        .           }
        .         
        .           // All words beyond the new width must be zero.
       14 (0.0%)    if (!bn_fits_in_words(bn, words)) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_BIGNUM_TOO_LONG);
        .             return 0;
        .           }
        8 (0.0%)    bn->width = (int)words;
        2 (0.0%)    return 1;
       46 (0.0%)  }
        .         
        .         void bn_select_words(BN_ULONG *r, BN_ULONG mask, const BN_ULONG *a,
  109,740 (0.0%)                       const BN_ULONG *b, size_t num) {
1,490,454 (0.5%)    for (size_t i = 0; i < num; i++) {
        .             OPENSSL_STATIC_ASSERT(sizeof(BN_ULONG) <= sizeof(crypto_word_t),
        .                                   crypto_word_t_is_too_small)
6,819,024 (2.2%)      r[i] = constant_time_select_w(mask, a[i], b[i]);
        .           }
   54,870 (0.0%)  }
        .         
   71,332 (0.0%)  int bn_minimal_width(const BIGNUM *bn) {
   53,499 (0.0%)    int ret = bn->width;
  309,389 (0.1%)    while (ret > 0 && bn->d[ret - 1] == 0) {
    6,465 (0.0%)      ret--;
        .           }
   17,833 (0.0%)    return ret;
   35,666 (0.0%)  }
        .         
   87,300 (0.0%)  void bn_set_minimal_width(BIGNUM *bn) {
   87,300 (0.0%)    bn->width = bn_minimal_width(bn);
   69,840 (0.0%)    if (bn->width == 0) {
        4 (0.0%)      bn->neg = 0;
        .           }
   52,380 (0.0%)  }
        .         
        .         int BN_get_flags(const BIGNUM *bn, int flags) {
        .           return bn->flags & flags;
        .         }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/cmp.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 59 ----------------------------------------
        .         #include <openssl/mem.h>
        .         #include <openssl/type_check.h>
        .         
        .         #include "internal.h"
        .         #include "../../internal.h"
        .         
        .         
        .         static int bn_cmp_words_consttime(const BN_ULONG *a, size_t a_len,
   24,320 (0.0%)                                    const BN_ULONG *b, size_t b_len) {
        .           OPENSSL_STATIC_ASSERT(sizeof(BN_ULONG) <= sizeof(crypto_word_t),
        .                                 crypto_word_t_is_too_small)
    3,040 (0.0%)    int ret = 0;
        .           // Process the common words in little-endian order.
   15,200 (0.0%)    size_t min = a_len < b_len ? a_len : b_len;
  403,048 (0.1%)    for (size_t i = 0; i < min; i++) {
1,357,468 (0.4%)      crypto_word_t eq = constant_time_eq_w(a[i], b[i]);
1,357,468 (0.4%)      crypto_word_t lt = constant_time_lt_w(a[i], b[i]);
        .             ret =
1,163,544 (0.4%)          constant_time_select_int(eq, ret, constant_time_select_int(lt, -1, 1));
        .           }
        .         
        .           // If |a| or |b| has non-zero words beyond |min|, they take precedence.
    9,120 (0.0%)    if (a_len < b_len) {
       63 (0.0%)      crypto_word_t mask = 0;
      878 (0.0%)      for (size_t i = a_len; i < b_len; i++) {
      750 (0.0%)        mask |= b[i];
        .             }
      693 (0.0%)      ret = constant_time_select_int(constant_time_is_zero_w(mask), ret, -1);
    8,931 (0.0%)    } else if (b_len < a_len) {
       63 (0.0%)      crypto_word_t mask = 0;
      754 (0.0%)      for (size_t i = b_len; i < a_len; i++) {
      564 (0.0%)        mask |= a[i];
        .             }
      630 (0.0%)      ret = constant_time_select_int(constant_time_is_zero_w(mask), ret, 1);
        .           }
        .         
    3,040 (0.0%)    return ret;
    6,080 (0.0%)  }
        .         
   17,748 (0.0%)  int BN_ucmp(const BIGNUM *a, const BIGNUM *b) {
   35,496 (0.0%)    return bn_cmp_words_consttime(a->d, a->width, b->d, b->width);
    5,916 (0.0%)  }
        .         
       60 (0.0%)  int BN_cmp(const BIGNUM *a, const BIGNUM *b) {
       40 (0.0%)    if ((a == NULL) || (b == NULL)) {
        .             if (a != NULL) {
        .               return -1;
        .             } else if (b != NULL) {
        .               return 1;
        .             } else {
        .               return 0;
        .             }
        .           }
        .         
        .           // We do not attempt to process the sign bit in constant time. Negative
        .           // |BIGNUM|s should never occur in crypto, only calculators.
       60 (0.0%)    if (a->neg != b->neg) {
        .             if (a->neg) {
        .               return -1;
        .             }
        .             return 1;
        .           }
        .         
       60 (0.0%)    int ret = BN_ucmp(a, b);
       50 (0.0%)    return a->neg ? -ret : ret;
       20 (0.0%)  }
        .         
      574 (0.0%)  int bn_less_than_words(const BN_ULONG *a, const BN_ULONG *b, size_t len) {
      656 (0.0%)    return bn_cmp_words_consttime(a, len, b, len) < 0;
      164 (0.0%)  }
        .         
       15 (0.0%)  int BN_abs_is_word(const BIGNUM *bn, BN_ULONG w) {
       12 (0.0%)    if (bn->width == 0) {
        .             return w == 0;
        .           }
       15 (0.0%)    BN_ULONG mask = bn->d[0] ^ w;
      338 (0.0%)    for (int i = 1; i < bn->width; i++) {
      512 (0.0%)      mask |= bn->d[i];
        .           }
        9 (0.0%)    return mask == 0;
        6 (0.0%)  }
        .         
        .         int BN_cmp_word(const BIGNUM *a, BN_ULONG b) {
        .           BIGNUM b_bn;
        .           BN_init(&b_bn);
        .         
        .           b_bn.d = &b;
        .           b_bn.width = b > 0;
        .           b_bn.dmax = 1;
        .           b_bn.flags = BN_FLG_STATIC_DATA;
        .           return BN_cmp(a, &b_bn);
        .         }
        .         
   14,805 (0.0%)  int BN_is_zero(const BIGNUM *bn) {
   11,844 (0.0%)    return bn_fits_in_words(bn, 0);
    5,922 (0.0%)  }
        .         
       15 (0.0%)  int BN_is_one(const BIGNUM *bn) {
       36 (0.0%)    return bn->neg == 0 && BN_abs_is_word(bn, 1);
        6 (0.0%)  }
        .         
        .         int BN_is_word(const BIGNUM *bn, BN_ULONG w) {
        .           return BN_abs_is_word(bn, w) && (w == 0 || bn->neg == 0);
        .         }
        .         
   23,960 (0.0%)  int BN_is_odd(const BIGNUM *bn) {
   68,998 (0.0%)    return bn->width > 0 && (bn->d[0] & 1) == 1;
   11,980 (0.0%)  }
        .         
        .         int BN_is_pow2(const BIGNUM *bn) {
        .           int width = bn_minimal_width(bn);
        .           if (width == 0 || bn->neg) {
        .             return 0;
        .           }
        .         
        .           for (int i = 0; i < width - 1; i++) {
-- line 174 ----------------------------------------
-- line 175 ----------------------------------------
        .             if (bn->d[i] != 0) {
        .               return 0;
        .             }
        .           }
        .         
        .           return 0 == (bn->d[width-1] & (bn->d[width-1] - 1));
        .         }
        .         
        5 (0.0%)  int BN_equal_consttime(const BIGNUM *a, const BIGNUM *b) {
        1 (0.0%)    BN_ULONG mask = 0;
        .           // If |a| or |b| has more words than the other, all those words must be zero.
        8 (0.0%)    for (int i = a->width; i < b->width; i++) {
        .             mask |= b->d[i];
        .           }
        8 (0.0%)    for (int i = b->width; i < a->width; i++) {
        .             mask |= a->d[i];
        .           }
        .           // Common words must match.
        7 (0.0%)    int min = a->width < b->width ? a->width : b->width;
      261 (0.0%)    for (int i = 0; i < min; i++) {
    1,024 (0.0%)      mask |= (a->d[i] ^ b->d[i]);
        .           }
        .           // The sign bit must match.
        7 (0.0%)    mask |= (a->neg ^ b->neg);
        3 (0.0%)    return mask == 0;
        2 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/div.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 132 ----------------------------------------
      .             l = (l & BN_MASK2l) << BN_BITS4;
      .           }
      .         
      .           ret |= q;
      .           return ret;
      .         }
      .         
      .         static inline void bn_div_rem_words(BN_ULONG *quotient_out, BN_ULONG *rem_out,
    931 (0.0%)                                      BN_ULONG n0, BN_ULONG n1, BN_ULONG d0) {
      .           // GCC and Clang generate function calls to |__udivdi3| and |__umoddi3| when
      .           // the |BN_ULLONG|-based C code is used.
      .           //
      .           // GCC bugs:
      .           //   * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=14224
      .           //   * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43721
      .           //   * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54183
      .           //   * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58897
-- line 148 ----------------------------------------
-- line 155 ----------------------------------------
      .           // These issues aren't specific to x86 and x86_64, so it might be worthwhile
      .           // to add more assembly language implementations.
      .         #if defined(BN_CAN_USE_INLINE_ASM) && defined(OPENSSL_X86)
      .           __asm__ volatile("divl %4"
      .                            : "=a"(*quotient_out), "=d"(*rem_out)
      .                            : "a"(n1), "d"(n0), "rm"(d0)
      .                            : "cc");
      .         #elif defined(BN_CAN_USE_INLINE_ASM) && defined(OPENSSL_X86_64)
  1,064 (0.0%)    __asm__ volatile("divq %4"
      .                            : "=a"(*quotient_out), "=d"(*rem_out)
      .                            : "a"(n1), "d"(n0), "rm"(d0)
      .                            : "cc");
      .         #else
      .         #if defined(BN_CAN_DIVIDE_ULLONG)
      .           BN_ULLONG n = (((BN_ULLONG)n0) << BN_BITS2) | n1;
      .           *quotient_out = (BN_ULONG)(n / d0);
      .         #else
      .           *quotient_out = bn_div_words(n0, n1, d0);
      .         #endif
      .           *rem_out = n1 - (*quotient_out * d0);
      .         #endif
    399 (0.0%)  }
      .         
      .         // BN_div computes "quotient := numerator / divisor", rounding towards zero,
      .         // and sets up |rem| such that "quotient * divisor + rem = numerator" holds.
      .         //
      .         // Thus:
      .         //
      .         //     quotient->neg == numerator->neg ^ divisor->neg
      .         //        (unless the result is zero)
-- line 184 ----------------------------------------
-- line 187 ----------------------------------------
      .         //
      .         // If |quotient| or |rem| is NULL, the respective value is not returned.
      .         //
      .         // This was specifically designed to contain fewer branches that may leak
      .         // sensitive information; see "New Branch Prediction Vulnerabilities in OpenSSL
      .         // and Necessary Software Countermeasures" by Onur Acıçmez, Shay Gueron, and
      .         // Jean-Pierre Seifert.
      .         int BN_div(BIGNUM *quotient, BIGNUM *rem, const BIGNUM *numerator,
     39 (0.0%)             const BIGNUM *divisor, BN_CTX *ctx) {
      .           int norm_shift, loop;
      .           BIGNUM wnum;
      .           BN_ULONG *resp, *wnump;
      .           BN_ULONG d0, d1;
      .           int num_n, div_n;
      .         
      .           // This function relies on the historical minimal-width |BIGNUM| invariant.
      .           // It is already not constant-time (constant-time reductions should use
      .           // Montgomery logic), so we shrink all inputs and intermediate values to
      .           // retain the previous behavior.
      .         
      .           // Invalid zero-padding would have particularly bad consequences.
     12 (0.0%)    int numerator_width = bn_minimal_width(numerator);
     12 (0.0%)    int divisor_width = bn_minimal_width(divisor);
     42 (0.0%)    if ((numerator_width > 0 && numerator->d[numerator_width - 1] == 0) ||
     30 (0.0%)        (divisor_width > 0 && divisor->d[divisor_width - 1] == 0)) {
      .             OPENSSL_PUT_ERROR(BN, BN_R_NOT_INITIALIZED);
      .             return 0;
      .           }
      .         
     15 (0.0%)    if (BN_is_zero(divisor)) {
      .             OPENSSL_PUT_ERROR(BN, BN_R_DIV_BY_ZERO);
      .             return 0;
      .           }
      .         
      9 (0.0%)    BN_CTX_start(ctx);
     12 (0.0%)    BIGNUM *tmp = BN_CTX_get(ctx);
     12 (0.0%)    BIGNUM *snum = BN_CTX_get(ctx);
     12 (0.0%)    BIGNUM *sdiv = BN_CTX_get(ctx);
      3 (0.0%)    BIGNUM *res = NULL;
      6 (0.0%)    if (quotient == NULL) {
     15 (0.0%)      res = BN_CTX_get(ctx);
      .           } else {
      .             res = quotient;
      .           }
     12 (0.0%)    if (sdiv == NULL || res == NULL) {
      .             goto err;
      .           }
      .         
      .           // First we normalise the numbers
     24 (0.0%)    norm_shift = BN_BITS2 - (BN_num_bits(divisor) % BN_BITS2);
     24 (0.0%)    if (!BN_lshift(sdiv, divisor, norm_shift)) {
      .             goto err;
      .           }
      9 (0.0%)    bn_set_minimal_width(sdiv);
      6 (0.0%)    sdiv->neg = 0;
      3 (0.0%)    norm_shift += BN_BITS2;
     24 (0.0%)    if (!BN_lshift(snum, numerator, norm_shift)) {
      .             goto err;
      .           }
      9 (0.0%)    bn_set_minimal_width(snum);
      6 (0.0%)    snum->neg = 0;
      .         
      .           // Since we don't want to have special-case logic for the case where snum is
      .           // larger than sdiv, we pad snum with enough zeroes without changing its
      .           // value.
     21 (0.0%)    if (snum->width <= sdiv->width + 1) {
     10 (0.0%)      if (!bn_wexpand(snum, sdiv->width + 2)) {
      .               goto err;
      .             }
     15 (0.0%)      for (int i = snum->width; i < sdiv->width + 2; i++) {
      7 (0.0%)        snum->d[i] = 0;
      .             }
      6 (0.0%)      snum->width = sdiv->width + 2;
      .           } else {
     20 (0.0%)      if (!bn_wexpand(snum, snum->width + 1)) {
      .               goto err;
      .             }
     16 (0.0%)      snum->d[snum->width] = 0;
     10 (0.0%)      snum->width++;
      .           }
      .         
      9 (0.0%)    div_n = sdiv->width;
      9 (0.0%)    num_n = snum->width;
      9 (0.0%)    loop = num_n - div_n;
      .           // Lets setup a 'window' into snum
      .           // This is the part that corresponds to the current
      .           // 'area' being divided
      3 (0.0%)    wnum.neg = 0;
     21 (0.0%)    wnum.d = &(snum->d[loop]);
      6 (0.0%)    wnum.width = div_n;
      .           // only needed when BN_ucmp messes up the values between width and max
     12 (0.0%)    wnum.dmax = snum->dmax - loop;  // so we don't step out of bounds
      .         
      .           // Get the top 2 words of sdiv
      .           // div_n=sdiv->width;
     27 (0.0%)    d0 = sdiv->d[div_n - 1];
     36 (0.0%)    d1 = (div_n == 1) ? 0 : sdiv->d[div_n - 2];
      .         
      .           // pointer to the 'top' of snum
     24 (0.0%)    wnump = &(snum->d[num_n - 1]);
      .         
      .           // Setup |res|. |numerator| and |res| may alias, so we save |numerator->neg|
      .           // for later.
      9 (0.0%)    const int numerator_neg = numerator->neg;
     18 (0.0%)    res->neg = (numerator_neg ^ divisor->neg);
     27 (0.0%)    if (!bn_wexpand(res, loop + 1)) {
      .             goto err;
      .           }
     12 (0.0%)    res->width = loop - 1;
     24 (0.0%)    resp = &(res->d[loop - 1]);
      .         
      .           // space for temp
     27 (0.0%)    if (!bn_wexpand(tmp, div_n + 1)) {
      .             goto err;
      .           }
      .         
      .           // if res->width == 0 then clear the neg value otherwise decrease
      .           // the resp pointer
     12 (0.0%)    if (res->width == 0) {
      .             res->neg = 0;
      .           } else {
      3 (0.0%)      resp--;
      .           }
      .         
    949 (0.0%)    for (int i = 0; i < loop - 1; i++, wnump--, resp--) {
      .             BN_ULONG q, l0;
      .             // the first part of the loop uses the top two words of snum and sdiv to
      .             // calculate a BN_ULONG q such that | wnum - sdiv * q | < sdiv
    133 (0.0%)      BN_ULONG n0, n1, rm = 0;
      .         
    399 (0.0%)      n0 = wnump[0];
    399 (0.0%)      n1 = wnump[-1];
    399 (0.0%)      if (n0 == d0) {
      .               q = BN_MASK2;
      .             } else {
      .               // n0 < d0
  1,064 (0.0%)        bn_div_rem_words(&q, &rm, n0, n1, d0);
      .         
      .         #ifdef BN_ULLONG
  2,261 (0.0%)        BN_ULLONG t2 = (BN_ULLONG)d1 * q;
      .               for (;;) {
  2,434 (0.0%)          if (t2 <= ((((BN_ULLONG)rm) << BN_BITS2) | wnump[-2])) {
    214 (0.0%)            break;
      .                 }
    132 (0.0%)          q--;
    176 (0.0%)          rm += d0;
    132 (0.0%)          if (rm < d0) {
     26 (0.0%)            break;  // don't let rm overflow
      .                 }
     72 (0.0%)          t2 -= d1;
      .               }
      .         #else  // !BN_ULLONG
      .               BN_ULONG t2l, t2h;
      .               BN_UMULT_LOHI(t2l, t2h, d1, q);
      .               for (;;) {
      .                 if (t2h < rm ||
      .                     (t2h == rm && t2l <= wnump[-2])) {
      .                   break;
-- line 344 ----------------------------------------
-- line 351 ----------------------------------------
      .                 if (t2l < d1) {
      .                   t2h--;
      .                 }
      .                 t2l -= d1;
      .               }
      .         #endif  // !BN_ULLONG
      .             }
      .         
  1,330 (0.0%)      l0 = bn_mul_words(tmp->d, sdiv->d, div_n, q);
  1,064 (0.0%)      tmp->d[div_n] = l0;
    399 (0.0%)      wnum.d--;
      .             // ingore top values of the bignums just sub the two
      .             // BN_ULONG arrays with bn_sub_words
  1,463 (0.0%)      if (bn_sub_words(wnum.d, wnum.d, tmp->d, div_n + 1)) {
      .               // Note: As we have considered only the leading
      .               // two BN_ULONGs in the calculation of q, sdiv * q
      .               // might be greater than wnum (but then (q-1) * sdiv
      .               // is less or equal than wnum)
      .               q--;
      .               if (bn_add_words(wnum.d, wnum.d, sdiv->d, div_n)) {
      .                 // we can't have an overflow here (assuming
      .                 // that q != 0, but if q == 0 then tmp is
      .                 // zero anyway)
      .                 (*wnump)++;
      .               }
      .             }
      .             // store part of the result
    399 (0.0%)      *resp = q;
      .           }
      .         
      9 (0.0%)    bn_set_minimal_width(snum);
      .         
      6 (0.0%)    if (rem != NULL) {
     24 (0.0%)      if (!BN_rshift(rem, snum, norm_shift)) {
      .               goto err;
      .             }
     15 (0.0%)      if (!BN_is_zero(rem)) {
      9 (0.0%)        rem->neg = numerator_neg;
      .             }
      .           }
      .         
      9 (0.0%)    bn_set_minimal_width(res);
      9 (0.0%)    BN_CTX_end(ctx);
      6 (0.0%)    return 1;
      .         
      .         err:
      .           BN_CTX_end(ctx);
      .           return 0;
     18 (0.0%)  }
      .         
      8 (0.0%)  int BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx) {
     10 (0.0%)    if (!(BN_mod(r, m, d, ctx))) {
      .             return 0;
      .           }
      4 (0.0%)    if (!r->neg) {
      .             return 1;
      .           }
      .         
      .           // now -|d| < r < 0, so we have to set r := r + |d|.
     12 (0.0%)    return (d->neg ? BN_sub : BN_add)(r, r, d);
      2 (0.0%)  }
      .         
      .         BN_ULONG bn_reduce_once(BN_ULONG *r, const BN_ULONG *a, BN_ULONG carry,
     81 (0.0%)                          const BN_ULONG *m, size_t num) {
     27 (0.0%)    assert(r != a);
      .           // |r| = |a| - |m|. |bn_sub_words| performs the bulk of the subtraction, and
      .           // then we apply the borrow to |carry|.
     63 (0.0%)    carry -= bn_sub_words(r, a, m, num);
      .           // We know 0 <= |a| < 2*|m|, so -|m| <= |r| < |m|.
      .           //
      .           // If 0 <= |r| < |m|, |r| fits in |num| words and |carry| is zero. We then
      .           // wish to select |r| as the answer. Otherwise -m <= r < 0 and we wish to
      .           // return |r| + |m|, or |a|. |carry| must then be -1 or all ones. In both
      .           // cases, |carry| is a suitable input to |bn_select_words|.
      .           //
      .           // Although |carry| may be one if it was one on input and |bn_sub_words|
      .           // returns zero, this would give |r| > |m|, violating our input assumptions.
     32 (0.0%)    assert(carry == 0 || carry == (BN_ULONG)-1);
     72 (0.0%)    bn_select_words(r, carry, a /* r < 0 */, r /* r >= 0 */, num);
      9 (0.0%)    return carry;
     18 (0.0%)  }
      .         
      .         BN_ULONG bn_reduce_once_in_place(BN_ULONG *r, BN_ULONG carry, const BN_ULONG *m,
 98,082 (0.0%)                                   BN_ULONG *tmp, size_t num) {
      .           // See |bn_reduce_once| for why this logic works.
 76,286 (0.0%)    carry -= bn_sub_words(tmp, r, m, num);
 33,170 (0.0%)    assert(carry == 0 || carry == (BN_ULONG)-1);
 87,184 (0.0%)    bn_select_words(r, carry, r /* tmp < 0 */, tmp /* tmp >= 0 */, num);
 10,898 (0.0%)    return carry;
 21,796 (0.0%)  }
      .         
      .         void bn_mod_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,
     10 (0.0%)                        const BN_ULONG *m, BN_ULONG *tmp, size_t num) {
      .           // r = a - b
      7 (0.0%)    BN_ULONG borrow = bn_sub_words(r, a, b, num);
      .           // tmp = a - b + m
      6 (0.0%)    bn_add_words(tmp, r, m, num);
     10 (0.0%)    bn_select_words(r, 0 - borrow, tmp /* r < 0 */, r /* r >= 0 */, num);
      3 (0.0%)  }
      .         
      .         void bn_mod_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,
  1,460 (0.0%)                        const BN_ULONG *m, BN_ULONG *tmp, size_t num) {
  1,022 (0.0%)    BN_ULONG carry = bn_add_words(r, a, b, num);
  1,168 (0.0%)    bn_reduce_once_in_place(r, carry, m, tmp, num);
    438 (0.0%)  }
      .         
      .         int bn_div_consttime(BIGNUM *quotient, BIGNUM *remainder,
      .                              const BIGNUM *numerator, const BIGNUM *divisor,
     50 (0.0%)                       unsigned divisor_min_bits, BN_CTX *ctx) {
     50 (0.0%)    if (BN_is_negative(numerator) || BN_is_negative(divisor)) {
      .             OPENSSL_PUT_ERROR(BN, BN_R_NEGATIVE_NUMBER);
      .             return 0;
      .           }
     25 (0.0%)    if (BN_is_zero(divisor)) {
      .             OPENSSL_PUT_ERROR(BN, BN_R_DIV_BY_ZERO);
      .             return 0;
      .           }
      .         
      .           // This function implements long division in binary. It is not very efficient,
      .           // but it is simple, easy to make constant-time, and performant enough for RSA
      .           // key generation.
      .         
      5 (0.0%)    int ret = 0;
     15 (0.0%)    BN_CTX_start(ctx);
     20 (0.0%)    BIGNUM *q = quotient, *r = remainder;
     10 (0.0%)    if (quotient == NULL || quotient == numerator || quotient == divisor) {
     20 (0.0%)      q = BN_CTX_get(ctx);
      .           }
     34 (0.0%)    if (remainder == NULL || remainder == numerator || remainder == divisor) {
      8 (0.0%)      r = BN_CTX_get(ctx);
      .           }
     20 (0.0%)    BIGNUM *tmp = BN_CTX_get(ctx);
     40 (0.0%)    if (q == NULL || r == NULL || tmp == NULL ||
     45 (0.0%)        !bn_wexpand(q, numerator->width) ||
     45 (0.0%)        !bn_wexpand(r, divisor->width) ||
     35 (0.0%)        !bn_wexpand(tmp, divisor->width)) {
      .             goto err;
      .           }
      .         
     45 (0.0%)    OPENSSL_memset(q->d, 0, numerator->width * sizeof(BN_ULONG));
     20 (0.0%)    q->width = numerator->width;
     10 (0.0%)    q->neg = 0;
      .         
     45 (0.0%)    OPENSSL_memset(r->d, 0, divisor->width * sizeof(BN_ULONG));
     20 (0.0%)    r->width = divisor->width;
     10 (0.0%)    r->neg = 0;
      .         
      .           // Incorporate |numerator| into |r|, one bit at a time, reducing after each
      .           // step. We maintain the invariant that |0 <= r < divisor| and
      .           // |q * divisor + r = n| where |n| is the portion of |numerator| incorporated
      .           // so far.
      .           //
      .           // First, we short-circuit the loop: if we know |divisor| has at least
      .           // |divisor_min_bits| bits, the top |divisor_min_bits - 1| can be incorporated
      .           // without reductions. This significantly speeds up |RSA_check_key|. For
      .           // simplicity, we round down to a whole number of words.
     25 (0.0%)    assert(divisor_min_bits <= BN_num_bits(divisor));
      5 (0.0%)    int initial_words = 0;
     10 (0.0%)    if (divisor_min_bits > 0) {
     20 (0.0%)      initial_words = (divisor_min_bits - 1) / BN_BITS2;
     20 (0.0%)      if (initial_words > numerator->width) {
      .               initial_words = numerator->width;
      .             }
     90 (0.0%)      OPENSSL_memcpy(r->d, numerator->d + numerator->width - initial_words,
      .                            initial_words * sizeof(BN_ULONG));
      .           }
      .         
    544 (0.0%)    for (int i = numerator->width - initial_words - 1; i >= 0; i--) {
 32,928 (0.0%)      for (int bit = BN_BITS2 - 1; bit >= 0; bit--) {
      .               // Incorporate the next bit of the numerator, by computing
      .               // r = 2*r or 2*r + 1. Note the result fits in one more word. We store the
      .               // extra word in |carry|.
129,024 (0.0%)        BN_ULONG carry = bn_add_words(r->d, r->d, r->d, divisor->width);
215,040 (0.1%)        r->d[0] |= (numerator->d[i] >> bit) & 1;
      .               // |r| was previously fully-reduced, so we know:
      .               //      2*0 <= r <= 2*(divisor-1) + 1
      .               //        0 <= r <= 2*divisor - 1 < 2*divisor.
      .               // Thus |r| satisfies the preconditions for |bn_reduce_once_in_place|.
129,024 (0.0%)        BN_ULONG subtracted = bn_reduce_once_in_place(r->d, carry, divisor->d,
 21,504 (0.0%)                                                      tmp->d, divisor->width);
      .               // The corresponding bit of the quotient is set iff we needed to subtract.
247,296 (0.1%)        q->d[i] |= (~subtracted & 1) << bit;
      .             }
      .           }
      .         
     20 (0.0%)    if ((quotient != NULL && !BN_copy(quotient, q)) ||
     35 (0.0%)        (remainder != NULL && !BN_copy(remainder, r))) {
      .             goto err;
      .           }
      .         
     10 (0.0%)    ret = 1;
      .         
      .         err:
     15 (0.0%)    BN_CTX_end(ctx);
      5 (0.0%)    return ret;
     10 (0.0%)  }
      .         
     18 (0.0%)  static BIGNUM *bn_scratch_space_from_ctx(size_t width, BN_CTX *ctx) {
     12 (0.0%)    BIGNUM *ret = BN_CTX_get(ctx);
     12 (0.0%)    if (ret == NULL ||
     15 (0.0%)        !bn_wexpand(ret, width)) {
      .             return NULL;
      .           }
      6 (0.0%)    ret->neg = 0;
     12 (0.0%)    ret->width = (int)width;
      3 (0.0%)    return ret;
      6 (0.0%)  }
      .         
      .         // bn_resized_from_ctx returns |bn| with width at least |width| or NULL on
      .         // error. This is so it may be used with low-level "words" functions. If
      .         // necessary, it allocates a new |BIGNUM| with a lifetime of the current scope
      .         // in |ctx|, so the caller does not need to explicitly free it. |bn| must fit in
      .         // |width| words.
      .         static const BIGNUM *bn_resized_from_ctx(const BIGNUM *bn, size_t width,
     14 (0.0%)                                           BN_CTX *ctx) {
     10 (0.0%)    if ((size_t)bn->width >= width) {
      .             // Any excess words must be zero.
     14 (0.0%)      assert(bn_fits_in_words(bn, width));
      4 (0.0%)      return bn;
      .           }
      .           BIGNUM *ret = bn_scratch_space_from_ctx(width, ctx);
      .           if (ret == NULL ||
      .               !BN_copy(ret, bn) ||
      .               !bn_resize_words(ret, width)) {
      .             return NULL;
      .           }
      .           return ret;
      4 (0.0%)  }
      .         
      .         int BN_mod_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,
      .                        BN_CTX *ctx) {
      .           if (!BN_add(r, a, b)) {
      .             return 0;
      .           }
      .           return BN_nnmod(r, r, m, ctx);
      .         }
-- line 586 ----------------------------------------
-- line 615 ----------------------------------------
      .                        BN_CTX *ctx) {
      .           if (!BN_sub(r, a, b)) {
      .             return 0;
      .           }
      .           return BN_nnmod(r, r, m, ctx);
      .         }
      .         
      .         int bn_mod_sub_consttime(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
      9 (0.0%)                           const BIGNUM *m, BN_CTX *ctx) {
      3 (0.0%)    BN_CTX_start(ctx);
      9 (0.0%)    a = bn_resized_from_ctx(a, m->width, ctx);
      9 (0.0%)    b = bn_resized_from_ctx(b, m->width, ctx);
      8 (0.0%)    BIGNUM *tmp = bn_scratch_space_from_ctx(m->width, ctx);
     11 (0.0%)    int ok = a != NULL && b != NULL && tmp != NULL &&
      7 (0.0%)             bn_wexpand(r, m->width);
      2 (0.0%)    if (ok) {
     17 (0.0%)      bn_mod_sub_words(r->d, a->d, b->d, m->d, tmp->d, m->width);
      4 (0.0%)      r->width = m->width;
      2 (0.0%)      r->neg = 0;
      .           }
      3 (0.0%)    BN_CTX_end(ctx);
      1 (0.0%)    return ok;
      2 (0.0%)  }
      .         
      .         int BN_mod_sub_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
      .                              const BIGNUM *m) {
      .           BN_CTX *ctx = BN_CTX_new();
      .           int ok = ctx != NULL &&
      .                    bn_mod_sub_consttime(r, a, b, m, ctx);
      .           BN_CTX_free(ctx);
      .           return ok;
-- line 645 ----------------------------------------
-- line 705 ----------------------------------------
      .         
      .           ret = bn_mod_lshift_consttime(r, r, n, (abs_m ? abs_m : m), ctx);
      .         
      .           BN_free(abs_m);
      .           return ret;
      .         }
      .         
      .         int bn_mod_lshift_consttime(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m,
     18 (0.0%)                              BN_CTX *ctx) {
     18 (0.0%)    if (!BN_copy(r, a) ||
     14 (0.0%)        !bn_resize_words(r, m->width)) {
      .             return 0;
      .           }
      .         
      6 (0.0%)    BN_CTX_start(ctx);
     16 (0.0%)    BIGNUM *tmp = bn_scratch_space_from_ctx(m->width, ctx);
      8 (0.0%)    int ok = tmp != NULL;
      4 (0.0%)    if (ok) {
    274 (0.0%)      for (int i = 0; i < n; i++) {
  1,122 (0.0%)        bn_mod_add_words(r->d, r->d, r->d, m->d, tmp->d, m->width);
      .             }
      4 (0.0%)      r->neg = 0;
      .           }
      6 (0.0%)    BN_CTX_end(ctx);
      2 (0.0%)    return ok;
      4 (0.0%)  }
      .         
      .         int BN_mod_lshift_quick(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m) {
      .           BN_CTX *ctx = BN_CTX_new();
      .           int ok = ctx != NULL &&
      .                    bn_mod_lshift_consttime(r, a, n, m, ctx);
      .           BN_CTX_free(ctx);
      .           return ok;
      .         }
-- line 738 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/gcd.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 109 ----------------------------------------
     .         #include <openssl/bn.h>
     .         
     .         #include <openssl/err.h>
     .         
     .         #include "internal.h"
     .         
     .         
     .         int BN_mod_inverse_odd(BIGNUM *out, int *out_no_inverse, const BIGNUM *a,
     9 (0.0%)                         const BIGNUM *n, BN_CTX *ctx) {
     2 (0.0%)    *out_no_inverse = 0;
     .         
     5 (0.0%)    if (!BN_is_odd(n)) {
     .             OPENSSL_PUT_ERROR(BN, BN_R_CALLED_WITH_EVEN_MODULUS);
     .             return 0;
     .           }
     .         
    12 (0.0%)    if (BN_is_negative(a) || BN_cmp(a, n) >= 0) {
     .             OPENSSL_PUT_ERROR(BN, BN_R_INPUT_NOT_REDUCED);
     .             return 0;
     .           }
     .         
     .           BIGNUM *A, *B, *X, *Y;
     1 (0.0%)    int ret = 0;
     .           int sign;
     .         
     3 (0.0%)    BN_CTX_start(ctx);
     4 (0.0%)    A = BN_CTX_get(ctx);
     4 (0.0%)    B = BN_CTX_get(ctx);
     4 (0.0%)    X = BN_CTX_get(ctx);
     4 (0.0%)    Y = BN_CTX_get(ctx);
     2 (0.0%)    if (Y == NULL) {
     .             goto err;
     .           }
     .         
     2 (0.0%)    BIGNUM *R = out;
     .         
     3 (0.0%)    BN_zero(Y);
    19 (0.0%)    if (!BN_one(X) || BN_copy(B, a) == NULL || BN_copy(A, n) == NULL) {
     .             goto err;
     .           }
     2 (0.0%)    A->neg = 0;
     1 (0.0%)    sign = -1;
     .           // From  B = a mod |n|,  A = |n|  it follows that
     .           //
     .           //      0 <= B < A,
     .           //     -sign*X*a  ==  B   (mod |n|),
     .           //      sign*Y*a  ==  A   (mod |n|).
     .         
     .           // Binary inversion algorithm; requires odd modulus. This is faster than the
     .           // general algorithm if the modulus is sufficiently small (about 400 .. 500
     .           // bits on 32-bit systems, but much more on 64-bit systems)
     .           int shift;
     .         
14,686 (0.0%)    while (!BN_is_zero(B)) {
     .             //      0 < B < |n|,
     .             //      0 < A <= |n|,
     .             // (1) -sign*X*a  ==  B   (mod |n|),
     .             // (2)  sign*Y*a  ==  A   (mod |n|)
     .         
     .             // Now divide  B  by the maximum possible power of two in the integers,
     .             // and divide  X  by the same value mod |n|.
     .             // When we're done, (1) still holds.
 2,936 (0.0%)      shift = 0;
43,851 (0.0%)      while (!BN_is_bit_set(B, shift)) {
     .               // note that 0 < B
 2,909 (0.0%)        shift++;
     .         
14,545 (0.0%)        if (BN_is_odd(X)) {
11,192 (0.0%)          if (!BN_uadd(X, X, n)) {
     .                   goto err;
     .                 }
     .               }
     .               // now X is even, so we can easily divide it by two
20,363 (0.0%)        if (!BN_rshift1(X, X)) {
     .                 goto err;
     .               }
     .             }
 5,872 (0.0%)      if (shift > 0) {
12,080 (0.0%)        if (!BN_rshift(B, B, shift)) {
     .                 goto err;
     .               }
     .             }
     .         
     .             // Same for A and Y. Afterwards, (2) still holds.
 2,936 (0.0%)      shift = 0;
43,403 (0.0%)      while (!BN_is_bit_set(A, shift)) {
     .               // note that 0 < A
 2,845 (0.0%)        shift++;
     .         
14,225 (0.0%)        if (BN_is_odd(Y)) {
11,784 (0.0%)          if (!BN_uadd(Y, Y, n)) {
     .                   goto err;
     .                 }
     .               }
     .               // now Y is even
19,915 (0.0%)        if (!BN_rshift1(Y, Y)) {
     .                 goto err;
     .               }
     .             }
 5,872 (0.0%)      if (shift > 0) {
11,400 (0.0%)        if (!BN_rshift(A, A, shift)) {
     .                 goto err;
     .               }
     .             }
     .         
     .             // We still have (1) and (2).
     .             // Both  A  and  B  are odd.
     .             // The following computations ensure that
     .             //
     .             //     0 <= B < |n|,
     .             //      0 < A < |n|,
     .             // (1) -sign*X*a  ==  B   (mod |n|),
     .             // (2)  sign*Y*a  ==  A   (mod |n|),
     .             //
     .             // and that either  A  or  B  is even in the next iteration.
20,552 (0.0%)      if (BN_ucmp(B, A) >= 0) {
     .               // -sign*(X + Y)*a == B - A  (mod |n|)
12,088 (0.0%)        if (!BN_uadd(X, X, Y)) {
     .                 goto err;
     .               }
     .               // NB: we could use BN_mod_add_quick(X, X, Y, n), but that
     .               // actually makes the algorithm slower
12,088 (0.0%)        if (!BN_usub(B, B, A)) {
     .                 goto err;
     .               }
     .             } else {
     .               //  sign*(X + Y)*a == A - B  (mod |n|)
11,400 (0.0%)        if (!BN_uadd(Y, Y, X)) {
     .                 goto err;
     .               }
     .               // as above, BN_mod_add_quick(Y, Y, X, n) would slow things down
11,400 (0.0%)        if (!BN_usub(A, A, B)) {
     .                 goto err;
     .               }
     .             }
     .           }
     .         
     5 (0.0%)    if (!BN_is_one(A)) {
     .             *out_no_inverse = 1;
     .             OPENSSL_PUT_ERROR(BN, BN_R_NO_INVERSE);
     .             goto err;
     .           }
     .         
     .           // The while loop (Euclid's algorithm) ends when
     .           //      A == gcd(a,n);
     .           // we have
     .           //       sign*Y*a  ==  A  (mod |n|),
     .           // where  Y  is non-negative.
     .         
     2 (0.0%)    if (sign < 0) {
     8 (0.0%)      if (!BN_sub(Y, n, Y)) {
     .               goto err;
     .             }
     .           }
     .           // Now  Y*a  ==  A  (mod |n|).
     .         
     .           // Y*a == 1  (mod |n|)
     4 (0.0%)    if (Y->neg || BN_ucmp(Y, n) >= 0) {
     8 (0.0%)      if (!BN_nnmod(Y, Y, n, ctx)) {
     .               goto err;
     .             }
     .           }
     7 (0.0%)    if (!BN_copy(R, Y)) {
     .             goto err;
     .           }
     .         
     2 (0.0%)    ret = 1;
     .         
     .         err:
     3 (0.0%)    BN_CTX_end(ctx);
     1 (0.0%)    return ret;
     2 (0.0%)  }
     .         
     .         BIGNUM *BN_mod_inverse(BIGNUM *out, const BIGNUM *a, const BIGNUM *n,
     .                                BN_CTX *ctx) {
     .           BIGNUM *new_out = NULL;
     .           if (out == NULL) {
     .             new_out = BN_new();
     .             if (new_out == NULL) {
     .               return NULL;
-- line 288 ----------------------------------------
-- line 319 ----------------------------------------
     .             BN_free(new_out);
     .             out = NULL;
     .           }
     .           BN_free(a_reduced);
     .           return out;
     .         }
     .         
     .         int BN_mod_inverse_blinded(BIGNUM *out, int *out_no_inverse, const BIGNUM *a,
    12 (0.0%)                             const BN_MONT_CTX *mont, BN_CTX *ctx) {
     2 (0.0%)    *out_no_inverse = 0;
     .         
    13 (0.0%)    if (BN_is_negative(a) || BN_cmp(a, &mont->N) >= 0) {
     .             OPENSSL_PUT_ERROR(BN, BN_R_INPUT_NOT_REDUCED);
     .             return 0;
     .           }
     .         
     1 (0.0%)    int ret = 0;
     .           BIGNUM blinding_factor;
     3 (0.0%)    BN_init(&blinding_factor);
     .         
    10 (0.0%)    if (!BN_rand_range_ex(&blinding_factor, 1, &mont->N) ||
    10 (0.0%)        !BN_mod_mul_montgomery(out, &blinding_factor, a, mont, ctx) ||
    11 (0.0%)        !BN_mod_inverse_odd(out, out_no_inverse, out, &mont->N, ctx) ||
     8 (0.0%)        !BN_mod_mul_montgomery(out, &blinding_factor, out, mont, ctx)) {
     .             OPENSSL_PUT_ERROR(BN, ERR_R_BN_LIB);
     .             goto err;
     .           }
     .         
     1 (0.0%)    ret = 1;
     .         
     .         err:
     3 (0.0%)    BN_free(&blinding_factor);
     1 (0.0%)    return ret;
     5 (0.0%)  }
     .         
     .         int bn_mod_inverse_prime(BIGNUM *out, const BIGNUM *a, const BIGNUM *p,
     .                                  BN_CTX *ctx, const BN_MONT_CTX *mont_p) {
     .           BN_CTX_start(ctx);
     .           BIGNUM *p_minus_2 = BN_CTX_get(ctx);
     .           int ok = p_minus_2 != NULL &&
     .                    BN_copy(p_minus_2, p) &&
     .                    BN_sub_word(p_minus_2, 2) &&
-- line 360 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/shift.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 59 ----------------------------------------
        .         #include <string.h>
        .         
        .         #include <openssl/err.h>
        .         #include <openssl/type_check.h>
        .         
        .         #include "internal.h"
        .         
        .         
       42 (0.0%)  int BN_lshift(BIGNUM *r, const BIGNUM *a, int n) {
        .           int i, nw, lb, rb;
        .           BN_ULONG *t, *f;
        .           BN_ULONG l;
        .         
       12 (0.0%)    if (n < 0) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_NEGATIVE_NUMBER);
        .             return 0;
        .           }
        .         
       24 (0.0%)    r->neg = a->neg;
       36 (0.0%)    nw = n / BN_BITS2;
       72 (0.0%)    if (!bn_wexpand(r, a->width + nw + 1)) {
        .             return 0;
        .           }
       48 (0.0%)    lb = n % BN_BITS2;
       18 (0.0%)    rb = BN_BITS2 - lb;
       18 (0.0%)    f = a->d;
       18 (0.0%)    t = r->d;
       54 (0.0%)    t[a->width + nw] = 0;
       12 (0.0%)    if (lb == 0) {
    1,590 (0.0%)      for (i = a->width - 1; i >= 0; i--) {
    7,196 (0.0%)        t[nw + i] = f[i];
        .             }
        .           } else {
        .             for (i = a->width - 1; i >= 0; i--) {
        .               l = f[i];
        .               t[nw + i + 1] |= l >> rb;
        .               t[nw + i] = l << lb;
        .             }
        .           }
       42 (0.0%)    OPENSSL_memset(t, 0, nw * sizeof(t[0]));
       42 (0.0%)    r->width = a->width + nw + 1;
       18 (0.0%)    bn_set_minimal_width(r);
        .         
        6 (0.0%)    return 1;
       12 (0.0%)  }
        .         
        .         int BN_lshift1(BIGNUM *r, const BIGNUM *a) {
        .           BN_ULONG *ap, *rp, t, c;
        .           int i;
        .         
        .           if (r != a) {
        .             r->neg = a->neg;
        .             if (!bn_wexpand(r, a->width + 1)) {
-- line 111 ----------------------------------------
-- line 129 ----------------------------------------
        .             *rp = 1;
        .             r->width++;
        .           }
        .         
        .           return 1;
        .         }
        .         
        .         void bn_rshift_words(BN_ULONG *r, const BN_ULONG *a, unsigned shift,
   23,504 (0.0%)                       size_t num) {
    8,814 (0.0%)    unsigned shift_bits = shift % BN_BITS2;
   11,752 (0.0%)    size_t shift_words = shift / BN_BITS2;
    8,814 (0.0%)    if (shift_words >= num) {
        .             OPENSSL_memset(r, 0, num * sizeof(BN_ULONG));
        .             return;
        .           }
    5,876 (0.0%)    if (shift_bits == 0) {
       36 (0.0%)      OPENSSL_memmove(r, a + shift_words, (num - shift_words) * sizeof(BN_ULONG));
        .           } else {
  482,780 (0.2%)      for (size_t i = shift_words; i < num - 1; i++) {
  554,682 (0.2%)        r[i - shift_words] =
1,848,940 (0.6%)            (a[i] >> shift_bits) | (a[i + 1] << (BN_BITS2 - shift_bits));
        .             }
   49,895 (0.0%)      r[num - 1 - shift_words] = a[num - 1] >> shift_bits;
        .           }
   29,380 (0.0%)    OPENSSL_memset(r + num - shift_words, 0, shift_words * sizeof(BN_ULONG));
    5,876 (0.0%)  }
        .         
   20,566 (0.0%)  int BN_rshift(BIGNUM *r, const BIGNUM *a, int n) {
    5,876 (0.0%)    if (n < 0) {
        .             OPENSSL_PUT_ERROR(BN, BN_R_NEGATIVE_NUMBER);
        .             return 0;
        .           }
        .         
   26,442 (0.0%)    if (!bn_wexpand(r, a->width)) {
        .             return 0;
        .           }
   29,380 (0.0%)    bn_rshift_words(r->d, a->d, n, a->width);
   11,752 (0.0%)    r->neg = a->neg;
   11,752 (0.0%)    r->width = a->width;
    8,814 (0.0%)    bn_set_minimal_width(r);
    2,938 (0.0%)    return 1;
    5,876 (0.0%)  }
        .         
        .         int bn_rshift_secret_shift(BIGNUM *r, const BIGNUM *a, unsigned n,
        .                                    BN_CTX *ctx) {
        .           int ret = 0;
        .           BN_CTX_start(ctx);
        .           BIGNUM *tmp = BN_CTX_get(ctx);
        .           if (tmp == NULL ||
        .               !BN_copy(r, a) ||
-- line 178 ----------------------------------------
-- line 192 ----------------------------------------
        .         
        .           ret = 1;
        .         
        .         err:
        .           BN_CTX_end(ctx);
        .           return ret;
        .         }
        .         
   34,524 (0.0%)  void bn_rshift1_words(BN_ULONG *r, const BN_ULONG *a, size_t num) {
   11,508 (0.0%)    if (num == 0) {
        .             return;
        .           }
1,868,984 (0.6%)    for (size_t i = 0; i < num - 1; i++) {
7,704,732 (2.5%)      r[i] = (a[i] >> 1) | (a[i + 1] << (BN_BITS2 - 1));
        .           }
   80,556 (0.0%)    r[num - 1] = a[num - 1] >> 1;
   11,508 (0.0%)  }
        .         
   34,524 (0.0%)  int BN_rshift1(BIGNUM *r, const BIGNUM *a) {
   51,786 (0.0%)    if (!bn_wexpand(r, a->width)) {
        .             return 0;
        .           }
   57,540 (0.0%)    bn_rshift1_words(r->d, a->d, a->width);
   23,016 (0.0%)    r->width = a->width;
   23,016 (0.0%)    r->neg = a->neg;
   17,262 (0.0%)    bn_set_minimal_width(r);
    5,754 (0.0%)    return 1;
   11,508 (0.0%)  }
        .         
       24 (0.0%)  int BN_set_bit(BIGNUM *a, int n) {
        8 (0.0%)    if (n < 0) {
        .             return 0;
        .           }
        .         
       24 (0.0%)    int i = n / BN_BITS2;
       32 (0.0%)    int j = n % BN_BITS2;
       16 (0.0%)    if (a->width <= i) {
       36 (0.0%)      if (!bn_wexpand(a, i + 1)) {
        .               return 0;
        .             }
    1,316 (0.0%)      for (int k = a->width; k < i + 1; k++) {
    2,254 (0.0%)        a->d[k] = 0;
        .             }
       16 (0.0%)      a->width = i + 1;
        .           }
        .         
       76 (0.0%)    a->d[i] |= (((BN_ULONG)1) << j);
        .         
        4 (0.0%)    return 1;
        8 (0.0%)  }
        .         
        .         int BN_clear_bit(BIGNUM *a, int n) {
        .           int i, j;
        .         
        .           if (n < 0) {
        .             return 0;
        .           }
        .         
-- line 249 ----------------------------------------
-- line 253 ----------------------------------------
        .             return 0;
        .           }
        .         
        .           a->d[i] &= (~(((BN_ULONG)1) << j));
        .           bn_set_minimal_width(a);
        .           return 1;
        .         }
        .         
   70,098 (0.0%)  int bn_is_bit_set_words(const BN_ULONG *a, size_t num, size_t bit) {
   35,049 (0.0%)    size_t i = bit / BN_BITS2;
   35,049 (0.0%)    size_t j = bit % BN_BITS2;
   35,049 (0.0%)    if (i >= num) {
        .             return 0;
        .           }
  105,147 (0.0%)    return (a[i] >> j) & 1;
   23,366 (0.0%)  }
        .         
   70,098 (0.0%)  int BN_is_bit_set(const BIGNUM *a, int n) {
   23,366 (0.0%)    if (n < 0) {
        .             return 0;
        .           }
  116,830 (0.0%)    return bn_is_bit_set_words(a->d, a->width, n);
   23,366 (0.0%)  }
        .         
        .         int BN_mask_bits(BIGNUM *a, int n) {
        .           if (n < 0) {
        .             return 0;
        .           }
        .         
        .           int w = n / BN_BITS2;
        .           int b = n % BN_BITS2;
-- line 283 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h
--------------------------------------------------------------------------------
Ir____________ 

-- line 866 ----------------------------------------
      .         static inline int OPENSSL_memcmp(const void *s1, const void *s2, size_t n) {
      .           if (n == 0) {
      .             return 0;
      .           }
      .         
      .           return memcmp(s1, s2, n);
      .         }
      .         
 21,438 (0.0%)  static inline void *OPENSSL_memcpy(void *dst, const void *src, size_t n) {
  7,146 (0.0%)    if (n == 0) {
      .             return dst;
      .           }
      .         
 21,438 (0.0%)    return memcpy(dst, src, n);
  7,146 (0.0%)  }
      .         
      .         static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
      .           if (n == 0) {
      .             return dst;
      .           }
      .         
      .           return memmove(dst, src, n);
      .         }
      .         
385,620 (0.1%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
128,540 (0.0%)    if (n == 0) {
      .             return dst;
      .           }
      .         
385,620 (0.1%)    return memset(dst, c, n);
128,540 (0.0%)  }
      .         
      .         
      .         // Loads and stores.
      .         //
      .         // The following functions load and store sized integers with the specified
      .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
      .         // requirements on the input and output pointers.
      .         
-- line 904 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 77 ----------------------------------------
      .         #define OPENSSL_MALLOC_PREFIX 8
      .         OPENSSL_STATIC_ASSERT(OPENSSL_MALLOC_PREFIX >= sizeof(size_t),
      .                               size_t_too_large)
      .         
      .         #if defined(OPENSSL_ASAN)
      .         void __asan_poison_memory_region(const volatile void *addr, size_t size);
      .         void __asan_unpoison_memory_region(const volatile void *addr, size_t size);
      .         #else
244,288 (0.1%)  static void __asan_poison_memory_region(const void *addr, size_t size) {}
363,760 (0.1%)  static void __asan_unpoison_memory_region(const void *addr, size_t size) {}
      .         #endif
      .         
      .         // Windows doesn't really support weak symbols as of May 2019, and Clang on
      .         // Windows will emit strong symbols instead. See
      .         // https://bugs.llvm.org/show_bug.cgi?id=37598
      .         #if defined(__ELF__) && defined(__GNUC__)
      .         #define WEAK_SYMBOL_FUNC(rettype, name, args) \
      .           rettype name args __attribute__((weak));
-- line 94 ----------------------------------------
-- line 157 ----------------------------------------
      .             return 0;
      .           }
      .           malloc_impl = m;
      .           realloc_impl = r;
      .           free_impl = f;
      .           return 1;
      .         }
      .         
147,565 (0.0%)  void *OPENSSL_malloc(size_t size) {
 88,539 (0.0%)    if (malloc_impl != NULL) {
      .             assert(OPENSSL_memory_alloc == NULL);
      .             assert(OPENSSL_memory_realloc == NULL);
      .             assert(OPENSSL_memory_free == NULL);
      .             assert(OPENSSL_memory_get_size == NULL);
      .             assert(realloc_impl != NULL);
      .             assert(free_impl != NULL);
      .             return malloc_impl(size, AWSLC_FILE, AWSLC_LINE);
      .           }
 88,539 (0.0%)    if (OPENSSL_memory_alloc != NULL) {
      .             assert(OPENSSL_memory_free != NULL);
      .             assert(OPENSSL_memory_get_size != NULL);
      .             void *ptr = OPENSSL_memory_alloc(size);
      .             if (ptr == NULL && size != 0) {
      .               goto err;
      .             }
      .             return ptr;
      .           }
      .         
 59,026 (0.0%)    if (size + OPENSSL_MALLOC_PREFIX < size) {
      .             goto err;
      .           }
      .         
147,565 (0.0%)    void *ptr = malloc(size + OPENSSL_MALLOC_PREFIX);
 59,026 (0.0%)    if (ptr == NULL) {
      .             goto err;
      .           }
      .         
 88,539 (0.0%)    *(size_t *)ptr = size;
      .         
118,052 (0.0%)    __asan_poison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
 88,539 (0.0%)    return ((uint8_t *)ptr) + OPENSSL_MALLOC_PREFIX;
      .         
      .          err:
      .           // This only works because ERR does not call OPENSSL_malloc.
      .           OPENSSL_PUT_ERROR(CRYPTO, ERR_R_MALLOC_FAILURE);
      .           return NULL;
 59,026 (0.0%)  }
      .         
 99,080 (0.0%)  void *OPENSSL_zalloc(size_t size) {
 79,264 (0.0%)    void *ret = OPENSSL_malloc(size);
 39,632 (0.0%)    if (ret != NULL) {
 99,080 (0.0%)      OPENSSL_memset(ret, 0, size);
      .           }
 19,816 (0.0%)    return ret;
 39,632 (0.0%)  }
      .         
 22,476 (0.0%)  void *OPENSSL_calloc(size_t num, size_t size) {
 33,714 (0.0%)    if (size != 0 && num > SIZE_MAX / size) {
      .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
      .             return NULL;
      .           }
      .         
 14,984 (0.0%)    return OPENSSL_zalloc(num * size);
  7,492 (0.0%)  }
      .         
289,975 (0.1%)  void OPENSSL_free(void *orig_ptr) {
115,990 (0.0%)    if (orig_ptr == NULL) {
 13,548 (0.0%)      return;
      .           }
133,341 (0.0%)    if (free_impl != NULL) {
      .             assert(OPENSSL_memory_alloc == NULL);
      .             assert(OPENSSL_memory_realloc == NULL);
      .             assert(OPENSSL_memory_free == NULL);
      .             assert(OPENSSL_memory_get_size == NULL);
      .             assert(malloc_impl != NULL);
      .             assert(realloc_impl != NULL);
      .             free_impl(orig_ptr, AWSLC_FILE, AWSLC_LINE);
      .             return;
      .           }
      .         
133,341 (0.0%)    if (OPENSSL_memory_free != NULL) {
      .             OPENSSL_memory_free(orig_ptr);
      .             return;
      .           }
      .         
133,341 (0.0%)    void *ptr = ((uint8_t *)orig_ptr) - OPENSSL_MALLOC_PREFIX;
177,788 (0.1%)    __asan_unpoison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
      .         
133,341 (0.0%)    size_t size = *(size_t *)ptr;
266,682 (0.1%)    OPENSSL_cleanse(ptr, size + OPENSSL_MALLOC_PREFIX);
      .         
      .         // ASan knows to intercept malloc and free, but not sdallocx.
      .         #if defined(OPENSSL_ASAN)
      .           (void)sdallocx;
      .           free(ptr);
      .           (void) sdallocx;
      .         #else
133,341 (0.0%)    if (sdallocx) {
      .             sdallocx(ptr, size + OPENSSL_MALLOC_PREFIX, 0 /* flags */);
      .           } else {
177,788 (0.1%)      free(ptr);
      .           }
      .         #endif
115,990 (0.0%)  }
      .         
 10,560 (0.0%)  void *OPENSSL_realloc(void *orig_ptr, size_t new_size) {
  3,520 (0.0%)    if (orig_ptr == NULL) {
  2,948 (0.0%)      return OPENSSL_malloc(new_size);
      .           }
  3,069 (0.0%)    if (realloc_impl != NULL) {
      .             assert(OPENSSL_memory_alloc == NULL);
      .             assert(OPENSSL_memory_realloc == NULL);
      .             assert(OPENSSL_memory_free == NULL);
      .             assert(OPENSSL_memory_get_size == NULL);
      .             assert(malloc_impl != NULL);
      .             assert(free_impl != NULL);
      .             return realloc_impl(orig_ptr, new_size, AWSLC_FILE, AWSLC_LINE);
      .           }
  3,069 (0.0%)    if (OPENSSL_memory_realloc != NULL) {
      .             assert(OPENSSL_memory_alloc != NULL);
      .             assert(OPENSSL_memory_free != NULL);
      .             assert(OPENSSL_memory_get_size != NULL);
      .             return OPENSSL_memory_realloc(orig_ptr, new_size);
      .           }
      .           size_t old_size;
  3,069 (0.0%)    if (OPENSSL_memory_get_size != NULL) {
      .             old_size = OPENSSL_memory_get_size(orig_ptr);
      .           } else {
  3,069 (0.0%)      void *ptr = ((uint8_t *)orig_ptr) - OPENSSL_MALLOC_PREFIX;
  4,092 (0.0%)      __asan_unpoison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
  3,069 (0.0%)      old_size = *(size_t *)ptr;
  4,092 (0.0%)      __asan_poison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
      .           }
      .         
  4,092 (0.0%)    void *ret = OPENSSL_malloc(new_size);
  2,046 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
  2,046 (0.0%)    size_t to_copy = new_size;
  3,069 (0.0%)    if (old_size < to_copy) {
  2,046 (0.0%)      to_copy = old_size;
      .           }
      .         
  6,138 (0.0%)    memcpy(ret, orig_ptr, to_copy);
  3,069 (0.0%)    OPENSSL_free(orig_ptr);
      .         
  1,023 (0.0%)    return ret;
  3,520 (0.0%)  }
      .         
266,724 (0.1%)  void OPENSSL_cleanse(void *ptr, size_t len) {
      .         #if defined(OPENSSL_WINDOWS)
      .           SecureZeroMemory(ptr, len);
      .         #else
222,270 (0.1%)    OPENSSL_memset(ptr, 0, len);
      .         
      .         #if !defined(OPENSSL_NO_ASM)
      .           /* As best as we can tell, this is sufficient to break any optimisations that
      .              might try to eliminate "superfluous" memsets. If there's an easy way to
      .              detect memset_s, it would be better to use that. */
 44,454 (0.0%)    __asm__ __volatile__("" : : "r"(ptr) : "memory");
      .         #endif
      .         #endif  // !OPENSSL_NO_ASM
133,362 (0.0%)  }
      .         
      .         void OPENSSL_clear_free(void *ptr, size_t unused) { OPENSSL_free(ptr); }
      .         
      .         int CRYPTO_secure_malloc_init(size_t size, size_t min_size) { return 0; }
      .         
      .         int CRYPTO_secure_malloc_initialized(void) { return 0; }
      .         
      .         size_t CRYPTO_secure_used(void) { return 0; }
-- line 328 ----------------------------------------
-- line 330 ----------------------------------------
      .         void *OPENSSL_secure_malloc(size_t size) { return OPENSSL_malloc(size); }
      .         
      .         void *OPENSSL_secure_zalloc(size_t size) { return OPENSSL_zalloc(size); }
      .         
      .         void OPENSSL_secure_clear_free(void *ptr, size_t len) {
      .           OPENSSL_clear_free(ptr, len);
      .         }
      .         
    696 (0.0%)  int CRYPTO_memcmp(const void *in_a, const void *in_b, size_t len) {
    232 (0.0%)    const uint8_t *a = in_a;
    232 (0.0%)    const uint8_t *b = in_b;
    116 (0.0%)    uint8_t x = 0;
      .         
  9,572 (0.0%)    for (size_t i = 0; i < len; i++) {
 22,480 (0.0%)      x |= a[i] ^ b[i];
      .           }
      .         
    116 (0.0%)    return x;
    232 (0.0%)  }
      .         
      .         uint32_t OPENSSL_hash32(const void *ptr, size_t len) {
      .           // These are the FNV-1a parameters for 32 bits.
      .           static const uint32_t kPrime = 16777619u;
      .           static const uint32_t kOffsetBasis = 2166136261u;
      .         
      .           const uint8_t *in = ptr;
      .           uint32_t h = kOffsetBasis;
-- line 356 ----------------------------------------
-- line 387 ----------------------------------------
      .           OPENSSL_memcpy(ret, s, len);
      .           return ret;
      .         }
      .         
      .         int OPENSSL_isalpha(int c) {
      .           return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
      .         }
      .         
 42,720 (0.0%)  int OPENSSL_isdigit(int c) { return c >= '0' && c <= '9'; }
      .         
      .         int OPENSSL_isxdigit(int c) {
      .           return OPENSSL_isdigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
      .         }
      .         
      .         int OPENSSL_fromxdigit(uint8_t *out, int c) {
      .           if (OPENSSL_isdigit(c)) {
      .             *out = c - '0';
-- line 403 ----------------------------------------
-- line 411 ----------------------------------------
      .             *out = c - 'A' + 10;
      .             return 1;
      .           }
      .           return 0;
      .         }
      .         
      .         int OPENSSL_isalnum(int c) { return OPENSSL_isalpha(c) || OPENSSL_isdigit(c); }
      .         
 60,584 (0.0%)  int OPENSSL_tolower(int c) {
 58,532 (0.0%)    if (c >= 'A' && c <= 'Z') {
 12,912 (0.0%)      return c + ('a' - 'A');
      .           }
 10,842 (0.0%)    return c;
 30,292 (0.0%)  }
      .         
 81,976 (0.0%)  int OPENSSL_isspace(int c) {
268,028 (0.1%)    return c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r' ||
      .                  c == ' ';
 40,988 (0.0%)  }
      .         
      .         int OPENSSL_strcasecmp(const char *a, const char *b) {
      .           for (size_t i = 0;; i++) {
      .             const int aa = OPENSSL_tolower(a[i]);
      .             const int bb = OPENSSL_tolower(b[i]);
      .         
      .             if (aa < bb) {
      .               return -1;
-- line 437 ----------------------------------------
-- line 542 ----------------------------------------
      .             return NULL;
      .           }
      .         
      .           OPENSSL_memcpy(ret, str, size);
      .           ret[size] = '\0';
      .           return ret;
      .         }
      .         
      7 (0.0%)  size_t OPENSSL_strlcpy(char *dst, const char *src, size_t dst_size) {
      1 (0.0%)    size_t l = 0;
      .         
    129 (0.0%)    for (; dst_size > 1 && *src; dst_size--) {
    144 (0.0%)      *dst++ = *src++;
     18 (0.0%)      l++;
      .           }
      .         
      2 (0.0%)    if (dst_size) {
      2 (0.0%)      *dst = 0;
      .           }
      .         
      5 (0.0%)    return l + strlen(src);
      2 (0.0%)  }
      .         
      .         size_t OPENSSL_strlcat(char *dst, const char *src, size_t dst_size) {
      .           size_t l = 0;
      .           for (; dst_size > 0 && *dst; dst_size--, dst++) {
      .             l++;
      .           }
      .           return l + OPENSSL_strlcpy(dst, src, dst_size);
      .         }
      .         
 21,438 (0.0%)  void *OPENSSL_memdup(const void *data, size_t size) {
  7,146 (0.0%)    if (size == 0) {
      .             return NULL;
      .           }
      .         
 14,292 (0.0%)    void *ret = OPENSSL_malloc(size);
  7,146 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
 21,438 (0.0%)    OPENSSL_memcpy(ret, data, size);
  3,573 (0.0%)    return ret;
  7,146 (0.0%)  }
      .         
      .         void *CRYPTO_malloc(size_t size, const char *file, int line) {
      .           return OPENSSL_malloc(size);
      .         }
      .         
      .         void *CRYPTO_realloc(void *ptr, size_t new_size, const char *file, int line) {
      .           return OPENSSL_realloc(ptr, new_size);
      .         }
-- line 593 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/pem/pem_lib.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 369 ----------------------------------------
     .           OPENSSL_cleanse(iv, sizeof(iv));
     .           OPENSSL_cleanse((char *)&ctx, sizeof(ctx));
     .           OPENSSL_cleanse(buf, PEM_BUFSIZE);
     .           OPENSSL_free(data);
     .           return ret;
     .         }
     .         
     .         int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,
 2,044 (0.0%)                    pem_password_cb *callback, void *u) {
   146 (0.0%)    int i = 0, j, o, klen;
     .           long len;
     .           EVP_CIPHER_CTX ctx;
     .           unsigned char key[EVP_MAX_KEY_LENGTH];
     .           char buf[PEM_BUFSIZE];
     .         
   438 (0.0%)    len = *plen;
     .         
   584 (0.0%)    if (cipher->cipher == NULL) {
   292 (0.0%)      return 1;
     .           }
     .         
     .           klen = 0;
     .           if (!callback) {
     .             callback = PEM_def_callback;
     .           }
     .           klen = callback(buf, PEM_BUFSIZE, 0, u);
     .           if (klen <= 0) {
-- line 395 ----------------------------------------
-- line 416 ----------------------------------------
     .           OPENSSL_cleanse((char *)key, sizeof(key));
     .           if (!o) {
     .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_DECRYPT);
     .             return 0;
     .           }
     .           j += i;
     .           *plen = j;
     .           return 1;
 1,168 (0.0%)  }
     .         
   876 (0.0%)  int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher) {
   146 (0.0%)    const EVP_CIPHER *enc = NULL;
     .           char *p, c;
   292 (0.0%)    char **header_pp = &header;
     .         
   292 (0.0%)    cipher->cipher = NULL;
   876 (0.0%)    OPENSSL_memset(cipher->iv, 0, sizeof(cipher->iv));
 1,022 (0.0%)    if ((header == NULL) || (*header == '\0') || (*header == '\n')) {
   292 (0.0%)      return 1;
     .           }
     .           if (strncmp(header, "Proc-Type: ", 11) != 0) {
     .             OPENSSL_PUT_ERROR(PEM, PEM_R_NOT_PROC_TYPE);
     .             return 0;
     .           }
     .           header += 11;
     .           if (*header != '4') {
     .             return 0;
-- line 442 ----------------------------------------
-- line 489 ----------------------------------------
     .             OPENSSL_PUT_ERROR(PEM, PEM_R_UNSUPPORTED_ENCRYPTION);
     .             return 0;
     .           }
     .           if (!load_iv(header_pp, &(cipher->iv[0]), EVP_CIPHER_iv_length(enc))) {
     .             return 0;
     .           }
     .         
     .           return 1;
   292 (0.0%)  }
     .         
     .         static int load_iv(char **fromp, unsigned char *to, size_t num) {
     .           uint8_t v;
     .           char *from;
     .         
     .           from = *fromp;
     .           for (size_t i = 0; i < num; i++) {
     .             to[i] = 0;
-- line 505 ----------------------------------------
-- line 599 ----------------------------------------
     .             return 0;
     .           }
     .           int ret = PEM_read_bio(b, name, header, data, len);
     .           BIO_free(b);
     .           return ret;
     .         }
     .         
     .         int PEM_read_bio(BIO *bp, char **name, char **header, unsigned char **data,
 1,764 (0.0%)                   long *len) {
     .           EVP_ENCODE_CTX ctx;
   588 (0.0%)    int end = 0, i, k, bl = 0, hl = 0, nohead = 0;
     .           char buf[256];
     .           BUF_MEM *nameB;
     .           BUF_MEM *headerB;
     .           BUF_MEM *dataB, *tmpB;
     .         
   294 (0.0%)    nameB = BUF_MEM_new();
   294 (0.0%)    headerB = BUF_MEM_new();
   294 (0.0%)    dataB = BUF_MEM_new();
   882 (0.0%)    if ((nameB == NULL) || (headerB == NULL) || (dataB == NULL)) {
     .             BUF_MEM_free(nameB);
     .             BUF_MEM_free(headerB);
     .             BUF_MEM_free(dataB);
     .             return 0;
     .           }
     .         
   147 (0.0%)    buf[254] = '\0';
     .           for (;;) {
 1,029 (0.0%)      i = BIO_gets(bp, buf, 254);
     .         
   294 (0.0%)      if (i <= 0) {
     7 (0.0%)        OPENSSL_PUT_ERROR(PEM, PEM_R_NO_START_LINE);
     1 (0.0%)        goto err;
     .             }
     .         
 3,066 (0.0%)      while ((i >= 0) && (buf[i] <= ' ')) {
   292 (0.0%)        i--;
     .             }
   584 (0.0%)      buf[++i] = '\n';
   584 (0.0%)      buf[++i] = '\0';
     .         
 1,168 (0.0%)      if (strncmp(buf, "-----BEGIN ", 11) == 0) {
   730 (0.0%)        i = strlen(&(buf[11]));
     .         
 1,752 (0.0%)        if (strncmp(&(buf[11 + i - 6]), "-----\n", 6) != 0) {
     .                 continue;
     .               }
 1,314 (0.0%)        if (!BUF_MEM_grow(nameB, i + 9)) {
     .                 goto err;
     .               }
 1,460 (0.0%)        OPENSSL_memcpy(nameB->data, &(buf[11]), i - 6);
 1,022 (0.0%)        nameB->data[i - 6] = '\0';
   146 (0.0%)        break;
     .             }
     .           }
   146 (0.0%)    hl = 0;
   876 (0.0%)    if (!BUF_MEM_grow(headerB, 256)) {
     .             goto err;
     .           }
   438 (0.0%)    headerB->data[0] = '\0';
     .           for (;;) {
27,566 (0.0%)      i = BIO_gets(bp, buf, 254);
 6,928 (0.0%)      if (i <= 0) {
     .               break;
     .             }
     .         
76,208 (0.0%)      while ((i >= 0) && (buf[i] <= ' ')) {
 6,928 (0.0%)        i--;
     .             }
13,856 (0.0%)      buf[++i] = '\n';
13,856 (0.0%)      buf[++i] = '\0';
     .         
10,392 (0.0%)      if (buf[0] == '\n') {
     .               break;
     .             }
38,104 (0.0%)      if (!BUF_MEM_grow(headerB, hl + i + 9)) {
     .               goto err;
     .             }
27,712 (0.0%)      if (strncmp(buf, "-----END ", 9) == 0) {
   146 (0.0%)        nohead = 1;
   146 (0.0%)        break;
     .             }
36,498 (0.0%)      OPENSSL_memcpy(&(headerB->data[hl]), buf, i);
26,544 (0.0%)      headerB->data[hl + i] = '\0';
 6,636 (0.0%)      hl += i;
     .           }
     .         
   146 (0.0%)    bl = 0;
   876 (0.0%)    if (!BUF_MEM_grow(dataB, 1024)) {
     .             goto err;
     .           }
   438 (0.0%)    dataB->data[0] = '\0';
   292 (0.0%)    if (!nohead) {
     .             for (;;) {
     .               i = BIO_gets(bp, buf, 254);
     .               if (i <= 0) {
     .                 break;
     .               }
     .         
     .               while ((i >= 0) && (buf[i] <= ' ')) {
     .                 i--;
-- line 699 ----------------------------------------
-- line 728 ----------------------------------------
     .                 }
     .                 buf[++i] = '\n';
     .                 buf[++i] = '\0';
     .         
     .                 break;
     .               }
     .             }
     .           } else {
   292 (0.0%)      tmpB = headerB;
   292 (0.0%)      headerB = dataB;
   292 (0.0%)      dataB = tmpB;
   438 (0.0%)      bl = hl;
     .           }
   730 (0.0%)    i = strlen(nameB->data);
 1,460 (0.0%)    if ((strncmp(buf, "-----END ", 9) != 0) ||
 1,606 (0.0%)        (strncmp(nameB->data, &(buf[9]), i) != 0) ||
 1,460 (0.0%)        (strncmp(&(buf[9 + i]), "-----\n", 6) != 0)) {
     .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_END_LINE);
     .             goto err;
     .           }
     .         
   438 (0.0%)    EVP_DecodeInit(&ctx);
 1,460 (0.0%)    i = EVP_DecodeUpdate(&ctx, (unsigned char *)dataB->data, &bl,
   292 (0.0%)                         (unsigned char *)dataB->data, bl);
   292 (0.0%)    if (i < 0) {
     .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_BASE64_DECODE);
     .             goto err;
     .           }
 1,606 (0.0%)    i = EVP_DecodeFinal(&ctx, (unsigned char *)&(dataB->data[bl]), &k);
   292 (0.0%)    if (i < 0) {
     .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_BASE64_DECODE);
     .             goto err;
     .           }
   584 (0.0%)    bl += k;
     .         
   438 (0.0%)    if (bl == 0) {
     .             goto err;
     .           }
   584 (0.0%)    *name = nameB->data;
   584 (0.0%)    *header = headerB->data;
   584 (0.0%)    *data = (unsigned char *)dataB->data;
   584 (0.0%)    *len = bl;
   438 (0.0%)    OPENSSL_free(nameB);
   438 (0.0%)    OPENSSL_free(headerB);
   438 (0.0%)    OPENSSL_free(dataB);
   292 (0.0%)    return 1;
     .         err:
     3 (0.0%)    BUF_MEM_free(nameB);
     3 (0.0%)    BUF_MEM_free(headerB);
     3 (0.0%)    BUF_MEM_free(dataB);
     1 (0.0%)    return 0;
   735 (0.0%)  }
     .         
     .         int PEM_def_callback(char *buf, int size, int rwflag, void *userdata) {
     .           if (!buf || !userdata || size < 0) {
     .             return 0;
     .           }
     .           size_t len = strlen((char *)userdata);
     .           if (len >= (size_t)size) {
     .             return 0;
-- line 787 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 69 ----------------------------------------
      .         #include "../internal.h"
      .         #include "internal.h"
      .         
      .         
      .         int X509_issuer_name_cmp(const X509 *a, const X509 *b) {
      .           return (X509_NAME_cmp(a->cert_info->issuer, b->cert_info->issuer));
      .         }
      .         
208,758 (0.1%)  int X509_subject_name_cmp(const X509 *a, const X509 *b) {
313,137 (0.1%)    return (X509_NAME_cmp(a->cert_info->subject, b->cert_info->subject));
 69,586 (0.0%)  }
      .         
      .         int X509_CRL_cmp(const X509_CRL *a, const X509_CRL *b) {
      .           return (X509_NAME_cmp(a->crl->issuer, b->crl->issuer));
      .         }
      .         
      .         int X509_CRL_match(const X509_CRL *a, const X509_CRL *b) {
      .           return OPENSSL_memcmp(a->crl_hash, b->crl_hash, SHA256_DIGEST_LENGTH);
      .         }
      .         
      4 (0.0%)  X509_NAME *X509_get_issuer_name(const X509 *a) {
      3 (0.0%)    return a->cert_info->issuer;
      2 (0.0%)  }
      .         
      .         uint32_t X509_issuer_name_hash(X509 *x) {
      .           return X509_NAME_hash(x->cert_info->issuer);
      .         }
      .         
      .         uint32_t X509_issuer_name_hash_old(X509 *x) {
      .           return (X509_NAME_hash_old(x->cert_info->issuer));
      .         }
      .         
      8 (0.0%)  X509_NAME *X509_get_subject_name(const X509 *a) {
      6 (0.0%)    return a->cert_info->subject;
      4 (0.0%)  }
      .         
      .         ASN1_INTEGER *X509_get_serialNumber(X509 *a) {
      .           return a->cert_info->serialNumber;
      .         }
      .         
      .         const ASN1_INTEGER *X509_get0_serialNumber(const X509 *x509) {
      .           return x509->cert_info->serialNumber;
      .         }
-- line 111 ----------------------------------------
-- line 134 ----------------------------------------
      .           // retain the old OpenSSL behavior, which was to ignore the error. See
      .           // https://crbug.com/boringssl/355.
      .           x509v3_cache_extensions((X509 *)a);
      .           x509v3_cache_extensions((X509 *)b);
      .         
      .           return OPENSSL_memcmp(a->cert_hash, b->cert_hash, SHA256_DIGEST_LENGTH);
      .         }
      .         
208,764 (0.1%)  int X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b) {
      .           int ret;
      .         
      .           // Ensure canonical encoding is present and up to date
      .         
278,352 (0.1%)    if (!a->canon_enc || a->modified) {
      .             ret = i2d_X509_NAME((X509_NAME *)a, NULL);
      .             if (ret < 0) {
      .               return -2;
      .             }
      .           }
      .         
278,352 (0.1%)    if (!b->canon_enc || b->modified) {
      .             ret = i2d_X509_NAME((X509_NAME *)b, NULL);
      .             if (ret < 0) {
      .               return -2;
      .             }
      .           }
      .         
208,764 (0.1%)    ret = a->canon_enclen - b->canon_enclen;
      .         
 69,588 (0.0%)    if (ret) {
 56,238 (0.0%)      return ret;
      .           }
      .         
 66,750 (0.0%)    return OPENSSL_memcmp(a->canon_enc, b->canon_enc, a->canon_enclen);
 69,588 (0.0%)  }
      .         
      .         uint32_t X509_NAME_hash(X509_NAME *x) {
      .           // Make sure the X509_NAME structure contains a valid cached encoding.
      .           if (i2d_X509_NAME(x, NULL) < 0) {
      .             return 0;
      .           }
      .         
      .           uint8_t md[SHA_DIGEST_LENGTH];
-- line 176 ----------------------------------------
-- line 220 ----------------------------------------
      .         
      .         EVP_PKEY *X509_get0_pubkey(const X509 *x) {
      .           if (x == NULL) {
      .             return NULL;
      .           }
      .           return X509_PUBKEY_get0(x->cert_info->key);
      .         }
      .         
     10 (0.0%)  EVP_PKEY *X509_get_pubkey(const X509 *x) {
      4 (0.0%)    if (x == NULL) {
      .             return NULL;
      .           }
     10 (0.0%)    return X509_PUBKEY_get(x->cert_info->key);
      4 (0.0%)  }
      .         
      .         ASN1_BIT_STRING *X509_get0_pubkey_bitstr(const X509 *x) {
      .           if (!x) {
      .             return NULL;
      .           }
      .           return x->cert_info->key->public_key;
      .         }
      .         
-- line 241 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 74 ----------------------------------------
      .         static int X509_OBJECT_up_ref_count(X509_OBJECT *a);
      .         
      .         static X509_LOOKUP *X509_LOOKUP_new(const X509_LOOKUP_METHOD *method,
      .                                             X509_STORE *store);
      .         static int X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,
      .                                           X509_OBJECT *ret);
      .         
      .         static X509_LOOKUP *X509_LOOKUP_new(const X509_LOOKUP_METHOD *method,
     12 (0.0%)                                      X509_STORE *store) {
      6 (0.0%)    X509_LOOKUP *ret = OPENSSL_zalloc(sizeof(X509_LOOKUP));
      4 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
      6 (0.0%)    ret->method = method;
      6 (0.0%)    ret->store_ctx = store;
     15 (0.0%)    if ((method->new_item != NULL) && !method->new_item(ret)) {
      .             OPENSSL_free(ret);
      .             return NULL;
      .           }
      2 (0.0%)    return ret;
      4 (0.0%)  }
      .         
     20 (0.0%)  void X509_LOOKUP_free(X509_LOOKUP *ctx) {
      8 (0.0%)    if (ctx == NULL) {
      .             return;
      .           }
     36 (0.0%)    if (ctx->method != NULL && ctx->method->free != NULL) {
     12 (0.0%)      (*ctx->method->free)(ctx);
      .           }
     16 (0.0%)    OPENSSL_free(ctx);
      8 (0.0%)  }
      .         
      .         int X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc, long argl,
     18 (0.0%)                       char **ret) {
      8 (0.0%)    if (ctx->method == NULL) {
      .             return -1;
      .           }
     10 (0.0%)    if (ctx->method->ctrl != NULL) {
     24 (0.0%)      return ctx->method->ctrl(ctx, cmd, argc, argl, ret);
      .           } else {
      .             return 1;
      .           }
      4 (0.0%)  }
      .         
      .         static int X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,
      .                                           X509_OBJECT *ret) {
      .           if (ctx->method == NULL || ctx->method->get_by_subject == NULL) {
      .             return 0;
      .           }
      .           // Note |get_by_subject| leaves |ret| in an inconsistent state. It has
      .           // pointers to an |X509| or |X509_CRL|, but has not bumped the refcount yet.
      .           // For now, the caller is expected to fix this, but ideally we'd fix the
      .           // |X509_LOOKUP| convention itself.
      .           return ctx->method->get_by_subject(ctx, type, name, ret) > 0;
      .         }
      .         
208,758 (0.1%)  static int x509_object_cmp(const X509_OBJECT *a, const X509_OBJECT *b) {
208,758 (0.1%)    int ret = a->type - b->type;
 69,586 (0.0%)    if (ret) {
      .             return ret;
      .           }
139,172 (0.0%)    switch (a->type) {
      .             case X509_LU_X509:
278,344 (0.1%)        return X509_subject_name_cmp(a->data.x509, b->data.x509);
      .             case X509_LU_CRL:
      .               return X509_CRL_cmp(a->data.crl, b->data.crl);
      .             default:
      .               // abort();
      .               return 0;
      .           }
 69,586 (0.0%)  }
      .         
      .         static int x509_object_cmp_sk(const X509_OBJECT *const *a,
208,758 (0.1%)                                const X509_OBJECT *const *b) {
243,551 (0.1%)    return x509_object_cmp(*a, *b);
 69,586 (0.0%)  }
      .         
      .         static CRYPTO_EX_DATA_CLASS g_ex_data_class =
      .             CRYPTO_EX_DATA_CLASS_INIT_WITH_APP_DATA;
      .         
      4 (0.0%)  X509_STORE *X509_STORE_new(void) {
      3 (0.0%)    X509_STORE *ret = OPENSSL_zalloc(sizeof(X509_STORE));
      2 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
      2 (0.0%)    ret->references = 1;
      4 (0.0%)    CRYPTO_MUTEX_init(&ret->objs_lock);
      4 (0.0%)    CRYPTO_new_ex_data(&ret->ex_data);
      5 (0.0%)    ret->objs = sk_X509_OBJECT_new(x509_object_cmp_sk);
      3 (0.0%)    ret->get_cert_methods = sk_X509_LOOKUP_new_null();
      3 (0.0%)    ret->param = X509_VERIFY_PARAM_new();
      6 (0.0%)    if (ret->objs == NULL ||
      4 (0.0%)        ret->get_cert_methods == NULL ||
      2 (0.0%)        ret->param == NULL) {
      .             X509_STORE_free(ret);
      .             return NULL;
      .           }
      .         
      1 (0.0%)    return ret;
      2 (0.0%)  }
      .         
      .         int X509_STORE_lock(X509_STORE *v) {
      .             if (v == NULL) {
      .               return 0;
      .             }
      .             CRYPTO_MUTEX_lock_write(&v->objs_lock);
      .             return 1;
      .         }
-- line 183 ----------------------------------------
-- line 190 ----------------------------------------
      .             return 1;
      .         }
      .         
      .         int X509_STORE_up_ref(X509_STORE *store) {
      .           CRYPTO_refcount_inc(&store->references);
      .           return 1;
      .         }
      .         
     10 (0.0%)  void X509_STORE_free(X509_STORE *vfy) {
      4 (0.0%)    if (vfy == NULL) {
      .             return;
      .           }
      .         
     12 (0.0%)    if (!CRYPTO_refcount_dec_and_test_zero(&vfy->references)) {
      .             return;
      .           }
      .         
      8 (0.0%)    CRYPTO_MUTEX_cleanup(&vfy->objs_lock);
     14 (0.0%)    CRYPTO_free_ex_data(&g_ex_data_class, vfy, &vfy->ex_data);
     12 (0.0%)    sk_X509_LOOKUP_pop_free(vfy->get_cert_methods, X509_LOOKUP_free);
     12 (0.0%)    sk_X509_OBJECT_pop_free(vfy->objs, X509_OBJECT_free);
      8 (0.0%)    X509_VERIFY_PARAM_free(vfy->param);
      8 (0.0%)    OPENSSL_free(vfy);
      4 (0.0%)  }
      .         
     12 (0.0%)  X509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, const X509_LOOKUP_METHOD *m) {
      6 (0.0%)    STACK_OF(X509_LOOKUP) *sk = v->get_cert_methods;
     20 (0.0%)    for (size_t i = 0; i < sk_X509_LOOKUP_num(sk); i++) {
      6 (0.0%)      X509_LOOKUP *lu = sk_X509_LOOKUP_value(sk, i);
      4 (0.0%)      if (m == lu->method) {
      .               return lu;
      .             }
      .           }
      .         
     12 (0.0%)    X509_LOOKUP *lu = X509_LOOKUP_new(m, v);
     20 (0.0%)    if (lu == NULL || !sk_X509_LOOKUP_push(v->get_cert_methods, lu)) {
      .             X509_LOOKUP_free(lu);
      .             return NULL;
      .           }
      .         
      2 (0.0%)    return lu;
      4 (0.0%)  }
      .         
      .         int X509_STORE_CTX_get_by_subject(X509_STORE_CTX *vs, int type, X509_NAME *name,
      .                                           X509_OBJECT *ret) {
      .           X509_STORE *ctx = vs->ctx;
      .           X509_OBJECT stmp;
      .           CRYPTO_MUTEX_lock_write(&ctx->objs_lock);
      .           X509_OBJECT *tmp = X509_OBJECT_retrieve_by_subject(ctx->objs, type, name);
      .           CRYPTO_MUTEX_unlock_write(&ctx->objs_lock);
-- line 239 ----------------------------------------
-- line 256 ----------------------------------------
      .           ret->type = tmp->type;
      .           ret->data.ptr = tmp->data.ptr;
      .         
      .           X509_OBJECT_up_ref_count(ret);
      .         
      .           return 1;
      .         }
      .         
  1,029 (0.0%)  static int x509_store_add(X509_STORE *ctx, void *x, int is_crl) {
    294 (0.0%)    if (x == NULL) {
      .             return 0;
      .           }
      .         
    294 (0.0%)    X509_OBJECT *const obj = X509_OBJECT_new();
    294 (0.0%)    if (obj == NULL) {
      .             return 0;
      .           }
      .         
    294 (0.0%)    if (is_crl) {
      .             obj->type = X509_LU_CRL;
      .             obj->data.crl = (X509_CRL *)x;
      .           } else {
    294 (0.0%)      obj->type = X509_LU_X509;
    441 (0.0%)      obj->data.x509 = (X509 *)x;
      .           }
    441 (0.0%)    X509_OBJECT_up_ref_count(obj);
      .         
    588 (0.0%)    CRYPTO_MUTEX_lock_write(&ctx->objs_lock);
      .         
    147 (0.0%)    int ret = 1;
    147 (0.0%)    int added = 0;
      .           // Duplicates are silently ignored
  1,176 (0.0%)    if (!X509_OBJECT_retrieve_match(ctx->objs, obj)) {
  1,764 (0.0%)      ret = added = (sk_X509_OBJECT_push(ctx->objs, obj) != 0);
      .           }
      .         
    588 (0.0%)    CRYPTO_MUTEX_unlock_write(&ctx->objs_lock);
      .         
    294 (0.0%)    if (!added) {
      .             X509_OBJECT_free(obj);
      .           }
      .         
    147 (0.0%)    return ret;
    294 (0.0%)  }
      .         
    882 (0.0%)  int X509_STORE_add_cert(X509_STORE *ctx, X509 *x) {
    882 (0.0%)    return x509_store_add(ctx, x, /*is_crl=*/0);
    294 (0.0%)  }
      .         
      .         int X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x) {
      .           return x509_store_add(ctx, x, /*is_crl=*/1);
      .         }
      .         
    441 (0.0%)  X509_OBJECT *X509_OBJECT_new(void) {
    294 (0.0%)    return OPENSSL_zalloc(sizeof(X509_OBJECT));
    294 (0.0%)  }
      .         
  1,465 (0.0%)  void X509_OBJECT_free(X509_OBJECT *obj) {
    586 (0.0%)    if (obj == NULL) {
      .             return;
      .           }
    879 (0.0%)    X509_OBJECT_free_contents(obj);
  1,172 (0.0%)    OPENSSL_free(obj);
    586 (0.0%)  }
      .         
    735 (0.0%)  static int X509_OBJECT_up_ref_count(X509_OBJECT *a) {
    588 (0.0%)    switch (a->type) {
      .             case X509_LU_X509:
    588 (0.0%)        X509_up_ref(a->data.x509);
    147 (0.0%)        break;
      .             case X509_LU_CRL:
      .               X509_CRL_up_ref(a->data.crl);
      .               break;
      .           }
    147 (0.0%)    return 1;
    294 (0.0%)  }
      .         
  1,465 (0.0%)  void X509_OBJECT_free_contents(X509_OBJECT *a) {
  1,172 (0.0%)    switch (a->type) {
      .             case X509_LU_X509:
  1,172 (0.0%)        X509_free(a->data.x509);
    293 (0.0%)        break;
      .             case X509_LU_CRL:
      .               X509_CRL_free(a->data.crl);
      .               break;
      .           }
      .         
  1,465 (0.0%)    OPENSSL_memset(a, 0, sizeof(X509_OBJECT));
    879 (0.0%)  }
      .         
      .         int X509_OBJECT_get_type(const X509_OBJECT *a) { return a->type; }
      .         
      .         X509 *X509_OBJECT_get0_X509(const X509_OBJECT *a) {
      .           if (a == NULL || a->type != X509_LU_X509) {
      .             return NULL;
      .           }
      .           return a->data.x509;
-- line 352 ----------------------------------------
-- line 519 ----------------------------------------
      .               return NULL;
      .             }
      .           }
      .           CRYPTO_MUTEX_unlock_write(&ctx->ctx->objs_lock);
      .           return sk;
      .         }
      .         
      .         static X509_OBJECT *X509_OBJECT_retrieve_match(STACK_OF(X509_OBJECT) *h,
  1,323 (0.0%)                                                 X509_OBJECT *x) {
    441 (0.0%)    sk_X509_OBJECT_sort(h);
      .           size_t idx;
  1,176 (0.0%)    if (!sk_X509_OBJECT_find_awslc(h, &idx, x)) {
    294 (0.0%)      return NULL;
      .           }
      .           if ((x->type != X509_LU_X509) && (x->type != X509_LU_CRL)) {
      .             return sk_X509_OBJECT_value(h, idx);
      .           }
      .           for (size_t i = idx; i < sk_X509_OBJECT_num(h); i++) {
      .             X509_OBJECT *obj = sk_X509_OBJECT_value(h, i);
      .             if (x509_object_cmp(obj, x)) {
      .               return NULL;
-- line 539 ----------------------------------------
-- line 546 ----------------------------------------
      .               if (!X509_CRL_match(obj->data.crl, x->data.crl)) {
      .                 return obj;
      .               }
      .             } else {
      .               return obj;
      .             }
      .           }
      .           return NULL;
    735 (0.0%)  }
      .         
      .         // Try to get issuer certificate from store. Due to limitations of the API
      .         // this can only retrieve a single certificate matching a given subject name.
      .         // However it will fill the cache with all matching certificates, so we can
      .         // examine the cache for all matches. Return values are: 1 lookup
      .         // successful.  0 certificate not found. -1 some other error.
      .         int X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x) {
      .           X509_NAME *xn;
-- line 562 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x_name.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 67 ----------------------------------------
      .         #include <openssl/x509.h>
      .         
      .         #include "../asn1/internal.h"
      .         #include "../internal.h"
      .         #include "internal.h"
      .         
      .         
      .         typedef STACK_OF(X509_NAME_ENTRY) STACK_OF_X509_NAME_ENTRY;
 72,716 (0.0%)  DEFINE_STACK_OF(STACK_OF_X509_NAME_ENTRY)
      .         
      .         // Maximum length of X509_NAME: much larger than anything we should
      .         // ever see in practice.
      .         
      .         #define X509_NAME_MAX (1024 * 1024)
      .         
      .         static int x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                     long len, const ASN1_ITEM *it, int tag, int aclass,
-- line 83 ----------------------------------------
-- line 94 ----------------------------------------
      .         static int i2d_name_canon(STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname,
      .                                   unsigned char **in);
      .         
      .         ASN1_SEQUENCE(X509_NAME_ENTRY) = {
      .             ASN1_SIMPLE(X509_NAME_ENTRY, object, ASN1_OBJECT),
      .             ASN1_SIMPLE(X509_NAME_ENTRY, value, ASN1_PRINTABLE),
      .         } ASN1_SEQUENCE_END(X509_NAME_ENTRY)
      .         
 46,704 (0.0%)  IMPLEMENT_ASN1_FUNCTIONS_const(X509_NAME_ENTRY)
      .         IMPLEMENT_ASN1_DUP_FUNCTION_const(X509_NAME_ENTRY)
      .         
      .         // For the "Name" type we need a SEQUENCE OF { SET OF X509_NAME_ENTRY } so
      .         // declare two template wrappers for this
      .         
      .         ASN1_ITEM_TEMPLATE(X509_NAME_ENTRIES) = ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SET_OF,
      .                                                                       0, RDNS,
      .                                                                       X509_NAME_ENTRY)
-- line 110 ----------------------------------------
-- line 129 ----------------------------------------
      .         };
      .         
      .         IMPLEMENT_EXTERN_ASN1(X509_NAME, V_ASN1_SEQUENCE, x509_name_ff)
      .         
      .         IMPLEMENT_ASN1_FUNCTIONS(X509_NAME)
      .         
      .         IMPLEMENT_ASN1_DUP_FUNCTION(X509_NAME)
      .         
  3,552 (0.0%)  static int x509_name_ex_new(ASN1_VALUE **val, const ASN1_ITEM *it) {
    592 (0.0%)    X509_NAME *ret = NULL;
  1,776 (0.0%)    ret = OPENSSL_malloc(sizeof(X509_NAME));
  1,184 (0.0%)    if (!ret) {
      .             goto memerr;
      .           }
  4,144 (0.0%)    if ((ret->entries = sk_X509_NAME_ENTRY_new_null()) == NULL) {
      .             goto memerr;
      .           }
  4,144 (0.0%)    if ((ret->bytes = BUF_MEM_new()) == NULL) {
      .             goto memerr;
      .           }
  1,184 (0.0%)    ret->canon_enc = NULL;
  1,184 (0.0%)    ret->canon_enclen = 0;
  1,184 (0.0%)    ret->modified = 1;
  1,776 (0.0%)    *val = (ASN1_VALUE *)ret;
  1,184 (0.0%)    return 1;
      .         
      .         memerr:
      .           if (ret) {
      .             if (ret->entries) {
      .               sk_X509_NAME_ENTRY_free(ret->entries);
      .             }
      .             OPENSSL_free(ret);
      .           }
      .           return 0;
  1,184 (0.0%)  }
      .         
  5,304 (0.0%)  static void x509_name_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
      .           X509_NAME *a;
  5,304 (0.0%)    if (!pval || !*pval) {
      .             return;
      .           }
  2,652 (0.0%)    a = (X509_NAME *)*pval;
      .         
  3,536 (0.0%)    BUF_MEM_free(a->bytes);
  5,304 (0.0%)    sk_X509_NAME_ENTRY_pop_free(a->entries, X509_NAME_ENTRY_free);
  3,536 (0.0%)    if (a->canon_enc) {
  2,352 (0.0%)      OPENSSL_free(a->canon_enc);
      .           }
  2,652 (0.0%)    OPENSSL_free(a);
  2,652 (0.0%)    *pval = NULL;
  1,768 (0.0%)  }
      .         
  5,340 (0.0%)  static void local_sk_X509_NAME_ENTRY_free(STACK_OF(X509_NAME_ENTRY) *ne) {
  3,204 (0.0%)    sk_X509_NAME_ENTRY_free(ne);
  3,204 (0.0%)  }
      .         
  5,340 (0.0%)  static void local_sk_X509_NAME_ENTRY_pop_free(STACK_OF(X509_NAME_ENTRY) *ne) {
  5,340 (0.0%)    sk_X509_NAME_ENTRY_pop_free(ne, X509_NAME_ENTRY_free);
  3,204 (0.0%)  }
      .         
      .         static int x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                     long len, const ASN1_ITEM *it, int tag, int aclass,
  5,032 (0.0%)                              char opt, ASN1_TLC *ctx) {
    888 (0.0%)    const unsigned char *p = *in, *q;
    296 (0.0%)    STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname = NULL;
    296 (0.0%)    X509_NAME *nm = NULL;
      .           size_t i, j;
      .           int ret;
      .           STACK_OF(X509_NAME_ENTRY) *entries;
      .           X509_NAME_ENTRY *entry;
      .           // Bound the size of an X509_NAME we are willing to parse.
    592 (0.0%)    if (len > X509_NAME_MAX) {
      .             len = X509_NAME_MAX;
      .           }
    592 (0.0%)    q = p;
      .         
      .           // Get internal representation of Name
    296 (0.0%)    ASN1_VALUE *intname_val = NULL;
  4,440 (0.0%)    ret = ASN1_item_ex_d2i(&intname_val, &p, len,
      .                                  ASN1_ITEM_rptr(X509_NAME_INTERNAL), tag, aclass, opt,
      .                                  ctx);
    592 (0.0%)    if (ret <= 0) {
      .             return ret;
      .           }
    592 (0.0%)    intname = (STACK_OF(STACK_OF_X509_NAME_ENTRY) *)intname_val;
      .         
  1,184 (0.0%)    if (*val) {
  1,184 (0.0%)      x509_name_ex_free(val, NULL);
      .           }
    296 (0.0%)    ASN1_VALUE *nm_val = NULL;
  1,776 (0.0%)    if (!x509_name_ex_new(&nm_val, NULL)) {
      .             goto err;
      .           }
    592 (0.0%)    nm = (X509_NAME *)nm_val;
      .           // We've decoded it: now cache encoding
  2,960 (0.0%)    if (!BUF_MEM_grow(nm->bytes, p - q)) {
      .             goto err;
      .           }
  2,960 (0.0%)    OPENSSL_memcpy(nm->bytes->data, q, p - q);
      .         
      .           // Convert internal representation to X509_NAME structure
  8,480 (0.0%)    for (i = 0; i < sk_STACK_OF_X509_NAME_ENTRY_num(intname); i++) {
  6,408 (0.0%)      entries = sk_STACK_OF_X509_NAME_ENTRY_value(intname, i);
 13,884 (0.0%)      for (j = 0; j < sk_X509_NAME_ENTRY_num(entries); j++) {
  6,408 (0.0%)        entry = sk_X509_NAME_ENTRY_value(entries, j);
  4,272 (0.0%)        entry->set = (int)i;
  8,544 (0.0%)        if (!sk_X509_NAME_ENTRY_push(nm->entries, entry)) {
      .                 goto err;
      .               }
  6,408 (0.0%)        (void)sk_X509_NAME_ENTRY_set(entries, j, NULL);
      .             }
      .           }
  1,184 (0.0%)    ret = x509_name_canon(nm);
    592 (0.0%)    if (!ret) {
      .             goto err;
      .           }
  1,480 (0.0%)    sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname, local_sk_X509_NAME_ENTRY_free);
    592 (0.0%)    nm->modified = 0;
    888 (0.0%)    *val = (ASN1_VALUE *)nm;
    888 (0.0%)    *in = p;
    592 (0.0%)    return ret;
      .         err:
      .           X509_NAME_free(nm);
      .           sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname,
      .                                                local_sk_X509_NAME_ENTRY_pop_free);
      .           OPENSSL_PUT_ERROR(X509, ERR_R_ASN1_LIB);
      .           return 0;
  1,480 (0.0%)  }
      .         
      .         static int x509_name_ex_i2d(ASN1_VALUE **val, unsigned char **out,
      .                                     const ASN1_ITEM *it, int tag, int aclass) {
      .           X509_NAME *a = (X509_NAME *)*val;
      .           if (a->modified && (!x509_name_encode(a) || !x509_name_canon(a))) {
      .             return -1;
      .           }
      .           int ret = a->bytes->length;
-- line 264 ----------------------------------------
-- line 324 ----------------------------------------
      .         // it all strings are converted to UTF8, leading, trailing and multiple
      .         // spaces collapsed, converted to lower case and the leading SEQUENCE header
      .         // removed. In future we could also normalize the UTF8 too. By doing this
      .         // comparison of Name structures can be rapidly perfomed by just using
      .         // OPENSSL_memcmp() of the canonical encoding. By omitting the leading SEQUENCE
      .         // name constraints of type dirName can also be checked with a simple
      .         // OPENSSL_memcmp().
      .         
  2,368 (0.0%)  static int x509_name_canon(X509_NAME *a) {
      .           unsigned char *p;
    296 (0.0%)    STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname = NULL;
    296 (0.0%)    STACK_OF(X509_NAME_ENTRY) *entries = NULL;
    296 (0.0%)    X509_NAME_ENTRY *entry, *tmpentry = NULL;
    592 (0.0%)    int set = -1, ret = 0, len;
      .           size_t i;
      .         
  1,184 (0.0%)    if (a->canon_enc) {
      .             OPENSSL_free(a->canon_enc);
      .             a->canon_enc = NULL;
      .           }
      .           // Special case: empty X509_NAME => null encoding
  1,776 (0.0%)    if (sk_X509_NAME_ENTRY_num(a->entries) == 0) {
      .             a->canon_enclen = 0;
      .             return 1;
      .           }
    592 (0.0%)    intname = sk_STACK_OF_X509_NAME_ENTRY_new_null();
    592 (0.0%)    if (!intname) {
      .             goto err;
      .           }
  9,844 (0.0%)    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {
  7,476 (0.0%)      entry = sk_X509_NAME_ENTRY_value(a->entries, i);
  4,272 (0.0%)      if (entry->set != set) {
  2,136 (0.0%)        entries = sk_X509_NAME_ENTRY_new_null();
  2,136 (0.0%)        if (!entries) {
      .                 goto err;
      .               }
  7,476 (0.0%)        if (!sk_STACK_OF_X509_NAME_ENTRY_push(intname, entries)) {
      .                 sk_X509_NAME_ENTRY_free(entries);
      .                 goto err;
      .               }
  3,204 (0.0%)        set = entry->set;
      .             }
  2,136 (0.0%)      tmpentry = X509_NAME_ENTRY_new();
  2,136 (0.0%)      if (tmpentry == NULL) {
      .               goto err;
      .             }
  6,408 (0.0%)      tmpentry->object = OBJ_dup(entry->object);
  9,612 (0.0%)      if (!asn1_string_canon(tmpentry->value, entry->value)) {
      .               goto err;
      .             }
  7,476 (0.0%)      if (!sk_X509_NAME_ENTRY_push(entries, tmpentry)) {
      .               goto err;
      .             }
  1,068 (0.0%)      tmpentry = NULL;
      .           }
      .         
      .           // Finally generate encoding
      .         
  1,480 (0.0%)    len = i2d_name_canon(intname, NULL);
    592 (0.0%)    if (len < 0) {
      .             goto err;
      .           }
    888 (0.0%)    a->canon_enclen = len;
      .         
  1,776 (0.0%)    p = OPENSSL_malloc(a->canon_enclen);
      .         
    888 (0.0%)    if (!p) {
      .             goto err;
      .           }
      .         
    888 (0.0%)    a->canon_enc = p;
      .         
  1,480 (0.0%)    i2d_name_canon(intname, &p);
      .         
    592 (0.0%)    ret = 1;
      .         
      .         err:
      .         
    592 (0.0%)    if (tmpentry) {
      .             X509_NAME_ENTRY_free(tmpentry);
      .           }
    592 (0.0%)    if (intname) {
  1,480 (0.0%)      sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname,
      .                                                  local_sk_X509_NAME_ENTRY_pop_free);
      .           }
    296 (0.0%)    return ret;
  1,480 (0.0%)  }
      .         
      .         // Bitmap of all the types of string that will be canonicalized.
      .         
      .         #define ASN1_MASK_CANON                                            \
      .           (B_ASN1_UTF8STRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | \
      .            B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING |  \
      .            B_ASN1_VISIBLESTRING)
      .         
  6,408 (0.0%)  static int asn1_string_canon(ASN1_STRING *out, ASN1_STRING *in) {
      .           unsigned char *to, *from;
      .           int len, i;
      .         
      .           // If type not in bitmask just copy string across
  7,476 (0.0%)    if (!(ASN1_tag2bit(in->type) & ASN1_MASK_CANON)) {
      .             if (!ASN1_STRING_copy(out, in)) {
      .               return 0;
      .             }
      .             return 1;
      .           }
      .         
  2,136 (0.0%)    out->type = V_ASN1_UTF8STRING;
  8,544 (0.0%)    out->length = ASN1_STRING_to_UTF8(&out->data, in);
  4,272 (0.0%)    if (out->length == -1) {
      .             return 0;
      .           }
      .         
  3,204 (0.0%)    to = out->data;
  2,136 (0.0%)    from = to;
      .         
  3,204 (0.0%)    len = out->length;
      .         
      .           // Convert string in place to canonical form.
      .         
      .           // Ignore leading spaces
 10,680 (0.0%)    while ((len > 0) && OPENSSL_isspace(*from)) {
      .             from++;
      .             len--;
      .           }
      .         
  5,340 (0.0%)    to = from + len;
      .         
      .           // Ignore trailing spaces
 11,748 (0.0%)    while ((len > 0) && OPENSSL_isspace(to[-1])) {
      .             to--;
      .             len--;
      .           }
      .         
  3,204 (0.0%)    to = out->data;
      .         
  1,068 (0.0%)    i = 0;
 54,528 (0.0%)    while (i < len) {
      .             // Collapse multiple spaces
117,264 (0.0%)      if (OPENSSL_isspace(*from)) {
      .               // Copy one space across
  6,424 (0.0%)        *to++ = ' ';
      .               // Ignore subsequent spaces. Note: don't need to check len here
      .               // because we know the last character is a non-space so we can't
      .               // overflow.
      .               do {
  1,606 (0.0%)          from++;
  1,606 (0.0%)          i++;
 12,848 (0.0%)        } while (OPENSSL_isspace(*from));
      .             } else {
166,606 (0.1%)        *to++ = OPENSSL_tolower(*from);
 15,146 (0.0%)        from++;
 15,146 (0.0%)        i++;
      .             }
      .           }
      .         
  6,408 (0.0%)    out->length = to - out->data;
      .         
  1,068 (0.0%)    return 1;
  2,136 (0.0%)  }
      .         
      .         static int i2d_name_canon(STACK_OF(STACK_OF_X509_NAME_ENTRY) *_intname,
  5,328 (0.0%)                            unsigned char **in) {
      .           int len, ltmp;
      .           size_t i;
      .           ASN1_VALUE *v;
  1,184 (0.0%)    STACK_OF(ASN1_VALUE) *intname = (STACK_OF(ASN1_VALUE) *)_intname;
      .         
    592 (0.0%)    len = 0;
 16,960 (0.0%)    for (i = 0; i < sk_ASN1_VALUE_num(intname); i++) {
 12,816 (0.0%)      v = sk_ASN1_VALUE_value(intname, i);
 17,088 (0.0%)      ltmp = ASN1_item_ex_i2d(&v, in, ASN1_ITEM_rptr(X509_NAME_ENTRIES),
      .                                     /*tag=*/-1, /*aclass=*/0);
  4,272 (0.0%)      if (ltmp < 0) {
      .               return ltmp;
      .             }
  4,272 (0.0%)      len += ltmp;
      .           }
    592 (0.0%)    return len;
  2,960 (0.0%)  }
      .         
      .         int X509_NAME_set(X509_NAME **xn, X509_NAME *name) {
      .           if ((name = X509_NAME_dup(name)) == NULL) {
      .             return 0;
      .           }
      .           X509_NAME_free(*xn);
      .           *xn = name;
      .           return 1;
-- line 511 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont.S
--------------------------------------------------------------------------------
Ir___________ 

-- line 10 ----------------------------------------
     .         .hidden OPENSSL_ia32cap_P
     .         
     .         .globl	bn_mul_mont
     .         .hidden bn_mul_mont
     .         .type	bn_mul_mont,@function
     .         .align	16
     .         bn_mul_mont:
     .         .cfi_startproc	
   236 (0.0%)  	movl	%r9d,%r9d
   236 (0.0%)  	movq	%rsp,%rax
     .         .cfi_def_cfa_register	%rax
   236 (0.0%)  	testl	$3,%r9d
   236 (0.0%)  	jnz	.Lmul_enter
   128 (0.0%)  	cmpl	$8,%r9d
   128 (0.0%)  	jb	.Lmul_enter
   108 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r11
   108 (0.0%)  	movl	8(%r11),%r11d
   108 (0.0%)  	cmpq	%rsi,%rdx
   108 (0.0%)  	jne	.Lmul4x_enter
    90 (0.0%)  	testl	$7,%r9d
    90 (0.0%)  	jz	.Lsqr8x_enter
     .         	jmp	.Lmul4x_enter
     .         
     .         .align	16
     .         .Lmul_enter:
   128 (0.0%)  	pushq	%rbx
     .         .cfi_offset	%rbx,-16
   128 (0.0%)  	pushq	%rbp
     .         .cfi_offset	%rbp,-24
   128 (0.0%)  	pushq	%r12
     .         .cfi_offset	%r12,-32
   128 (0.0%)  	pushq	%r13
     .         .cfi_offset	%r13,-40
   128 (0.0%)  	pushq	%r14
     .         .cfi_offset	%r14,-48
   128 (0.0%)  	pushq	%r15
     .         .cfi_offset	%r15,-56
     .         
   128 (0.0%)  	negq	%r9
   128 (0.0%)  	movq	%rsp,%r11
   128 (0.0%)  	leaq	-16(%rsp,%r9,8),%r10
   128 (0.0%)  	negq	%r9
   128 (0.0%)  	andq	$-1024,%r10
     .         
     .         
     .         
     .         
     .         
     .         
     .         
     .         
     .         
   128 (0.0%)  	subq	%r10,%r11
   128 (0.0%)  	andq	$-4096,%r11
   128 (0.0%)  	leaq	(%r10,%r11,1),%rsp
   128 (0.0%)  	movq	(%rsp),%r11
   128 (0.0%)  	cmpq	%r10,%rsp
   128 (0.0%)  	ja	.Lmul_page_walk
   128 (0.0%)  	jmp	.Lmul_page_walk_done
     .         
     .         .align	16
     .         .Lmul_page_walk:
     .         	leaq	-4096(%rsp),%rsp
     .         	movq	(%rsp),%r11
     .         	cmpq	%r10,%rsp
     .         	ja	.Lmul_page_walk
     .         .Lmul_page_walk_done:
     .         
   128 (0.0%)  	movq	%rax,8(%rsp,%r9,8)
     .         .cfi_escape	0x0f,0x0a,0x77,0x08,0x79,0x00,0x38,0x1e,0x22,0x06,0x23,0x08
     .         .Lmul_body:
   128 (0.0%)  	movq	%rdx,%r12
   128 (0.0%)  	movq	(%r8),%r8
   128 (0.0%)  	movq	(%r12),%rbx
   128 (0.0%)  	movq	(%rsi),%rax
     .         
   128 (0.0%)  	xorq	%r14,%r14
   128 (0.0%)  	xorq	%r15,%r15
     .         
   128 (0.0%)  	movq	%r8,%rbp
   128 (0.0%)  	mulq	%rbx
   128 (0.0%)  	movq	%rax,%r10
   128 (0.0%)  	movq	(%rcx),%rax
     .         
   128 (0.0%)  	imulq	%r10,%rbp
   128 (0.0%)  	movq	%rdx,%r11
     .         
   128 (0.0%)  	mulq	%rbp
   128 (0.0%)  	addq	%rax,%r10
   128 (0.0%)  	movq	8(%rsi),%rax
   128 (0.0%)  	adcq	$0,%rdx
   128 (0.0%)  	movq	%rdx,%r13
     .         
   128 (0.0%)  	leaq	1(%r15),%r15
   128 (0.0%)  	jmp	.L1st_enter
     .         
     .         .align	16
     .         .L1st:
   472 (0.0%)  	addq	%rax,%r13
   472 (0.0%)  	movq	(%rsi,%r15,8),%rax
   472 (0.0%)  	adcq	$0,%rdx
   472 (0.0%)  	addq	%r11,%r13
   472 (0.0%)  	movq	%r10,%r11
   472 (0.0%)  	adcq	$0,%rdx
   472 (0.0%)  	movq	%r13,-16(%rsp,%r15,8)
   472 (0.0%)  	movq	%rdx,%r13
     .         
     .         .L1st_enter:
   600 (0.0%)  	mulq	%rbx
   600 (0.0%)  	addq	%rax,%r11
   600 (0.0%)  	movq	(%rcx,%r15,8),%rax
   600 (0.0%)  	adcq	$0,%rdx
   600 (0.0%)  	leaq	1(%r15),%r15
   600 (0.0%)  	movq	%rdx,%r10
     .         
   600 (0.0%)  	mulq	%rbp
   600 (0.0%)  	cmpq	%r9,%r15
   600 (0.0%)  	jne	.L1st
     .         
   128 (0.0%)  	addq	%rax,%r13
   128 (0.0%)  	movq	(%rsi),%rax
   128 (0.0%)  	adcq	$0,%rdx
   128 (0.0%)  	addq	%r11,%r13
   128 (0.0%)  	adcq	$0,%rdx
   128 (0.0%)  	movq	%r13,-16(%rsp,%r15,8)
   128 (0.0%)  	movq	%rdx,%r13
   128 (0.0%)  	movq	%r10,%r11
     .         
   128 (0.0%)  	xorq	%rdx,%rdx
   128 (0.0%)  	addq	%r11,%r13
   128 (0.0%)  	adcq	$0,%rdx
   128 (0.0%)  	movq	%r13,-8(%rsp,%r9,8)
   128 (0.0%)  	movq	%rdx,(%rsp,%r9,8)
     .         
   128 (0.0%)  	leaq	1(%r14),%r14
   128 (0.0%)  	jmp	.Louter
     .         .align	16
     .         .Louter:
   600 (0.0%)  	movq	(%r12,%r14,8),%rbx
   600 (0.0%)  	xorq	%r15,%r15
   600 (0.0%)  	movq	%r8,%rbp
   600 (0.0%)  	movq	(%rsp),%r10
   600 (0.0%)  	mulq	%rbx
   600 (0.0%)  	addq	%rax,%r10
   600 (0.0%)  	movq	(%rcx),%rax
   600 (0.0%)  	adcq	$0,%rdx
     .         
   600 (0.0%)  	imulq	%r10,%rbp
   600 (0.0%)  	movq	%rdx,%r11
     .         
   600 (0.0%)  	mulq	%rbp
   600 (0.0%)  	addq	%rax,%r10
   600 (0.0%)  	movq	8(%rsi),%rax
   600 (0.0%)  	adcq	$0,%rdx
   600 (0.0%)  	movq	8(%rsp),%r10
   600 (0.0%)  	movq	%rdx,%r13
     .         
   600 (0.0%)  	leaq	1(%r15),%r15
   600 (0.0%)  	jmp	.Linner_enter
     .         
     .         .align	16
     .         .Linner:
 2,280 (0.0%)  	addq	%rax,%r13
 2,280 (0.0%)  	movq	(%rsi,%r15,8),%rax
 2,280 (0.0%)  	adcq	$0,%rdx
 2,280 (0.0%)  	addq	%r10,%r13
 2,280 (0.0%)  	movq	(%rsp,%r15,8),%r10
 2,280 (0.0%)  	adcq	$0,%rdx
 2,280 (0.0%)  	movq	%r13,-16(%rsp,%r15,8)
 2,280 (0.0%)  	movq	%rdx,%r13
     .         
     .         .Linner_enter:
 2,880 (0.0%)  	mulq	%rbx
 2,880 (0.0%)  	addq	%rax,%r11
 2,880 (0.0%)  	movq	(%rcx,%r15,8),%rax
 2,880 (0.0%)  	adcq	$0,%rdx
 2,880 (0.0%)  	addq	%r11,%r10
 2,880 (0.0%)  	movq	%rdx,%r11
 2,880 (0.0%)  	adcq	$0,%r11
 2,880 (0.0%)  	leaq	1(%r15),%r15
     .         
 2,880 (0.0%)  	mulq	%rbp
 2,880 (0.0%)  	cmpq	%r9,%r15
 2,880 (0.0%)  	jne	.Linner
     .         
   600 (0.0%)  	addq	%rax,%r13
   600 (0.0%)  	movq	(%rsi),%rax
   600 (0.0%)  	adcq	$0,%rdx
   600 (0.0%)  	addq	%r10,%r13
   600 (0.0%)  	movq	(%rsp,%r15,8),%r10
   600 (0.0%)  	adcq	$0,%rdx
   600 (0.0%)  	movq	%r13,-16(%rsp,%r15,8)
   600 (0.0%)  	movq	%rdx,%r13
     .         
   600 (0.0%)  	xorq	%rdx,%rdx
   600 (0.0%)  	addq	%r11,%r13
   600 (0.0%)  	adcq	$0,%rdx
   600 (0.0%)  	addq	%r10,%r13
   600 (0.0%)  	adcq	$0,%rdx
   600 (0.0%)  	movq	%r13,-8(%rsp,%r9,8)
   600 (0.0%)  	movq	%rdx,(%rsp,%r9,8)
     .         
   600 (0.0%)  	leaq	1(%r14),%r14
   600 (0.0%)  	cmpq	%r9,%r14
   600 (0.0%)  	jb	.Louter
     .         
   128 (0.0%)  	xorq	%r14,%r14
   128 (0.0%)  	movq	(%rsp),%rax
   128 (0.0%)  	movq	%r9,%r15
     .         
     .         .align	16
   728 (0.0%)  .Lsub:	sbbq	(%rcx,%r14,8),%rax
   728 (0.0%)  	movq	%rax,(%rdi,%r14,8)
   728 (0.0%)  	movq	8(%rsp,%r14,8),%rax
   728 (0.0%)  	leaq	1(%r14),%r14
   728 (0.0%)  	decq	%r15
   728 (0.0%)  	jnz	.Lsub
     .         
   128 (0.0%)  	sbbq	$0,%rax
   128 (0.0%)  	movq	$-1,%rbx
   128 (0.0%)  	xorq	%rax,%rbx
   128 (0.0%)  	xorq	%r14,%r14
   128 (0.0%)  	movq	%r9,%r15
     .         
     .         .Lcopy:
   728 (0.0%)  	movq	(%rdi,%r14,8),%rcx
   728 (0.0%)  	movq	(%rsp,%r14,8),%rdx
   728 (0.0%)  	andq	%rbx,%rcx
   728 (0.0%)  	andq	%rax,%rdx
   728 (0.0%)  	movq	%r9,(%rsp,%r14,8)
   728 (0.0%)  	orq	%rcx,%rdx
   728 (0.0%)  	movq	%rdx,(%rdi,%r14,8)
   728 (0.0%)  	leaq	1(%r14),%r14
   728 (0.0%)  	subq	$1,%r15
   728 (0.0%)  	jnz	.Lcopy
     .         
   128 (0.0%)  	movq	8(%rsp,%r9,8),%rsi
     .         .cfi_def_cfa	%rsi,8
   128 (0.0%)  	movq	$1,%rax
   128 (0.0%)  	movq	-48(%rsi),%r15
     .         .cfi_restore	%r15
   128 (0.0%)  	movq	-40(%rsi),%r14
     .         .cfi_restore	%r14
   128 (0.0%)  	movq	-32(%rsi),%r13
     .         .cfi_restore	%r13
   128 (0.0%)  	movq	-24(%rsi),%r12
     .         .cfi_restore	%r12
   128 (0.0%)  	movq	-16(%rsi),%rbp
     .         .cfi_restore	%rbp
   128 (0.0%)  	movq	-8(%rsi),%rbx
     .         .cfi_restore	%rbx
   256 (0.0%)  	leaq	(%rsi),%rsp
     .         .cfi_def_cfa_register	%rsp
     .         .Lmul_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	bn_mul_mont,.-bn_mul_mont
     .         .type	bn_mul4x_mont,@function
     .         .align	16
     .         bn_mul4x_mont:
     .         .cfi_startproc	
     .         	movl	%r9d,%r9d
     .         	movq	%rsp,%rax
     .         .cfi_def_cfa_register	%rax
     .         .Lmul4x_enter:
    18 (0.0%)  	andl	$0x80100,%r11d
    18 (0.0%)  	cmpl	$0x80100,%r11d
    18 (0.0%)  	je	.Lmulx4x_enter
    18 (0.0%)  	pushq	%rbx
     .         .cfi_offset	%rbx,-16
    18 (0.0%)  	pushq	%rbp
     .         .cfi_offset	%rbp,-24
    18 (0.0%)  	pushq	%r12
     .         .cfi_offset	%r12,-32
    18 (0.0%)  	pushq	%r13
     .         .cfi_offset	%r13,-40
    18 (0.0%)  	pushq	%r14
     .         .cfi_offset	%r14,-48
    18 (0.0%)  	pushq	%r15
     .         .cfi_offset	%r15,-56
     .         
    18 (0.0%)  	negq	%r9
    18 (0.0%)  	movq	%rsp,%r11
    18 (0.0%)  	leaq	-32(%rsp,%r9,8),%r10
    18 (0.0%)  	negq	%r9
    18 (0.0%)  	andq	$-1024,%r10
     .         
    18 (0.0%)  	subq	%r10,%r11
    18 (0.0%)  	andq	$-4096,%r11
    18 (0.0%)  	leaq	(%r10,%r11,1),%rsp
    18 (0.0%)  	movq	(%rsp),%r11
    18 (0.0%)  	cmpq	%r10,%rsp
    18 (0.0%)  	ja	.Lmul4x_page_walk
    18 (0.0%)  	jmp	.Lmul4x_page_walk_done
     .         
     .         .Lmul4x_page_walk:
     .         	leaq	-4096(%rsp),%rsp
     .         	movq	(%rsp),%r11
     .         	cmpq	%r10,%rsp
     .         	ja	.Lmul4x_page_walk
     .         .Lmul4x_page_walk_done:
     .         
    18 (0.0%)  	movq	%rax,8(%rsp,%r9,8)
     .         .cfi_escape	0x0f,0x0a,0x77,0x08,0x79,0x00,0x38,0x1e,0x22,0x06,0x23,0x08
     .         .Lmul4x_body:
    18 (0.0%)  	movq	%rdi,16(%rsp,%r9,8)
    18 (0.0%)  	movq	%rdx,%r12
    18 (0.0%)  	movq	(%r8),%r8
    18 (0.0%)  	movq	(%r12),%rbx
    18 (0.0%)  	movq	(%rsi),%rax
     .         
    18 (0.0%)  	xorq	%r14,%r14
    18 (0.0%)  	xorq	%r15,%r15
     .         
    18 (0.0%)  	movq	%r8,%rbp
    18 (0.0%)  	mulq	%rbx
    18 (0.0%)  	movq	%rax,%r10
    18 (0.0%)  	movq	(%rcx),%rax
     .         
    18 (0.0%)  	imulq	%r10,%rbp
    18 (0.0%)  	movq	%rdx,%r11
     .         
    18 (0.0%)  	mulq	%rbp
    18 (0.0%)  	addq	%rax,%r10
    18 (0.0%)  	movq	8(%rsi),%rax
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	movq	%rdx,%rdi
     .         
    18 (0.0%)  	mulq	%rbx
    18 (0.0%)  	addq	%rax,%r11
    18 (0.0%)  	movq	8(%rcx),%rax
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	movq	%rdx,%r10
     .         
    18 (0.0%)  	mulq	%rbp
    18 (0.0%)  	addq	%rax,%rdi
    18 (0.0%)  	movq	16(%rsi),%rax
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	addq	%r11,%rdi
    18 (0.0%)  	leaq	4(%r15),%r15
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	movq	%rdi,(%rsp)
    18 (0.0%)  	movq	%rdx,%r13
    18 (0.0%)  	jmp	.L1st4x
     .         .align	16
     .         .L1st4x:
   214 (0.0%)  	mulq	%rbx
   214 (0.0%)  	addq	%rax,%r10
   214 (0.0%)  	movq	-16(%rcx,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	movq	%rdx,%r11
     .         
   214 (0.0%)  	mulq	%rbp
   214 (0.0%)  	addq	%rax,%r13
   214 (0.0%)  	movq	-8(%rsi,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	addq	%r10,%r13
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	movq	%r13,-24(%rsp,%r15,8)
   214 (0.0%)  	movq	%rdx,%rdi
     .         
   214 (0.0%)  	mulq	%rbx
   214 (0.0%)  	addq	%rax,%r11
   214 (0.0%)  	movq	-8(%rcx,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	movq	%rdx,%r10
     .         
   214 (0.0%)  	mulq	%rbp
   214 (0.0%)  	addq	%rax,%rdi
   214 (0.0%)  	movq	(%rsi,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	addq	%r11,%rdi
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	movq	%rdi,-16(%rsp,%r15,8)
   214 (0.0%)  	movq	%rdx,%r13
     .         
   214 (0.0%)  	mulq	%rbx
   214 (0.0%)  	addq	%rax,%r10
   214 (0.0%)  	movq	(%rcx,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	movq	%rdx,%r11
     .         
   214 (0.0%)  	mulq	%rbp
   214 (0.0%)  	addq	%rax,%r13
   214 (0.0%)  	movq	8(%rsi,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	addq	%r10,%r13
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	movq	%r13,-8(%rsp,%r15,8)
   214 (0.0%)  	movq	%rdx,%rdi
     .         
   214 (0.0%)  	mulq	%rbx
   214 (0.0%)  	addq	%rax,%r11
   214 (0.0%)  	movq	8(%rcx,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	leaq	4(%r15),%r15
   214 (0.0%)  	movq	%rdx,%r10
     .         
   214 (0.0%)  	mulq	%rbp
   214 (0.0%)  	addq	%rax,%rdi
   214 (0.0%)  	movq	-16(%rsi,%r15,8),%rax
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	addq	%r11,%rdi
   214 (0.0%)  	adcq	$0,%rdx
   214 (0.0%)  	movq	%rdi,-32(%rsp,%r15,8)
   214 (0.0%)  	movq	%rdx,%r13
   214 (0.0%)  	cmpq	%r9,%r15
   214 (0.0%)  	jb	.L1st4x
     .         
    18 (0.0%)  	mulq	%rbx
    18 (0.0%)  	addq	%rax,%r10
    18 (0.0%)  	movq	-16(%rcx,%r15,8),%rax
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	movq	%rdx,%r11
     .         
    18 (0.0%)  	mulq	%rbp
    18 (0.0%)  	addq	%rax,%r13
    18 (0.0%)  	movq	-8(%rsi,%r15,8),%rax
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	addq	%r10,%r13
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	movq	%r13,-24(%rsp,%r15,8)
    18 (0.0%)  	movq	%rdx,%rdi
     .         
    18 (0.0%)  	mulq	%rbx
    18 (0.0%)  	addq	%rax,%r11
    18 (0.0%)  	movq	-8(%rcx,%r15,8),%rax
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	movq	%rdx,%r10
     .         
    18 (0.0%)  	mulq	%rbp
    18 (0.0%)  	addq	%rax,%rdi
    18 (0.0%)  	movq	(%rsi),%rax
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	addq	%r11,%rdi
    18 (0.0%)  	adcq	$0,%rdx
    18 (0.0%)  	movq	%rdi,-16(%rsp,%r15,8)
    18 (0.0%)  	movq	%rdx,%r13
     .         
    18 (0.0%)  	xorq	%rdi,%rdi
    18 (0.0%)  	addq	%r10,%r13
    18 (0.0%)  	adcq	$0,%rdi
    18 (0.0%)  	movq	%r13,-8(%rsp,%r15,8)
    18 (0.0%)  	movq	%rdi,(%rsp,%r15,8)
     .         
    18 (0.0%)  	leaq	1(%r14),%r14
     .         .align	4
     .         .Louter4x:
   910 (0.0%)  	movq	(%r12,%r14,8),%rbx
   910 (0.0%)  	xorq	%r15,%r15
   910 (0.0%)  	movq	(%rsp),%r10
   910 (0.0%)  	movq	%r8,%rbp
   910 (0.0%)  	mulq	%rbx
   910 (0.0%)  	addq	%rax,%r10
   910 (0.0%)  	movq	(%rcx),%rax
   910 (0.0%)  	adcq	$0,%rdx
     .         
   910 (0.0%)  	imulq	%r10,%rbp
   910 (0.0%)  	movq	%rdx,%r11
     .         
   910 (0.0%)  	mulq	%rbp
   910 (0.0%)  	addq	%rax,%r10
   910 (0.0%)  	movq	8(%rsi),%rax
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	movq	%rdx,%rdi
     .         
   910 (0.0%)  	mulq	%rbx
   910 (0.0%)  	addq	%rax,%r11
   910 (0.0%)  	movq	8(%rcx),%rax
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	addq	8(%rsp),%r11
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	movq	%rdx,%r10
     .         
   910 (0.0%)  	mulq	%rbp
   910 (0.0%)  	addq	%rax,%rdi
   910 (0.0%)  	movq	16(%rsi),%rax
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	addq	%r11,%rdi
   910 (0.0%)  	leaq	4(%r15),%r15
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	movq	%rdi,(%rsp)
   910 (0.0%)  	movq	%rdx,%r13
   910 (0.0%)  	jmp	.Linner4x
     .         .align	16
     .         .Linner4x:
11,914 (0.0%)  	mulq	%rbx
11,914 (0.0%)  	addq	%rax,%r10
11,914 (0.0%)  	movq	-16(%rcx,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	-16(%rsp,%r15,8),%r10
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	movq	%rdx,%r11
     .         
11,914 (0.0%)  	mulq	%rbp
11,914 (0.0%)  	addq	%rax,%r13
11,914 (0.0%)  	movq	-8(%rsi,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	%r10,%r13
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	movq	%r13,-24(%rsp,%r15,8)
11,914 (0.0%)  	movq	%rdx,%rdi
     .         
11,914 (0.0%)  	mulq	%rbx
11,914 (0.0%)  	addq	%rax,%r11
11,914 (0.0%)  	movq	-8(%rcx,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	-8(%rsp,%r15,8),%r11
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	movq	%rdx,%r10
     .         
11,914 (0.0%)  	mulq	%rbp
11,914 (0.0%)  	addq	%rax,%rdi
11,914 (0.0%)  	movq	(%rsi,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	%r11,%rdi
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	movq	%rdi,-16(%rsp,%r15,8)
11,914 (0.0%)  	movq	%rdx,%r13
     .         
11,914 (0.0%)  	mulq	%rbx
11,914 (0.0%)  	addq	%rax,%r10
11,914 (0.0%)  	movq	(%rcx,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	(%rsp,%r15,8),%r10
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	movq	%rdx,%r11
     .         
11,914 (0.0%)  	mulq	%rbp
11,914 (0.0%)  	addq	%rax,%r13
11,914 (0.0%)  	movq	8(%rsi,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	%r10,%r13
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	movq	%r13,-8(%rsp,%r15,8)
11,914 (0.0%)  	movq	%rdx,%rdi
     .         
11,914 (0.0%)  	mulq	%rbx
11,914 (0.0%)  	addq	%rax,%r11
11,914 (0.0%)  	movq	8(%rcx,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	8(%rsp,%r15,8),%r11
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	leaq	4(%r15),%r15
11,914 (0.0%)  	movq	%rdx,%r10
     .         
11,914 (0.0%)  	mulq	%rbp
11,914 (0.0%)  	addq	%rax,%rdi
11,914 (0.0%)  	movq	-16(%rsi,%r15,8),%rax
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	addq	%r11,%rdi
11,914 (0.0%)  	adcq	$0,%rdx
11,914 (0.0%)  	movq	%rdi,-32(%rsp,%r15,8)
11,914 (0.0%)  	movq	%rdx,%r13
11,914 (0.0%)  	cmpq	%r9,%r15
11,914 (0.0%)  	jb	.Linner4x
     .         
   910 (0.0%)  	mulq	%rbx
   910 (0.0%)  	addq	%rax,%r10
   910 (0.0%)  	movq	-16(%rcx,%r15,8),%rax
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	addq	-16(%rsp,%r15,8),%r10
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	movq	%rdx,%r11
     .         
   910 (0.0%)  	mulq	%rbp
   910 (0.0%)  	addq	%rax,%r13
   910 (0.0%)  	movq	-8(%rsi,%r15,8),%rax
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	addq	%r10,%r13
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	movq	%r13,-24(%rsp,%r15,8)
   910 (0.0%)  	movq	%rdx,%rdi
     .         
   910 (0.0%)  	mulq	%rbx
   910 (0.0%)  	addq	%rax,%r11
   910 (0.0%)  	movq	-8(%rcx,%r15,8),%rax
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	addq	-8(%rsp,%r15,8),%r11
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	leaq	1(%r14),%r14
   910 (0.0%)  	movq	%rdx,%r10
     .         
   910 (0.0%)  	mulq	%rbp
   910 (0.0%)  	addq	%rax,%rdi
   910 (0.0%)  	movq	(%rsi),%rax
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	addq	%r11,%rdi
   910 (0.0%)  	adcq	$0,%rdx
   910 (0.0%)  	movq	%rdi,-16(%rsp,%r15,8)
   910 (0.0%)  	movq	%rdx,%r13
     .         
   910 (0.0%)  	xorq	%rdi,%rdi
   910 (0.0%)  	addq	%r10,%r13
   910 (0.0%)  	adcq	$0,%rdi
   910 (0.0%)  	addq	(%rsp,%r9,8),%r13
   910 (0.0%)  	adcq	$0,%rdi
   910 (0.0%)  	movq	%r13,-8(%rsp,%r15,8)
   910 (0.0%)  	movq	%rdi,(%rsp,%r15,8)
     .         
   910 (0.0%)  	cmpq	%r9,%r14
   910 (0.0%)  	jb	.Louter4x
    18 (0.0%)  	movq	16(%rsp,%r9,8),%rdi
    18 (0.0%)  	leaq	-4(%r9),%r15
    18 (0.0%)  	movq	0(%rsp),%rax
    18 (0.0%)  	movq	8(%rsp),%rdx
    18 (0.0%)  	shrq	$2,%r15
    18 (0.0%)  	leaq	(%rsp),%rsi
    18 (0.0%)  	xorq	%r14,%r14
     .         
    18 (0.0%)  	subq	0(%rcx),%rax
    18 (0.0%)  	movq	16(%rsi),%rbx
    18 (0.0%)  	movq	24(%rsi),%rbp
    18 (0.0%)  	sbbq	8(%rcx),%rdx
     .         
     .         .Lsub4x:
   214 (0.0%)  	movq	%rax,0(%rdi,%r14,8)
   214 (0.0%)  	movq	%rdx,8(%rdi,%r14,8)
   214 (0.0%)  	sbbq	16(%rcx,%r14,8),%rbx
   214 (0.0%)  	movq	32(%rsi,%r14,8),%rax
   214 (0.0%)  	movq	40(%rsi,%r14,8),%rdx
   214 (0.0%)  	sbbq	24(%rcx,%r14,8),%rbp
   214 (0.0%)  	movq	%rbx,16(%rdi,%r14,8)
   214 (0.0%)  	movq	%rbp,24(%rdi,%r14,8)
   214 (0.0%)  	sbbq	32(%rcx,%r14,8),%rax
   214 (0.0%)  	movq	48(%rsi,%r14,8),%rbx
   214 (0.0%)  	movq	56(%rsi,%r14,8),%rbp
   214 (0.0%)  	sbbq	40(%rcx,%r14,8),%rdx
   214 (0.0%)  	leaq	4(%r14),%r14
   214 (0.0%)  	decq	%r15
   214 (0.0%)  	jnz	.Lsub4x
     .         
    18 (0.0%)  	movq	%rax,0(%rdi,%r14,8)
    18 (0.0%)  	movq	32(%rsi,%r14,8),%rax
    18 (0.0%)  	sbbq	16(%rcx,%r14,8),%rbx
    18 (0.0%)  	movq	%rdx,8(%rdi,%r14,8)
    18 (0.0%)  	sbbq	24(%rcx,%r14,8),%rbp
    18 (0.0%)  	movq	%rbx,16(%rdi,%r14,8)
     .         
    18 (0.0%)  	sbbq	$0,%rax
    18 (0.0%)  	movq	%rbp,24(%rdi,%r14,8)
    36 (0.0%)  	pxor	%xmm0,%xmm0
     .         .byte	102,72,15,110,224
    18 (0.0%)  	pcmpeqd	%xmm5,%xmm5
    18 (0.0%)  	pshufd	$0,%xmm4,%xmm4
    18 (0.0%)  	movq	%r9,%r15
    18 (0.0%)  	pxor	%xmm4,%xmm5
    18 (0.0%)  	shrq	$2,%r15
    18 (0.0%)  	xorl	%eax,%eax
     .         
    18 (0.0%)  	jmp	.Lcopy4x
     .         .align	16
     .         .Lcopy4x:
   232 (0.0%)  	movdqa	(%rsp,%rax,1),%xmm1
   232 (0.0%)  	movdqu	(%rdi,%rax,1),%xmm2
   232 (0.0%)  	pand	%xmm4,%xmm1
   232 (0.0%)  	pand	%xmm5,%xmm2
   232 (0.0%)  	movdqa	16(%rsp,%rax,1),%xmm3
   232 (0.0%)  	movdqa	%xmm0,(%rsp,%rax,1)
   232 (0.0%)  	por	%xmm2,%xmm1
   232 (0.0%)  	movdqu	16(%rdi,%rax,1),%xmm2
   232 (0.0%)  	movdqu	%xmm1,(%rdi,%rax,1)
   232 (0.0%)  	pand	%xmm4,%xmm3
   232 (0.0%)  	pand	%xmm5,%xmm2
   232 (0.0%)  	movdqa	%xmm0,16(%rsp,%rax,1)
   232 (0.0%)  	por	%xmm2,%xmm3
   232 (0.0%)  	movdqu	%xmm3,16(%rdi,%rax,1)
   232 (0.0%)  	leaq	32(%rax),%rax
   232 (0.0%)  	decq	%r15
   232 (0.0%)  	jnz	.Lcopy4x
    18 (0.0%)  	movq	8(%rsp,%r9,8),%rsi
     .         .cfi_def_cfa	%rsi, 8
    18 (0.0%)  	movq	$1,%rax
    18 (0.0%)  	movq	-48(%rsi),%r15
     .         .cfi_restore	%r15
    18 (0.0%)  	movq	-40(%rsi),%r14
     .         .cfi_restore	%r14
    18 (0.0%)  	movq	-32(%rsi),%r13
     .         .cfi_restore	%r13
    18 (0.0%)  	movq	-24(%rsi),%r12
     .         .cfi_restore	%r12
    18 (0.0%)  	movq	-16(%rsi),%rbp
     .         .cfi_restore	%rbp
    18 (0.0%)  	movq	-8(%rsi),%rbx
     .         .cfi_restore	%rbx
    36 (0.0%)  	leaq	(%rsi),%rsp
     .         .cfi_def_cfa_register	%rsp
     .         .Lmul4x_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	bn_mul4x_mont,.-bn_mul4x_mont
     .         .extern	bn_sqrx8x_internal
     .         .hidden bn_sqrx8x_internal
     .         .extern	bn_sqr8x_internal
-- line 703 ----------------------------------------
-- line 705 ----------------------------------------
     .         
     .         .type	bn_sqr8x_mont,@function
     .         .align	32
     .         bn_sqr8x_mont:
     .         .cfi_startproc	
     .         	movq	%rsp,%rax
     .         .cfi_def_cfa_register	%rax
     .         .Lsqr8x_enter:
    90 (0.0%)  	pushq	%rbx
     .         .cfi_offset	%rbx,-16
    90 (0.0%)  	pushq	%rbp
     .         .cfi_offset	%rbp,-24
    90 (0.0%)  	pushq	%r12
     .         .cfi_offset	%r12,-32
    90 (0.0%)  	pushq	%r13
     .         .cfi_offset	%r13,-40
    90 (0.0%)  	pushq	%r14
     .         .cfi_offset	%r14,-48
    90 (0.0%)  	pushq	%r15
     .         .cfi_offset	%r15,-56
     .         .Lsqr8x_prologue:
     .         
    90 (0.0%)  	movl	%r9d,%r10d
    90 (0.0%)  	shll	$3,%r9d
    90 (0.0%)  	shlq	$3+2,%r10
    90 (0.0%)  	negq	%r9
     .         
     .         
     .         
     .         
     .         
     .         
    90 (0.0%)  	leaq	-64(%rsp,%r9,2),%r11
    90 (0.0%)  	movq	%rsp,%rbp
    90 (0.0%)  	movq	(%r8),%r8
    90 (0.0%)  	subq	%rsi,%r11
    90 (0.0%)  	andq	$4095,%r11
    90 (0.0%)  	cmpq	%r11,%r10
    90 (0.0%)  	jb	.Lsqr8x_sp_alt
    22 (0.0%)  	subq	%r11,%rbp
    22 (0.0%)  	leaq	-64(%rbp,%r9,2),%rbp
    22 (0.0%)  	jmp	.Lsqr8x_sp_done
     .         
     .         .align	32
     .         .Lsqr8x_sp_alt:
    68 (0.0%)  	leaq	4096-64(,%r9,2),%r10
    68 (0.0%)  	leaq	-64(%rbp,%r9,2),%rbp
    68 (0.0%)  	subq	%r10,%r11
    68 (0.0%)  	movq	$0,%r10
    68 (0.0%)  	cmovcq	%r10,%r11
    68 (0.0%)  	subq	%r11,%rbp
     .         .Lsqr8x_sp_done:
    90 (0.0%)  	andq	$-64,%rbp
    90 (0.0%)  	movq	%rsp,%r11
    90 (0.0%)  	subq	%rbp,%r11
    90 (0.0%)  	andq	$-4096,%r11
    90 (0.0%)  	leaq	(%r11,%rbp,1),%rsp
    90 (0.0%)  	movq	(%rsp),%r10
    90 (0.0%)  	cmpq	%rbp,%rsp
    90 (0.0%)  	ja	.Lsqr8x_page_walk
    90 (0.0%)  	jmp	.Lsqr8x_page_walk_done
     .         
     .         .align	16
     .         .Lsqr8x_page_walk:
     .         	leaq	-4096(%rsp),%rsp
     .         	movq	(%rsp),%r10
     .         	cmpq	%rbp,%rsp
     .         	ja	.Lsqr8x_page_walk
     .         .Lsqr8x_page_walk_done:
     .         
    90 (0.0%)  	movq	%r9,%r10
    90 (0.0%)  	negq	%r9
     .         
    90 (0.0%)  	movq	%r8,32(%rsp)
   180 (0.0%)  	movq	%rax,40(%rsp)
     .         .cfi_escape	0x0f,0x05,0x77,0x28,0x06,0x23,0x08
     .         .Lsqr8x_body:
     .         
     .         .byte	102,72,15,110,209
   270 (0.0%)  	pxor	%xmm0,%xmm0
     .         .byte	102,72,15,110,207
     .         .byte	102,73,15,110,218
    90 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rax
    90 (0.0%)  	movl	8(%rax),%eax
    90 (0.0%)  	andl	$0x80100,%eax
    90 (0.0%)  	cmpl	$0x80100,%eax
    90 (0.0%)  	jne	.Lsqr8x_nox
     .         
     .         	call	bn_sqrx8x_internal
     .         
     .         
     .         
     .         
     .         	leaq	(%r8,%rcx,1),%rbx
     .         	movq	%rcx,%r9
     .         	movq	%rcx,%rdx
     .         .byte	102,72,15,126,207
     .         	sarq	$3+2,%rcx
     .         	jmp	.Lsqr8x_sub
     .         
     .         .align	32
     .         .Lsqr8x_nox:
    90 (0.0%)  	call	bn_sqr8x_internal
     .         
     .         
     .         
     .         
    90 (0.0%)  	leaq	(%rdi,%r9,1),%rbx
    90 (0.0%)  	movq	%r9,%rcx
   180 (0.0%)  	movq	%r9,%rdx
     .         .byte	102,72,15,126,207
    90 (0.0%)  	sarq	$3+2,%rcx
    90 (0.0%)  	jmp	.Lsqr8x_sub
     .         
     .         .align	32
     .         .Lsqr8x_sub:
 1,104 (0.0%)  	movq	0(%rbx),%r12
 1,104 (0.0%)  	movq	8(%rbx),%r13
 1,104 (0.0%)  	movq	16(%rbx),%r14
 1,104 (0.0%)  	movq	24(%rbx),%r15
 1,104 (0.0%)  	leaq	32(%rbx),%rbx
 1,104 (0.0%)  	sbbq	0(%rbp),%r12
 1,104 (0.0%)  	sbbq	8(%rbp),%r13
 1,104 (0.0%)  	sbbq	16(%rbp),%r14
 1,104 (0.0%)  	sbbq	24(%rbp),%r15
 1,104 (0.0%)  	leaq	32(%rbp),%rbp
 1,104 (0.0%)  	movq	%r12,0(%rdi)
 1,104 (0.0%)  	movq	%r13,8(%rdi)
 1,104 (0.0%)  	movq	%r14,16(%rdi)
 1,104 (0.0%)  	movq	%r15,24(%rdi)
 1,104 (0.0%)  	leaq	32(%rdi),%rdi
 1,104 (0.0%)  	incq	%rcx
 1,104 (0.0%)  	jnz	.Lsqr8x_sub
     .         
    90 (0.0%)  	sbbq	$0,%rax
    90 (0.0%)  	leaq	(%rbx,%r9,1),%rbx
   180 (0.0%)  	leaq	(%rdi,%r9,1),%rdi
     .         
     .         .byte	102,72,15,110,200
    90 (0.0%)  	pxor	%xmm0,%xmm0
    90 (0.0%)  	pshufd	$0,%xmm1,%xmm1
    90 (0.0%)  	movq	40(%rsp),%rsi
     .         .cfi_def_cfa	%rsi,8
    90 (0.0%)  	jmp	.Lsqr8x_cond_copy
     .         
     .         .align	32
     .         .Lsqr8x_cond_copy:
 1,104 (0.0%)  	movdqa	0(%rbx),%xmm2
 1,104 (0.0%)  	movdqa	16(%rbx),%xmm3
 1,104 (0.0%)  	leaq	32(%rbx),%rbx
 1,104 (0.0%)  	movdqu	0(%rdi),%xmm4
 1,104 (0.0%)  	movdqu	16(%rdi),%xmm5
 1,104 (0.0%)  	leaq	32(%rdi),%rdi
 1,104 (0.0%)  	movdqa	%xmm0,-32(%rbx)
 1,104 (0.0%)  	movdqa	%xmm0,-16(%rbx)
 1,104 (0.0%)  	movdqa	%xmm0,-32(%rbx,%rdx,1)
 1,104 (0.0%)  	movdqa	%xmm0,-16(%rbx,%rdx,1)
 1,104 (0.0%)  	pcmpeqd	%xmm1,%xmm0
 1,104 (0.0%)  	pand	%xmm1,%xmm2
 1,104 (0.0%)  	pand	%xmm1,%xmm3
 1,104 (0.0%)  	pand	%xmm0,%xmm4
 1,104 (0.0%)  	pand	%xmm0,%xmm5
 1,104 (0.0%)  	pxor	%xmm0,%xmm0
 1,104 (0.0%)  	por	%xmm2,%xmm4
 1,104 (0.0%)  	por	%xmm3,%xmm5
 1,104 (0.0%)  	movdqu	%xmm4,-32(%rdi)
 1,104 (0.0%)  	movdqu	%xmm5,-16(%rdi)
 1,104 (0.0%)  	addq	$32,%r9
 1,104 (0.0%)  	jnz	.Lsqr8x_cond_copy
     .         
    90 (0.0%)  	movq	$1,%rax
    90 (0.0%)  	movq	-48(%rsi),%r15
     .         .cfi_restore	%r15
    90 (0.0%)  	movq	-40(%rsi),%r14
     .         .cfi_restore	%r14
    90 (0.0%)  	movq	-32(%rsi),%r13
     .         .cfi_restore	%r13
    90 (0.0%)  	movq	-24(%rsi),%r12
     .         .cfi_restore	%r12
    90 (0.0%)  	movq	-16(%rsi),%rbp
     .         .cfi_restore	%rbp
    90 (0.0%)  	movq	-8(%rsi),%rbx
     .         .cfi_restore	%rbx
   180 (0.0%)  	leaq	(%rsi),%rsp
     .         .cfi_def_cfa_register	%rsp
     .         .Lsqr8x_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	bn_sqr8x_mont,.-bn_sqr8x_mont
     .         .type	bn_mulx4x_mont,@function
     .         .align	32
     .         bn_mulx4x_mont:
-- line 896 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont5.S
--------------------------------------------------------------------------------
Ir____________ 

-- line 10 ----------------------------------------
      .         .hidden OPENSSL_ia32cap_P
      .         
      .         .globl	bn_mul_mont_gather5
      .         .hidden bn_mul_mont_gather5
      .         .type	bn_mul_mont_gather5,@function
      .         .align	64
      .         bn_mul_mont_gather5:
      .         .cfi_startproc	
     30 (0.0%)  	movl	%r9d,%r9d
     30 (0.0%)  	movq	%rsp,%rax
      .         .cfi_def_cfa_register	%rax
     30 (0.0%)  	testl	$7,%r9d
     30 (0.0%)  	jnz	.Lmul_enter
     30 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r11
     30 (0.0%)  	movl	8(%r11),%r11d
     30 (0.0%)  	jmp	.Lmul4x_enter
      .         
      .         .align	16
      .         .Lmul_enter:
      .         	movd	8(%rsp),%xmm5
      .         	pushq	%rbx
      .         .cfi_offset	%rbx,-16
      .         	pushq	%rbp
      .         .cfi_offset	%rbp,-24
-- line 33 ----------------------------------------
-- line 455 ----------------------------------------
      .         .type	bn_mul4x_mont_gather5,@function
      .         .align	32
      .         bn_mul4x_mont_gather5:
      .         .cfi_startproc	
      .         .byte	0x67
      .         	movq	%rsp,%rax
      .         .cfi_def_cfa_register	%rax
      .         .Lmul4x_enter:
     30 (0.0%)  	andl	$0x80108,%r11d
     30 (0.0%)  	cmpl	$0x80108,%r11d
     30 (0.0%)  	je	.Lmulx4x_enter
     30 (0.0%)  	pushq	%rbx
      .         .cfi_offset	%rbx,-16
     30 (0.0%)  	pushq	%rbp
      .         .cfi_offset	%rbp,-24
     30 (0.0%)  	pushq	%r12
      .         .cfi_offset	%r12,-32
     30 (0.0%)  	pushq	%r13
      .         .cfi_offset	%r13,-40
     30 (0.0%)  	pushq	%r14
      .         .cfi_offset	%r14,-48
     60 (0.0%)  	pushq	%r15
      .         .cfi_offset	%r15,-56
      .         .Lmul4x_prologue:
      .         
      .         .byte	0x67
      .         	shll	$3,%r9d
     30 (0.0%)  	leaq	(%r9,%r9,2),%r10
     30 (0.0%)  	negq	%r9
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
     30 (0.0%)  	leaq	-320(%rsp,%r9,2),%r11
     30 (0.0%)  	movq	%rsp,%rbp
     30 (0.0%)  	subq	%rdi,%r11
     30 (0.0%)  	andq	$4095,%r11
     30 (0.0%)  	cmpq	%r11,%r10
     30 (0.0%)  	jb	.Lmul4xsp_alt
      .         	subq	%r11,%rbp
      .         	leaq	-320(%rbp,%r9,2),%rbp
      .         	jmp	.Lmul4xsp_done
      .         
      .         .align	32
      .         .Lmul4xsp_alt:
     30 (0.0%)  	leaq	4096-320(,%r9,2),%r10
     30 (0.0%)  	leaq	-320(%rbp,%r9,2),%rbp
     30 (0.0%)  	subq	%r10,%r11
     30 (0.0%)  	movq	$0,%r10
     30 (0.0%)  	cmovcq	%r10,%r11
     30 (0.0%)  	subq	%r11,%rbp
      .         .Lmul4xsp_done:
     30 (0.0%)  	andq	$-64,%rbp
     30 (0.0%)  	movq	%rsp,%r11
     30 (0.0%)  	subq	%rbp,%r11
     30 (0.0%)  	andq	$-4096,%r11
     30 (0.0%)  	leaq	(%r11,%rbp,1),%rsp
     30 (0.0%)  	movq	(%rsp),%r10
     30 (0.0%)  	cmpq	%rbp,%rsp
     30 (0.0%)  	ja	.Lmul4x_page_walk
     30 (0.0%)  	jmp	.Lmul4x_page_walk_done
      .         
      .         .Lmul4x_page_walk:
      .         	leaq	-4096(%rsp),%rsp
      .         	movq	(%rsp),%r10
      .         	cmpq	%rbp,%rsp
      .         	ja	.Lmul4x_page_walk
      .         .Lmul4x_page_walk_done:
      .         
     30 (0.0%)  	negq	%r9
      .         
     30 (0.0%)  	movq	%rax,40(%rsp)
      .         .cfi_escape	0x0f,0x05,0x77,0x28,0x06,0x23,0x08
      .         .Lmul4x_body:
      .         
     30 (0.0%)  	call	mul4x_internal
      .         
     30 (0.0%)  	movq	40(%rsp),%rsi
      .         .cfi_def_cfa	%rsi,8
     30 (0.0%)  	movq	$1,%rax
      .         
     30 (0.0%)  	movq	-48(%rsi),%r15
      .         .cfi_restore	%r15
     30 (0.0%)  	movq	-40(%rsi),%r14
      .         .cfi_restore	%r14
     30 (0.0%)  	movq	-32(%rsi),%r13
      .         .cfi_restore	%r13
     30 (0.0%)  	movq	-24(%rsi),%r12
      .         .cfi_restore	%r12
     30 (0.0%)  	movq	-16(%rsi),%rbp
      .         .cfi_restore	%rbp
     30 (0.0%)  	movq	-8(%rsi),%rbx
      .         .cfi_restore	%rbx
     60 (0.0%)  	leaq	(%rsi),%rsp
      .         .cfi_def_cfa_register	%rsp
      .         .Lmul4x_epilogue:
      .         	.byte	0xf3,0xc3
      .         .cfi_endproc	
      .         .size	bn_mul4x_mont_gather5,.-bn_mul4x_mont_gather5
      .         
      .         .type	mul4x_internal,@function
      .         .align	32
      .         mul4x_internal:
      .         .cfi_startproc	
    848 (0.0%)  	shlq	$5,%r9
    848 (0.0%)  	movd	8(%rax),%xmm5
    848 (0.0%)  	leaq	.Linc(%rip),%rax
    848 (0.0%)  	leaq	128(%rdx,%r9,1),%r13
    848 (0.0%)  	shrq	$5,%r9
    848 (0.0%)  	movdqa	0(%rax),%xmm0
    848 (0.0%)  	movdqa	16(%rax),%xmm1
    848 (0.0%)  	leaq	88-112(%rsp,%r9,1),%r10
    848 (0.0%)  	leaq	128(%rdx),%r12
      .         
    848 (0.0%)  	pshufd	$0,%xmm5,%xmm5
  1,696 (0.0%)  	movdqa	%xmm1,%xmm4
      .         .byte	0x67,0x67
      .         	movdqa	%xmm1,%xmm2
    848 (0.0%)  	paddd	%xmm0,%xmm1
  1,696 (0.0%)  	pcmpeqd	%xmm5,%xmm0
      .         .byte	0x67
      .         	movdqa	%xmm4,%xmm3
    848 (0.0%)  	paddd	%xmm1,%xmm2
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm1
    848 (0.0%)  	movdqa	%xmm0,112(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm0
      .         
    848 (0.0%)  	paddd	%xmm2,%xmm3
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm2
    848 (0.0%)  	movdqa	%xmm1,128(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm1
      .         
    848 (0.0%)  	paddd	%xmm3,%xmm0
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm3
    848 (0.0%)  	movdqa	%xmm2,144(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm2
      .         
    848 (0.0%)  	paddd	%xmm0,%xmm1
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm0
    848 (0.0%)  	movdqa	%xmm3,160(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm3
    848 (0.0%)  	paddd	%xmm1,%xmm2
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm1
    848 (0.0%)  	movdqa	%xmm0,176(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm0
      .         
    848 (0.0%)  	paddd	%xmm2,%xmm3
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm2
    848 (0.0%)  	movdqa	%xmm1,192(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm1
      .         
    848 (0.0%)  	paddd	%xmm3,%xmm0
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm3
    848 (0.0%)  	movdqa	%xmm2,208(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm2
      .         
    848 (0.0%)  	paddd	%xmm0,%xmm1
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm0
    848 (0.0%)  	movdqa	%xmm3,224(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm3
    848 (0.0%)  	paddd	%xmm1,%xmm2
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm1
    848 (0.0%)  	movdqa	%xmm0,240(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm0
      .         
    848 (0.0%)  	paddd	%xmm2,%xmm3
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm2
    848 (0.0%)  	movdqa	%xmm1,256(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm1
      .         
    848 (0.0%)  	paddd	%xmm3,%xmm0
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm3
    848 (0.0%)  	movdqa	%xmm2,272(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm2
      .         
    848 (0.0%)  	paddd	%xmm0,%xmm1
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm0
    848 (0.0%)  	movdqa	%xmm3,288(%r10)
    848 (0.0%)  	movdqa	%xmm4,%xmm3
    848 (0.0%)  	paddd	%xmm1,%xmm2
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm1
    848 (0.0%)  	movdqa	%xmm0,304(%r10)
      .         
  1,696 (0.0%)  	paddd	%xmm2,%xmm3
      .         .byte	0x67
      .         	pcmpeqd	%xmm5,%xmm2
    848 (0.0%)  	movdqa	%xmm1,320(%r10)
      .         
    848 (0.0%)  	pcmpeqd	%xmm5,%xmm3
    848 (0.0%)  	movdqa	%xmm2,336(%r10)
    848 (0.0%)  	pand	64(%r12),%xmm0
      .         
    848 (0.0%)  	pand	80(%r12),%xmm1
    848 (0.0%)  	pand	96(%r12),%xmm2
    848 (0.0%)  	movdqa	%xmm3,352(%r10)
    848 (0.0%)  	pand	112(%r12),%xmm3
    848 (0.0%)  	por	%xmm2,%xmm0
    848 (0.0%)  	por	%xmm3,%xmm1
    848 (0.0%)  	movdqa	-128(%r12),%xmm4
    848 (0.0%)  	movdqa	-112(%r12),%xmm5
    848 (0.0%)  	movdqa	-96(%r12),%xmm2
    848 (0.0%)  	pand	112(%r10),%xmm4
    848 (0.0%)  	movdqa	-80(%r12),%xmm3
    848 (0.0%)  	pand	128(%r10),%xmm5
    848 (0.0%)  	por	%xmm4,%xmm0
    848 (0.0%)  	pand	144(%r10),%xmm2
    848 (0.0%)  	por	%xmm5,%xmm1
    848 (0.0%)  	pand	160(%r10),%xmm3
    848 (0.0%)  	por	%xmm2,%xmm0
    848 (0.0%)  	por	%xmm3,%xmm1
    848 (0.0%)  	movdqa	-64(%r12),%xmm4
    848 (0.0%)  	movdqa	-48(%r12),%xmm5
    848 (0.0%)  	movdqa	-32(%r12),%xmm2
    848 (0.0%)  	pand	176(%r10),%xmm4
    848 (0.0%)  	movdqa	-16(%r12),%xmm3
    848 (0.0%)  	pand	192(%r10),%xmm5
    848 (0.0%)  	por	%xmm4,%xmm0
    848 (0.0%)  	pand	208(%r10),%xmm2
    848 (0.0%)  	por	%xmm5,%xmm1
    848 (0.0%)  	pand	224(%r10),%xmm3
    848 (0.0%)  	por	%xmm2,%xmm0
    848 (0.0%)  	por	%xmm3,%xmm1
    848 (0.0%)  	movdqa	0(%r12),%xmm4
    848 (0.0%)  	movdqa	16(%r12),%xmm5
    848 (0.0%)  	movdqa	32(%r12),%xmm2
    848 (0.0%)  	pand	240(%r10),%xmm4
    848 (0.0%)  	movdqa	48(%r12),%xmm3
    848 (0.0%)  	pand	256(%r10),%xmm5
    848 (0.0%)  	por	%xmm4,%xmm0
    848 (0.0%)  	pand	272(%r10),%xmm2
    848 (0.0%)  	por	%xmm5,%xmm1
    848 (0.0%)  	pand	288(%r10),%xmm3
    848 (0.0%)  	por	%xmm2,%xmm0
    848 (0.0%)  	por	%xmm3,%xmm1
    848 (0.0%)  	por	%xmm1,%xmm0
      .         
    848 (0.0%)  	pshufd	$0x4e,%xmm0,%xmm1
    848 (0.0%)  	por	%xmm1,%xmm0
  1,696 (0.0%)  	leaq	256(%r12),%r12
      .         .byte	102,72,15,126,195
      .         
    848 (0.0%)  	movq	%r13,16+8(%rsp)
    848 (0.0%)  	movq	%rdi,56+8(%rsp)
      .         
    848 (0.0%)  	movq	(%r8),%r8
    848 (0.0%)  	movq	(%rsi),%rax
    848 (0.0%)  	leaq	(%rsi,%r9,1),%rsi
    848 (0.0%)  	negq	%r9
      .         
    848 (0.0%)  	movq	%r8,%rbp
    848 (0.0%)  	mulq	%rbx
    848 (0.0%)  	movq	%rax,%r10
    848 (0.0%)  	movq	(%rcx),%rax
      .         
    848 (0.0%)  	imulq	%r10,%rbp
    848 (0.0%)  	leaq	64+8(%rsp),%r14
    848 (0.0%)  	movq	%rdx,%r11
      .         
    848 (0.0%)  	mulq	%rbp
    848 (0.0%)  	addq	%rax,%r10
    848 (0.0%)  	movq	8(%rsi,%r9,1),%rax
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	movq	%rdx,%rdi
      .         
    848 (0.0%)  	mulq	%rbx
    848 (0.0%)  	addq	%rax,%r11
    848 (0.0%)  	movq	8(%rcx),%rax
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	movq	%rdx,%r10
      .         
    848 (0.0%)  	mulq	%rbp
    848 (0.0%)  	addq	%rax,%rdi
    848 (0.0%)  	movq	16(%rsi,%r9,1),%rax
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	addq	%r11,%rdi
    848 (0.0%)  	leaq	32(%r9),%r15
    848 (0.0%)  	leaq	32(%rcx),%rcx
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	movq	%rdi,(%r14)
    848 (0.0%)  	movq	%rdx,%r13
    848 (0.0%)  	jmp	.L1st4x
      .         
      .         .align	32
      .         .L1st4x:
  5,936 (0.0%)  	mulq	%rbx
  5,936 (0.0%)  	addq	%rax,%r10
  5,936 (0.0%)  	movq	-16(%rcx),%rax
  5,936 (0.0%)  	leaq	32(%r14),%r14
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%rdx,%r11
      .         
  5,936 (0.0%)  	mulq	%rbp
  5,936 (0.0%)  	addq	%rax,%r13
  5,936 (0.0%)  	movq	-8(%rsi,%r15,1),%rax
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	addq	%r10,%r13
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%r13,-24(%r14)
  5,936 (0.0%)  	movq	%rdx,%rdi
      .         
  5,936 (0.0%)  	mulq	%rbx
  5,936 (0.0%)  	addq	%rax,%r11
  5,936 (0.0%)  	movq	-8(%rcx),%rax
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%rdx,%r10
      .         
  5,936 (0.0%)  	mulq	%rbp
  5,936 (0.0%)  	addq	%rax,%rdi
  5,936 (0.0%)  	movq	(%rsi,%r15,1),%rax
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	addq	%r11,%rdi
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%rdi,-16(%r14)
  5,936 (0.0%)  	movq	%rdx,%r13
      .         
  5,936 (0.0%)  	mulq	%rbx
  5,936 (0.0%)  	addq	%rax,%r10
  5,936 (0.0%)  	movq	0(%rcx),%rax
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%rdx,%r11
      .         
  5,936 (0.0%)  	mulq	%rbp
  5,936 (0.0%)  	addq	%rax,%r13
  5,936 (0.0%)  	movq	8(%rsi,%r15,1),%rax
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	addq	%r10,%r13
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%r13,-8(%r14)
  5,936 (0.0%)  	movq	%rdx,%rdi
      .         
  5,936 (0.0%)  	mulq	%rbx
  5,936 (0.0%)  	addq	%rax,%r11
  5,936 (0.0%)  	movq	8(%rcx),%rax
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%rdx,%r10
      .         
  5,936 (0.0%)  	mulq	%rbp
  5,936 (0.0%)  	addq	%rax,%rdi
  5,936 (0.0%)  	movq	16(%rsi,%r15,1),%rax
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	addq	%r11,%rdi
  5,936 (0.0%)  	leaq	32(%rcx),%rcx
  5,936 (0.0%)  	adcq	$0,%rdx
  5,936 (0.0%)  	movq	%rdi,(%r14)
  5,936 (0.0%)  	movq	%rdx,%r13
      .         
  5,936 (0.0%)  	addq	$32,%r15
  5,936 (0.0%)  	jnz	.L1st4x
      .         
    848 (0.0%)  	mulq	%rbx
    848 (0.0%)  	addq	%rax,%r10
    848 (0.0%)  	movq	-16(%rcx),%rax
    848 (0.0%)  	leaq	32(%r14),%r14
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	movq	%rdx,%r11
      .         
    848 (0.0%)  	mulq	%rbp
    848 (0.0%)  	addq	%rax,%r13
    848 (0.0%)  	movq	-8(%rsi),%rax
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	addq	%r10,%r13
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	movq	%r13,-24(%r14)
    848 (0.0%)  	movq	%rdx,%rdi
      .         
    848 (0.0%)  	mulq	%rbx
    848 (0.0%)  	addq	%rax,%r11
    848 (0.0%)  	movq	-8(%rcx),%rax
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	movq	%rdx,%r10
      .         
    848 (0.0%)  	mulq	%rbp
    848 (0.0%)  	addq	%rax,%rdi
    848 (0.0%)  	movq	(%rsi,%r9,1),%rax
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	addq	%r11,%rdi
    848 (0.0%)  	adcq	$0,%rdx
    848 (0.0%)  	movq	%rdi,-16(%r14)
    848 (0.0%)  	movq	%rdx,%r13
      .         
    848 (0.0%)  	leaq	(%rcx,%r9,1),%rcx
      .         
    848 (0.0%)  	xorq	%rdi,%rdi
    848 (0.0%)  	addq	%r10,%r13
    848 (0.0%)  	adcq	$0,%rdi
    848 (0.0%)  	movq	%r13,-8(%r14)
      .         
    848 (0.0%)  	jmp	.Louter4x
      .         
      .         .align	32
      .         .Louter4x:
 26,288 (0.0%)  	leaq	16+128(%r14),%rdx
 26,288 (0.0%)  	pxor	%xmm4,%xmm4
 26,288 (0.0%)  	pxor	%xmm5,%xmm5
 26,288 (0.0%)  	movdqa	-128(%r12),%xmm0
 26,288 (0.0%)  	movdqa	-112(%r12),%xmm1
 26,288 (0.0%)  	movdqa	-96(%r12),%xmm2
 26,288 (0.0%)  	movdqa	-80(%r12),%xmm3
 26,288 (0.0%)  	pand	-128(%rdx),%xmm0
 26,288 (0.0%)  	pand	-112(%rdx),%xmm1
 26,288 (0.0%)  	por	%xmm0,%xmm4
 26,288 (0.0%)  	pand	-96(%rdx),%xmm2
 26,288 (0.0%)  	por	%xmm1,%xmm5
 26,288 (0.0%)  	pand	-80(%rdx),%xmm3
 26,288 (0.0%)  	por	%xmm2,%xmm4
 26,288 (0.0%)  	por	%xmm3,%xmm5
 26,288 (0.0%)  	movdqa	-64(%r12),%xmm0
 26,288 (0.0%)  	movdqa	-48(%r12),%xmm1
 26,288 (0.0%)  	movdqa	-32(%r12),%xmm2
 26,288 (0.0%)  	movdqa	-16(%r12),%xmm3
 26,288 (0.0%)  	pand	-64(%rdx),%xmm0
 26,288 (0.0%)  	pand	-48(%rdx),%xmm1
 26,288 (0.0%)  	por	%xmm0,%xmm4
 26,288 (0.0%)  	pand	-32(%rdx),%xmm2
 26,288 (0.0%)  	por	%xmm1,%xmm5
 26,288 (0.0%)  	pand	-16(%rdx),%xmm3
 26,288 (0.0%)  	por	%xmm2,%xmm4
 26,288 (0.0%)  	por	%xmm3,%xmm5
 26,288 (0.0%)  	movdqa	0(%r12),%xmm0
 26,288 (0.0%)  	movdqa	16(%r12),%xmm1
 26,288 (0.0%)  	movdqa	32(%r12),%xmm2
 26,288 (0.0%)  	movdqa	48(%r12),%xmm3
 26,288 (0.0%)  	pand	0(%rdx),%xmm0
 26,288 (0.0%)  	pand	16(%rdx),%xmm1
 26,288 (0.0%)  	por	%xmm0,%xmm4
 26,288 (0.0%)  	pand	32(%rdx),%xmm2
 26,288 (0.0%)  	por	%xmm1,%xmm5
 26,288 (0.0%)  	pand	48(%rdx),%xmm3
 26,288 (0.0%)  	por	%xmm2,%xmm4
 26,288 (0.0%)  	por	%xmm3,%xmm5
 26,288 (0.0%)  	movdqa	64(%r12),%xmm0
 26,288 (0.0%)  	movdqa	80(%r12),%xmm1
 26,288 (0.0%)  	movdqa	96(%r12),%xmm2
 26,288 (0.0%)  	movdqa	112(%r12),%xmm3
 26,288 (0.0%)  	pand	64(%rdx),%xmm0
 26,288 (0.0%)  	pand	80(%rdx),%xmm1
 26,288 (0.0%)  	por	%xmm0,%xmm4
 26,288 (0.0%)  	pand	96(%rdx),%xmm2
 26,288 (0.0%)  	por	%xmm1,%xmm5
 26,288 (0.0%)  	pand	112(%rdx),%xmm3
 26,288 (0.0%)  	por	%xmm2,%xmm4
 26,288 (0.0%)  	por	%xmm3,%xmm5
 26,288 (0.0%)  	por	%xmm5,%xmm4
      .         
 26,288 (0.0%)  	pshufd	$0x4e,%xmm4,%xmm0
 26,288 (0.0%)  	por	%xmm4,%xmm0
 52,576 (0.0%)  	leaq	256(%r12),%r12
      .         .byte	102,72,15,126,195
      .         
 26,288 (0.0%)  	movq	(%r14,%r9,1),%r10
 26,288 (0.0%)  	movq	%r8,%rbp
 26,288 (0.0%)  	mulq	%rbx
 26,288 (0.0%)  	addq	%rax,%r10
 26,288 (0.0%)  	movq	(%rcx),%rax
 26,288 (0.0%)  	adcq	$0,%rdx
      .         
 26,288 (0.0%)  	imulq	%r10,%rbp
 26,288 (0.0%)  	movq	%rdx,%r11
 26,288 (0.0%)  	movq	%rdi,(%r14)
      .         
 26,288 (0.0%)  	leaq	(%r14,%r9,1),%r14
      .         
 26,288 (0.0%)  	mulq	%rbp
 26,288 (0.0%)  	addq	%rax,%r10
 26,288 (0.0%)  	movq	8(%rsi,%r9,1),%rax
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	movq	%rdx,%rdi
      .         
 26,288 (0.0%)  	mulq	%rbx
 26,288 (0.0%)  	addq	%rax,%r11
 26,288 (0.0%)  	movq	8(%rcx),%rax
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	addq	8(%r14),%r11
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	movq	%rdx,%r10
      .         
 26,288 (0.0%)  	mulq	%rbp
 26,288 (0.0%)  	addq	%rax,%rdi
 26,288 (0.0%)  	movq	16(%rsi,%r9,1),%rax
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	addq	%r11,%rdi
 26,288 (0.0%)  	leaq	32(%r9),%r15
 26,288 (0.0%)  	leaq	32(%rcx),%rcx
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	movq	%rdx,%r13
 26,288 (0.0%)  	jmp	.Linner4x
      .         
      .         .align	32
      .         .Linner4x:
184,016 (0.1%)  	mulq	%rbx
184,016 (0.1%)  	addq	%rax,%r10
184,016 (0.1%)  	movq	-16(%rcx),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	16(%r14),%r10
184,016 (0.1%)  	leaq	32(%r14),%r14
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%rdx,%r11
      .         
184,016 (0.1%)  	mulq	%rbp
184,016 (0.1%)  	addq	%rax,%r13
184,016 (0.1%)  	movq	-8(%rsi,%r15,1),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	%r10,%r13
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%rdi,-32(%r14)
184,016 (0.1%)  	movq	%rdx,%rdi
      .         
184,016 (0.1%)  	mulq	%rbx
184,016 (0.1%)  	addq	%rax,%r11
184,016 (0.1%)  	movq	-8(%rcx),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	-8(%r14),%r11
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%rdx,%r10
      .         
184,016 (0.1%)  	mulq	%rbp
184,016 (0.1%)  	addq	%rax,%rdi
184,016 (0.1%)  	movq	(%rsi,%r15,1),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	%r11,%rdi
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%r13,-24(%r14)
184,016 (0.1%)  	movq	%rdx,%r13
      .         
184,016 (0.1%)  	mulq	%rbx
184,016 (0.1%)  	addq	%rax,%r10
184,016 (0.1%)  	movq	0(%rcx),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	(%r14),%r10
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%rdx,%r11
      .         
184,016 (0.1%)  	mulq	%rbp
184,016 (0.1%)  	addq	%rax,%r13
184,016 (0.1%)  	movq	8(%rsi,%r15,1),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	%r10,%r13
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%rdi,-16(%r14)
184,016 (0.1%)  	movq	%rdx,%rdi
      .         
184,016 (0.1%)  	mulq	%rbx
184,016 (0.1%)  	addq	%rax,%r11
184,016 (0.1%)  	movq	8(%rcx),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	8(%r14),%r11
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%rdx,%r10
      .         
184,016 (0.1%)  	mulq	%rbp
184,016 (0.1%)  	addq	%rax,%rdi
184,016 (0.1%)  	movq	16(%rsi,%r15,1),%rax
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	addq	%r11,%rdi
184,016 (0.1%)  	leaq	32(%rcx),%rcx
184,016 (0.1%)  	adcq	$0,%rdx
184,016 (0.1%)  	movq	%r13,-8(%r14)
184,016 (0.1%)  	movq	%rdx,%r13
      .         
184,016 (0.1%)  	addq	$32,%r15
184,016 (0.1%)  	jnz	.Linner4x
      .         
 26,288 (0.0%)  	mulq	%rbx
 26,288 (0.0%)  	addq	%rax,%r10
 26,288 (0.0%)  	movq	-16(%rcx),%rax
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	addq	16(%r14),%r10
 26,288 (0.0%)  	leaq	32(%r14),%r14
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	movq	%rdx,%r11
      .         
 26,288 (0.0%)  	mulq	%rbp
 26,288 (0.0%)  	addq	%rax,%r13
 26,288 (0.0%)  	movq	-8(%rsi),%rax
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	addq	%r10,%r13
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	movq	%rdi,-32(%r14)
 26,288 (0.0%)  	movq	%rdx,%rdi
      .         
 26,288 (0.0%)  	mulq	%rbx
 26,288 (0.0%)  	addq	%rax,%r11
 26,288 (0.0%)  	movq	%rbp,%rax
 26,288 (0.0%)  	movq	-8(%rcx),%rbp
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	addq	-8(%r14),%r11
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	movq	%rdx,%r10
      .         
 26,288 (0.0%)  	mulq	%rbp
 26,288 (0.0%)  	addq	%rax,%rdi
 26,288 (0.0%)  	movq	(%rsi,%r9,1),%rax
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	addq	%r11,%rdi
 26,288 (0.0%)  	adcq	$0,%rdx
 26,288 (0.0%)  	movq	%r13,-24(%r14)
 26,288 (0.0%)  	movq	%rdx,%r13
      .         
 26,288 (0.0%)  	movq	%rdi,-16(%r14)
 26,288 (0.0%)  	leaq	(%rcx,%r9,1),%rcx
      .         
 26,288 (0.0%)  	xorq	%rdi,%rdi
 26,288 (0.0%)  	addq	%r10,%r13
 26,288 (0.0%)  	adcq	$0,%rdi
 26,288 (0.0%)  	addq	(%r14),%r13
 26,288 (0.0%)  	adcq	$0,%rdi
 26,288 (0.0%)  	movq	%r13,-8(%r14)
      .         
 26,288 (0.0%)  	cmpq	16+8(%rsp),%r12
 26,288 (0.0%)  	jb	.Louter4x
    848 (0.0%)  	xorq	%rax,%rax
    848 (0.0%)  	subq	%r13,%rbp
    848 (0.0%)  	adcq	%r15,%r15
    848 (0.0%)  	orq	%r15,%rdi
    848 (0.0%)  	subq	%rdi,%rax
    848 (0.0%)  	leaq	(%r14,%r9,1),%rbx
    848 (0.0%)  	movq	(%rcx),%r12
    848 (0.0%)  	leaq	(%rcx),%rbp
    848 (0.0%)  	movq	%r9,%rcx
    848 (0.0%)  	sarq	$3+2,%rcx
    848 (0.0%)  	movq	56+8(%rsp),%rdi
    848 (0.0%)  	decq	%r12
    848 (0.0%)  	xorq	%r10,%r10
    848 (0.0%)  	movq	8(%rbp),%r13
    848 (0.0%)  	movq	16(%rbp),%r14
    848 (0.0%)  	movq	24(%rbp),%r15
    848 (0.0%)  	jmp	.Lsqr4x_sub_entry
      .         .cfi_endproc	
      .         .size	mul4x_internal,.-mul4x_internal
      .         .globl	bn_power5
      .         .hidden bn_power5
      .         .type	bn_power5,@function
      .         .align	32
      .         bn_power5:
      .         .cfi_startproc	
    818 (0.0%)  	movq	%rsp,%rax
      .         .cfi_def_cfa_register	%rax
    818 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r11
    818 (0.0%)  	movl	8(%r11),%r11d
    818 (0.0%)  	andl	$0x80108,%r11d
    818 (0.0%)  	cmpl	$0x80108,%r11d
    818 (0.0%)  	je	.Lpowerx5_enter
    818 (0.0%)  	pushq	%rbx
      .         .cfi_offset	%rbx,-16
    818 (0.0%)  	pushq	%rbp
      .         .cfi_offset	%rbp,-24
    818 (0.0%)  	pushq	%r12
      .         .cfi_offset	%r12,-32
    818 (0.0%)  	pushq	%r13
      .         .cfi_offset	%r13,-40
    818 (0.0%)  	pushq	%r14
      .         .cfi_offset	%r14,-48
    818 (0.0%)  	pushq	%r15
      .         .cfi_offset	%r15,-56
      .         .Lpower5_prologue:
      .         
    818 (0.0%)  	shll	$3,%r9d
    818 (0.0%)  	leal	(%r9,%r9,2),%r10d
    818 (0.0%)  	negq	%r9
    818 (0.0%)  	movq	(%r8),%r8
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
    818 (0.0%)  	leaq	-320(%rsp,%r9,2),%r11
    818 (0.0%)  	movq	%rsp,%rbp
    818 (0.0%)  	subq	%rdi,%r11
    818 (0.0%)  	andq	$4095,%r11
    818 (0.0%)  	cmpq	%r11,%r10
    818 (0.0%)  	jb	.Lpwr_sp_alt
      .         	subq	%r11,%rbp
      .         	leaq	-320(%rbp,%r9,2),%rbp
      .         	jmp	.Lpwr_sp_done
      .         
      .         .align	32
      .         .Lpwr_sp_alt:
    818 (0.0%)  	leaq	4096-320(,%r9,2),%r10
    818 (0.0%)  	leaq	-320(%rbp,%r9,2),%rbp
    818 (0.0%)  	subq	%r10,%r11
    818 (0.0%)  	movq	$0,%r10
    818 (0.0%)  	cmovcq	%r10,%r11
    818 (0.0%)  	subq	%r11,%rbp
      .         .Lpwr_sp_done:
    818 (0.0%)  	andq	$-64,%rbp
    818 (0.0%)  	movq	%rsp,%r11
    818 (0.0%)  	subq	%rbp,%r11
    818 (0.0%)  	andq	$-4096,%r11
    818 (0.0%)  	leaq	(%r11,%rbp,1),%rsp
    818 (0.0%)  	movq	(%rsp),%r10
    818 (0.0%)  	cmpq	%rbp,%rsp
    818 (0.0%)  	ja	.Lpwr_page_walk
    818 (0.0%)  	jmp	.Lpwr_page_walk_done
      .         
      .         .Lpwr_page_walk:
      .         	leaq	-4096(%rsp),%rsp
      .         	movq	(%rsp),%r10
      .         	cmpq	%rbp,%rsp
      .         	ja	.Lpwr_page_walk
      .         .Lpwr_page_walk_done:
      .         
    818 (0.0%)  	movq	%r9,%r10
    818 (0.0%)  	negq	%r9
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
    818 (0.0%)  	movq	%r8,32(%rsp)
  4,090 (0.0%)  	movq	%rax,40(%rsp)
      .         .cfi_escape	0x0f,0x05,0x77,0x28,0x06,0x23,0x08
      .         .Lpower5_body:
      .         .byte	102,72,15,110,207
      .         .byte	102,72,15,110,209
      .         .byte	102,73,15,110,218
      .         .byte	102,72,15,110,226
      .         
    818 (0.0%)  	call	__bn_sqr8x_internal
    818 (0.0%)  	call	__bn_post4x_internal
    818 (0.0%)  	call	__bn_sqr8x_internal
    818 (0.0%)  	call	__bn_post4x_internal
    818 (0.0%)  	call	__bn_sqr8x_internal
    818 (0.0%)  	call	__bn_post4x_internal
    818 (0.0%)  	call	__bn_sqr8x_internal
    818 (0.0%)  	call	__bn_post4x_internal
    818 (0.0%)  	call	__bn_sqr8x_internal
  2,454 (0.0%)  	call	__bn_post4x_internal
      .         
      .         .byte	102,72,15,126,209
      .         .byte	102,72,15,126,226
    818 (0.0%)  	movq	%rsi,%rdi
    818 (0.0%)  	movq	40(%rsp),%rax
    818 (0.0%)  	leaq	32(%rsp),%r8
      .         
    818 (0.0%)  	call	mul4x_internal
      .         
    818 (0.0%)  	movq	40(%rsp),%rsi
      .         .cfi_def_cfa	%rsi,8
    818 (0.0%)  	movq	$1,%rax
    818 (0.0%)  	movq	-48(%rsi),%r15
      .         .cfi_restore	%r15
    818 (0.0%)  	movq	-40(%rsi),%r14
      .         .cfi_restore	%r14
    818 (0.0%)  	movq	-32(%rsi),%r13
      .         .cfi_restore	%r13
    818 (0.0%)  	movq	-24(%rsi),%r12
      .         .cfi_restore	%r12
    818 (0.0%)  	movq	-16(%rsi),%rbp
      .         .cfi_restore	%rbp
    818 (0.0%)  	movq	-8(%rsi),%rbx
      .         .cfi_restore	%rbx
  1,636 (0.0%)  	leaq	(%rsi),%rsp
      .         .cfi_def_cfa_register	%rsp
      .         .Lpower5_epilogue:
      .         	.byte	0xf3,0xc3
      .         .cfi_endproc	
      .         .size	bn_power5,.-bn_power5
      .         
      .         .globl	bn_sqr8x_internal
      .         .hidden bn_sqr8x_internal
-- line 1228 ----------------------------------------
-- line 1300 ----------------------------------------
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
  4,180 (0.0%)  	leaq	32(%r10),%rbp
  4,180 (0.0%)  	leaq	(%rsi,%r9,1),%rsi
      .         
  4,180 (0.0%)  	movq	%r9,%rcx
      .         
      .         
  4,180 (0.0%)  	movq	-32(%rsi,%rbp,1),%r14
  4,180 (0.0%)  	leaq	48+8(%rsp,%r9,2),%rdi
  4,180 (0.0%)  	movq	-24(%rsi,%rbp,1),%rax
  4,180 (0.0%)  	leaq	-32(%rdi,%rbp,1),%rdi
  4,180 (0.0%)  	movq	-16(%rsi,%rbp,1),%rbx
  4,180 (0.0%)  	movq	%rax,%r15
      .         
  4,180 (0.0%)  	mulq	%r14
  4,180 (0.0%)  	movq	%rax,%r10
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	movq	%rdx,%r11
  4,180 (0.0%)  	movq	%r10,-24(%rdi,%rbp,1)
      .         
  4,180 (0.0%)  	mulq	%r14
  4,180 (0.0%)  	addq	%rax,%r11
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	adcq	$0,%rdx
  4,180 (0.0%)  	movq	%r11,-16(%rdi,%rbp,1)
  4,180 (0.0%)  	movq	%rdx,%r10
      .         
      .         
  4,180 (0.0%)  	movq	-8(%rsi,%rbp,1),%rbx
  4,180 (0.0%)  	mulq	%r15
  4,180 (0.0%)  	movq	%rax,%r12
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	movq	%rdx,%r13
      .         
  4,180 (0.0%)  	leaq	(%rbp),%rcx
  4,180 (0.0%)  	mulq	%r14
  4,180 (0.0%)  	addq	%rax,%r10
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	movq	%rdx,%r11
  4,180 (0.0%)  	adcq	$0,%r11
  4,180 (0.0%)  	addq	%r12,%r10
  4,180 (0.0%)  	adcq	$0,%r11
  4,180 (0.0%)  	movq	%r10,-8(%rdi,%rcx,1)
  4,180 (0.0%)  	jmp	.Lsqr4x_1st
      .         
      .         .align	32
      .         .Lsqr4x_1st:
 29,644 (0.0%)  	movq	(%rsi,%rcx,1),%rbx
 29,644 (0.0%)  	mulq	%r15
 29,644 (0.0%)  	addq	%rax,%r13
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	%rdx,%r12
 29,644 (0.0%)  	adcq	$0,%r12
      .         
 29,644 (0.0%)  	mulq	%r14
 29,644 (0.0%)  	addq	%rax,%r11
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	8(%rsi,%rcx,1),%rbx
 29,644 (0.0%)  	movq	%rdx,%r10
 29,644 (0.0%)  	adcq	$0,%r10
 29,644 (0.0%)  	addq	%r13,%r11
 29,644 (0.0%)  	adcq	$0,%r10
      .         
      .         
 29,644 (0.0%)  	mulq	%r15
 29,644 (0.0%)  	addq	%rax,%r12
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	%r11,(%rdi,%rcx,1)
 29,644 (0.0%)  	movq	%rdx,%r13
 29,644 (0.0%)  	adcq	$0,%r13
      .         
 29,644 (0.0%)  	mulq	%r14
 29,644 (0.0%)  	addq	%rax,%r10
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	16(%rsi,%rcx,1),%rbx
 29,644 (0.0%)  	movq	%rdx,%r11
 29,644 (0.0%)  	adcq	$0,%r11
 29,644 (0.0%)  	addq	%r12,%r10
 29,644 (0.0%)  	adcq	$0,%r11
      .         
 29,644 (0.0%)  	mulq	%r15
 29,644 (0.0%)  	addq	%rax,%r13
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	%r10,8(%rdi,%rcx,1)
 29,644 (0.0%)  	movq	%rdx,%r12
 29,644 (0.0%)  	adcq	$0,%r12
      .         
 29,644 (0.0%)  	mulq	%r14
 29,644 (0.0%)  	addq	%rax,%r11
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	24(%rsi,%rcx,1),%rbx
 29,644 (0.0%)  	movq	%rdx,%r10
 29,644 (0.0%)  	adcq	$0,%r10
 29,644 (0.0%)  	addq	%r13,%r11
 29,644 (0.0%)  	adcq	$0,%r10
      .         
      .         
 29,644 (0.0%)  	mulq	%r15
 29,644 (0.0%)  	addq	%rax,%r12
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	%r11,16(%rdi,%rcx,1)
 29,644 (0.0%)  	movq	%rdx,%r13
 29,644 (0.0%)  	adcq	$0,%r13
 29,644 (0.0%)  	leaq	32(%rcx),%rcx
      .         
 29,644 (0.0%)  	mulq	%r14
 29,644 (0.0%)  	addq	%rax,%r10
 29,644 (0.0%)  	movq	%rbx,%rax
 29,644 (0.0%)  	movq	%rdx,%r11
 29,644 (0.0%)  	adcq	$0,%r11
 29,644 (0.0%)  	addq	%r12,%r10
 29,644 (0.0%)  	adcq	$0,%r11
 29,644 (0.0%)  	movq	%r10,-8(%rdi,%rcx,1)
      .         
 29,644 (0.0%)  	cmpq	$0,%rcx
 29,644 (0.0%)  	jne	.Lsqr4x_1st
      .         
  4,180 (0.0%)  	mulq	%r15
  4,180 (0.0%)  	addq	%rax,%r13
  4,180 (0.0%)  	leaq	16(%rbp),%rbp
  4,180 (0.0%)  	adcq	$0,%rdx
  4,180 (0.0%)  	addq	%r11,%r13
  4,180 (0.0%)  	adcq	$0,%rdx
      .         
  4,180 (0.0%)  	movq	%r13,(%rdi)
  4,180 (0.0%)  	movq	%rdx,%r12
  4,180 (0.0%)  	movq	%rdx,8(%rdi)
  4,180 (0.0%)  	jmp	.Lsqr4x_outer
      .         
      .         .align	32
      .         .Lsqr4x_outer:
 55,108 (0.0%)  	movq	-32(%rsi,%rbp,1),%r14
 55,108 (0.0%)  	leaq	48+8(%rsp,%r9,2),%rdi
 55,108 (0.0%)  	movq	-24(%rsi,%rbp,1),%rax
 55,108 (0.0%)  	leaq	-32(%rdi,%rbp,1),%rdi
 55,108 (0.0%)  	movq	-16(%rsi,%rbp,1),%rbx
 55,108 (0.0%)  	movq	%rax,%r15
      .         
 55,108 (0.0%)  	mulq	%r14
 55,108 (0.0%)  	movq	-24(%rdi,%rbp,1),%r10
 55,108 (0.0%)  	addq	%rax,%r10
 55,108 (0.0%)  	movq	%rbx,%rax
 55,108 (0.0%)  	adcq	$0,%rdx
 55,108 (0.0%)  	movq	%r10,-24(%rdi,%rbp,1)
 55,108 (0.0%)  	movq	%rdx,%r11
      .         
 55,108 (0.0%)  	mulq	%r14
 55,108 (0.0%)  	addq	%rax,%r11
 55,108 (0.0%)  	movq	%rbx,%rax
 55,108 (0.0%)  	adcq	$0,%rdx
 55,108 (0.0%)  	addq	-16(%rdi,%rbp,1),%r11
 55,108 (0.0%)  	movq	%rdx,%r10
 55,108 (0.0%)  	adcq	$0,%r10
 55,108 (0.0%)  	movq	%r11,-16(%rdi,%rbp,1)
      .         
 55,108 (0.0%)  	xorq	%r12,%r12
      .         
 55,108 (0.0%)  	movq	-8(%rsi,%rbp,1),%rbx
 55,108 (0.0%)  	mulq	%r15
 55,108 (0.0%)  	addq	%rax,%r12
 55,108 (0.0%)  	movq	%rbx,%rax
 55,108 (0.0%)  	adcq	$0,%rdx
 55,108 (0.0%)  	addq	-8(%rdi,%rbp,1),%r12
 55,108 (0.0%)  	movq	%rdx,%r13
 55,108 (0.0%)  	adcq	$0,%r13
      .         
 55,108 (0.0%)  	mulq	%r14
 55,108 (0.0%)  	addq	%rax,%r10
 55,108 (0.0%)  	movq	%rbx,%rax
 55,108 (0.0%)  	adcq	$0,%rdx
 55,108 (0.0%)  	addq	%r12,%r10
 55,108 (0.0%)  	movq	%rdx,%r11
 55,108 (0.0%)  	adcq	$0,%r11
 55,108 (0.0%)  	movq	%r10,-8(%rdi,%rbp,1)
      .         
 55,108 (0.0%)  	leaq	(%rbp),%rcx
 55,108 (0.0%)  	jmp	.Lsqr4x_inner
      .         
      .         .align	32
      .         .Lsqr4x_inner:
396,892 (0.1%)  	movq	(%rsi,%rcx,1),%rbx
396,892 (0.1%)  	mulq	%r15
396,892 (0.1%)  	addq	%rax,%r13
396,892 (0.1%)  	movq	%rbx,%rax
396,892 (0.1%)  	movq	%rdx,%r12
396,892 (0.1%)  	adcq	$0,%r12
396,892 (0.1%)  	addq	(%rdi,%rcx,1),%r13
793,784 (0.3%)  	adcq	$0,%r12
      .         
      .         .byte	0x67
      .         	mulq	%r14
396,892 (0.1%)  	addq	%rax,%r11
396,892 (0.1%)  	movq	%rbx,%rax
396,892 (0.1%)  	movq	8(%rsi,%rcx,1),%rbx
396,892 (0.1%)  	movq	%rdx,%r10
396,892 (0.1%)  	adcq	$0,%r10
396,892 (0.1%)  	addq	%r13,%r11
396,892 (0.1%)  	adcq	$0,%r10
      .         
396,892 (0.1%)  	mulq	%r15
396,892 (0.1%)  	addq	%rax,%r12
396,892 (0.1%)  	movq	%r11,(%rdi,%rcx,1)
396,892 (0.1%)  	movq	%rbx,%rax
396,892 (0.1%)  	movq	%rdx,%r13
396,892 (0.1%)  	adcq	$0,%r13
396,892 (0.1%)  	addq	8(%rdi,%rcx,1),%r12
396,892 (0.1%)  	leaq	16(%rcx),%rcx
396,892 (0.1%)  	adcq	$0,%r13
      .         
396,892 (0.1%)  	mulq	%r14
396,892 (0.1%)  	addq	%rax,%r10
396,892 (0.1%)  	movq	%rbx,%rax
396,892 (0.1%)  	adcq	$0,%rdx
396,892 (0.1%)  	addq	%r12,%r10
396,892 (0.1%)  	movq	%rdx,%r11
396,892 (0.1%)  	adcq	$0,%r11
396,892 (0.1%)  	movq	%r10,-8(%rdi,%rcx,1)
      .         
396,892 (0.1%)  	cmpq	$0,%rcx
452,000 (0.1%)  	jne	.Lsqr4x_inner
      .         
      .         .byte	0x67
      .         	mulq	%r15
 55,108 (0.0%)  	addq	%rax,%r13
 55,108 (0.0%)  	adcq	$0,%rdx
 55,108 (0.0%)  	addq	%r11,%r13
 55,108 (0.0%)  	adcq	$0,%rdx
      .         
 55,108 (0.0%)  	movq	%r13,(%rdi)
 55,108 (0.0%)  	movq	%rdx,%r12
 55,108 (0.0%)  	movq	%rdx,8(%rdi)
      .         
 55,108 (0.0%)  	addq	$16,%rbp
 55,108 (0.0%)  	jnz	.Lsqr4x_outer
      .         
      .         
  4,180 (0.0%)  	movq	-32(%rsi),%r14
  4,180 (0.0%)  	leaq	48+8(%rsp,%r9,2),%rdi
  4,180 (0.0%)  	movq	-24(%rsi),%rax
  4,180 (0.0%)  	leaq	-32(%rdi,%rbp,1),%rdi
  4,180 (0.0%)  	movq	-16(%rsi),%rbx
  4,180 (0.0%)  	movq	%rax,%r15
      .         
  4,180 (0.0%)  	mulq	%r14
  4,180 (0.0%)  	addq	%rax,%r10
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	movq	%rdx,%r11
  4,180 (0.0%)  	adcq	$0,%r11
      .         
  4,180 (0.0%)  	mulq	%r14
  4,180 (0.0%)  	addq	%rax,%r11
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	movq	%r10,-24(%rdi)
  4,180 (0.0%)  	movq	%rdx,%r10
  4,180 (0.0%)  	adcq	$0,%r10
  4,180 (0.0%)  	addq	%r13,%r11
  4,180 (0.0%)  	movq	-8(%rsi),%rbx
  4,180 (0.0%)  	adcq	$0,%r10
      .         
  4,180 (0.0%)  	mulq	%r15
  4,180 (0.0%)  	addq	%rax,%r12
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	movq	%r11,-16(%rdi)
  4,180 (0.0%)  	movq	%rdx,%r13
  4,180 (0.0%)  	adcq	$0,%r13
      .         
  4,180 (0.0%)  	mulq	%r14
  4,180 (0.0%)  	addq	%rax,%r10
  4,180 (0.0%)  	movq	%rbx,%rax
  4,180 (0.0%)  	movq	%rdx,%r11
  4,180 (0.0%)  	adcq	$0,%r11
  4,180 (0.0%)  	addq	%r12,%r10
  4,180 (0.0%)  	adcq	$0,%r11
  4,180 (0.0%)  	movq	%r10,-8(%rdi)
      .         
  4,180 (0.0%)  	mulq	%r15
  4,180 (0.0%)  	addq	%rax,%r13
  4,180 (0.0%)  	movq	-16(%rsi),%rax
  4,180 (0.0%)  	adcq	$0,%rdx
  4,180 (0.0%)  	addq	%r11,%r13
  4,180 (0.0%)  	adcq	$0,%rdx
      .         
  4,180 (0.0%)  	movq	%r13,(%rdi)
  4,180 (0.0%)  	movq	%rdx,%r12
  4,180 (0.0%)  	movq	%rdx,8(%rdi)
      .         
  4,180 (0.0%)  	mulq	%rbx
  4,180 (0.0%)  	addq	$16,%rbp
  4,180 (0.0%)  	xorq	%r14,%r14
  4,180 (0.0%)  	subq	%r9,%rbp
  4,180 (0.0%)  	xorq	%r15,%r15
      .         
  4,180 (0.0%)  	addq	%r12,%rax
  4,180 (0.0%)  	adcq	$0,%rdx
  4,180 (0.0%)  	movq	%rax,8(%rdi)
  4,180 (0.0%)  	movq	%rdx,16(%rdi)
  4,180 (0.0%)  	movq	%r15,24(%rdi)
      .         
  4,180 (0.0%)  	movq	-16(%rsi,%rbp,1),%rax
  4,180 (0.0%)  	leaq	48+8(%rsp),%rdi
  4,180 (0.0%)  	xorq	%r10,%r10
  4,180 (0.0%)  	movq	8(%rdi),%r11
      .         
  4,180 (0.0%)  	leaq	(%r14,%r10,2),%r12
  4,180 (0.0%)  	shrq	$63,%r10
  4,180 (0.0%)  	leaq	(%rcx,%r11,2),%r13
  4,180 (0.0%)  	shrq	$63,%r11
  4,180 (0.0%)  	orq	%r10,%r13
  4,180 (0.0%)  	movq	16(%rdi),%r10
  4,180 (0.0%)  	movq	%r11,%r14
  4,180 (0.0%)  	mulq	%rax
  4,180 (0.0%)  	negq	%r15
  4,180 (0.0%)  	movq	24(%rdi),%r11
  4,180 (0.0%)  	adcq	%rax,%r12
  4,180 (0.0%)  	movq	-8(%rsi,%rbp,1),%rax
  4,180 (0.0%)  	movq	%r12,(%rdi)
  4,180 (0.0%)  	adcq	%rdx,%r13
      .         
  4,180 (0.0%)  	leaq	(%r14,%r10,2),%rbx
  4,180 (0.0%)  	movq	%r13,8(%rdi)
  4,180 (0.0%)  	sbbq	%r15,%r15
  4,180 (0.0%)  	shrq	$63,%r10
  4,180 (0.0%)  	leaq	(%rcx,%r11,2),%r8
  4,180 (0.0%)  	shrq	$63,%r11
  4,180 (0.0%)  	orq	%r10,%r8
  4,180 (0.0%)  	movq	32(%rdi),%r10
  4,180 (0.0%)  	movq	%r11,%r14
  4,180 (0.0%)  	mulq	%rax
  4,180 (0.0%)  	negq	%r15
  4,180 (0.0%)  	movq	40(%rdi),%r11
  4,180 (0.0%)  	adcq	%rax,%rbx
  4,180 (0.0%)  	movq	0(%rsi,%rbp,1),%rax
  4,180 (0.0%)  	movq	%rbx,16(%rdi)
  4,180 (0.0%)  	adcq	%rdx,%r8
  4,180 (0.0%)  	leaq	16(%rbp),%rbp
  4,180 (0.0%)  	movq	%r8,24(%rdi)
  4,180 (0.0%)  	sbbq	%r15,%r15
  4,180 (0.0%)  	leaq	64(%rdi),%rdi
  4,180 (0.0%)  	jmp	.Lsqr4x_shift_n_add
      .         
      .         .align	32
      .         .Lsqr4x_shift_n_add:
 29,644 (0.0%)  	leaq	(%r14,%r10,2),%r12
 29,644 (0.0%)  	shrq	$63,%r10
 29,644 (0.0%)  	leaq	(%rcx,%r11,2),%r13
 29,644 (0.0%)  	shrq	$63,%r11
 29,644 (0.0%)  	orq	%r10,%r13
 29,644 (0.0%)  	movq	-16(%rdi),%r10
 29,644 (0.0%)  	movq	%r11,%r14
 29,644 (0.0%)  	mulq	%rax
 29,644 (0.0%)  	negq	%r15
 29,644 (0.0%)  	movq	-8(%rdi),%r11
 29,644 (0.0%)  	adcq	%rax,%r12
 29,644 (0.0%)  	movq	-8(%rsi,%rbp,1),%rax
 29,644 (0.0%)  	movq	%r12,-32(%rdi)
 29,644 (0.0%)  	adcq	%rdx,%r13
      .         
 29,644 (0.0%)  	leaq	(%r14,%r10,2),%rbx
 29,644 (0.0%)  	movq	%r13,-24(%rdi)
 29,644 (0.0%)  	sbbq	%r15,%r15
 29,644 (0.0%)  	shrq	$63,%r10
 29,644 (0.0%)  	leaq	(%rcx,%r11,2),%r8
 29,644 (0.0%)  	shrq	$63,%r11
 29,644 (0.0%)  	orq	%r10,%r8
 29,644 (0.0%)  	movq	0(%rdi),%r10
 29,644 (0.0%)  	movq	%r11,%r14
 29,644 (0.0%)  	mulq	%rax
 29,644 (0.0%)  	negq	%r15
 29,644 (0.0%)  	movq	8(%rdi),%r11
 29,644 (0.0%)  	adcq	%rax,%rbx
 29,644 (0.0%)  	movq	0(%rsi,%rbp,1),%rax
 29,644 (0.0%)  	movq	%rbx,-16(%rdi)
 29,644 (0.0%)  	adcq	%rdx,%r8
      .         
 29,644 (0.0%)  	leaq	(%r14,%r10,2),%r12
 29,644 (0.0%)  	movq	%r8,-8(%rdi)
 29,644 (0.0%)  	sbbq	%r15,%r15
 29,644 (0.0%)  	shrq	$63,%r10
 29,644 (0.0%)  	leaq	(%rcx,%r11,2),%r13
 29,644 (0.0%)  	shrq	$63,%r11
 29,644 (0.0%)  	orq	%r10,%r13
 29,644 (0.0%)  	movq	16(%rdi),%r10
 29,644 (0.0%)  	movq	%r11,%r14
 29,644 (0.0%)  	mulq	%rax
 29,644 (0.0%)  	negq	%r15
 29,644 (0.0%)  	movq	24(%rdi),%r11
 29,644 (0.0%)  	adcq	%rax,%r12
 29,644 (0.0%)  	movq	8(%rsi,%rbp,1),%rax
 29,644 (0.0%)  	movq	%r12,0(%rdi)
 29,644 (0.0%)  	adcq	%rdx,%r13
      .         
 29,644 (0.0%)  	leaq	(%r14,%r10,2),%rbx
 29,644 (0.0%)  	movq	%r13,8(%rdi)
 29,644 (0.0%)  	sbbq	%r15,%r15
 29,644 (0.0%)  	shrq	$63,%r10
 29,644 (0.0%)  	leaq	(%rcx,%r11,2),%r8
 29,644 (0.0%)  	shrq	$63,%r11
 29,644 (0.0%)  	orq	%r10,%r8
 29,644 (0.0%)  	movq	32(%rdi),%r10
 29,644 (0.0%)  	movq	%r11,%r14
 29,644 (0.0%)  	mulq	%rax
 29,644 (0.0%)  	negq	%r15
 29,644 (0.0%)  	movq	40(%rdi),%r11
 29,644 (0.0%)  	adcq	%rax,%rbx
 29,644 (0.0%)  	movq	16(%rsi,%rbp,1),%rax
 29,644 (0.0%)  	movq	%rbx,16(%rdi)
 29,644 (0.0%)  	adcq	%rdx,%r8
 29,644 (0.0%)  	movq	%r8,24(%rdi)
 29,644 (0.0%)  	sbbq	%r15,%r15
 29,644 (0.0%)  	leaq	64(%rdi),%rdi
 29,644 (0.0%)  	addq	$32,%rbp
 29,644 (0.0%)  	jnz	.Lsqr4x_shift_n_add
      .         
  8,360 (0.0%)  	leaq	(%r14,%r10,2),%r12
      .         .byte	0x67
      .         	shrq	$63,%r10
  4,180 (0.0%)  	leaq	(%rcx,%r11,2),%r13
  4,180 (0.0%)  	shrq	$63,%r11
  4,180 (0.0%)  	orq	%r10,%r13
  4,180 (0.0%)  	movq	-16(%rdi),%r10
  4,180 (0.0%)  	movq	%r11,%r14
  4,180 (0.0%)  	mulq	%rax
  4,180 (0.0%)  	negq	%r15
  4,180 (0.0%)  	movq	-8(%rdi),%r11
  4,180 (0.0%)  	adcq	%rax,%r12
  4,180 (0.0%)  	movq	-8(%rsi),%rax
  4,180 (0.0%)  	movq	%r12,-32(%rdi)
  4,180 (0.0%)  	adcq	%rdx,%r13
      .         
  4,180 (0.0%)  	leaq	(%r14,%r10,2),%rbx
  4,180 (0.0%)  	movq	%r13,-24(%rdi)
  4,180 (0.0%)  	sbbq	%r15,%r15
  4,180 (0.0%)  	shrq	$63,%r10
  4,180 (0.0%)  	leaq	(%rcx,%r11,2),%r8
  4,180 (0.0%)  	shrq	$63,%r11
  4,180 (0.0%)  	orq	%r10,%r8
  4,180 (0.0%)  	mulq	%rax
  4,180 (0.0%)  	negq	%r15
  4,180 (0.0%)  	adcq	%rax,%rbx
  4,180 (0.0%)  	adcq	%rdx,%r8
  4,180 (0.0%)  	movq	%rbx,-16(%rdi)
  8,360 (0.0%)  	movq	%r8,-8(%rdi)
      .         .byte	102,72,15,126,213
      .         __bn_sqr8x_reduction:
  4,180 (0.0%)  	xorq	%rax,%rax
  4,180 (0.0%)  	leaq	(%r9,%rbp,1),%rcx
  4,180 (0.0%)  	leaq	48+8(%rsp,%r9,2),%rdx
  4,180 (0.0%)  	movq	%rcx,0+8(%rsp)
  4,180 (0.0%)  	leaq	48+8(%rsp,%r9,1),%rdi
  4,180 (0.0%)  	movq	%rdx,8+8(%rsp)
  4,180 (0.0%)  	negq	%r9
  4,180 (0.0%)  	jmp	.L8x_reduction_loop
      .         
      .         .align	32
      .         .L8x_reduction_loop:
 33,824 (0.0%)  	leaq	(%rdi,%r9,1),%rdi
      .         .byte	0x66
      .         	movq	0(%rdi),%rbx
 16,912 (0.0%)  	movq	8(%rdi),%r9
 16,912 (0.0%)  	movq	16(%rdi),%r10
 16,912 (0.0%)  	movq	24(%rdi),%r11
 16,912 (0.0%)  	movq	32(%rdi),%r12
 16,912 (0.0%)  	movq	40(%rdi),%r13
 16,912 (0.0%)  	movq	48(%rdi),%r14
 16,912 (0.0%)  	movq	56(%rdi),%r15
 16,912 (0.0%)  	movq	%rax,(%rdx)
 33,824 (0.0%)  	leaq	64(%rdi),%rdi
      .         
      .         .byte	0x67
      .         	movq	%rbx,%r8
 16,912 (0.0%)  	imulq	32+8(%rsp),%rbx
 16,912 (0.0%)  	movq	0(%rbp),%rax
 16,912 (0.0%)  	movl	$8,%ecx
 16,912 (0.0%)  	jmp	.L8x_reduce
      .         
      .         .align	32
      .         .L8x_reduce:
135,296 (0.0%)  	mulq	%rbx
135,296 (0.0%)  	movq	8(%rbp),%rax
135,296 (0.0%)  	negq	%r8
135,296 (0.0%)  	movq	%rdx,%r8
135,296 (0.0%)  	adcq	$0,%r8
      .         
135,296 (0.0%)  	mulq	%rbx
135,296 (0.0%)  	addq	%rax,%r9
135,296 (0.0%)  	movq	16(%rbp),%rax
135,296 (0.0%)  	adcq	$0,%rdx
135,296 (0.0%)  	addq	%r9,%r8
135,296 (0.0%)  	movq	%rbx,48-8+8(%rsp,%rcx,8)
135,296 (0.0%)  	movq	%rdx,%r9
135,296 (0.0%)  	adcq	$0,%r9
      .         
135,296 (0.0%)  	mulq	%rbx
135,296 (0.0%)  	addq	%rax,%r10
135,296 (0.0%)  	movq	24(%rbp),%rax
135,296 (0.0%)  	adcq	$0,%rdx
135,296 (0.0%)  	addq	%r10,%r9
135,296 (0.0%)  	movq	32+8(%rsp),%rsi
135,296 (0.0%)  	movq	%rdx,%r10
135,296 (0.0%)  	adcq	$0,%r10
      .         
135,296 (0.0%)  	mulq	%rbx
135,296 (0.0%)  	addq	%rax,%r11
135,296 (0.0%)  	movq	32(%rbp),%rax
135,296 (0.0%)  	adcq	$0,%rdx
135,296 (0.0%)  	imulq	%r8,%rsi
135,296 (0.0%)  	addq	%r11,%r10
135,296 (0.0%)  	movq	%rdx,%r11
135,296 (0.0%)  	adcq	$0,%r11
      .         
135,296 (0.0%)  	mulq	%rbx
135,296 (0.0%)  	addq	%rax,%r12
135,296 (0.0%)  	movq	40(%rbp),%rax
135,296 (0.0%)  	adcq	$0,%rdx
135,296 (0.0%)  	addq	%r12,%r11
135,296 (0.0%)  	movq	%rdx,%r12
135,296 (0.0%)  	adcq	$0,%r12
      .         
135,296 (0.0%)  	mulq	%rbx
135,296 (0.0%)  	addq	%rax,%r13
135,296 (0.0%)  	movq	48(%rbp),%rax
135,296 (0.0%)  	adcq	$0,%rdx
135,296 (0.0%)  	addq	%r13,%r12
135,296 (0.0%)  	movq	%rdx,%r13
135,296 (0.0%)  	adcq	$0,%r13
      .         
135,296 (0.0%)  	mulq	%rbx
135,296 (0.0%)  	addq	%rax,%r14
135,296 (0.0%)  	movq	56(%rbp),%rax
135,296 (0.0%)  	adcq	$0,%rdx
135,296 (0.0%)  	addq	%r14,%r13
135,296 (0.0%)  	movq	%rdx,%r14
135,296 (0.0%)  	adcq	$0,%r14
      .         
135,296 (0.0%)  	mulq	%rbx
135,296 (0.0%)  	movq	%rsi,%rbx
135,296 (0.0%)  	addq	%rax,%r15
135,296 (0.0%)  	movq	0(%rbp),%rax
135,296 (0.0%)  	adcq	$0,%rdx
135,296 (0.0%)  	addq	%r15,%r14
135,296 (0.0%)  	movq	%rdx,%r15
135,296 (0.0%)  	adcq	$0,%r15
      .         
135,296 (0.0%)  	decl	%ecx
135,296 (0.0%)  	jnz	.L8x_reduce
      .         
 16,912 (0.0%)  	leaq	64(%rbp),%rbp
 16,912 (0.0%)  	xorq	%rax,%rax
 16,912 (0.0%)  	movq	8+8(%rsp),%rdx
 16,912 (0.0%)  	cmpq	0+8(%rsp),%rbp
 33,824 (0.0%)  	jae	.L8x_no_tail
      .         
      .         .byte	0x66
      .         	addq	0(%rdi),%r8
 16,912 (0.0%)  	adcq	8(%rdi),%r9
 16,912 (0.0%)  	adcq	16(%rdi),%r10
 16,912 (0.0%)  	adcq	24(%rdi),%r11
 16,912 (0.0%)  	adcq	32(%rdi),%r12
 16,912 (0.0%)  	adcq	40(%rdi),%r13
 16,912 (0.0%)  	adcq	48(%rdi),%r14
 16,912 (0.0%)  	adcq	56(%rdi),%r15
 16,912 (0.0%)  	sbbq	%rsi,%rsi
      .         
 16,912 (0.0%)  	movq	48+56+8(%rsp),%rbx
 16,912 (0.0%)  	movl	$8,%ecx
 16,912 (0.0%)  	movq	0(%rbp),%rax
 16,912 (0.0%)  	jmp	.L8x_tail
      .         
      .         .align	32
      .         .L8x_tail:
418,176 (0.1%)  	mulq	%rbx
418,176 (0.1%)  	addq	%rax,%r8
418,176 (0.1%)  	movq	8(%rbp),%rax
418,176 (0.1%)  	movq	%r8,(%rdi)
418,176 (0.1%)  	movq	%rdx,%r8
418,176 (0.1%)  	adcq	$0,%r8
      .         
418,176 (0.1%)  	mulq	%rbx
418,176 (0.1%)  	addq	%rax,%r9
418,176 (0.1%)  	movq	16(%rbp),%rax
418,176 (0.1%)  	adcq	$0,%rdx
418,176 (0.1%)  	addq	%r9,%r8
418,176 (0.1%)  	leaq	8(%rdi),%rdi
418,176 (0.1%)  	movq	%rdx,%r9
418,176 (0.1%)  	adcq	$0,%r9
      .         
418,176 (0.1%)  	mulq	%rbx
418,176 (0.1%)  	addq	%rax,%r10
418,176 (0.1%)  	movq	24(%rbp),%rax
418,176 (0.1%)  	adcq	$0,%rdx
418,176 (0.1%)  	addq	%r10,%r9
418,176 (0.1%)  	movq	%rdx,%r10
418,176 (0.1%)  	adcq	$0,%r10
      .         
418,176 (0.1%)  	mulq	%rbx
418,176 (0.1%)  	addq	%rax,%r11
418,176 (0.1%)  	movq	32(%rbp),%rax
418,176 (0.1%)  	adcq	$0,%rdx
418,176 (0.1%)  	addq	%r11,%r10
418,176 (0.1%)  	movq	%rdx,%r11
418,176 (0.1%)  	adcq	$0,%r11
      .         
418,176 (0.1%)  	mulq	%rbx
418,176 (0.1%)  	addq	%rax,%r12
418,176 (0.1%)  	movq	40(%rbp),%rax
418,176 (0.1%)  	adcq	$0,%rdx
418,176 (0.1%)  	addq	%r12,%r11
418,176 (0.1%)  	movq	%rdx,%r12
418,176 (0.1%)  	adcq	$0,%r12
      .         
418,176 (0.1%)  	mulq	%rbx
418,176 (0.1%)  	addq	%rax,%r13
418,176 (0.1%)  	movq	48(%rbp),%rax
418,176 (0.1%)  	adcq	$0,%rdx
418,176 (0.1%)  	addq	%r13,%r12
418,176 (0.1%)  	movq	%rdx,%r13
418,176 (0.1%)  	adcq	$0,%r13
      .         
418,176 (0.1%)  	mulq	%rbx
418,176 (0.1%)  	addq	%rax,%r14
418,176 (0.1%)  	movq	56(%rbp),%rax
418,176 (0.1%)  	adcq	$0,%rdx
418,176 (0.1%)  	addq	%r14,%r13
418,176 (0.1%)  	movq	%rdx,%r14
418,176 (0.1%)  	adcq	$0,%r14
      .         
418,176 (0.1%)  	mulq	%rbx
418,176 (0.1%)  	movq	48-16+8(%rsp,%rcx,8),%rbx
418,176 (0.1%)  	addq	%rax,%r15
418,176 (0.1%)  	adcq	$0,%rdx
418,176 (0.1%)  	addq	%r15,%r14
418,176 (0.1%)  	movq	0(%rbp),%rax
418,176 (0.1%)  	movq	%rdx,%r15
418,176 (0.1%)  	adcq	$0,%r15
      .         
418,176 (0.1%)  	decl	%ecx
418,176 (0.1%)  	jnz	.L8x_tail
      .         
 52,272 (0.0%)  	leaq	64(%rbp),%rbp
 52,272 (0.0%)  	movq	8+8(%rsp),%rdx
 52,272 (0.0%)  	cmpq	0+8(%rsp),%rbp
 52,272 (0.0%)  	jae	.L8x_tail_done
      .         
 35,360 (0.0%)  	movq	48+56+8(%rsp),%rbx
 35,360 (0.0%)  	negq	%rsi
 35,360 (0.0%)  	movq	0(%rbp),%rax
 35,360 (0.0%)  	adcq	0(%rdi),%r8
 35,360 (0.0%)  	adcq	8(%rdi),%r9
 35,360 (0.0%)  	adcq	16(%rdi),%r10
 35,360 (0.0%)  	adcq	24(%rdi),%r11
 35,360 (0.0%)  	adcq	32(%rdi),%r12
 35,360 (0.0%)  	adcq	40(%rdi),%r13
 35,360 (0.0%)  	adcq	48(%rdi),%r14
 35,360 (0.0%)  	adcq	56(%rdi),%r15
 35,360 (0.0%)  	sbbq	%rsi,%rsi
      .         
 35,360 (0.0%)  	movl	$8,%ecx
 35,360 (0.0%)  	jmp	.L8x_tail
      .         
      .         .align	32
      .         .L8x_tail_done:
 16,912 (0.0%)  	xorq	%rax,%rax
 16,912 (0.0%)  	addq	(%rdx),%r8
 16,912 (0.0%)  	adcq	$0,%r9
 16,912 (0.0%)  	adcq	$0,%r10
 16,912 (0.0%)  	adcq	$0,%r11
 16,912 (0.0%)  	adcq	$0,%r12
 16,912 (0.0%)  	adcq	$0,%r13
 16,912 (0.0%)  	adcq	$0,%r14
 16,912 (0.0%)  	adcq	$0,%r15
 16,912 (0.0%)  	adcq	$0,%rax
      .         
 16,912 (0.0%)  	negq	%rsi
      .         .L8x_no_tail:
 16,912 (0.0%)  	adcq	0(%rdi),%r8
 16,912 (0.0%)  	adcq	8(%rdi),%r9
 16,912 (0.0%)  	adcq	16(%rdi),%r10
 16,912 (0.0%)  	adcq	24(%rdi),%r11
 16,912 (0.0%)  	adcq	32(%rdi),%r12
 16,912 (0.0%)  	adcq	40(%rdi),%r13
 16,912 (0.0%)  	adcq	48(%rdi),%r14
 16,912 (0.0%)  	adcq	56(%rdi),%r15
 16,912 (0.0%)  	adcq	$0,%rax
 16,912 (0.0%)  	movq	-8(%rbp),%rcx
 33,824 (0.0%)  	xorq	%rsi,%rsi
      .         
      .         .byte	102,72,15,126,213
      .         
 16,912 (0.0%)  	movq	%r8,0(%rdi)
 33,824 (0.0%)  	movq	%r9,8(%rdi)
      .         .byte	102,73,15,126,217
 16,912 (0.0%)  	movq	%r10,16(%rdi)
 16,912 (0.0%)  	movq	%r11,24(%rdi)
 16,912 (0.0%)  	movq	%r12,32(%rdi)
 16,912 (0.0%)  	movq	%r13,40(%rdi)
 16,912 (0.0%)  	movq	%r14,48(%rdi)
 16,912 (0.0%)  	movq	%r15,56(%rdi)
 16,912 (0.0%)  	leaq	64(%rdi),%rdi
      .         
 16,912 (0.0%)  	cmpq	%rdx,%rdi
 21,092 (0.0%)  	jb	.L8x_reduction_loop
      .         	.byte	0xf3,0xc3
      .         .cfi_endproc	
      .         .size	bn_sqr8x_internal,.-bn_sqr8x_internal
      .         .type	__bn_post4x_internal,@function
      .         .align	32
      .         __bn_post4x_internal:
      .         .cfi_startproc	
  4,090 (0.0%)  	movq	0(%rbp),%r12
  4,090 (0.0%)  	leaq	(%rdi,%r9,1),%rbx
  8,180 (0.0%)  	movq	%r9,%rcx
      .         .byte	102,72,15,126,207
  8,180 (0.0%)  	negq	%rax
      .         .byte	102,72,15,126,206
  4,090 (0.0%)  	sarq	$3+2,%rcx
  4,090 (0.0%)  	decq	%r12
  4,090 (0.0%)  	xorq	%r10,%r10
  4,090 (0.0%)  	movq	8(%rbp),%r13
  4,090 (0.0%)  	movq	16(%rbp),%r14
  4,090 (0.0%)  	movq	24(%rbp),%r15
  4,090 (0.0%)  	jmp	.Lsqr4x_sub_entry
      .         
      .         .align	16
      .         .Lsqr4x_sub:
 34,566 (0.0%)  	movq	0(%rbp),%r12
 34,566 (0.0%)  	movq	8(%rbp),%r13
 34,566 (0.0%)  	movq	16(%rbp),%r14
 34,566 (0.0%)  	movq	24(%rbp),%r15
      .         .Lsqr4x_sub_entry:
 39,504 (0.0%)  	leaq	32(%rbp),%rbp
 39,504 (0.0%)  	notq	%r12
 39,504 (0.0%)  	notq	%r13
 39,504 (0.0%)  	notq	%r14
 39,504 (0.0%)  	notq	%r15
 39,504 (0.0%)  	andq	%rax,%r12
 39,504 (0.0%)  	andq	%rax,%r13
 39,504 (0.0%)  	andq	%rax,%r14
 39,504 (0.0%)  	andq	%rax,%r15
      .         
 39,504 (0.0%)  	negq	%r10
 39,504 (0.0%)  	adcq	0(%rbx),%r12
 39,504 (0.0%)  	adcq	8(%rbx),%r13
 39,504 (0.0%)  	adcq	16(%rbx),%r14
 39,504 (0.0%)  	adcq	24(%rbx),%r15
 39,504 (0.0%)  	movq	%r12,0(%rdi)
 39,504 (0.0%)  	leaq	32(%rbx),%rbx
 39,504 (0.0%)  	movq	%r13,8(%rdi)
 39,504 (0.0%)  	sbbq	%r10,%r10
 39,504 (0.0%)  	movq	%r14,16(%rdi)
 39,504 (0.0%)  	movq	%r15,24(%rdi)
 39,504 (0.0%)  	leaq	32(%rdi),%rdi
      .         
 39,504 (0.0%)  	incq	%rcx
 39,504 (0.0%)  	jnz	.Lsqr4x_sub
      .         
  4,938 (0.0%)  	movq	%r9,%r10
  9,876 (0.0%)  	negq	%r9
      .         	.byte	0xf3,0xc3
      .         .cfi_endproc	
      .         .size	__bn_post4x_internal,.-__bn_post4x_internal
      .         .type	bn_mulx4x_mont_gather5,@function
      .         .align	32
      .         bn_mulx4x_mont_gather5:
      .         .cfi_startproc	
      .         	movq	%rsp,%rax
-- line 2071 ----------------------------------------
-- line 3411 ----------------------------------------
      .         .cfi_endproc	
      .         .size	__bn_postx4x_internal,.-__bn_postx4x_internal
      .         .globl	bn_scatter5
      .         .hidden bn_scatter5
      .         .type	bn_scatter5,@function
      .         .align	16
      .         bn_scatter5:
      .         .cfi_startproc	
     64 (0.0%)  	cmpl	$0,%esi
     64 (0.0%)  	jz	.Lscatter_epilogue
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
      .         
     64 (0.0%)  	leaq	(%rdx,%rcx,8),%rdx
      .         .Lscatter:
  2,048 (0.0%)  	movq	(%rdi),%rax
  2,048 (0.0%)  	leaq	8(%rdi),%rdi
  2,048 (0.0%)  	movq	%rax,(%rdx)
  2,048 (0.0%)  	leaq	256(%rdx),%rdx
  2,048 (0.0%)  	subl	$1,%esi
  2,116 (0.0%)  	jnz	.Lscatter
      .         .Lscatter_epilogue:
      .         	.byte	0xf3,0xc3
      .         .cfi_endproc	
      .         .size	bn_scatter5,.-bn_scatter5
      .         
      .         .globl	bn_gather5
      .         .hidden bn_gather5
      .         .type	bn_gather5,@function
-- line 3445 ----------------------------------------
-- line 3446 ----------------------------------------
      .         .align	32
      .         bn_gather5:
      .         .cfi_startproc	
      .         .LSEH_begin_bn_gather5:
      .         
      .         .byte	0x4c,0x8d,0x14,0x24
      .         .cfi_def_cfa_register	%r10
      .         .byte	0x48,0x81,0xec,0x08,0x01,0x00,0x00
      2 (0.0%)  	leaq	.Linc(%rip),%rax
      2 (0.0%)  	andq	$-16,%rsp
      .         
      2 (0.0%)  	movd	%ecx,%xmm5
      2 (0.0%)  	movdqa	0(%rax),%xmm0
      2 (0.0%)  	movdqa	16(%rax),%xmm1
      2 (0.0%)  	leaq	128(%rdx),%r11
      2 (0.0%)  	leaq	128(%rsp),%rax
      .         
      2 (0.0%)  	pshufd	$0,%xmm5,%xmm5
      2 (0.0%)  	movdqa	%xmm1,%xmm4
      2 (0.0%)  	movdqa	%xmm1,%xmm2
      2 (0.0%)  	paddd	%xmm0,%xmm1
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm0
      2 (0.0%)  	movdqa	%xmm4,%xmm3
      .         
      2 (0.0%)  	paddd	%xmm1,%xmm2
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm1
      2 (0.0%)  	movdqa	%xmm0,-128(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm0
      .         
      2 (0.0%)  	paddd	%xmm2,%xmm3
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm2
      2 (0.0%)  	movdqa	%xmm1,-112(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm1
      .         
      2 (0.0%)  	paddd	%xmm3,%xmm0
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm3
      2 (0.0%)  	movdqa	%xmm2,-96(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm2
      2 (0.0%)  	paddd	%xmm0,%xmm1
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm0
      2 (0.0%)  	movdqa	%xmm3,-80(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm3
      .         
      2 (0.0%)  	paddd	%xmm1,%xmm2
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm1
      2 (0.0%)  	movdqa	%xmm0,-64(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm0
      .         
      2 (0.0%)  	paddd	%xmm2,%xmm3
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm2
      2 (0.0%)  	movdqa	%xmm1,-48(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm1
      .         
      2 (0.0%)  	paddd	%xmm3,%xmm0
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm3
      2 (0.0%)  	movdqa	%xmm2,-32(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm2
      2 (0.0%)  	paddd	%xmm0,%xmm1
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm0
      2 (0.0%)  	movdqa	%xmm3,-16(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm3
      .         
      2 (0.0%)  	paddd	%xmm1,%xmm2
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm1
      2 (0.0%)  	movdqa	%xmm0,0(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm0
      .         
      2 (0.0%)  	paddd	%xmm2,%xmm3
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm2
      2 (0.0%)  	movdqa	%xmm1,16(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm1
      .         
      2 (0.0%)  	paddd	%xmm3,%xmm0
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm3
      2 (0.0%)  	movdqa	%xmm2,32(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm2
      2 (0.0%)  	paddd	%xmm0,%xmm1
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm0
      2 (0.0%)  	movdqa	%xmm3,48(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm3
      .         
      2 (0.0%)  	paddd	%xmm1,%xmm2
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm1
      2 (0.0%)  	movdqa	%xmm0,64(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm0
      .         
      2 (0.0%)  	paddd	%xmm2,%xmm3
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm2
      2 (0.0%)  	movdqa	%xmm1,80(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm1
      .         
      2 (0.0%)  	paddd	%xmm3,%xmm0
      2 (0.0%)  	pcmpeqd	%xmm5,%xmm3
      2 (0.0%)  	movdqa	%xmm2,96(%rax)
      2 (0.0%)  	movdqa	%xmm4,%xmm2
      2 (0.0%)  	movdqa	%xmm3,112(%rax)
      2 (0.0%)  	jmp	.Lgather
      .         
      .         .align	32
      .         .Lgather:
     64 (0.0%)  	pxor	%xmm4,%xmm4
     64 (0.0%)  	pxor	%xmm5,%xmm5
     64 (0.0%)  	movdqa	-128(%r11),%xmm0
     64 (0.0%)  	movdqa	-112(%r11),%xmm1
     64 (0.0%)  	movdqa	-96(%r11),%xmm2
     64 (0.0%)  	pand	-128(%rax),%xmm0
     64 (0.0%)  	movdqa	-80(%r11),%xmm3
     64 (0.0%)  	pand	-112(%rax),%xmm1
     64 (0.0%)  	por	%xmm0,%xmm4
     64 (0.0%)  	pand	-96(%rax),%xmm2
     64 (0.0%)  	por	%xmm1,%xmm5
     64 (0.0%)  	pand	-80(%rax),%xmm3
     64 (0.0%)  	por	%xmm2,%xmm4
     64 (0.0%)  	por	%xmm3,%xmm5
     64 (0.0%)  	movdqa	-64(%r11),%xmm0
     64 (0.0%)  	movdqa	-48(%r11),%xmm1
     64 (0.0%)  	movdqa	-32(%r11),%xmm2
     64 (0.0%)  	pand	-64(%rax),%xmm0
     64 (0.0%)  	movdqa	-16(%r11),%xmm3
     64 (0.0%)  	pand	-48(%rax),%xmm1
     64 (0.0%)  	por	%xmm0,%xmm4
     64 (0.0%)  	pand	-32(%rax),%xmm2
     64 (0.0%)  	por	%xmm1,%xmm5
     64 (0.0%)  	pand	-16(%rax),%xmm3
     64 (0.0%)  	por	%xmm2,%xmm4
     64 (0.0%)  	por	%xmm3,%xmm5
     64 (0.0%)  	movdqa	0(%r11),%xmm0
     64 (0.0%)  	movdqa	16(%r11),%xmm1
     64 (0.0%)  	movdqa	32(%r11),%xmm2
     64 (0.0%)  	pand	0(%rax),%xmm0
     64 (0.0%)  	movdqa	48(%r11),%xmm3
     64 (0.0%)  	pand	16(%rax),%xmm1
     64 (0.0%)  	por	%xmm0,%xmm4
     64 (0.0%)  	pand	32(%rax),%xmm2
     64 (0.0%)  	por	%xmm1,%xmm5
     64 (0.0%)  	pand	48(%rax),%xmm3
     64 (0.0%)  	por	%xmm2,%xmm4
     64 (0.0%)  	por	%xmm3,%xmm5
     64 (0.0%)  	movdqa	64(%r11),%xmm0
     64 (0.0%)  	movdqa	80(%r11),%xmm1
     64 (0.0%)  	movdqa	96(%r11),%xmm2
     64 (0.0%)  	pand	64(%rax),%xmm0
     64 (0.0%)  	movdqa	112(%r11),%xmm3
     64 (0.0%)  	pand	80(%rax),%xmm1
     64 (0.0%)  	por	%xmm0,%xmm4
     64 (0.0%)  	pand	96(%rax),%xmm2
     64 (0.0%)  	por	%xmm1,%xmm5
     64 (0.0%)  	pand	112(%rax),%xmm3
     64 (0.0%)  	por	%xmm2,%xmm4
     64 (0.0%)  	por	%xmm3,%xmm5
     64 (0.0%)  	por	%xmm5,%xmm4
     64 (0.0%)  	leaq	256(%r11),%r11
      .         
     64 (0.0%)  	pshufd	$0x4e,%xmm4,%xmm0
     64 (0.0%)  	por	%xmm4,%xmm0
     64 (0.0%)  	movq	%xmm0,(%rdi)
     64 (0.0%)  	leaq	8(%rdi),%rdi
     64 (0.0%)  	subl	$1,%esi
     64 (0.0%)  	jnz	.Lgather
      .         
      4 (0.0%)  	leaq	(%r10),%rsp
      .         .cfi_def_cfa_register	%rsp
      .         	.byte	0xf3,0xc3
      .         .LSEH_end_bn_gather5:
      .         .cfi_endproc	
      .         .size	bn_gather5,.-bn_gather5
      .         .section	.rodata
      .         .align	64
      .         .Linc:
-- line 3614 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 18 ----------------------------------------
      .         #include <sys/param.h>
      .         
      .         #include "error/s2n_errno.h"
      .         #include "utils/s2n_blob.h"
      .         #include "utils/s2n_mem.h"
      .         #include "utils/s2n_safety.h"
      .         
      .         S2N_RESULT s2n_stuffer_validate(const struct s2n_stuffer *stuffer)
315,588 (0.1%)  {
      .             /**
      .              * Note that we do not assert any properties on the tainted field,
      .              * as any boolean value in that field is valid.
      .              */
105,196 (0.0%)      RESULT_ENSURE_REF(stuffer);
420,784 (0.1%)      RESULT_GUARD(s2n_blob_validate(&stuffer->blob));
477,288 (0.2%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(stuffer->growable, stuffer->alloced), S2N_ERR_SAFETY);
      .         
      .             /* <= is valid because we can have a fully written/read stuffer */
473,382 (0.2%)      RESULT_DEBUG_ENSURE(stuffer->high_water_mark <= stuffer->blob.size, S2N_ERR_SAFETY);
473,382 (0.2%)      RESULT_DEBUG_ENSURE(stuffer->write_cursor <= stuffer->high_water_mark, S2N_ERR_SAFETY);
473,382 (0.2%)      RESULT_DEBUG_ENSURE(stuffer->read_cursor <= stuffer->write_cursor, S2N_ERR_SAFETY);
 52,598 (0.0%)      return S2N_RESULT_OK;
157,794 (0.1%)  }
      .         
      .         S2N_RESULT s2n_stuffer_reservation_validate(const struct s2n_stuffer_reservation *reservation)
      .         {
      .             /**
      .              * Note that we need two dereferences here to decrease proof complexity
      .              * for CBMC (see https://github.com/awslabs/s2n/issues/2290). We can roll back
      .              * this change once CBMC can handle common subexpression elimination.
      .              */
-- line 48 ----------------------------------------
-- line 56 ----------------------------------------
      .             /* The entire reservation must fit between the stuffer read and write cursors */
      .             RESULT_ENSURE_LTE(reserve_obj.write_cursor + reserve_obj.length, stuffer_obj.write_cursor);
      .             RESULT_ENSURE_GTE(reserve_obj.write_cursor, stuffer_obj.read_cursor);
      .         
      .             return S2N_RESULT_OK;
      .         }
      .         
      .         int s2n_stuffer_init(struct s2n_stuffer *stuffer, struct s2n_blob *in)
     70 (0.0%)  {
     20 (0.0%)      POSIX_ENSURE_MUT(stuffer);
    150 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(in));
     80 (0.0%)      stuffer->blob = *in;
     20 (0.0%)      stuffer->read_cursor = 0;
     20 (0.0%)      stuffer->write_cursor = 0;
     20 (0.0%)      stuffer->high_water_mark = 0;
     40 (0.0%)      stuffer->alloced = 0;
     40 (0.0%)      stuffer->growable = 0;
     40 (0.0%)      stuffer->tainted = 0;
    150 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     10 (0.0%)      return S2N_SUCCESS;
     30 (0.0%)  }
      .         
      .         int s2n_stuffer_init_written(struct s2n_stuffer *stuffer, struct s2n_blob *in)
      .         {
      .             POSIX_ENSURE_REF(in);
      .             POSIX_GUARD(s2n_stuffer_init(stuffer, in));
      .             POSIX_GUARD(s2n_stuffer_skip_write(stuffer, in->size));
      .             return S2N_SUCCESS;
      .         }
      .         
      .         int s2n_stuffer_alloc(struct s2n_stuffer *stuffer, const uint32_t size)
     42 (0.0%)  {
     12 (0.0%)      POSIX_ENSURE_REF(stuffer);
     30 (0.0%)      *stuffer = (struct s2n_stuffer){ 0 };
     42 (0.0%)      POSIX_GUARD(s2n_alloc(&stuffer->blob, size));
     42 (0.0%)      POSIX_GUARD(s2n_stuffer_init(stuffer, &stuffer->blob));
      .         
     24 (0.0%)      stuffer->alloced = 1;
      .         
     90 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
      6 (0.0%)      return S2N_SUCCESS;
     18 (0.0%)  }
      .         
      .         int s2n_stuffer_growable_alloc(struct s2n_stuffer *stuffer, const uint32_t size)
     18 (0.0%)  {
     21 (0.0%)      POSIX_GUARD(s2n_stuffer_alloc(stuffer, size));
      .         
     12 (0.0%)      stuffer->growable = 1;
      .         
     45 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
      3 (0.0%)      return S2N_SUCCESS;
      6 (0.0%)  }
      .         
      .         int s2n_stuffer_free(struct s2n_stuffer *stuffer)
     30 (0.0%)  {
     90 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
     30 (0.0%)      if (stuffer->alloced) {
     30 (0.0%)          POSIX_GUARD(s2n_free(&stuffer->blob));
      .             }
     30 (0.0%)      *stuffer = (struct s2n_stuffer){ 0 };
      6 (0.0%)      return S2N_SUCCESS;
     12 (0.0%)  }
      .         
      .         int s2n_stuffer_free_without_wipe(struct s2n_stuffer *stuffer)
      .         {
      .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
      .             if (stuffer->alloced) {
      .                 POSIX_GUARD(s2n_free_without_wipe(&stuffer->blob));
      .             }
      .             *stuffer = (struct s2n_stuffer){ 0 };
-- line 125 ----------------------------------------
-- line 170 ----------------------------------------
      .                 POSIX_ENSURE(stuffer->growable, S2N_ERR_RESIZE_STATIC_STUFFER);
      .                 POSIX_GUARD(s2n_realloc(&stuffer->blob, size));
      .             }
      .             POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
      .             return S2N_SUCCESS;
      .         }
      .         
      .         int s2n_stuffer_rewrite(struct s2n_stuffer *stuffer)
    535 (0.0%)  {
  1,605 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    214 (0.0%)      stuffer->write_cursor = 0;
    214 (0.0%)      stuffer->read_cursor = 0;
  1,605 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    107 (0.0%)      return S2N_SUCCESS;
    214 (0.0%)  }
      .         
      .         int s2n_stuffer_rewind_read(struct s2n_stuffer *stuffer, const uint32_t size)
      .         {
      .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
      .             POSIX_ENSURE(stuffer->read_cursor >= size, S2N_ERR_STUFFER_OUT_OF_DATA);
      .             stuffer->read_cursor -= size;
      .             POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
      .             return S2N_SUCCESS;
      .         }
      .         
      .         int s2n_stuffer_reread(struct s2n_stuffer *stuffer)
     25 (0.0%)  {
     75 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
     10 (0.0%)      stuffer->read_cursor = 0;
      5 (0.0%)      return S2N_SUCCESS;
     10 (0.0%)  }
      .         
      .         int s2n_stuffer_wipe_n(struct s2n_stuffer *stuffer, const uint32_t size)
      .         {
      .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
      .             uint32_t wipe_size = MIN(size, stuffer->write_cursor);
      .         
      .             stuffer->write_cursor -= wipe_size;
      .             stuffer->read_cursor = MIN(stuffer->read_cursor, stuffer->write_cursor);
-- line 208 ----------------------------------------
-- line 213 ----------------------------------------
      .         }
      .         
      .         bool s2n_stuffer_is_consumed(struct s2n_stuffer *stuffer)
      .         {
      .             return stuffer && (stuffer->read_cursor == stuffer->write_cursor) && !stuffer->tainted;
      .         }
      .         
      .         int s2n_stuffer_wipe(struct s2n_stuffer *stuffer)
      6 (0.0%)  {
     15 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
      4 (0.0%)      if (!s2n_stuffer_is_wiped(stuffer)) {
      .                 POSIX_CHECKED_MEMSET(stuffer->blob.data, S2N_WIPE_PATTERN, stuffer->high_water_mark);
      .             }
      .         
      4 (0.0%)      stuffer->tainted = 0;
      2 (0.0%)      stuffer->write_cursor = 0;
      2 (0.0%)      stuffer->read_cursor = 0;
      2 (0.0%)      stuffer->high_water_mark = 0;
     15 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
      1 (0.0%)      return S2N_SUCCESS;
      3 (0.0%)  }
      .         
      .         int s2n_stuffer_skip_read(struct s2n_stuffer *stuffer, uint32_t n)
 12,145 (0.0%)  {
 26,025 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 12,145 (0.0%)      POSIX_ENSURE(s2n_stuffer_data_available(stuffer) >= n, S2N_ERR_STUFFER_OUT_OF_DATA);
      .         
 10,410 (0.0%)      stuffer->read_cursor += n;
  1,735 (0.0%)      return S2N_SUCCESS;
  5,205 (0.0%)  }
      .         
      .         void *s2n_stuffer_raw_read(struct s2n_stuffer *stuffer, uint32_t data_len)
      6 (0.0%)  {
      7 (0.0%)      PTR_GUARD_POSIX(s2n_stuffer_skip_read(stuffer, data_len));
      .         
      4 (0.0%)      stuffer->tainted = 1;
      .         
     13 (0.0%)      return (stuffer->blob.data) ? (stuffer->blob.data + stuffer->read_cursor - data_len) : NULL;
      2 (0.0%)  }
      .         
      .         int s2n_stuffer_read(struct s2n_stuffer *stuffer, struct s2n_blob *out)
 12,138 (0.0%)  {
  3,468 (0.0%)      POSIX_ENSURE_REF(out);
      .         
 13,872 (0.0%)      return s2n_stuffer_read_bytes(stuffer, out->data, out->size);
  5,202 (0.0%)  }
      .         
      .         int s2n_stuffer_erase_and_read(struct s2n_stuffer *stuffer, struct s2n_blob *out)
      .         {
      .             POSIX_GUARD(s2n_stuffer_skip_read(stuffer, out->size));
      .         
      .             void *ptr = (stuffer->blob.data) ? (stuffer->blob.data + stuffer->read_cursor - out->size) : NULL;
      .             POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, out->size), S2N_ERR_NULL);
      .         
      .             POSIX_CHECKED_MEMCPY(out->data, ptr, out->size);
      .             POSIX_CHECKED_MEMSET(ptr, 0, out->size);
      .         
      .             return S2N_SUCCESS;
      .         }
      .         
      .         int s2n_stuffer_read_bytes(struct s2n_stuffer *stuffer, uint8_t *data, uint32_t size)
 13,872 (0.0%)  {
  3,468 (0.0%)      POSIX_ENSURE_REF(data);
 26,010 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 12,138 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_read(stuffer, size));
  6,936 (0.0%)      POSIX_ENSURE_REF(stuffer->blob.data);
 15,606 (0.0%)      void *ptr = stuffer->blob.data + stuffer->read_cursor - size;
      .         
 27,744 (0.0%)      POSIX_CHECKED_MEMCPY(data, ptr, size);
      .         
  1,734 (0.0%)      return S2N_SUCCESS;
  5,202 (0.0%)  }
      .         
      .         int s2n_stuffer_erase_and_read_bytes(struct s2n_stuffer *stuffer, uint8_t *data, uint32_t size)
      .         {
      .             POSIX_GUARD(s2n_stuffer_skip_read(stuffer, size));
      .             POSIX_ENSURE_REF(stuffer->blob.data);
      .             void *ptr = stuffer->blob.data + stuffer->read_cursor - size;
      .         
      .             POSIX_CHECKED_MEMCPY(data, ptr, size);
      .             POSIX_CHECKED_MEMSET(ptr, 0, size);
      .         
      .             return S2N_SUCCESS;
      .         }
      .         
      .         int s2n_stuffer_skip_write(struct s2n_stuffer *stuffer, const uint32_t n)
 52,002 (0.0%)  {
130,005 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 60,669 (0.0%)      POSIX_GUARD(s2n_stuffer_reserve_space(stuffer, n));
 52,002 (0.0%)      stuffer->write_cursor += n;
 69,336 (0.0%)      stuffer->high_water_mark = MAX(stuffer->write_cursor, stuffer->high_water_mark);
130,005 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  8,667 (0.0%)      return S2N_SUCCESS;
 17,334 (0.0%)  }
      .         
      .         void *s2n_stuffer_raw_write(struct s2n_stuffer *stuffer, const uint32_t data_len)
      .         {
      .             PTR_GUARD_POSIX(s2n_stuffer_skip_write(stuffer, data_len));
      .         
      .             stuffer->tainted = 1;
      .         
      .             return (stuffer->blob.data) ? (stuffer->blob.data + stuffer->write_cursor - data_len) : NULL;
-- line 314 ----------------------------------------
-- line 317 ----------------------------------------
      .         int s2n_stuffer_write(struct s2n_stuffer *stuffer, const struct s2n_blob *in)
      .         {
      .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
      .             POSIX_PRECONDITION(s2n_blob_validate(in));
      .             return s2n_stuffer_write_bytes(stuffer, in->data, in->size);
      .         }
      .         
      .         int s2n_stuffer_write_bytes(struct s2n_stuffer *stuffer, const uint8_t *data, const uint32_t size)
 55,480 (0.0%)  {
 27,740 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_SAFETY);
104,025 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 48,545 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(stuffer, size));
      .         
 62,415 (0.0%)      void *ptr = stuffer->blob.data + stuffer->write_cursor - size;
 27,740 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, size), S2N_ERR_NULL);
      .         
 20,805 (0.0%)      if (ptr == data) {
      .                 POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
      .                 return S2N_SUCCESS;
      .             }
      .         
110,960 (0.0%)      POSIX_CHECKED_MEMCPY(ptr, data, size);
      .         
104,025 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  6,935 (0.0%)      return S2N_SUCCESS;
 20,805 (0.0%)  }
      .         
      .         int s2n_stuffer_writev_bytes(struct s2n_stuffer *stuffer, const struct iovec *iov, size_t iov_count, uint32_t offs,
      .                 uint32_t size)
      .         {
      .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
      .             POSIX_ENSURE_REF(iov);
      .             void *ptr = s2n_stuffer_raw_write(stuffer, size);
      .             POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, size), S2N_ERR_NULL);
-- line 350 ----------------------------------------
-- line 382 ----------------------------------------
      .             uint8_t *to_ptr = (to->blob.data) ? (to->blob.data + to->write_cursor - len) : NULL;
      .         
      .             POSIX_CHECKED_MEMCPY(to_ptr, from_ptr, len);
      .         
      .             return S2N_SUCCESS;
      .         }
      .         
      .         int s2n_stuffer_reserve_space(struct s2n_stuffer *stuffer, uint32_t n)
 86,670 (0.0%)  {
130,005 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 60,669 (0.0%)      if (s2n_stuffer_space_remaining(stuffer) < n) {
      .                 POSIX_ENSURE(stuffer->growable, S2N_ERR_STUFFER_IS_FULL);
      .                 /* Always grow a stuffer by at least 1k */
      .                 const uint32_t growth = MAX(n - s2n_stuffer_space_remaining(stuffer), S2N_MIN_STUFFER_GROWTH_IN_BYTES);
      .                 uint32_t new_size = 0;
      .                 POSIX_GUARD(s2n_add_overflow(stuffer->blob.size, growth, &new_size));
      .                 POSIX_GUARD(s2n_stuffer_resize(stuffer, new_size));
      .             }
130,005 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  8,667 (0.0%)      return S2N_SUCCESS;
 52,002 (0.0%)  }
      .         
      .         /* Copies "len" bytes from "from" to "to".
      .          * If the copy cannot succeed (i.e. there are either not enough bytes available, or there is not enough space to write them
      .          * restore the old value of the stuffer */
      .         int s2n_stuffer_copy(struct s2n_stuffer *from, struct s2n_stuffer *to, const uint32_t len)
      .         {
      .             const uint32_t orig_read_cursor = from->read_cursor;
      .             const uint32_t orig_write_cursor = to->write_cursor;
-- line 410 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 19 ----------------------------------------
      .         #include <string.h>
      .         #include <sys/param.h>
      .         
      .         #include "api/s2n.h"
      .         #include "error/s2n_errno.h"
      .         #include "utils/s2n_safety.h"
      .         
      .         S2N_RESULT s2n_blob_validate(const struct s2n_blob *b)
317,574 (0.1%)  {
105,858 (0.0%)      RESULT_ENSURE_REF(b);
370,846 (0.1%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->data == NULL, b->size == 0), S2N_ERR_SAFETY);
370,846 (0.1%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->data == NULL, b->allocated == 0), S2N_ERR_SAFETY);
742,352 (0.2%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->growable == 0, b->allocated == 0), S2N_ERR_SAFETY);
489,753 (0.2%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->growable != 0, b->size <= b->allocated), S2N_ERR_SAFETY);
422,086 (0.1%)      RESULT_DEBUG_ENSURE(S2N_MEM_IS_READABLE(b->data, b->allocated), S2N_ERR_SAFETY);
740,663 (0.2%)      RESULT_DEBUG_ENSURE(S2N_MEM_IS_READABLE(b->data, b->size), S2N_ERR_SAFETY);
 52,929 (0.0%)      return S2N_RESULT_OK;
158,787 (0.1%)  }
      .         
      .         int s2n_blob_init(struct s2n_blob *b, uint8_t *data, uint32_t size)
    968 (0.0%)  {
    242 (0.0%)      POSIX_ENSURE_REF(b);
    484 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_SAFETY);
  1,452 (0.0%)      *b = (struct s2n_blob){ .data = data, .size = size, .allocated = 0, .growable = 0 };
  1,815 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(b));
    121 (0.0%)      return S2N_SUCCESS;
    363 (0.0%)  }
      .         
      .         int s2n_blob_zero(struct s2n_blob *b)
    360 (0.0%)  {
    900 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(b));
  1,170 (0.0%)      POSIX_CHECKED_MEMSET(b->data, 0, MAX(b->allocated, b->size));
    900 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(b));
     60 (0.0%)      return S2N_SUCCESS;
    180 (0.0%)  }
      .         
      .         int s2n_blob_slice(const struct s2n_blob *b, struct s2n_blob *slice, uint32_t offset, uint32_t size)
     12 (0.0%)  {
     15 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(b));
     15 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(slice));
      .         
      1 (0.0%)      uint32_t slice_size = 0;
      8 (0.0%)      POSIX_GUARD(s2n_add_overflow(offset, size, &slice_size));
      5 (0.0%)      POSIX_ENSURE(b->size >= slice_size, S2N_ERR_SIZE_MISMATCH);
     11 (0.0%)      slice->data = (b->data) ? (b->data + offset) : NULL;
      3 (0.0%)      slice->size = size;
      4 (0.0%)      slice->growable = 0;
      2 (0.0%)      slice->allocated = 0;
      .         
     15 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(slice));
      1 (0.0%)      return S2N_SUCCESS;
      6 (0.0%)  }
      .         
      .         int s2n_blob_char_to_lower(struct s2n_blob *b)
     10 (0.0%)  {
     30 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(b));
    122 (0.0%)      for (size_t i = 0; i < b->size; i++) {
    270 (0.0%)          b->data[i] = tolower(b->data[i]);
      .             }
     30 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(b));
      2 (0.0%)      return S2N_SUCCESS;
      4 (0.0%)  }
      .         
      .         /* An inverse map from an ascii value to a hexidecimal nibble value
      .          * accounts for all possible char values, where 255 is invalid value */
      .         static const uint8_t hex_inverse[256] = {
      .             /* clang-format off */
      .             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      .             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      .             255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
-- line 88 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 79 ----------------------------------------
      .         #include "utils/s2n_result.h"
      .         
      .         #include <stdbool.h>
      .         
      .         #include "api/s2n.h"
      .         
      .         /* returns true when the result is S2N_RESULT_OK */
      .         inline bool s2n_result_is_ok(s2n_result result)
634,292 (0.2%)  {
475,719 (0.2%)      return result.__error_signal == S2N_SUCCESS;
317,146 (0.1%)  }
      .         
      .         /* returns true when the result is S2N_RESULT_ERROR */
      .         inline bool s2n_result_is_error(s2n_result result)
      .         {
      .             return result.__error_signal == S2N_FAILURE;
      .         }
      .         
      .         /* ignores the returned result of a function */
-- line 97 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir_________________ 

284,925,588 (93.5%)    annotated: files known & above threshold & readable, line numbers known
          0            annotated: files known & above threshold & readable, line numbers unknown
          0          unannotated: files known & above threshold & two or more non-identical
 12,838,515  (4.2%)  unannotated: files known & above threshold & unreadable 
  6,639,943  (2.2%)  unannotated: files known & below threshold
    240,019  (0.1%)  unannotated: files unknown

