--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate cachegrind.out.139275
Command:          target/debug/ecdsa_handshake
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir________________ 

6,268,257 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir______________________  file:function

< 2,420,862 (38.6%, 38.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S:
  1,061,900 (16.9%)           __ecp_nistz256_mul_montq
    695,625 (11.1%)           __ecp_nistz256_sqr_montq
    143,598  (2.3%)           aws_lc_0_19_0_ecp_nistz256_point_double
     83,789  (1.3%)           __ecp_nistz256_sub_fromq
     75,744  (1.2%)           __ecp_nistz256_mul_by_2q
     65,268  (1.0%)           aws_lc_0_19_0_ecp_nistz256_avx2_select_w7
     57,750  (0.9%)           aws_lc_0_19_0_ecp_nistz256_point_add
     46,621  (0.7%)           aws_lc_0_19_0_ecp_nistz256_ord_sqr_mont
     38,448  (0.6%)           aws_lc_0_19_0_ecp_nistz256_point_add_affine
     37,872  (0.6%)           __ecp_nistz256_add_toq
     33,540  (0.5%)           ecp_nistz256_avx2_select_w5
     31,925  (0.5%)           aws_lc_0_19_0_ecp_nistz256_sqr_mont
     27,113  (0.4%)           __ecp_nistz256_subq
      9,520  (0.2%)           aws_lc_0_19_0_ecp_nistz256_neg
      9,272  (0.1%)           aws_lc_0_19_0_ecp_nistz256_ord_mul_mont

<   576,919  (9.2%, 47.8%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha256-x86_64.S:
    574,444  (9.2%)           sha256_block_data_order_avx

<   375,409  (6.0%, 53.8%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c:
    235,223  (3.8%)           s2n_stuffer_validate
     32,580  (0.5%)           s2n_stuffer_skip_write
     30,402  (0.5%)           s2n_stuffer_reserve_space
     24,530  (0.4%)           s2n_stuffer_write_bytes
     10,374  (0.2%)           s2n_stuffer_skip_read
      9,100  (0.1%)           s2n_stuffer_read_bytes
      6,486  (0.1%)           s2n_stuffer_init

<   370,621  (5.9%, 59.7%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c:
    352,205  (5.6%)           s2n_blob_validate
     10,972  (0.2%)           s2n_blob_init

<   179,455  (2.9%, 62.6%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c:
    119,012  (1.9%)           s2n_tls_hmac_init
     14,496  (0.2%)           s2n_hmac_state_validate
      7,560  (0.1%)           s2n_hmac_reset
      7,280  (0.1%)           s2n_hmac_init
      7,176  (0.1%)           s2n_hmac_hash_alg
      6,862  (0.1%)           s2n_hmac_update

<   164,059  (2.6%, 65.2%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c:
    163,845  (2.6%)           s2n_result_is_ok

<   152,052  (2.4%, 67.6%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c:
     25,008  (0.4%)           s2n_hash_state_validate
     15,746  (0.3%)           s2n_low_level_hash_update
     13,808  (0.2%)           s2n_hash_update
     13,068  (0.2%)           s2n_hash_init
     11,118  (0.2%)           s2n_low_level_hash_new
      9,600  (0.2%)           s2n_hash_set_impl
      9,116  (0.1%)           s2n_low_level_hash_init
      9,010  (0.1%)           s2n_hash_copy
      6,540  (0.1%)           s2n_hash_new

<   113,163  (1.8%, 69.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h:
     28,496  (0.5%)           OPENSSL_memcpy
     22,208  (0.4%)           CRYPTO_bswap4
     20,376  (0.3%)           CRYPTO_store_u32_be
      9,076  (0.1%)           OPENSSL_memset
      8,148  (0.1%)           constant_time_select_w

<   104,859  (1.7%, 71.1%)  ./malloc/./malloc/malloc.c:
     49,556  (0.8%)           _int_malloc
     19,259  (0.3%)           malloc
     15,222  (0.2%)           _int_free
      8,756  (0.1%)           malloc_consolidate
      6,732  (0.1%)           free

<   103,123  (1.6%, 72.8%)  ./elf/./elf/dl-lookup.c:
     66,754  (1.1%)           do_lookup_x
     21,732  (0.3%)           _dl_lookup_symbol_x
     14,637  (0.2%)           check_match

<    82,402  (1.3%, 74.1%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms

<    80,716  (1.3%, 75.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c:
     22,537  (0.4%)           cbs_get
     13,977  (0.2%)           aws_lc_0_19_0_CBS_get_u8
     11,121  (0.2%)           cbs_get_any_asn1_element

<    72,970  (1.2%, 76.5%)  ./elf/../sysdeps/x86_64/dl-machine.h:
     72,904  (1.2%)           _dl_relocate_object

<    68,374  (1.1%, 77.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/p256-nistz.c:
     17,889  (0.3%)           copy_conditional
     14,196  (0.2%)           ecp_nistz256_windowed_mul
     10,600  (0.2%)           ecp_nistz256_mod_inverse_sqr_mont
      6,624  (0.1%)           calc_wvalue

<    62,597  (1.0%, 78.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c:
     21,700  (0.3%)           aws_lc_0_19_0_OBJ_cmp
     18,760  (0.3%)           get_builtin_object
     16,093  (0.3%)           obj_cmp

<    55,661  (0.9%, 79.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c:
     20,134  (0.3%)           asn1_item_ex_i2d_opt
     12,912  (0.2%)           asn1_template_ex_i2d
     11,407  (0.2%)           asn1_ex_i2c
      8,778  (0.1%)           asn1_i2d_ex_primitive

<    50,756  (0.8%, 80.3%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha512-x86_64.S:
     50,639  (0.8%)           sha512_block_data_order_avx

<    50,173  (0.8%, 81.1%)  ./elf/./elf/do-rel.h:
     50,117  (0.8%)           _dl_relocate_object

<    50,026  (0.8%, 81.9%)  ./stdio-common/./stdio-common/vfscanf-internal.c:__vfscanf_internal

<    46,604  (0.7%, 82.7%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:
     46,062  (0.7%)           __memcpy_avx_unaligned_erms

<    44,916  (0.7%, 83.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c:
     12,576  (0.2%)           aws_lc_0_19_0_OPENSSL_malloc
      8,994  (0.1%)           aws_lc_0_19_0_OPENSSL_free

<    44,442  (0.7%, 84.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c:
     15,762  (0.3%)           asn1_item_ex_d2i
      7,596  (0.1%)           asn1_check_tlen
      7,107  (0.1%)           asn1_template_noexp_d2i

<    36,876  (0.6%, 84.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont.S:aws_lc_0_19_0_bn_mul_mont

<    30,686  (0.5%, 85.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/sha/sha256.c:
     15,444  (0.2%)           sha256_final_impl
      7,595  (0.1%)           aws_lc_0_19_0_SHA256_Update

<    27,848  (0.4%, 85.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c:
     18,810  (0.3%)           aws_lc_0_19_0_X509_NAME_cmp
      8,823  (0.1%)           aws_lc_0_19_0_X509_subject_name_cmp

<    27,828  (0.4%, 86.0%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha1-x86_64.S:
     27,674  (0.4%)           sha1_block_data_order_avx2

<    25,235  (0.4%, 86.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/md4/../digest/md32_common.h:
     17,675  (0.3%)           crypto_md32_update
      7,560  (0.1%)           crypto_md32_final

<    24,112  (0.4%, 86.8%)  ./stdlib/../stdlib/strtol_l.c:____strtoul_l_internal

<    23,601  (0.4%, 87.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c:
     10,595  (0.2%)           aws_lc_0_19_0_ASN1_get_object

<    23,008  (0.4%, 87.6%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_network_order.c:
     10,913  (0.2%)           s2n_stuffer_write_network_order

<    22,653  (0.4%, 87.9%)  ./elf/./elf/dl-tunables.c:
     21,511  (0.3%)           __GI___tunables_init

<    22,515  (0.4%, 88.3%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c:
     14,532  (0.2%)           x509_object_cmp
      7,785  (0.1%)           x509_object_cmp_sk

<    22,238  (0.4%, 88.6%)  ./elf/./elf/dl-reloc.c:_dl_relocate_object

<    21,192  (0.3%, 89.0%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/md5-x86_64.S:aws_lc_0_19_0_md5_block_asm_data_order

<    20,015  (0.3%, 89.3%)  ./string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S:
     19,983  (0.3%)           strcmp

<    19,010  (0.3%, 89.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c:
      6,650  (0.1%)           aws_lc_0_19_0_asn1_get_field_ptr

<    18,874  (0.3%, 89.9%)  ./elf/../sysdeps/generic/dl-new-hash.h:_dl_lookup_symbol_x

<    18,500  (0.3%, 90.2%)  /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_ensure.c:s2n_ensure_memmove_trace

<    17,730  (0.3%, 90.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c:
      7,504  (0.1%)           aws_lc_0_19_0_bn_select_words

<    16,164  (0.3%, 90.7%)  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe

<    16,014  (0.3%, 91.0%)  ./stdlib/../bits/stdlib-bsearch.h:bsearch

<    15,392  (0.2%, 91.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256_beeu-x86_64-asm.S:aws_lc_0_19_0_beeu_mod_inverse_vartime

<    15,293  (0.2%, 91.5%)  ./stdlib/./stdlib/qsort.c:
     15,209  (0.2%)           msort_with_tmp.part.0

<    15,241  (0.2%, 91.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c:
      7,354  (0.1%)           asn1_item_ex_combine_new

<     9,480  (0.2%, 91.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bytes.c:
      7,305  (0.1%)           aws_lc_0_19_0_bn_words_to_big_endian

<     9,312  (0.1%, 92.0%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/../internal.h:OPENSSL_memcmp

<     8,800  (0.1%, 92.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h:
      8,208  (0.1%)           OPENSSL_memset

<     8,126  (0.1%, 92.3%)  ./elf/./elf/dl-version.c:
      8,041  (0.1%)           _dl_check_map_versions

<     7,151  (0.1%, 92.4%)  ???:
      6,726  (0.1%)           ???

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir______________________  function:file

> 1,061,900 (16.9%, 16.9%)  __ecp_nistz256_mul_montq:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>   695,625 (11.1%, 28.0%)  __ecp_nistz256_sqr_montq:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>   574,444  (9.2%, 37.2%)  sha256_block_data_order_avx:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha256-x86_64.S

>   352,205  (5.6%, 42.8%)  s2n_blob_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c

>   235,223  (3.8%, 46.6%)  s2n_stuffer_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>   163,845  (2.6%, 49.2%)  s2n_result_is_ok:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c

>   145,986  (2.3%, 51.5%)  _dl_relocate_object:
     72,904  (1.2%)           ./elf/../sysdeps/x86_64/dl-machine.h
     50,117  (0.8%)           ./elf/./elf/do-rel.h
     22,238  (0.4%)           ./elf/./elf/dl-reloc.c

>   143,598  (2.3%, 53.8%)  aws_lc_0_19_0_ecp_nistz256_point_double:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>   119,012  (1.9%, 55.7%)  s2n_tls_hmac_init:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c

>    83,789  (1.3%, 57.0%)  __ecp_nistz256_sub_fromq:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    82,402  (1.3%, 58.4%)  __memset_avx2_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

>    75,744  (1.2%, 59.6%)  __ecp_nistz256_mul_by_2q:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    68,644  (1.1%, 60.7%)  do_lookup_x:
     66,754  (1.1%)           ./elf/./elf/dl-lookup.c

>    65,268  (1.0%, 61.7%)  aws_lc_0_19_0_ecp_nistz256_avx2_select_w7:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    57,750  (0.9%, 62.6%)  aws_lc_0_19_0_ecp_nistz256_point_add:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    51,636  (0.8%, 63.4%)  __vfscanf_internal:
     50,026  (0.8%)           ./stdio-common/./stdio-common/vfscanf-internal.c

>    50,639  (0.8%, 64.3%)  sha512_block_data_order_avx:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha512-x86_64.S

>    49,556  (0.8%, 65.0%)  _int_malloc:./malloc/./malloc/malloc.c

>    46,621  (0.7%, 65.8%)  aws_lc_0_19_0_ecp_nistz256_ord_sqr_mont:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    46,062  (0.7%, 66.5%)  __memcpy_avx_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

>    40,606  (0.6%, 67.2%)  _dl_lookup_symbol_x:
     21,732  (0.3%)           ./elf/./elf/dl-lookup.c
     18,874  (0.3%)           ./elf/../sysdeps/generic/dl-new-hash.h

>    38,448  (0.6%, 67.8%)  aws_lc_0_19_0_ecp_nistz256_point_add_affine:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    37,872  (0.6%, 68.4%)  __ecp_nistz256_add_toq:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    36,876  (0.6%, 69.0%)  aws_lc_0_19_0_bn_mul_mont:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont.S

>    33,540  (0.5%, 69.5%)  ecp_nistz256_avx2_select_w5:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    32,580  (0.5%, 70.0%)  s2n_stuffer_skip_write:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    31,925  (0.5%, 70.5%)  aws_lc_0_19_0_ecp_nistz256_sqr_mont:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    30,402  (0.5%, 71.0%)  s2n_stuffer_reserve_space:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    30,336  (0.5%, 71.5%)  OPENSSL_memcpy:
     28,496  (0.5%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    27,674  (0.4%, 72.0%)  sha1_block_data_order_avx2:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha1-x86_64.S

>    27,113  (0.4%, 72.4%)  __ecp_nistz256_subq:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>    25,008  (0.4%, 72.8%)  s2n_hash_state_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>    24,530  (0.4%, 73.2%)  s2n_stuffer_write_bytes:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>    24,112  (0.4%, 73.6%)  ____strtoul_l_internal:./stdlib/../stdlib/strtol_l.c

>    24,043  (0.4%, 73.9%)  __GI___tunables_init:
     21,511  (0.3%)           ./elf/./elf/dl-tunables.c

>    22,537  (0.4%, 74.3%)  cbs_get:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    22,304  (0.4%, 74.7%)  CRYPTO_bswap4:
     22,208  (0.4%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    21,700  (0.3%, 75.0%)  aws_lc_0_19_0_OBJ_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c

>    21,192  (0.3%, 75.3%)  aws_lc_0_19_0_md5_block_asm_data_order:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/md5-x86_64.S

>    20,376  (0.3%, 75.7%)  CRYPTO_store_u32_be:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    20,134  (0.3%, 76.0%)  asn1_item_ex_i2d_opt:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>    20,027  (0.3%, 76.3%)  strcmp:
     19,983  (0.3%)           ./string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S

>    19,714  (0.3%, 76.6%)  malloc:
     19,259  (0.3%)           ./malloc/./malloc/malloc.c

>    18,810  (0.3%, 76.9%)  aws_lc_0_19_0_X509_NAME_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c

>    18,760  (0.3%, 77.2%)  get_builtin_object:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c

>    18,500  (0.3%, 77.5%)  s2n_ensure_memmove_trace:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_ensure.c

>    18,068  (0.3%, 77.8%)  OPENSSL_memset:
      9,076  (0.1%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h
      8,208  (0.1%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h

>    17,889  (0.3%, 78.1%)  copy_conditional:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/p256-nistz.c

>    17,675  (0.3%, 78.4%)  crypto_md32_update:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/md4/../digest/md32_common.h

>    16,164  (0.3%, 78.6%)  __memcmp_avx2_movbe:./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S

>    16,093  (0.3%, 78.9%)  obj_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c

>    16,014  (0.3%, 79.1%)  bsearch:./stdlib/../bits/stdlib-bsearch.h

>    15,796  (0.3%, 79.4%)  msort_with_tmp.part.0:
     15,209  (0.2%)           ./stdlib/./stdlib/qsort.c

>    15,762  (0.3%, 79.6%)  asn1_item_ex_d2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>    15,746  (0.3%, 79.9%)  s2n_low_level_hash_update:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>    15,444  (0.2%, 80.1%)  sha256_final_impl:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/sha/sha256.c

>    15,392  (0.2%, 80.4%)  aws_lc_0_19_0_beeu_mod_inverse_vartime:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256_beeu-x86_64-asm.S

>    15,222  (0.2%, 80.6%)  _int_free:./malloc/./malloc/malloc.c

>    14,637  (0.2%, 80.9%)  check_match:./elf/./elf/dl-lookup.c

>    14,532  (0.2%, 81.1%)  x509_object_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c

>    14,496  (0.2%, 81.3%)  s2n_hmac_state_validate:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c

>    14,196  (0.2%, 81.6%)  ecp_nistz256_windowed_mul:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/p256-nistz.c

>    13,977  (0.2%, 81.8%)  aws_lc_0_19_0_CBS_get_u8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    13,808  (0.2%, 82.0%)  s2n_hash_update:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>    13,068  (0.2%, 82.2%)  s2n_hash_init:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>    12,912  (0.2%, 82.4%)  asn1_template_ex_i2d:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>    12,576  (0.2%, 82.6%)  aws_lc_0_19_0_OPENSSL_malloc:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    11,407  (0.2%, 82.8%)  asn1_ex_i2c:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>    11,360  (0.2%, 83.0%)  OPENSSL_memcmp:
      9,312  (0.1%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/../internal.h

>    11,121  (0.2%, 83.2%)  cbs_get_any_asn1_element:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    11,118  (0.2%, 83.3%)  s2n_low_level_hash_new:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>    10,972  (0.2%, 83.5%)  s2n_blob_init:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c

>    10,913  (0.2%, 83.7%)  s2n_stuffer_write_network_order:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_network_order.c

>    10,600  (0.2%, 83.9%)  ecp_nistz256_mod_inverse_sqr_mont:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/p256-nistz.c

>    10,595  (0.2%, 84.0%)  aws_lc_0_19_0_ASN1_get_object:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c

>    10,374  (0.2%, 84.2%)  s2n_stuffer_skip_read:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>     9,600  (0.2%, 84.3%)  s2n_hash_set_impl:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>     9,520  (0.2%, 84.5%)  aws_lc_0_19_0_ecp_nistz256_neg:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>     9,272  (0.1%, 84.6%)  aws_lc_0_19_0_ecp_nistz256_ord_mul_mont:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S

>     9,116  (0.1%, 84.8%)  s2n_low_level_hash_init:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>     9,100  (0.1%, 84.9%)  s2n_stuffer_read_bytes:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

>     9,010  (0.1%, 85.1%)  s2n_hash_copy:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>     8,994  (0.1%, 85.2%)  aws_lc_0_19_0_OPENSSL_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>     8,823  (0.1%, 85.4%)  aws_lc_0_19_0_X509_subject_name_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c

>     8,778  (0.1%, 85.5%)  asn1_i2d_ex_primitive:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>     8,756  (0.1%, 85.6%)  malloc_consolidate:./malloc/./malloc/malloc.c

>     8,148  (0.1%, 85.8%)  constant_time_select_w:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>     8,071  (0.1%, 85.9%)  _dl_check_map_versions:
      8,041  (0.1%)           ./elf/./elf/dl-version.c

>     7,785  (0.1%, 86.0%)  x509_object_cmp_sk:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c

>     7,596  (0.1%, 86.1%)  asn1_check_tlen:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>     7,595  (0.1%, 86.3%)  aws_lc_0_19_0_SHA256_Update:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/sha/sha256.c

>     7,560  (0.1%, 86.4%)  s2n_hmac_reset:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c

>     7,560  (0.1%, 86.5%)  crypto_md32_final:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/md4/../digest/md32_common.h

>     7,504  (0.1%, 86.6%)  aws_lc_0_19_0_bn_select_words:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c

>     7,446  (0.1%, 86.7%)  free:
      6,732  (0.1%)           ./malloc/./malloc/malloc.c

>     7,354  (0.1%, 86.9%)  asn1_item_ex_combine_new:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c

>     7,305  (0.1%, 87.0%)  aws_lc_0_19_0_bn_words_to_big_endian:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bytes.c

>     7,280  (0.1%, 87.1%)  s2n_hmac_init:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c

>     7,176  (0.1%, 87.2%)  s2n_hmac_hash_alg:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c

>     7,107  (0.1%, 87.3%)  asn1_template_noexp_d2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>     6,862  (0.1%, 87.4%)  s2n_hmac_update:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c

>     6,726  (0.1%, 87.5%)  ???:???

>     6,650  (0.1%, 87.6%)  aws_lc_0_19_0_asn1_get_field_ptr:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c

>     6,624  (0.1%, 87.7%)  calc_wvalue:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/p256-nistz.c

>     6,540  (0.1%, 87.9%)  s2n_hash_new:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c

>     6,486  (0.1%, 88.0%)  s2n_stuffer_init:/home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/../sysdeps/generic/dl-new-hash.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/../sysdeps/generic/dl-new-hash.h

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/../sysdeps/x86_64/dl-machine.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/../sysdeps/x86_64/dl-machine.h

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-lookup.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-lookup.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-reloc.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-reloc.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-tunables.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-tunables.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/dl-version.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/dl-version.c

--------------------------------------------------------------------------------
-- Annotated source file: ./elf/./elf/do-rel.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./elf/./elf/do-rel.h

--------------------------------------------------------------------------------
-- Annotated source file: ./malloc/./malloc/malloc.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./malloc/./malloc/malloc.c

--------------------------------------------------------------------------------
-- Annotated source file: ./stdio-common/./stdio-common/vfscanf-internal.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdio-common/./stdio-common/vfscanf-internal.c

--------------------------------------------------------------------------------
-- Annotated source file: ./stdlib/../bits/stdlib-bsearch.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdlib/../bits/stdlib-bsearch.h

--------------------------------------------------------------------------------
-- Annotated source file: ./stdlib/../stdlib/strtol_l.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdlib/../stdlib/strtol_l.c

--------------------------------------------------------------------------------
-- Annotated source file: ./stdlib/./stdlib/qsort.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdlib/./stdlib/qsort.c

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 109 ----------------------------------------
    .         //
    .         // In particular, this limit is small enough that the bit count of a BIT STRING
    .         // comfortably fits in an |int|, with room for arithmetic.
    .         #define ASN1_STRING_MAX (64 * 1024 * 1024)
    .         
    .         static void asn1_put_length(unsigned char **pp, int length);
    .         
    .         int ASN1_get_object(const unsigned char **inp, long *out_len, int *out_tag,
1,500 (0.0%)                      int *out_class, long in_len) {
  250 (0.0%)    if (in_len < 0) {
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_HEADER_TOO_LONG);
    .             return 0x80;
    .           }
    .         
    .           // TODO(https://crbug.com/boringssl/354): This should use |CBS_get_asn1| to
    .           // reject non-minimal lengths, which are only allowed in BER. However,
    .           // Android sometimes needs allow a non-minimal length in certificate
    .           // signature fields (see b/18228011). Make this only apply to that field,
    .           // while requiring DER elsewhere. Better yet, it should be limited to an
    .           // preprocessing step in that part of Android.
    .           CBS_ASN1_TAG tag;
    .           size_t header_len;
    .           int indefinite;
    .           CBS cbs, body;
  875 (0.0%)    CBS_init(&cbs, *inp, (size_t)in_len);
1,375 (0.0%)    if (!CBS_get_any_ber_asn1_element(&cbs, &body, &tag, &header_len,
  375 (0.0%)                                      /*out_ber_found=*/NULL, &indefinite) ||
1,125 (0.0%)        indefinite || !CBS_skip(&body, header_len) ||
    .               // Bound the length to comfortably fit in an int. Lengths in this
    .               // module often switch between int and long without overflow checks.
  375 (0.0%)        CBS_len(&body) > INT_MAX / 2) {
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_HEADER_TOO_LONG);
    .             return 0x80;
    .           }
    .         
    .           // Convert between tag representations.
  500 (0.0%)    int tag_class = (tag & CBS_ASN1_CLASS_MASK) >> CBS_ASN1_TAG_SHIFT;
  500 (0.0%)    int constructed = (tag & CBS_ASN1_CONSTRUCTED) >> CBS_ASN1_TAG_SHIFT;
  375 (0.0%)    int tag_number = tag & CBS_ASN1_TAG_NUMBER_MASK;
    .         
    .           // To avoid ambiguity with V_ASN1_NEG, impose a limit on universal tags.
  470 (0.0%)    if (tag_class == V_ASN1_UNIVERSAL && tag_number > V_ASN1_MAX_UNIVERSAL) {
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_HEADER_TOO_LONG);
    .             return 0x80;
    .           }
    .         
  625 (0.0%)    *inp = CBS_data(&body);
  750 (0.0%)    *out_len = CBS_len(&body);
  375 (0.0%)    *out_tag = tag_number;
  375 (0.0%)    *out_class = tag_class;
  125 (0.0%)    return constructed;
  625 (0.0%)  }
    .         
    .         // class 0 is constructed constructed == 2 for indefinite length constructed
    .         void ASN1_put_object(unsigned char **pp, int constructed, int length, int tag,
  732 (0.0%)                       int xclass) {
  183 (0.0%)    unsigned char *p = *pp;
    .           int i, ttag;
    .         
  274 (0.0%)    i = (constructed) ? V_ASN1_CONSTRUCTED : 0;
  183 (0.0%)    i |= (xclass & V_ASN1_PRIVATE);
  122 (0.0%)    if (tag < 31) {
  732 (0.0%)      *(p++) = i | (tag & V_ASN1_PRIMITIVE_TAG);
    .           } else {
    .             *(p++) = i | V_ASN1_PRIMITIVE_TAG;
    .             for (i = 0, ttag = tag; ttag > 0; i++) {
    .               ttag >>= 7;
    .             }
    .             ttag = i;
    .             while (i-- > 0) {
    .               p[i] = tag & 0x7f;
    .               if (i != (ttag - 1)) {
    .                 p[i] |= 0x80;
    .               }
    .               tag >>= 7;
    .             }
    .             p += ttag;
    .           }
  122 (0.0%)    if (constructed == 2) {
    .             *(p++) = 0x80;
    .           } else {
  305 (0.0%)      asn1_put_length(&p, length);
    .           }
  183 (0.0%)    *pp = p;
  366 (0.0%)  }
    .         
    .         int ASN1_put_eoc(unsigned char **pp) {
    .           // This function is no longer used in the library, but some external code
    .           // uses it.
    .           unsigned char *p = *pp;
    .           *p++ = 0;
    .           *p++ = 0;
    .           *pp = p;
    .           return 2;
    .         }
    .         
  305 (0.0%)  static void asn1_put_length(unsigned char **pp, int length) {
  183 (0.0%)    unsigned char *p = *pp;
    .           int i, l;
  122 (0.0%)    if (length <= 127) {
  354 (0.0%)      *(p++) = (unsigned char)length;
    .           } else {
    4 (0.0%)      l = length;
   20 (0.0%)      for (i = 0; l > 0; i++) {
    4 (0.0%)        l >>= 8;
    .             }
   16 (0.0%)      *(p++) = i | 0x80;
    4 (0.0%)      l = i;
   32 (0.0%)      while (i-- > 0) {
   24 (0.0%)        p[i] = length & 0xff;
    4 (0.0%)        length >>= 8;
    .             }
    6 (0.0%)      p += l;
    .           }
  183 (0.0%)    *pp = p;
  183 (0.0%)  }
    .         
1,176 (0.0%)  int ASN1_object_size(int constructed, int length, int tag) {
  196 (0.0%)    int ret = 1;
  392 (0.0%)    if (length < 0) {
    .             return -1;
    .           }
  392 (0.0%)    if (tag >= 31) {
    .             while (tag > 0) {
    .               tag >>= 7;
    .               ret++;
    .             }
    .           }
  392 (0.0%)    if (constructed == 2) {
    .             ret += 3;
    .           } else {
  196 (0.0%)      ret++;
  392 (0.0%)      if (length > 127) {
    8 (0.0%)        int tmplen = length;
   28 (0.0%)        while (tmplen > 0) {
    8 (0.0%)          tmplen >>= 8;
    8 (0.0%)          ret++;
    .               }
    .             }
    .           }
  784 (0.0%)    if (ret >= INT_MAX - length) {
    .             return -1;
    .           }
  588 (0.0%)    return ret + length;
  392 (0.0%)  }
    .         
    .         int ASN1_STRING_copy(ASN1_STRING *dst, const ASN1_STRING *str) {
    .           if (str == NULL) {
    .             return 0;
    .           }
    .           if (!ASN1_STRING_set(dst, str->data, str->length)) {
    .             return 0;
    .           }
-- line 261 ----------------------------------------
-- line 275 ----------------------------------------
    .           }
    .           if (!ASN1_STRING_copy(ret, str)) {
    .             ASN1_STRING_free(ret);
    .             return NULL;
    .           }
    .           return ret;
    .         }
    .         
  259 (0.0%)  int ASN1_STRING_set(ASN1_STRING *str, const void *_data, ossl_ssize_t len_s) {
   74 (0.0%)    const char *data = _data;
    .           size_t len;
   74 (0.0%)    if (len_s < 0) {
    .             if (data == NULL) {
    .               return 0;
    .             }
    .             len = strlen(data);
    .           } else {
   74 (0.0%)      len = (size_t)len_s;
    .           }
    .         
    .           OPENSSL_STATIC_ASSERT(ASN1_STRING_MAX < INT_MAX, len_will_not_overflow_int);
   74 (0.0%)    if (len > ASN1_STRING_MAX) {
    .             OPENSSL_PUT_ERROR(ASN1, ERR_R_OVERFLOW);
    .             return 0;
    .           }
    .         
  185 (0.0%)    if (str->length <= (int)len || str->data == NULL) {
  111 (0.0%)      unsigned char *c = str->data;
   74 (0.0%)      if (c == NULL) {
  259 (0.0%)        str->data = OPENSSL_malloc(len + 1);
    .             } else {
    .               str->data = OPENSSL_realloc(c, len + 1);
    .             }
    .         
  148 (0.0%)      if (str->data == NULL) {
    .               str->data = c;
    .               return 0;
    .             }
    .           }
  148 (0.0%)    str->length = (int)len;
   74 (0.0%)    if (data != NULL) {
  259 (0.0%)      OPENSSL_memcpy(str->data, data, len);
    .             // Historically, OpenSSL would NUL-terminate most (but not all)
    .             // |ASN1_STRING|s, in case anyone accidentally passed |str->data| into a
    .             // function expecting a C string. We retain this behavior for compatibility,
    .             // but code must not rely on this. See CVE-2021-3712.
  185 (0.0%)      str->data[len] = '\0';
    .           }
   37 (0.0%)    return 1;
   74 (0.0%)  }
    .         
   14 (0.0%)  void ASN1_STRING_set0(ASN1_STRING *str, void *data, int len) {
    8 (0.0%)    OPENSSL_free(str->data);
    6 (0.0%)    str->data = data;
    6 (0.0%)    str->length = len;
    6 (0.0%)  }
    .         
    .         ASN1_STRING *ASN1_STRING_new(void) {
    .           return (ASN1_STRING_type_new(V_ASN1_OCTET_STRING));
    .         }
    .         
  205 (0.0%)  ASN1_STRING *ASN1_STRING_type_new(int type) {
    .           ASN1_STRING *ret;
    .         
  123 (0.0%)    ret = (ASN1_STRING *)OPENSSL_zalloc(sizeof(ASN1_STRING));
   82 (0.0%)    if (ret == NULL) {
    .             return NULL;
    .           }
  123 (0.0%)    ret->type = type;
   41 (0.0%)    return ret;
   82 (0.0%)  }
    .         
  110 (0.0%)  void ASN1_STRING_free(ASN1_STRING *str) {
   44 (0.0%)    if (str == NULL) {
    9 (0.0%)      return;
    .           }
   52 (0.0%)    OPENSSL_free(str->data);
   52 (0.0%)    OPENSSL_free(str);
   44 (0.0%)  }
    .         
    .         void ASN1_STRING_clear_free(ASN1_STRING *str) {
    .           ASN1_STRING_free(str);
    .         }
    .         
   36 (0.0%)  int ASN1_STRING_cmp(const ASN1_STRING *a, const ASN1_STRING *b) {
    .           // Capture padding bits and implicit truncation in BIT STRINGs.
   24 (0.0%)    int a_length = a->length, b_length = b->length;
    8 (0.0%)    uint8_t a_padding = 0, b_padding = 0;
   16 (0.0%)    if (a->type == V_ASN1_BIT_STRING) {
    .             a_length = asn1_bit_string_length(a, &a_padding);
    .           }
   16 (0.0%)    if (b->type == V_ASN1_BIT_STRING) {
    .             b_length = asn1_bit_string_length(b, &b_padding);
    .           }
    .         
   12 (0.0%)    if (a_length < b_length) {
    .             return -1;
    .           }
   12 (0.0%)    if (a_length > b_length) {
    .             return 1;
    .           }
    .           // In a BIT STRING, the number of bits is 8 * length - padding. Invert this
    .           // comparison so we compare by lengths.
   16 (0.0%)    if (a_padding > b_padding) {
    .             return -1;
    .           }
   16 (0.0%)    if (a_padding < b_padding) {
    .             return 1;
    .           }
    .         
   40 (0.0%)    int ret = OPENSSL_memcmp(a->data, b->data, a_length);
    8 (0.0%)    if (ret != 0) {
    .             return ret;
    .           }
    .         
    .           // Comparing the type first is more natural, but this matches OpenSSL.
   24 (0.0%)    if (a->type < b->type) {
    .             return -1;
    .           }
   24 (0.0%)    if (a->type > b->type) {
    .             return 1;
    .           }
    4 (0.0%)    return 0;
   20 (0.0%)  }
    .         
    8 (0.0%)  int ASN1_STRING_length(const ASN1_STRING *str) { return str->length; }
    .         
    .         int ASN1_STRING_type(const ASN1_STRING *str) { return str->type; }
    .         
    8 (0.0%)  unsigned char *ASN1_STRING_data(ASN1_STRING *str) { return str->data; }
    .         
    .         const unsigned char *ASN1_STRING_get0_data(const ASN1_STRING *str) {
    .           return str->data;
    .         }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 121 ----------------------------------------
    .             B_ASN1_GRAPHICSTRING,
    .             B_ASN1_ISO64STRING,
    .             B_ASN1_GENERALSTRING,
    .             B_ASN1_UNIVERSALSTRING,
    .             B_ASN1_UNKNOWN,  // CHARACTER STRING
    .             B_ASN1_BMPSTRING,
    .         };
    .         
  104 (0.0%)  unsigned long ASN1_tag2bit(int tag) {
  104 (0.0%)    if (tag < 0 || tag > 30) {
    .             return 0;
    .           }
  130 (0.0%)    return tag2bit[tag];
   52 (0.0%)  }
    .         
    .         // Macro to initialize and invalidate the cache
    .         
    .         // Decode an ASN1 item, this currently behaves just like a standard 'd2i'
    .         // function. 'in' points to a buffer to read the data from, in future we
    .         // will have more advanced versions that can input data a piece at a time and
    .         // this will simply be a special case.
    .         
    .         ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
  110 (0.0%)                            const ASN1_ITEM *it) {
   10 (0.0%)    ASN1_VALUE *ptmpval = NULL;
   20 (0.0%)    if (!pval) {
   20 (0.0%)      pval = &ptmpval;
    .           }
    .         
  130 (0.0%)    if (asn1_item_ex_d2i(pval, in, len, it, -1, 0, 0, 0) > 0) {
   30 (0.0%)      return *pval;
    .           }
    .           return NULL;
   50 (0.0%)  }
    .         
    .         // Decode an item, taking care of IMPLICIT tagging, if any. If 'opt' set and
    .         // tag mismatch return -1 to handle OPTIONAL
    .         
    .         static int asn1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in,
    .                                     long len, const ASN1_ITEM *it, int tag, int aclass,
1,680 (0.0%)                              char opt, int depth) {
  112 (0.0%)    const ASN1_TEMPLATE *tt, *errtt = NULL;
    .           const ASN1_EXTERN_FUNCS *ef;
  112 (0.0%)    const unsigned char *p = NULL, *q;
    .           unsigned char oclass;
    .           char cst, isopt;
    .           int i;
    .           int otag;
  112 (0.0%)    int ret = 0;
    .           ASN1_VALUE **pchptr;
  336 (0.0%)    int combine = aclass & ASN1_TFLG_COMBINE;
  112 (0.0%)    aclass &= ~ASN1_TFLG_COMBINE;
  448 (0.0%)    if (pval == NULL || it == NULL) {
    .             return 0;
    .           }
    .         
    .           // Bound |len| to comfortably fit in an int. Lengths in this module often
    .           // switch between int and long without overflow checks.
  336 (0.0%)    if (len > INT_MAX / 2) {
    .             len = INT_MAX / 2;
    .           }
    .         
  336 (0.0%)    if (++depth > ASN1_MAX_CONSTRUCTED_NEST) {
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_TOO_DEEP);
    .             goto err;
    .           }
    .         
1,456 (0.0%)    switch (it->itype) {
    .             case ASN1_ITYPE_PRIMITIVE:
  252 (0.0%)        if (it->templates) {
    .                 // tagging or OPTIONAL is currently illegal on an item template
    .                 // because the flags can't get passed down. In practice this
    .                 // isn't a problem: we include the relevant flags from the item
    .                 // template in the template itself.
   68 (0.0%)          if ((tag != -1) || opt) {
    .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
    .                   goto err;
    .                 }
  204 (0.0%)          return asn1_template_ex_d2i(pval, in, len, it->templates, opt, depth);
    .               }
  598 (0.0%)        return asn1_d2i_ex_primitive(pval, in, len, it, tag, aclass, opt);
    .               break;
    .         
    .             case ASN1_ITYPE_MSTRING:
    .               // It never makes sense for multi-strings to have implicit tagging, so
    .               // if tag != -1, then this looks like an error in the template.
   28 (0.0%)        if (tag != -1) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
    .                 goto err;
    .               }
    .         
   42 (0.0%)        p = *in;
    .               // Just read in tag and class
  224 (0.0%)        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, &p, len, -1, 0, 1);
   28 (0.0%)        if (!ret) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .                 goto err;
    .               }
    .         
    .               // Must be UNIVERSAL class
   42 (0.0%)        if (oclass != V_ASN1_UNIVERSAL) {
    .                 // If OPTIONAL, assume this is OK
    .                 if (opt) {
    .                   return -1;
    .                 }
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_MSTRING_NOT_UNIVERSAL);
    .                 goto err;
    .               }
    .               // Check tag matches bit map
  140 (0.0%)        if (!(ASN1_tag2bit(otag) & it->utype)) {
    .                 // If OPTIONAL, assume this is OK
    .                 if (opt) {
    .                   return -1;
    .                 }
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_MSTRING_WRONG_TAG);
    .                 goto err;
    .               }
  182 (0.0%)        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0);
    .         
    .             case ASN1_ITYPE_EXTERN:
    .               // Use new style d2i
    6 (0.0%)        ef = it->funcs;
   30 (0.0%)        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, NULL);
    .         
    .             case ASN1_ITYPE_CHOICE: {
    .               // It never makes sense for CHOICE types to have implicit tagging, so if
    .               // tag != -1, then this looks like an error in the template.
    6 (0.0%)        if (tag != -1) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
    .                 goto err;
    .               }
    .         
    9 (0.0%)        const ASN1_AUX *aux = it->funcs;
   12 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
    6 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL)) {
    .                 goto auxerr;
    .               }
    .         
   12 (0.0%)        if (*pval) {
    .                 // Free up and zero CHOICE value if initialised
    .                 i = asn1_get_choice_selector(pval, it);
    .                 if ((i >= 0) && (i < it->tcount)) {
    .                   tt = it->templates + i;
    .                   pchptr = asn1_get_field_ptr(pval, tt);
    .                   ASN1_template_free(pchptr, tt);
    .                   asn1_set_choice_selector(pval, -1, it);
    .                 }
   21 (0.0%)        } else if (!ASN1_item_ex_new(pval, it)) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .                 goto err;
    .               }
    .               // CHOICE type, try each possibility in turn
    9 (0.0%)        p = *in;
   81 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
   54 (0.0%)          pchptr = asn1_get_field_ptr(pval, tt);
    .                 // We mark field as OPTIONAL so its absence can be recognised.
   90 (0.0%)          ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, depth);
    .                 // If field not present, try the next one
   18 (0.0%)          if (ret == -1) {
    6 (0.0%)            continue;
    .                 }
    .                 // If positive return, read OK, break loop
    6 (0.0%)          if (ret > 0) {
    3 (0.0%)            break;
    .                 }
    .                 // Otherwise must be an ASN1 parsing error
    .                 errtt = tt;
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .                 goto err;
    .               }
    .         
    .               // Did we fall off the end without reading anything?
   18 (0.0%)        if (i == it->tcount) {
    .                 // If OPTIONAL, this is OK
    .                 if (opt) {
    .                   // Free and zero it
    .                   ASN1_item_ex_free(pval, it);
    .                   return -1;
    .                 }
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NO_MATCHING_CHOICE_TYPE);
    .                 goto err;
    .               }
    .         
   18 (0.0%)        asn1_set_choice_selector(pval, i, it);
    6 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL)) {
    .                 goto auxerr;
    .               }
    9 (0.0%)        *in = p;
    6 (0.0%)        return 1;
    .             }
    .         
    .             case ASN1_ITYPE_SEQUENCE: {
   90 (0.0%)        p = *in;
    .         
    .               // If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL
   60 (0.0%)        if (tag == -1) {
   27 (0.0%)          tag = V_ASN1_SEQUENCE;
   27 (0.0%)          aclass = V_ASN1_UNIVERSAL;
    .               }
    .               // Get SEQUENCE length and update len, p
  600 (0.0%)        ret = asn1_check_tlen(&len, NULL, NULL, &cst, &p, len, tag, aclass, opt);
   60 (0.0%)        if (!ret) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .                 goto err;
   60 (0.0%)        } else if (ret == -1) {
    6 (0.0%)          return -1;
    .               }
   81 (0.0%)        if (!cst) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
    .                 goto err;
    .               }
    .         
  255 (0.0%)        if (!*pval && !ASN1_item_ex_new(pval, it)) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .                 goto err;
    .               }
    .         
   81 (0.0%)        const ASN1_AUX *aux = it->funcs;
  114 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
   72 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL)) {
    .                 goto auxerr;
    .               }
    .         
    .               // Free up and zero any ADB found
  849 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
  345 (0.0%)          if (tt->flags & ASN1_TFLG_ADB_MASK) {
    .                   const ASN1_TEMPLATE *seqtt;
    .                   ASN1_VALUE **pseqval;
    .                   seqtt = asn1_do_adb(pval, tt, 0);
    .                   if (seqtt == NULL) {
    .                     continue;
    .                   }
    .                   pseqval = asn1_get_field_ptr(pval, seqtt);
    .                   ASN1_template_free(pseqval, seqtt);
    .                 }
    .               }
    .         
    .               // Get each field entry
  806 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
    .                 const ASN1_TEMPLATE *seqtt;
    .                 ASN1_VALUE **pseqval;
  469 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
  134 (0.0%)          if (seqtt == NULL) {
    .                   goto err;
    .                 }
  402 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
    .                 // Have we ran out of data?
  201 (0.0%)          if (!len) {
    6 (0.0%)            break;
    .                 }
  122 (0.0%)          q = p;
    .                 // This determines the OPTIONAL flag value. The field cannot be
    .                 // omitted if it is the last of a SEQUENCE and there is still
    .                 // data to be read. This isn't strictly necessary but it
    .                 // increases efficiency in some cases.
  427 (0.0%)          if (i == (it->tcount - 1)) {
   42 (0.0%)            isopt = 0;
    .                 } else {
  240 (0.0%)            isopt = (seqtt->flags & ASN1_TFLG_OPTIONAL) != 0;
    .                 }
    .                 // attempt to read in field, allowing each to be OPTIONAL
    .         
  671 (0.0%)          ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, depth);
  122 (0.0%)          if (!ret) {
    .                   errtt = seqtt;
    .                   goto err;
  122 (0.0%)          } else if (ret == -1) {
    .                   // OPTIONAL component absent. Free and zero the field.
   25 (0.0%)            ASN1_template_free(pseqval, seqtt);
    5 (0.0%)            continue;
    .                 }
    .                 // Update length
  280 (0.0%)          len -= p - q;
    .               }
    .         
    .               // Check all data read
   81 (0.0%)        if (len) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
    .                 goto err;
    .               }
    .         
    .               // If we get here we've got no more data in the SEQUENCE, however we
    .               // may not have read all fields so check all remaining are OPTIONAL
    .               // and clear any that are.
  226 (0.0%)        for (; i < it->tcount; tt++, i++) {
    .                 const ASN1_TEMPLATE *seqtt;
   56 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
   16 (0.0%)          if (seqtt == NULL) {
    .                   goto err;
    .                 }
   40 (0.0%)          if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
    .                   ASN1_VALUE **pseqval;
   48 (0.0%)            pseqval = asn1_get_field_ptr(pval, seqtt);
   48 (0.0%)            ASN1_template_free(pseqval, seqtt);
    .                 } else {
    .                   errtt = seqtt;
    .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_FIELD_MISSING);
    .                   goto err;
    .                 }
    .               }
    .               // Save encoding
  405 (0.0%)        if (!asn1_enc_save(pval, *in, p - *in, it)) {
    .                 goto auxerr;
    .               }
   72 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL)) {
    .                 goto auxerr;
    .               }
   81 (0.0%)        *in = p;
   54 (0.0%)        return 1;
    .             }
    .         
    .             default:
    .               return 0;
    .           }
    .         auxerr:
    .           OPENSSL_PUT_ERROR(ASN1, ASN1_R_AUX_ERROR);
    .         err:
-- line 437 ----------------------------------------
-- line 439 ----------------------------------------
    .             ASN1_item_ex_free(pval, it);
    .           }
    .           if (errtt) {
    .             ERR_add_error_data(4, "Field=", errtt->field_name, ", Type=", it->sname);
    .           } else {
    .             ERR_add_error_data(2, "Type=", it->sname);
    .           }
    .           return 0;
  560 (0.0%)  }
    .         
    .         int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
    .                              const ASN1_ITEM *it, int tag, int aclass, char opt,
   24 (0.0%)                       ASN1_TLC *ctx) {
   24 (0.0%)    return asn1_item_ex_d2i(pval, in, len, it, tag, aclass, opt, 0);
    4 (0.0%)  }
    .         
    .         // Templates are handled with two separate functions. One handles any
    .         // EXPLICIT tag and the other handles the rest.
    .         
    .         static int asn1_template_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
    .                                         long inlen, const ASN1_TEMPLATE *tt, char opt,
1,218 (0.0%)                                  int depth) {
    .           int aclass;
    .           int ret;
    .           long len;
    .           const unsigned char *p, *q;
  174 (0.0%)    if (!val) {
    .             return 0;
    .           }
  261 (0.0%)    uint32_t flags = tt->flags;
  261 (0.0%)    aclass = flags & ASN1_TFLG_TAG_CLASS;
    .         
  261 (0.0%)    p = *in;
    .         
    .           // Check if EXPLICIT tag expected
  348 (0.0%)    if (flags & ASN1_TFLG_EXPTAG) {
    .             char cst;
    .             // Need to work out amount of data available to the inner content and
    .             // where it starts: so read in EXPLICIT header to get the info.
   42 (0.0%)      ret = asn1_check_tlen(&len, NULL, NULL, &cst, &p, inlen, tt->tag, aclass,
    .                                   opt);
    4 (0.0%)      q = p;
    4 (0.0%)      if (!ret) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .               return 0;
    4 (0.0%)      } else if (ret == -1) {
    .               return -1;
    .             }
    6 (0.0%)      if (!cst) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);
    .               return 0;
    .             }
    .             // We've found the field so it can't be OPTIONAL now
   20 (0.0%)      ret = asn1_template_noexp_d2i(val, &p, len, tt, 0, depth);
    4 (0.0%)      if (!ret) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .               return 0;
    .             }
    .             // We read the field in OK so update length
   10 (0.0%)      len -= p - q;
    .             // Check for trailing data.
    6 (0.0%)      if (len) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_EXPLICIT_LENGTH_MISMATCH);
    .               goto err;
    .             }
    .           } else {
  935 (0.0%)      return asn1_template_noexp_d2i(val, in, inlen, tt, opt, depth);
    .           }
    .         
    6 (0.0%)    *in = p;
    2 (0.0%)    return 1;
    .         
    .         err:
    .           ASN1_template_free(val, tt);
    .           return 0;
  435 (0.0%)  }
    .         
    .         static int asn1_template_noexp_d2i(ASN1_VALUE **val, const unsigned char **in,
    .                                            long len, const ASN1_TEMPLATE *tt, char opt,
1,218 (0.0%)                                     int depth) {
    .           int aclass;
    .           int ret;
    .           const unsigned char *p;
  174 (0.0%)    if (!val) {
    .             return 0;
    .           }
  261 (0.0%)    uint32_t flags = tt->flags;
  261 (0.0%)    aclass = flags & ASN1_TFLG_TAG_CLASS;
    .         
  261 (0.0%)    p = *in;
    .         
  348 (0.0%)    if (flags & ASN1_TFLG_SK_MASK) {
    .             // SET OF, SEQUENCE OF
    .             int sktag, skaclass;
    .             // First work out expected inner tag value
   72 (0.0%)      if (flags & ASN1_TFLG_IMPTAG) {
    .               sktag = tt->tag;
    .               skaclass = aclass;
    .             } else {
   18 (0.0%)        skaclass = V_ASN1_UNIVERSAL;
   72 (0.0%)        if (flags & ASN1_TFLG_SET_OF) {
   24 (0.0%)          sktag = V_ASN1_SET;
    .               } else {
    6 (0.0%)          sktag = V_ASN1_SEQUENCE;
    .               }
    .             }
    .             // Get the tag
    .             ret =
  342 (0.0%)          asn1_check_tlen(&len, NULL, NULL, NULL, &p, len, sktag, skaclass, opt);
   36 (0.0%)      if (!ret) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .               return 0;
   36 (0.0%)      } else if (ret == -1) {
    .               return -1;
    .             }
   72 (0.0%)      if (!*val) {
   72 (0.0%)        *val = (ASN1_VALUE *)sk_ASN1_VALUE_new_null();
    .             } else {
    .               // We've got a valid STACK: free up any items present
    .               STACK_OF(ASN1_VALUE) *sktmp = (STACK_OF(ASN1_VALUE) *)*val;
    .               ASN1_VALUE *vtmp;
    .               while (sk_ASN1_VALUE_num(sktmp) > 0) {
    .                 vtmp = sk_ASN1_VALUE_pop(sktmp);
    .                 ASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item));
    .               }
    .             }
    .         
   72 (0.0%)      if (!*val) {
    .               goto err;
    .             }
    .         
    .             // Read as many items as we can
  183 (0.0%)      while (len > 0) {
    .               ASN1_VALUE *skfield;
   62 (0.0%)        const unsigned char *q = p;
   31 (0.0%)        skfield = NULL;
  465 (0.0%)        if (!asn1_item_ex_d2i(&skfield, &p, len, ASN1_ITEM_ptr(tt->item), -1, 0,
    .                                     0, depth)) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .                 goto err;
    .               }
  155 (0.0%)        len -= p - q;
  248 (0.0%)        if (!sk_ASN1_VALUE_push((STACK_OF(ASN1_VALUE) *)*val, skfield)) {
    .                 ASN1_item_ex_free(&skfield, ASN1_ITEM_ptr(tt->item));
    .                 goto err;
    .               }
    .             }
  276 (0.0%)    } else if (flags & ASN1_TFLG_IMPTAG) {
    .             // IMPLICIT tagging
  221 (0.0%)      ret = asn1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), tt->tag,
    .                                    aclass, opt, depth);
   26 (0.0%)      if (!ret) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .               goto err;
   26 (0.0%)      } else if (ret == -1) {
   16 (0.0%)        return -1;
    .             }
    .           } else {
    .             // Nothing special
  896 (0.0%)      ret = asn1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), -1,
  112 (0.0%)                             tt->flags & ASN1_TFLG_COMBINE, opt, depth);
  112 (0.0%)      if (!ret) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .               goto err;
  112 (0.0%)      } else if (ret == -1) {
    6 (0.0%)        return -1;
    .             }
    .           }
    .         
  228 (0.0%)    *in = p;
  152 (0.0%)    return 1;
    .         
    .         err:
    .           ASN1_template_free(val, tt);
    .           return 0;
  435 (0.0%)  }
    .         
    .         static int asn1_d2i_ex_primitive(ASN1_VALUE **pval, const unsigned char **in,
    .                                          long inlen, const ASN1_ITEM *it, int tag,
  900 (0.0%)                                   int aclass, char opt) {
   60 (0.0%)    int ret = 0, utype;
    .           long plen;
    .           char cst;
    .           const unsigned char *p;
   60 (0.0%)    const unsigned char *cont = NULL;
    .           long len;
  120 (0.0%)    if (!pval) {
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_NULL);
    .             return 0;  // Should never happen
    .           }
    .         
  240 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
   28 (0.0%)      utype = tag;
   28 (0.0%)      tag = -1;
    .           } else {
  138 (0.0%)      utype = it->utype;
    .           }
    .         
  180 (0.0%)    if (utype == V_ASN1_ANY) {
    .             // If type is ANY need to figure out type from tag
    .             unsigned char oclass;
    2 (0.0%)      if (tag >= 0) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_TAGGED_ANY);
    .               return 0;
    .             }
    2 (0.0%)      if (opt) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OPTIONAL_ANY);
    .               return 0;
    .             }
    3 (0.0%)      p = *in;
   16 (0.0%)      ret = asn1_check_tlen(NULL, &utype, &oclass, NULL, &p, inlen, -1, 0, 0);
    2 (0.0%)      if (!ret) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .               return 0;
    .             }
    3 (0.0%)      if (oclass != V_ASN1_UNIVERSAL) {
    .               utype = V_ASN1_OTHER;
    .             }
    .           }
  120 (0.0%)    if (tag == -1) {
  100 (0.0%)      tag = utype;
   50 (0.0%)      aclass = V_ASN1_UNIVERSAL;
    .           }
  180 (0.0%)    p = *in;
    .           // Check header
1,200 (0.0%)    ret = asn1_check_tlen(&plen, NULL, NULL, &cst, &p, inlen, tag, aclass, opt);
  120 (0.0%)    if (!ret) {
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
    .             return 0;
  120 (0.0%)    } else if (ret == -1) {
   16 (0.0%)      return -1;
    .           }
   52 (0.0%)    ret = 0;
    .           // SEQUENCE, SET and "OTHER" are left in encoded form
  416 (0.0%)    if ((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||
   52 (0.0%)        (utype == V_ASN1_OTHER)) {
    .             // SEQUENCE and SET must be constructed
    .             if (utype != V_ASN1_OTHER && !cst) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_TYPE_NOT_CONSTRUCTED);
    .               return 0;
    .             }
    .         
    .             cont = *in;
    .             len = p - cont + plen;
    .             p += plen;
  156 (0.0%)    } else if (cst) {
    .             // This parser historically supported BER constructed strings. We no
    .             // longer do and will gradually tighten this parser into a DER
    .             // parser. BER types should use |CBS_asn1_ber_to_der|.
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_TYPE_NOT_PRIMITIVE);
    .             return 0;
    .           } else {
  104 (0.0%)      cont = p;
  104 (0.0%)      len = plen;
  208 (0.0%)      p += plen;
    .           }
    .         
    .           // We now have content length and type: translate into a structure
  520 (0.0%)    if (!asn1_ex_c2i(pval, cont, len, utype, it)) {
    .             goto err;
    .           }
    .         
  156 (0.0%)    *in = p;
  104 (0.0%)    ret = 1;
    .         err:
   52 (0.0%)    return ret;
  300 (0.0%)  }
    .         
    .         // Translate ASN1 content octets into a structure
    .         
    .         static int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, long len,
  624 (0.0%)                         int utype, const ASN1_ITEM *it) {
   52 (0.0%)    ASN1_VALUE **opval = NULL;
    .           ASN1_STRING *stmp;
   52 (0.0%)    ASN1_TYPE *typ = NULL;
   52 (0.0%)    int ret = 0;
    .           ASN1_INTEGER **tint;
    .         
    .           // Historically, |it->funcs| for primitive types contained an
    .           // |ASN1_PRIMITIVE_FUNCS| table of callbacks.
  208 (0.0%)    assert(it->funcs == NULL);
    .         
    .           // If ANY type clear type and set pointer to internal value
  208 (0.0%)    if (it->utype == V_ASN1_ANY) {
    4 (0.0%)      if (!*pval) {
    2 (0.0%)        typ = ASN1_TYPE_new();
    2 (0.0%)        if (typ == NULL) {
    .                 goto err;
    .               }
    4 (0.0%)        *pval = (ASN1_VALUE *)typ;
    .             } else {
    .               typ = (ASN1_TYPE *)*pval;
    .             }
    .         
    4 (0.0%)      if (utype != typ->type) {
    6 (0.0%)        ASN1_TYPE_set(typ, utype, NULL);
    .             }
    2 (0.0%)      opval = pval;
    3 (0.0%)      pval = &typ->value.asn1_value;
    .           }
  384 (0.0%)    switch (utype) {
    .             case V_ASN1_OBJECT:
  160 (0.0%)        if (!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, &cont, len)) {
    .                 goto err;
    .               }
   40 (0.0%)        break;
    .         
    .             case V_ASN1_NULL:
    .               if (len) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NULL_IS_WRONG_LENGTH);
    .                 goto err;
    .               }
    .               *pval = (ASN1_VALUE *)1;
    .               break;
    .         
    .             case V_ASN1_BOOLEAN:
    6 (0.0%)        if (len != 1) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BOOLEAN_IS_WRONG_LENGTH);
    .                 goto err;
    .               } else {
    .                 ASN1_BOOLEAN *tbool;
    6 (0.0%)          tbool = (ASN1_BOOLEAN *)pval;
   15 (0.0%)          *tbool = *cont;
    .               }
    3 (0.0%)        break;
    .         
    .             case V_ASN1_BIT_STRING:
   16 (0.0%)        if (!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, &cont, len)) {
    .                 goto err;
    .               }
    4 (0.0%)        break;
    .         
    .             case V_ASN1_INTEGER:
    .             case V_ASN1_ENUMERATED:
    4 (0.0%)        tint = (ASN1_INTEGER **)pval;
   16 (0.0%)        if (!c2i_ASN1_INTEGER(tint, &cont, len)) {
    .                 goto err;
    .               }
    .               // Fixup type to match the expected form
   18 (0.0%)        (*tint)->type = utype | ((*tint)->type & V_ASN1_NEG);
    2 (0.0%)        break;
    .         
    .             case V_ASN1_OCTET_STRING:
    .             case V_ASN1_NUMERICSTRING:
    .             case V_ASN1_PRINTABLESTRING:
    .             case V_ASN1_T61STRING:
    .             case V_ASN1_VIDEOTEXSTRING:
    .             case V_ASN1_IA5STRING:
    .             case V_ASN1_UTCTIME:
-- line 787 ----------------------------------------
-- line 791 ----------------------------------------
    .             case V_ASN1_GENERALSTRING:
    .             case V_ASN1_UNIVERSALSTRING:
    .             case V_ASN1_BMPSTRING:
    .             case V_ASN1_UTF8STRING:
    .             case V_ASN1_OTHER:
    .             case V_ASN1_SET:
    .             case V_ASN1_SEQUENCE:
    .             default:
   50 (0.0%)        if (utype == V_ASN1_BMPSTRING && (len & 1)) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
    .                 goto err;
    .               }
   50 (0.0%)        if (utype == V_ASN1_UNIVERSALSTRING && (len & 3)) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
    .                 goto err;
    .               }
   50 (0.0%)        if (utype == V_ASN1_UTCTIME) {
    .                 CBS cbs;
    6 (0.0%)          CBS_init(&cbs, cont, (size_t)len);
    7 (0.0%)          if (!CBS_parse_utc_time(&cbs, NULL, /*allow_timezone_offset=*/1)) {
    .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_TIME_FORMAT);
    .                   goto err;
    .                 }
    .               }
   50 (0.0%)        if (utype == V_ASN1_GENERALIZEDTIME) {
    .                 CBS cbs;
    6 (0.0%)          CBS_init(&cbs, cont, (size_t)len);
    7 (0.0%)          if (!CBS_parse_generalized_time(&cbs, NULL,
    .                                                 /*allow_timezone_offset=*/0)) {
    .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_TIME_FORMAT);
    .                   goto err;
    .                 }
    .               }
    .               // All based on ASN1_STRING and handled the same
  100 (0.0%)        if (!*pval) {
   28 (0.0%)          stmp = ASN1_STRING_type_new(utype);
   14 (0.0%)          if (!stmp) {
    .                   goto err;
    .                 }
   28 (0.0%)          *pval = (ASN1_VALUE *)stmp;
    .               } else {
   54 (0.0%)          stmp = (ASN1_STRING *)*pval;
   54 (0.0%)          stmp->type = utype;
    .               }
  200 (0.0%)        if (!ASN1_STRING_set(stmp, cont, len)) {
    .                 ASN1_STRING_free(stmp);
    .                 *pval = NULL;
    .                 goto err;
    .               }
   25 (0.0%)        break;
    .           }
    .           // If ASN1_ANY and NULL type fix up value
  106 (0.0%)    if (typ && (utype == V_ASN1_NULL)) {
    .             typ->value.ptr = NULL;
    .           }
    .         
  104 (0.0%)    ret = 1;
    .         err:
  104 (0.0%)    if (!ret) {
    .             ASN1_TYPE_free(typ);
    .             if (opval) {
    .               *opval = NULL;
    .             }
    .           }
   52 (0.0%)    return ret;
  260 (0.0%)  }
    .         
    .         // Check an ASN1 tag and length: a bit like ASN1_get_object but it
    .         // checks the expected tag.
    .         
    .         static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,
    .                                    char *cst, const unsigned char **in, long len,
1,875 (0.0%)                             int exptag, int expclass, char opt) {
    .           int i;
    .           int ptag, pclass;
    .           long plen;
    .           const unsigned char *p;
  375 (0.0%)    p = *in;
    .         
1,125 (0.0%)    i = ASN1_get_object(&p, &plen, &ptag, &pclass, len);
  500 (0.0%)    if (i & 0x80) {
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_OBJECT_HEADER);
    .             return 0;
    .           }
  250 (0.0%)    if (exptag >= 0) {
  627 (0.0%)      if ((exptag != ptag) || (expclass != pclass)) {
    .               // If type is OPTIONAL, not an error: indicate missing type.
   22 (0.0%)        if (opt) {
   22 (0.0%)          return -1;
    .               }
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TAG);
    .               return 0;
    .             }
    .           }
    .         
  228 (0.0%)    if (cst) {
  405 (0.0%)      *cst = i & V_ASN1_CONSTRUCTED;
    .           }
    .         
  228 (0.0%)    if (olen) {
  297 (0.0%)      *olen = plen;
    .           }
    .         
  228 (0.0%)    if (oclass) {
   60 (0.0%)      *oclass = pclass;
    .           }
    .         
  228 (0.0%)    if (otag) {
   45 (0.0%)      *otag = ptag;
    .           }
    .         
  342 (0.0%)    *in = p;
  114 (0.0%)    return 1;
  625 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 78 ----------------------------------------
    .         static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
    .                                     int skcontlen, const ASN1_ITEM *item, int do_sort);
    .         static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
    .                                         const ASN1_TEMPLATE *tt, int tag, int aclass,
    .                                         int optional);
    .         
    .         // Top level i2d equivalents
    .         
   30 (0.0%)  int ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it) {
   18 (0.0%)    if (out && !*out) {
    .             unsigned char *p, *buf;
   24 (0.0%)      int len = ASN1_item_ex_i2d(&val, NULL, it, /*tag=*/-1, /*aclass=*/0);
    6 (0.0%)      if (len <= 0) {
    .               return len;
    .             }
   15 (0.0%)      buf = OPENSSL_malloc(len);
    6 (0.0%)      if (!buf) {
    .               return -1;
    .             }
    6 (0.0%)      p = buf;
   24 (0.0%)      int len2 = ASN1_item_ex_i2d(&val, &p, it, /*tag=*/-1, /*aclass=*/0);
    6 (0.0%)      if (len2 <= 0) {
    .               OPENSSL_free(buf);
    .               return len2;
    .             }
    9 (0.0%)      assert(len == len2);
    9 (0.0%)      *out = buf;
    6 (0.0%)      return len;
    .           }
    .         
    .           return ASN1_item_ex_i2d(&val, out, it, /*tag=*/-1, /*aclass=*/0);
   15 (0.0%)  }
    .         
    .         // Encode an item, taking care of IMPLICIT tagging (if any). This function
    .         // performs the normal item handling: it can be used in external types.
    .         
    .         int ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
  594 (0.0%)                       const ASN1_ITEM *it, int tag, int aclass) {
  660 (0.0%)    int ret = asn1_item_ex_i2d_opt(pval, out, it, tag, aclass, /*optional=*/0);
  132 (0.0%)    assert(ret != 0);
   66 (0.0%)    return ret;
  132 (0.0%)  }
    .         
    .         // asn1_item_ex_i2d_opt behaves like |ASN1_item_ex_i2d| but, if |optional| is
    .         // non-zero and |*pval| is omitted, it returns zero and writes no bytes.
    .         int asn1_item_ex_i2d_opt(ASN1_VALUE **pval, unsigned char **out,
    .                                  const ASN1_ITEM *it, int tag, int aclass,
2,730 (0.0%)                           int optional) {
  210 (0.0%)    const ASN1_TEMPLATE *tt = NULL;
    .           int i, seqcontlen, seqlen;
    .         
    .           // Historically, |aclass| was repurposed to pass additional flags into the
    .           // encoding process.
  840 (0.0%)    assert((aclass & ASN1_TFLG_TAG_CLASS) == aclass);
    .           // If not overridding the tag, |aclass| is ignored and should be zero.
  840 (0.0%)    assert(tag != -1 || aclass == 0);
    .         
    .           // All fields are pointers, except for boolean |ASN1_ITYPE_PRIMITIVE|s.
    .           // Optional primitives are handled later.
1,260 (0.0%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) {
    .             if (optional) {
    .               return 0;
    .             }
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
    .             return -1;
    .           }
    .         
2,730 (0.0%)    switch (it->itype) {
    .             case ASN1_ITYPE_PRIMITIVE:
  420 (0.0%)        if (it->templates) {
    .                 // This is an |ASN1_ITEM_TEMPLATE|.
  144 (0.0%)          if (it->templates->flags & ASN1_TFLG_OPTIONAL) {
    .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
    .                   return -1;
    .                 }
  288 (0.0%)          return asn1_template_ex_i2d(pval, out, it->templates, tag, aclass,
    .                                             optional);
    .               }
  891 (0.0%)        return asn1_i2d_ex_primitive(pval, out, it, tag, aclass, optional);
    .         
    .             case ASN1_ITYPE_MSTRING:
    .               // It never makes sense for multi-strings to have implicit tagging, so
    .               // if tag != -1, then this looks like an error in the template.
   96 (0.0%)        if (tag != -1) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
    .                 return -1;
    .               }
  480 (0.0%)        return asn1_i2d_ex_primitive(pval, out, it, -1, 0, optional);
    .         
    .             case ASN1_ITYPE_CHOICE: {
    .               // It never makes sense for CHOICE types to have implicit tagging, so if
    .               // tag != -1, then this looks like an error in the template.
    .               if (tag != -1) {
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
    .                 return -1;
    .               }
-- line 173 ----------------------------------------
-- line 195 ----------------------------------------
    .                 // must be pointers.
    .                 OPENSSL_PUT_ERROR(ASN1, ERR_R_INTERNAL_ERROR);
    .                 return -1;
    .               }
    .               return ret;
    .             }
    .         
    .             case ASN1_ITYPE_SEQUENCE: {
  399 (0.0%)        i = asn1_enc_restore(&seqcontlen, out, pval, it);
    .               // An error occurred
  114 (0.0%)        if (i < 0) {
    .                 return -1;
    .               }
    .               // We have a valid cached encoding...
  114 (0.0%)        if (i > 0) {
   12 (0.0%)          return seqcontlen;
    .               }
    .               // Otherwise carry on
   51 (0.0%)        seqcontlen = 0;
    .               // If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL
  102 (0.0%)        if (tag == -1) {
   51 (0.0%)          tag = V_ASN1_SEQUENCE;
   51 (0.0%)          aclass = V_ASN1_UNIVERSAL;
    .               }
    .               // First work out sequence content length
1,409 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
    .                 const ASN1_TEMPLATE *seqtt;
    .                 ASN1_VALUE **pseqval;
    .                 int tmplen;
  742 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
  212 (0.0%)          if (!seqtt) {
    .                   return -1;
    .                 }
  636 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
    .                 tmplen =
  954 (0.0%)              asn1_template_ex_i2d(pseqval, NULL, seqtt, -1, 0, /*optional=*/0);
  742 (0.0%)          if (tmplen == -1 || (tmplen > INT_MAX - seqcontlen)) {
    .                   return -1;
    .                 }
  424 (0.0%)          seqcontlen += tmplen;
    .               }
    .         
  306 (0.0%)        seqlen = ASN1_object_size(/*constructed=*/1, seqcontlen, tag);
  138 (0.0%)        if (!out || seqlen == -1) {
   66 (0.0%)          return seqlen;
    .               }
    .               // Output SEQUENCE header
  144 (0.0%)        ASN1_put_object(out, /*constructed=*/1, seqcontlen, tag, aclass);
  502 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
    .                 const ASN1_TEMPLATE *seqtt;
    .                 ASN1_VALUE **pseqval;
  266 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
   76 (0.0%)          if (!seqtt) {
    .                   return -1;
    .                 }
  228 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
  380 (0.0%)          if (asn1_template_ex_i2d(pseqval, out, seqtt, -1, 0, /*optional=*/0) <
    .                     0) {
    .                   return -1;
    .                 }
    .               }
   36 (0.0%)        return seqlen;
    .             }
    .         
    .             default:
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
    .               return -1;
    .           }
1,050 (0.0%)  }
    .         
    .         // asn1_template_ex_i2d behaves like |asn1_item_ex_i2d_opt| but uses an
    .         // |ASN1_TEMPLATE| instead of an |ASN1_ITEM|. An |ASN1_TEMPLATE| wraps an
    .         // |ASN1_ITEM| with modifiers such as tagging, SEQUENCE or SET, etc.
    .         static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
    .                                         const ASN1_TEMPLATE *tt, int tag, int iclass,
2,184 (0.0%)                                  int optional) {
    .           int i, ret, ttag, tclass;
    .           size_t j;
  504 (0.0%)    uint32_t flags = tt->flags;
    .         
    .           // Historically, |iclass| was repurposed to pass additional flags into the
    .           // encoding process.
  672 (0.0%)    assert((iclass & ASN1_TFLG_TAG_CLASS) == iclass);
    .           // If not overridding the tag, |iclass| is ignored and should be zero.
  672 (0.0%)    assert(tag != -1 || iclass == 0);
    .         
    .           // Work out tag and class to use: tagging may come either from the
    .           // template or the arguments, not both because this would create
    .           // ambiguity.
  672 (0.0%)    if (flags & ASN1_TFLG_TAG_MASK) {
    .             // Error if argument and template tagging
    .             if (tag != -1) {
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
    .               return -1;
    .             }
    .             // Get tagging from template
    .             ttag = tt->tag;
    .             tclass = flags & ASN1_TFLG_TAG_CLASS;
  336 (0.0%)    } else if (tag != -1) {
    .             // No template tagging, get from arguments
    .             ttag = tag;
    .             tclass = iclass & ASN1_TFLG_TAG_CLASS;
    .           } else {
  168 (0.0%)      ttag = -1;
  168 (0.0%)      tclass = 0;
    .           }
    .         
    .           // The template may itself by marked as optional, or this may be the template
    .           // of an |ASN1_ITEM_TEMPLATE| type which was contained inside an outer
    .           // optional template. (They cannot both be true because the
    .           // |ASN1_ITEM_TEMPLATE| codepath rejects optional templates.)
  336 (0.0%)    assert(!optional || (flags & ASN1_TFLG_OPTIONAL) == 0);
1,356 (0.0%)    optional = optional || (flags & ASN1_TFLG_OPTIONAL) != 0;
    .         
    .           // At this point 'ttag' contains the outer tag to use, and 'tclass' is the
    .           // class.
    .         
  672 (0.0%)    if (flags & ASN1_TFLG_SK_MASK) {
    .             // SET OF, SEQUENCE OF
   72 (0.0%)      STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;
    .             int isset, sktag, skaclass;
    .             int skcontlen, sklen;
    .             ASN1_VALUE *skitem;
    .         
   96 (0.0%)      if (!*pval) {
    .               if (optional) {
    .                 return 0;
    .               }
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
    .               return -1;
    .             }
    .         
   96 (0.0%)      if (flags & ASN1_TFLG_SET_OF) {
   24 (0.0%)        isset = 1;
    .               // Historically, types with both bits set were mutated when
    .               // serialized to apply the sort. We no longer support this.
   96 (0.0%)        assert((flags & ASN1_TFLG_SEQUENCE_OF) == 0);
    .             } else {
    .               isset = 0;
    .             }
    .         
    .             // Work out inner tag value: if EXPLICIT or no tagging use underlying
    .             // type.
   48 (0.0%)      if ((ttag != -1) && !(flags & ASN1_TFLG_EXPTAG)) {
    .               sktag = ttag;
    .               skaclass = tclass;
    .             } else {
   24 (0.0%)        skaclass = V_ASN1_UNIVERSAL;
   48 (0.0%)        if (isset) {
   48 (0.0%)          sktag = V_ASN1_SET;
    .               } else {
    .                 sktag = V_ASN1_SEQUENCE;
    .               }
    .             }
    .         
    .             // Determine total length of items
   24 (0.0%)      skcontlen = 0;
  312 (0.0%)      for (j = 0; j < sk_ASN1_VALUE_num(sk); j++) {
    .               int tmplen;
  144 (0.0%)        skitem = sk_ASN1_VALUE_value(sk, j);
  216 (0.0%)        tmplen = ASN1_item_ex_i2d(&skitem, NULL, ASN1_ITEM_ptr(tt->item), -1, 0);
  144 (0.0%)        if (tmplen == -1 || (skcontlen > INT_MAX - tmplen)) {
    .                 return -1;
    .               }
   48 (0.0%)        skcontlen += tmplen;
    .             }
  144 (0.0%)      sklen = ASN1_object_size(/*constructed=*/1, skcontlen, sktag);
   48 (0.0%)      if (sklen == -1) {
    .               return -1;
    .             }
    .             // If EXPLICIT need length of surrounding tag
   96 (0.0%)      if (flags & ASN1_TFLG_EXPTAG) {
    .               ret = ASN1_object_size(/*constructed=*/1, sklen, ttag);
    .             } else {
   48 (0.0%)        ret = sklen;
    .             }
    .         
   72 (0.0%)      if (!out || ret == -1) {
   24 (0.0%)        return ret;
    .             }
    .         
    .             // Now encode this lot...
    .             // EXPLICIT tag
   48 (0.0%)      if (flags & ASN1_TFLG_EXPTAG) {
    .               ASN1_put_object(out, /*constructed=*/1, sklen, ttag, tclass);
    .             }
    .             // SET or SEQUENCE and IMPLICIT tag
   96 (0.0%)      ASN1_put_object(out, /*constructed=*/1, skcontlen, sktag, skaclass);
    .             // And the stuff itself
  132 (0.0%)      if (!asn1_set_seq_out(sk, out, skcontlen, ASN1_ITEM_ptr(tt->item), isset)) {
    .               return -1;
    .             }
   24 (0.0%)      return ret;
    .           }
    .         
  576 (0.0%)    if (flags & ASN1_TFLG_EXPTAG) {
    .             // EXPLICIT tagging
    .             // Find length of tagged item
    .             i = asn1_item_ex_i2d_opt(pval, NULL, ASN1_ITEM_ptr(tt->item), -1, 0,
    .                                      optional);
    .             if (i <= 0) {
    .               return i;
    .             }
    .             // Find length of EXPLICIT tag
-- line 398 ----------------------------------------
-- line 403 ----------------------------------------
    .               if (ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item), -1, 0) < 0) {
    .                 return -1;
    .               }
    .             }
    .             return ret;
    .           }
    .         
    .           // Either normal or IMPLICIT tagging
1,584 (0.0%)    return asn1_item_ex_i2d_opt(pval, out, ASN1_ITEM_ptr(tt->item), ttag, tclass,
    .                                       optional);
  840 (0.0%)  }
    .         
    .         // Temporary structure used to hold DER encoding of items for SET OF
    .         
    .         typedef struct {
    .           unsigned char *data;
    .           int length;
    .         } DER_ENC;
    .         
-- line 421 ----------------------------------------
-- line 431 ----------------------------------------
    .         }
    .         
    .         // asn1_set_seq_out writes |sk| to |out| under the i2d output convention,
    .         // excluding the tag and length. It returns one on success and zero on error.
    .         // |skcontlen| must be the total encoded size. If |do_sort| is non-zero, the
    .         // elements are sorted for a SET OF type. Each element of |sk| has type
    .         // |item|.
    .         static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
  156 (0.0%)                              int skcontlen, const ASN1_ITEM *item, int do_sort) {
    .           // No need to sort if there are fewer than two items.
   84 (0.0%)    if (!do_sort || sk_ASN1_VALUE_num(sk) < 2) {
  156 (0.0%)      for (size_t i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
   72 (0.0%)        ASN1_VALUE *skitem = sk_ASN1_VALUE_value(sk, i);
  108 (0.0%)        if (ASN1_item_ex_i2d(&skitem, out, item, -1, 0) < 0) {
    .                 return 0;
    .               }
    .             }
   24 (0.0%)      return 1;
    .           }
    .         
    .           int ret = 0;
    .           unsigned char *const buf = OPENSSL_malloc(skcontlen);
    .           DER_ENC *encoded = OPENSSL_calloc(sk_ASN1_VALUE_num(sk), sizeof(*encoded));
    .           if (encoded == NULL || buf == NULL) {
    .             goto err;
    .           }
-- line 456 ----------------------------------------
-- line 478 ----------------------------------------
    .           *out = p;
    .         
    .           ret = 1;
    .         
    .         err:
    .           OPENSSL_free(encoded);
    .           OPENSSL_free(buf);
    .           return ret;
   72 (0.0%)  }
    .         
    .         // asn1_i2d_ex_primitive behaves like |ASN1_item_ex_i2d| but |item| must be a
    .         // a PRIMITIVE or MSTRING type that is not an |ASN1_ITEM_TEMPLATE|.
    .         static int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out,
    .                                          const ASN1_ITEM *it, int tag, int aclass,
1,677 (0.0%)                                   int optional) {
    .           // Get length of content octets and maybe find out the underlying type.
    .           int omit;
  387 (0.0%)    int utype = it->utype;
1,161 (0.0%)    int len = asn1_ex_i2c(pval, NULL, &omit, &utype, it);
  258 (0.0%)    if (len < 0) {
    .             return -1;
    .           }
  387 (0.0%)    if (omit) {
   16 (0.0%)      if (optional) {
   16 (0.0%)        return 0;
    .             }
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
    .             return -1;
    .           }
    .         
    .           // If SEQUENCE, SET or OTHER then header is included in pseudo content
    .           // octets so don't include tag+length. We need to check here because the
    .           // call to asn1_ex_i2c() could change utype.
  121 (0.0%)    int usetag =
1,331 (0.0%)        utype != V_ASN1_SEQUENCE && utype != V_ASN1_SET && utype != V_ASN1_OTHER;
    .         
    .           // If not implicitly tagged get tag from underlying type
  242 (0.0%)    if (tag == -1) {
  242 (0.0%)      tag = utype;
    .           }
    .         
    .           // Output tag+length followed by content octets
  242 (0.0%)    if (out) {
   62 (0.0%)      if (usetag) {
  248 (0.0%)        ASN1_put_object(out, /*constructed=*/0, len, tag, aclass);
    .             }
  310 (0.0%)      int len2 = asn1_ex_i2c(pval, *out, &omit, &utype, it);
   62 (0.0%)      if (len2 < 0) {
    .               return -1;
    .             }
   93 (0.0%)      assert(len == len2);
   93 (0.0%)      assert(!omit);
  217 (0.0%)      *out += len;
    .           }
    .         
  242 (0.0%)    if (usetag) {
  726 (0.0%)      return ASN1_object_size(/*constructed=*/0, len, tag);
    .           }
    .           return len;
  645 (0.0%)  }
    .         
    .         // asn1_ex_i2c writes the |*pval| to |cout| under the i2d output convention,
    .         // excluding the tag and length. It returns the number of bytes written,
    .         // possibly zero, on success or -1 on error. If |*pval| should be omitted, it
    .         // returns zero and sets |*out_omit| to true.
    .         //
    .         // If |it| is an MSTRING or ANY type, it gets the underlying type from |*pval|,
    .         // which must be an |ASN1_STRING| or |ASN1_TYPE|, respectively. It then updates
-- line 545 ----------------------------------------
-- line 548 ----------------------------------------
    .         // |V_ASN1_OTHER|, it additionally outputs the tag and length, so the caller
    .         // must not do so.
    .         //
    .         // Otherwise, |*putype| must contain |it->utype|.
    .         //
    .         // WARNING: Unlike most functions in this file, |asn1_ex_i2c| can return zero
    .         // without omitting the element. ASN.1 values may have empty contents.
    .         static int asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cout, int *out_omit,
1,920 (0.0%)                         int *putype, const ASN1_ITEM *it) {
  160 (0.0%)    ASN1_BOOLEAN *tbool = NULL;
    .           ASN1_STRING *strtmp;
    .           ASN1_OBJECT *otmp;
    .           int utype;
    .           const unsigned char *cont;
    .           unsigned char c;
    .           int len;
    .         
    .           // Historically, |it->funcs| for primitive types contained an
    .           // |ASN1_PRIMITIVE_FUNCS| table of callbacks.
  640 (0.0%)    assert(it->funcs == NULL);
    .         
  320 (0.0%)    *out_omit = 0;
    .         
    .           // Should type be omitted?
1,040 (0.0%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) || (it->utype != V_ASN1_BOOLEAN)) {
  640 (0.0%)      if (!*pval) {
   16 (0.0%)        *out_omit = 1;
   16 (0.0%)        return 0;
    .             }
    .           }
    .         
  608 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
    .             // If MSTRING type set the underlying type
  180 (0.0%)      strtmp = (ASN1_STRING *)*pval;
  180 (0.0%)      utype = strtmp->type;
  120 (0.0%)      if (utype < 0 && utype != V_ASN1_OTHER) {
    .               // MSTRINGs can have type -1 when default-constructed.
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TYPE);
    .               return -1;
    .             }
    .             // Negative INTEGER and ENUMERATED values use |ASN1_STRING| type values
    .             // that do not match their corresponding utype values. INTEGERs cannot
    .             // participate in MSTRING types, but ENUMERATEDs can.
    .             //
    .             // TODO(davidben): Is this a bug? Although arguably one of the MSTRING
    .             // types should contain more values, rather than less. See
    .             // https://crbug.com/boringssl/412. But it is not possible to fit all
    .             // possible ANY values into an |ASN1_STRING|, so matching the spec here
    .             // is somewhat hopeless.
  120 (0.0%)      if (utype == V_ASN1_NEG_INTEGER) {
    .               utype = V_ASN1_INTEGER;
  120 (0.0%)      } else if (utype == V_ASN1_NEG_ENUMERATED) {
    .               utype = V_ASN1_ENUMERATED;
    .             }
  240 (0.0%)      *putype = utype;
  368 (0.0%)    } else if (it->utype == V_ASN1_ANY) {
    .             // If ANY set type and pointer to value
    .             ASN1_TYPE *typ;
   15 (0.0%)      typ = (ASN1_TYPE *)*pval;
   15 (0.0%)      utype = typ->type;
   10 (0.0%)      if (utype < 0 && utype != V_ASN1_OTHER) {
    .               // |ASN1_TYPE|s can have type -1 when default-constructed.
    .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TYPE);
    .               return -1;
    .             }
   15 (0.0%)      *putype = utype;
   20 (0.0%)      pval = &typ->value.asn1_value;
    .           } else {
  261 (0.0%)      utype = *putype;
    .           }
    .         
1,040 (0.0%)    switch (utype) {
    .             case V_ASN1_OBJECT:
  240 (0.0%)        otmp = (ASN1_OBJECT *)*pval;
  240 (0.0%)        cont = otmp->data;
  240 (0.0%)        len = otmp->length;
  160 (0.0%)        if (len == 0) {
    .                 // Some |ASN1_OBJECT|s do not have OIDs and cannot be serialized.
    .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OBJECT);
    .                 return -1;
    .               }
   80 (0.0%)        break;
    .         
    .             case V_ASN1_NULL:
    .               cont = NULL;
    .               len = 0;
    .               break;
    .         
    .             case V_ASN1_BOOLEAN:
    .               tbool = (ASN1_BOOLEAN *)pval;
-- line 637 ----------------------------------------
-- line 648 ----------------------------------------
    .               }
    .               c = *tbool ? 0xff : 0x00;
    .               cont = &c;
    .               len = 1;
    .               break;
    .         
    .             case V_ASN1_BIT_STRING: {
    .               int ret =
  123 (0.0%)            i2c_ASN1_BIT_STRING((ASN1_BIT_STRING *)*pval, cout ? &cout : NULL);
    .               // |i2c_ASN1_BIT_STRING| returns zero on error instead of -1.
   48 (0.0%)        return ret <= 0 ? -1 : ret;
    .             }
    .         
    .             case V_ASN1_INTEGER:
    .             case V_ASN1_ENUMERATED: {
    .               // |i2c_ASN1_INTEGER| also handles ENUMERATED.
    .               int ret = i2c_ASN1_INTEGER((ASN1_INTEGER *)*pval, cout ? &cout : NULL);
    .               // |i2c_ASN1_INTEGER| returns zero on error instead of -1.
    .               return ret <= 0 ? -1 : ret;
-- line 666 ----------------------------------------
-- line 679 ----------------------------------------
    .             case V_ASN1_GENERALSTRING:
    .             case V_ASN1_UNIVERSALSTRING:
    .             case V_ASN1_BMPSTRING:
    .             case V_ASN1_UTF8STRING:
    .             case V_ASN1_SEQUENCE:
    .             case V_ASN1_SET:
    .             default:
    .               // All based on ASN1_STRING and handled the same
  180 (0.0%)        strtmp = (ASN1_STRING *)*pval;
  180 (0.0%)        cont = strtmp->data;
  180 (0.0%)        len = strtmp->length;
    .         
   60 (0.0%)        break;
    .           }
  476 (0.0%)    if (cout && len) {
  196 (0.0%)      OPENSSL_memcpy(cout, cont, len);
    .           }
  140 (0.0%)    return len;
  800 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 70 ----------------------------------------
    .         static int asn1_item_ex_combine_new(ASN1_VALUE **pval, const ASN1_ITEM *it,
    .                                             int combine);
    .         static void asn1_item_clear(ASN1_VALUE **pval, const ASN1_ITEM *it);
    .         static int ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);
    .         static void asn1_template_clear(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);
    .         static int ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it);
    .         static void asn1_primitive_clear(ASN1_VALUE **pval, const ASN1_ITEM *it);
    .         
  104 (0.0%)  ASN1_VALUE *ASN1_item_new(const ASN1_ITEM *it) {
   13 (0.0%)    ASN1_VALUE *ret = NULL;
   91 (0.0%)    if (ASN1_item_ex_new(&ret, it) > 0) {
   26 (0.0%)      return ret;
    .           }
    .           return NULL;
   65 (0.0%)  }
    .         
    .         // Allocate an ASN1 structure
    .         
  222 (0.0%)  int ASN1_item_ex_new(ASN1_VALUE **pval, const ASN1_ITEM *it) {
  222 (0.0%)    return asn1_item_ex_combine_new(pval, it, 0);
   74 (0.0%)  }
    .         
    .         static int asn1_item_ex_combine_new(ASN1_VALUE **pval, const ASN1_ITEM *it,
  763 (0.0%)                                      int combine) {
  109 (0.0%)    const ASN1_TEMPLATE *tt = NULL;
    .           const ASN1_EXTERN_FUNCS *ef;
    .           ASN1_VALUE **pseqval;
    .           int i;
    .         
1,417 (0.0%)    switch (it->itype) {
    .             case ASN1_ITYPE_EXTERN:
    6 (0.0%)        ef = it->funcs;
   12 (0.0%)        if (ef && ef->asn1_ex_new) {
   18 (0.0%)          if (!ef->asn1_ex_new(pval, it)) {
    .                   goto memerr;
    .                 }
    .               }
    4 (0.0%)        break;
    .         
    .             case ASN1_ITYPE_PRIMITIVE:
  156 (0.0%)        if (it->templates) {
    .                 if (!ASN1_template_new(pval, it->templates)) {
    .                   goto memerr;
    .                 }
  273 (0.0%)        } else if (!ASN1_primitive_new(pval, it)) {
    .                 goto memerr;
    .               }
   78 (0.0%)        break;
    .         
    .             case ASN1_ITYPE_MSTRING:
  182 (0.0%)        if (!ASN1_primitive_new(pval, it)) {
    .                 goto memerr;
    .               }
   52 (0.0%)        break;
    .         
    .             case ASN1_ITYPE_CHOICE: {
    9 (0.0%)        const ASN1_AUX *aux = it->funcs;
   12 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
    6 (0.0%)        if (asn1_cb) {
    .                 i = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);
    .                 if (!i) {
    .                   goto auxerr;
    .                 }
    .                 if (i == 2) {
    .                   return 1;
    .                 }
    .               }
    6 (0.0%)        if (!combine) {
   18 (0.0%)          *pval = OPENSSL_zalloc(it->size);
   12 (0.0%)          if (!*pval) {
    .                   goto memerr;
    .                 }
    .               }
   15 (0.0%)        asn1_set_choice_selector(pval, -1, it);
    6 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL)) {
    .                 goto auxerr2;
    .               }
    6 (0.0%)        break;
    .             }
    .         
    .             case ASN1_ITYPE_SEQUENCE: {
  117 (0.0%)        const ASN1_AUX *aux = it->funcs;
  162 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
   78 (0.0%)        if (asn1_cb) {
   16 (0.0%)          i = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);
    4 (0.0%)          if (!i) {
    .                   goto auxerr;
    .                 }
    4 (0.0%)          if (i == 2) {
    .                   return 1;
    .                 }
    .               }
   78 (0.0%)        if (!combine) {
  234 (0.0%)          *pval = OPENSSL_zalloc(it->size);
  156 (0.0%)          if (!*pval) {
    .                   goto memerr;
    .                 }
  195 (0.0%)          asn1_refcount_set_one(pval, it);
  195 (0.0%)          asn1_enc_init(pval, it);
    .               }
1,173 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
  558 (0.0%)          pseqval = asn1_get_field_ptr(pval, tt);
  651 (0.0%)          if (!ASN1_template_new(pseqval, tt)) {
    .                   goto memerr2;
    .                 }
    .               }
   96 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL)) {
    .                 goto auxerr2;
    .               }
   41 (0.0%)        break;
    .             }
    .           }
  218 (0.0%)    return 1;
    .         
    .         memerr2:
    .           asn1_item_combine_free(pval, it, combine);
    .         memerr:
    .           return 0;
    .         
    .         auxerr2:
    .           asn1_item_combine_free(pval, it, combine);
    .         auxerr:
    .           OPENSSL_PUT_ERROR(ASN1, ASN1_R_AUX_ERROR);
    .           return 0;
  218 (0.0%)  }
    .         
  108 (0.0%)  static void asn1_item_clear(ASN1_VALUE **pval, const ASN1_ITEM *it) {
  234 (0.0%)    switch (it->itype) {
    .             case ASN1_ITYPE_EXTERN:
    .               *pval = NULL;
    .               break;
    .         
    .             case ASN1_ITYPE_PRIMITIVE:
   72 (0.0%)        if (it->templates) {
    .                 asn1_template_clear(pval, it->templates);
    .               } else {
   90 (0.0%)          asn1_primitive_clear(pval, it);
    .               }
   18 (0.0%)        break;
    .         
    .             case ASN1_ITYPE_MSTRING:
    .               asn1_primitive_clear(pval, it);
    .               break;
    .         
    .             case ASN1_ITYPE_CHOICE:
    .             case ASN1_ITYPE_SEQUENCE:
    .               *pval = NULL;
    .               break;
    .           }
   54 (0.0%)  }
    .         
  558 (0.0%)  static int ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
  279 (0.0%)    const ASN1_ITEM *it = ASN1_ITEM_ptr(tt->item);
    .           int ret;
  465 (0.0%)    if (tt->flags & ASN1_TFLG_OPTIONAL) {
  105 (0.0%)      asn1_template_clear(pval, tt);
   42 (0.0%)      return 1;
    .           }
    .           // If ANY DEFINED BY nothing to do
    .         
  360 (0.0%)    if (tt->flags & ASN1_TFLG_ADB_MASK) {
    .             *pval = NULL;
    .             return 1;
    .           }
    .           // If SET OF or SEQUENCE OF, its a STACK
  360 (0.0%)    if (tt->flags & ASN1_TFLG_SK_MASK) {
    .             STACK_OF(ASN1_VALUE) *skval;
    .             skval = sk_ASN1_VALUE_new_null();
    .             if (!skval) {
    .               ret = 0;
    .               goto done;
    .             }
    .             *pval = (ASN1_VALUE *)skval;
    .             ret = 1;
    .             goto done;
    .           }
    .           // Otherwise pass it back to the item routine
  720 (0.0%)    ret = asn1_item_ex_combine_new(pval, it, tt->flags & ASN1_TFLG_COMBINE);
    .         done:
   72 (0.0%)    return ret;
  186 (0.0%)  }
    .         
  126 (0.0%)  static void asn1_template_clear(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
    .           // If ADB or STACK just NULL the field
  105 (0.0%)    if (tt->flags & (ASN1_TFLG_ADB_MASK | ASN1_TFLG_SK_MASK)) {
    6 (0.0%)      *pval = NULL;
    .           } else {
  108 (0.0%)      asn1_item_clear(pval, ASN1_ITEM_ptr(tt->item));
    .           }
   66 (0.0%)  }
    .         
    .         // NB: could probably combine most of the real XXX_new() behaviour and junk
    .         // all the old functions.
    .         
  390 (0.0%)  static int ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it) {
  130 (0.0%)    if (!it) {
    .             return 0;
    .           }
    .         
    .           // Historically, |it->funcs| for primitive types contained an
    .           // |ASN1_PRIMITIVE_FUNCS| table of calbacks.
  260 (0.0%)    assert(it->funcs == NULL);
    .         
    .           int utype;
  260 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
   52 (0.0%)      utype = -1;
    .           } else {
  117 (0.0%)      utype = it->utype;
    .           }
  501 (0.0%)    switch (utype) {
    .             case V_ASN1_OBJECT:
   93 (0.0%)        *pval = (ASN1_VALUE *)OBJ_get_undef();
   62 (0.0%)        return 1;
    .         
    .             case V_ASN1_BOOLEAN:
    .               *(ASN1_BOOLEAN *)pval = (ASN1_BOOLEAN)it->size;
    .               return 1;
    .         
    .             case V_ASN1_NULL:
    .               *pval = (ASN1_VALUE *)1;
    .               return 1;
    .         
    .             case V_ASN1_ANY: {
    3 (0.0%)        ASN1_TYPE *typ = OPENSSL_zalloc(sizeof(ASN1_TYPE));
    2 (0.0%)        if (!typ) {
    .                 return 0;
    .               }
    2 (0.0%)        typ->type = -1;
    3 (0.0%)        *pval = (ASN1_VALUE *)typ;
    1 (0.0%)        break;
    .             }
    .         
    .             default:
  165 (0.0%)        *pval = (ASN1_VALUE *)ASN1_STRING_type_new(utype);
   33 (0.0%)        break;
    .           }
  136 (0.0%)    if (*pval) {
   68 (0.0%)      return 1;
    .           }
    .           return 0;
  130 (0.0%)  }
    .         
  108 (0.0%)  static void asn1_primitive_clear(ASN1_VALUE **pval, const ASN1_ITEM *it) {
    .           int utype;
    .           // Historically, |it->funcs| for primitive types contained an
    .           // |ASN1_PRIMITIVE_FUNCS| table of calbacks.
  108 (0.0%)    assert(it == NULL || it->funcs == NULL);
  108 (0.0%)    if (!it || (it->itype == ASN1_ITYPE_MSTRING)) {
    .             utype = -1;
    .           } else {
   54 (0.0%)      utype = it->utype;
    .           }
   36 (0.0%)    if (utype == V_ASN1_BOOLEAN) {
   30 (0.0%)      *(ASN1_BOOLEAN *)pval = (ASN1_BOOLEAN)it->size;
    .           } else {
   24 (0.0%)      *pval = NULL;
    .           }
   60 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 70 ----------------------------------------
    .         
    .         
    .         // Utility functions for manipulating fields and offsets
    .         
    .         // Add 'offset' to 'addr'
    .         #define offset2ptr(addr, offset) (void *)(((char *)(addr)) + (offset))
    .         
    .         // Given an ASN1_ITEM CHOICE type return the selector value
    5 (0.0%)  int asn1_get_choice_selector(ASN1_VALUE **pval, const ASN1_ITEM *it) {
    7 (0.0%)    int *sel = offset2ptr(*pval, it->utype);
    2 (0.0%)    return *sel;
    2 (0.0%)  }
    .         
    .         // Given an ASN1_ITEM CHOICE type set the selector value, return old value.
    .         int asn1_set_choice_selector(ASN1_VALUE **pval, int value,
   36 (0.0%)                               const ASN1_ITEM *it) {
    .           int *sel, ret;
   42 (0.0%)    sel = offset2ptr(*pval, it->utype);
   18 (0.0%)    ret = *sel;
   18 (0.0%)    *sel = value;
    6 (0.0%)    return ret;
   12 (0.0%)  }
    .         
    .         static CRYPTO_refcount_t *asn1_get_references(ASN1_VALUE **pval,
  275 (0.0%)                                                const ASN1_ITEM *it) {
  220 (0.0%)    if (it->itype != ASN1_ITYPE_SEQUENCE) {
    .             return NULL;
    .           }
  165 (0.0%)    const ASN1_AUX *aux = it->funcs;
  135 (0.0%)    if (!aux || !(aux->flags & ASN1_AFLG_REFCOUNT)) {
  104 (0.0%)      return NULL;
    .           }
   18 (0.0%)    return offset2ptr(*pval, aux->ref_offset);
  110 (0.0%)  }
    .         
  234 (0.0%)  void asn1_refcount_set_one(ASN1_VALUE **pval, const ASN1_ITEM *it) {
  234 (0.0%)    CRYPTO_refcount_t *references = asn1_get_references(pval, it);
   78 (0.0%)    if (references != NULL) {
    2 (0.0%)      *references = 1;
    .           }
  117 (0.0%)  }
    .         
   96 (0.0%)  int asn1_refcount_dec_and_test_zero(ASN1_VALUE **pval, const ASN1_ITEM *it) {
   96 (0.0%)    CRYPTO_refcount_t *references = asn1_get_references(pval, it);
   32 (0.0%)    if (references != NULL) {
    8 (0.0%)      return CRYPTO_refcount_dec_and_test_zero(references);
    .           }
   14 (0.0%)    return 1;
   32 (0.0%)  }
    .         
  822 (0.0%)  static ASN1_ENCODING *asn1_get_enc_ptr(ASN1_VALUE **pval, const ASN1_ITEM *it) {
  548 (0.0%)    assert(it->itype == ASN1_ITYPE_SEQUENCE);
    .           const ASN1_AUX *aux;
  822 (0.0%)    if (!pval || !*pval) {
    .             return NULL;
    .           }
  411 (0.0%)    aux = it->funcs;
  364 (0.0%)    if (!aux || !(aux->flags & ASN1_AFLG_ENCODING)) {
  258 (0.0%)      return NULL;
    .           }
   48 (0.0%)    return offset2ptr(*pval, aux->enc_offset);
  274 (0.0%)  }
    .         
  234 (0.0%)  void asn1_enc_init(ASN1_VALUE **pval, const ASN1_ITEM *it) {
  234 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
   78 (0.0%)    if (enc) {
    2 (0.0%)      enc->enc = NULL;
    2 (0.0%)      enc->len = 0;
    4 (0.0%)      enc->alias_only = 0;
    4 (0.0%)      enc->alias_only_on_next_parse = 0;
    .           }
  117 (0.0%)  }
    .         
   84 (0.0%)  void asn1_enc_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
   84 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
   28 (0.0%)    if (enc) {
    .             asn1_encoding_clear(enc);
    .           }
   42 (0.0%)  }
    .         
    .         int asn1_enc_save(ASN1_VALUE **pval, const unsigned char *in, int inlen,
  216 (0.0%)                    const ASN1_ITEM *it) {
    .           ASN1_ENCODING *enc;
  162 (0.0%)    enc = asn1_get_enc_ptr(pval, it);
   54 (0.0%)    if (!enc) {
   52 (0.0%)      return 1;
    .           }
    .         
    5 (0.0%)    if (!enc->alias_only) {
    4 (0.0%)      OPENSSL_free(enc->enc);
    .           }
    .         
   11 (0.0%)    enc->alias_only = enc->alias_only_on_next_parse;
    4 (0.0%)    enc->alias_only_on_next_parse = 0;
    .         
    5 (0.0%)    if (enc->alias_only) {
    .             enc->enc = (uint8_t *)in;
    .           } else {
    8 (0.0%)      enc->enc = OPENSSL_memdup(in, inlen);
    4 (0.0%)      if (!enc->enc) {
    .               return 0;
    .             }
    .           }
    .         
    4 (0.0%)    enc->len = inlen;
    1 (0.0%)    return 1;
   54 (0.0%)  }
    .         
    .         void asn1_encoding_clear(ASN1_ENCODING *enc) {
    .           if (!enc->alias_only) {
    .             OPENSSL_free(enc->enc);
    .           }
    .           enc->enc = NULL;
    .           enc->len = 0;
    .           enc->alias_only = 0;
    .           enc->alias_only_on_next_parse = 0;
    .         }
    .         
    .         int asn1_enc_restore(int *len, unsigned char **out, ASN1_VALUE **pval,
  456 (0.0%)                       const ASN1_ITEM *it) {
  342 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
  138 (0.0%)    if (!enc || enc->len == 0) {
  102 (0.0%)      return 0;
    .           }
   12 (0.0%)    if (out) {
   20 (0.0%)      OPENSSL_memcpy(*out, enc->enc, enc->len);
   14 (0.0%)      *out += enc->len;
    .           }
   12 (0.0%)    if (len) {
   30 (0.0%)      *len = enc->len;
    .           }
    6 (0.0%)    return 1;
  114 (0.0%)  }
    .         
    .         // Given an ASN1_TEMPLATE get a pointer to a field
1,750 (0.0%)  ASN1_VALUE **asn1_get_field_ptr(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
    .           ASN1_VALUE **pvaltmp;
1,750 (0.0%)    if (tt->flags & ASN1_TFLG_COMBINE) {
    .             return pval;
    .           }
2,100 (0.0%)    pvaltmp = offset2ptr(*pval, tt->offset);
    .           // NOTE for BOOLEAN types the field is just a plain int so we can't return
    .           // int **, so settle for (int *).
  350 (0.0%)    return pvaltmp;
  700 (0.0%)  }
    .         
    .         // Handle ANY DEFINED BY template, find the selector, look up the relevant
    .         // ASN1_TEMPLATE in the table and return it.
    .         const ASN1_TEMPLATE *asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt,
1,729 (0.0%)                                   int nullerr) {
    .           const ASN1_ADB *adb;
    .           const ASN1_ADB_TABLE *atbl;
    .           ASN1_VALUE **sfld;
    .           int i;
1,235 (0.0%)    if (!(tt->flags & ASN1_TFLG_ADB_MASK)) {
  494 (0.0%)      return tt;
    .           }
    .         
    .           // Else ANY DEFINED BY ... get the table
    .           adb = ASN1_ADB_ptr(tt->item);
    .         
    .           // Get the selector field
    .           sfld = offset2ptr(*pval, adb->offset);
    .         
-- line 233 ----------------------------------------
-- line 265 ----------------------------------------
    .           return adb->default_tt;
    .         
    .         err:
    .           // FIXME: should log the value or OID of unsupported type
    .           if (nullerr) {
    .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);
    .           }
    .           return NULL;
  494 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 26 ----------------------------------------
    .         
    .         #include <string.h>
    .         
    .         #include "../asn1/internal.h"
    .         #include "../internal.h"
    .         #include "internal.h"
    .         
    .         
1,812 (0.0%)  void CBS_init(CBS *cbs, const uint8_t *data, size_t len) {
  906 (0.0%)    cbs->data = data;
  906 (0.0%)    cbs->len = len;
  906 (0.0%)  }
    .         
4,728 (0.1%)  static int cbs_get(CBS *cbs, const uint8_t **p, size_t n) {
3,152 (0.1%)    if (cbs->len < n) {
   42 (0.0%)      return 0;
    .           }
    .         
3,068 (0.0%)    *p = cbs->data;
4,602 (0.1%)    cbs->data += n;
4,602 (0.1%)    cbs->len -= n;
  767 (0.0%)    return 1;
1,576 (0.0%)  }
    .         
1,197 (0.0%)  int CBS_skip(CBS *cbs, size_t len) {
    .           const uint8_t *dummy;
  798 (0.0%)    return cbs_get(cbs, &dummy, len);
  665 (0.0%)  }
    .         
1,064 (0.0%)  const uint8_t *CBS_data(const CBS *cbs) { return cbs->data; }
    .         
5,064 (0.1%)  size_t CBS_len(const CBS *cbs) { return cbs->len; }
    .         
    .         int CBS_stow(const CBS *cbs, uint8_t **out_ptr, size_t *out_len) {
    .           OPENSSL_free(*out_ptr);
    .           *out_ptr = NULL;
    .           *out_len = 0;
    .         
    .           if (cbs->len == 0) {
    .             return 1;
-- line 65 ----------------------------------------
-- line 79 ----------------------------------------
    .           *out_ptr = OPENSSL_strndup((const char *)cbs->data, cbs->len);
    .           return (*out_ptr != NULL);
    .         }
    .         
    .         int CBS_contains_zero_byte(const CBS *cbs) {
    .           return OPENSSL_memchr(cbs->data, 0, cbs->len) != NULL;
    .         }
    .         
   14 (0.0%)  int CBS_mem_equal(const CBS *cbs, const uint8_t *data, size_t len) {
    8 (0.0%)    if (len != cbs->len) {
    2 (0.0%)      return 0;
    .           }
   10 (0.0%)    return CRYPTO_memcmp(cbs->data, data, len) == 0;
    4 (0.0%)  }
    .         
   20 (0.0%)  static int cbs_get_u(CBS *cbs, uint64_t *out, size_t len) {
    2 (0.0%)    uint64_t result = 0;
    .           const uint8_t *data;
    .         
   16 (0.0%)    if (!cbs_get(cbs, &data, len)) {
    .             return 0;
    .           }
   26 (0.0%)    for (size_t i = 0; i < len; i++) {
    4 (0.0%)      result <<= 8;
   24 (0.0%)      result |= data[i];
    .           }
    6 (0.0%)    *out = result;
    2 (0.0%)    return 1;
   10 (0.0%)  }
    .         
4,680 (0.1%)  int CBS_get_u8(CBS *cbs, uint8_t *out) {
    .           const uint8_t *v;
4,160 (0.1%)    if (!cbs_get(cbs, &v, 1)) {
   42 (0.0%)      return 0;
    .           }
1,996 (0.0%)    *out = *v;
  499 (0.0%)    return 1;
2,600 (0.0%)  }
    .         
    .         int CBS_get_u16(CBS *cbs, uint16_t *out) {
    .           uint64_t v;
    .           if (!cbs_get_u(cbs, &v, 2)) {
    .             return 0;
    .           }
    .           *out = v;
    .           return 1;
-- line 124 ----------------------------------------
-- line 172 ----------------------------------------
    .           if (cbs->len == 0) {
    .             return 0;
    .           }
    .           *out = cbs->data[cbs->len - 1];
    .           cbs->len--;
    .           return 1;
    .         }
    .         
1,330 (0.0%)  int CBS_get_bytes(CBS *cbs, CBS *out, size_t len) {
    .           const uint8_t *v;
1,064 (0.0%)    if (!cbs_get(cbs, &v, len)) {
    .             return 0;
    .           }
  798 (0.0%)    CBS_init(out, v, len);
  133 (0.0%)    return 1;
  665 (0.0%)  }
    .         
    .         int CBS_copy_bytes(CBS *cbs, uint8_t *out, size_t len) {
    .           const uint8_t *v;
    .           if (!cbs_get(cbs, &v, len)) {
    .             return 0;
    .           }
    .           OPENSSL_memcpy(out, v, len);
    .           return 1;
-- line 195 ----------------------------------------
-- line 272 ----------------------------------------
    .         
    .             // Values end at an octet with the high bit cleared.
    .           } while (b & 0x80);
    .         
    .           *out = v;
    .           return 1;
    .         }
    .         
1,197 (0.0%)  static int parse_asn1_tag(CBS *cbs, CBS_ASN1_TAG *out) {
    .           uint8_t tag_byte;
  931 (0.0%)    if (!CBS_get_u8(cbs, &tag_byte)) {
    .             return 0;
    .           }
    .         
    .           // ITU-T X.690 section 8.1.2.3 specifies the format for identifiers with a tag
    .           // number no greater than 30.
    .           //
    .           // If the number portion is 31 (0x1f, the largest value that fits in the
    .           // allotted bits), then the tag is more than one byte long and the
    .           // continuation bytes contain the tag number.
  665 (0.0%)    CBS_ASN1_TAG tag = ((CBS_ASN1_TAG)tag_byte & 0xe0) << CBS_ASN1_TAG_SHIFT;
  532 (0.0%)    CBS_ASN1_TAG tag_number = tag_byte & 0x1f;
  266 (0.0%)    if (tag_number == 0x1f) {
    .             uint64_t v;
    .             if (!parse_base128_integer(cbs, &v) ||
    .                 // Check the tag number is within our supported bounds.
    .                 v > CBS_ASN1_TAG_NUMBER_MASK ||
    .                 // Small tag numbers should have used low tag number form, even in BER.
    .                 v < 0x1f) {
    .               return 0;
    .             }
    .             tag_number = (CBS_ASN1_TAG)v;
    .           }
    .         
  266 (0.0%)    tag |= tag_number;
    .         
    .           // Tag [UNIVERSAL 0] is reserved for use by the encoding. Reject it here to
    .           // avoid some ambiguity around ANY values and BER indefinite-length EOCs. See
    .           // https://crbug.com/boringssl/455.
  532 (0.0%)    if ((tag & ~CBS_ASN1_CONSTRUCTED) == 0) {
    .             return 0;
    .           }
    .         
  399 (0.0%)    *out = tag;
  133 (0.0%)    return 1;
  665 (0.0%)  }
    .         
    .         static int cbs_get_any_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
    .                                             size_t *out_header_len, int *out_ber_found,
1,862 (0.0%)                                      int *out_indefinite, int ber_ok) {
  665 (0.0%)    CBS header = *cbs;
    .           CBS throwaway;
    .         
  266 (0.0%)    if (out == NULL) {
    .             out = &throwaway;
    .           }
  266 (0.0%)    if (ber_ok) {
  250 (0.0%)      *out_ber_found = 0;
  375 (0.0%)      *out_indefinite = 0;
    .           } else {
   16 (0.0%)      assert(out_ber_found == NULL);
   16 (0.0%)      assert(out_indefinite == NULL);
    .           }
    .         
    .           CBS_ASN1_TAG tag;
  931 (0.0%)    if (!parse_asn1_tag(&header, &tag)) {
    .             return 0;
    .           }
  266 (0.0%)    if (out_tag != NULL) {
  399 (0.0%)      *out_tag = tag;
    .           }
    .         
    .           uint8_t length_byte;
  931 (0.0%)    if (!CBS_get_u8(&header, &length_byte)) {
    .             return 0;
    .           }
    .         
1,330 (0.0%)    size_t header_len = CBS_len(cbs) - CBS_len(&header);
    .         
    .           size_t len;
    .           // The format for the length encoding is specified in ITU-T X.690 section
    .           // 8.1.3.
  399 (0.0%)    if ((length_byte & 0x80) == 0) {
    .             // Short form length.
  655 (0.0%)      len = ((size_t)length_byte) + header_len;
  262 (0.0%)      if (out_header_len != NULL) {
  524 (0.0%)        *out_header_len = header_len;
    .             }
    .           } else {
    .             // The high bit indicate that this is the long form, while the next 7 bits
    .             // encode the number of subsequent octets used to encode the length (ITU-T
    .             // X.690 clause 8.1.3.5.b).
    8 (0.0%)      const size_t num_bytes = length_byte & 0x7f;
    .             uint64_t len64;
    .         
   16 (0.0%)      if (ber_ok && (tag & CBS_ASN1_CONSTRUCTED) != 0 && num_bytes == 0) {
    .               // indefinite length
    .               if (out_header_len != NULL) {
    .                 *out_header_len = header_len;
    .               }
    .               *out_ber_found = 1;
    .               *out_indefinite = 1;
    .               return CBS_get_bytes(cbs, out, header_len);
    .             }
    .         
    .             // ITU-T X.690 clause 8.1.3.5.c specifies that the value 0xff shall not be
    .             // used as the first byte of the length. If this parser encounters that
    .             // value, num_bytes will be parsed as 127, which will fail this check.
    8 (0.0%)      if (num_bytes == 0 || num_bytes > 4) {
    .               return 0;
    .             }
   16 (0.0%)      if (!cbs_get_u(&header, &len64, num_bytes)) {
    .               return 0;
    .             }
    .             // ITU-T X.690 section 10.1 (DER length forms) requires encoding the
    .             // length with the minimum number of octets. BER could, technically, have
    .             // 125 superfluous zero bytes. We do not attempt to handle that and still
    .             // require that the length fit in a |uint32_t| for BER.
    6 (0.0%)      if (len64 < 128) {
    .               // Length should have used short-form encoding.
    .               if (ber_ok) {
    .                 *out_ber_found = 1;
    .               } else {
    .                 return 0;
    .               }
    .             }
   18 (0.0%)      if ((len64 >> ((num_bytes - 1) * 8)) == 0) {
    .               // Length should have been at least one byte shorter.
    .               if (ber_ok) {
    .                 *out_ber_found = 1;
    .               } else {
    .                 return 0;
    .               }
    .             }
    4 (0.0%)      len = len64;
   14 (0.0%)      if (len + header_len + num_bytes < len) {
    .               // Overflow.
    .               return 0;
    .             }
    8 (0.0%)      len += header_len + num_bytes;
    4 (0.0%)      if (out_header_len != NULL) {
   10 (0.0%)        *out_header_len = header_len + num_bytes;
    .             }
    .           }
    .         
  798 (0.0%)    return CBS_get_bytes(cbs, out, len);
  798 (0.0%)  }
    .         
    .         int CBS_get_any_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag) {
    .           size_t header_len;
    .           if (!CBS_get_any_asn1_element(cbs, out, out_tag, &header_len)) {
    .             return 0;
    .           }
    .         
    .           if (!CBS_skip(out, header_len)) {
-- line 426 ----------------------------------------
-- line 427 ----------------------------------------
    .             assert(0);
    .             return 0;
    .           }
    .         
    .           return 1;
    .         }
    .         
    .         int CBS_get_any_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
   64 (0.0%)                               size_t *out_header_len) {
   88 (0.0%)    return cbs_get_any_asn1_element(cbs, out, out_tag, out_header_len, NULL, NULL,
    .                                           /*ber_ok=*/0);
   16 (0.0%)  }
    .         
    .         int CBS_get_any_ber_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
    .                                          size_t *out_header_len, int *out_ber_found,
1,625 (0.0%)                                   int *out_indefinite) {
    .           int ber_found_temp;
1,875 (0.0%)    return cbs_get_any_asn1_element(
    .               cbs, out, out_tag, out_header_len,
    .               out_ber_found ? out_ber_found : &ber_found_temp, out_indefinite,
    .               /*ber_ok=*/1);
  625 (0.0%)  }
    .         
    .         static int cbs_get_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value,
   88 (0.0%)                          int skip_header) {
    .           size_t header_len;
    .           CBS_ASN1_TAG tag;
    .           CBS throwaway;
    .         
   16 (0.0%)    if (out == NULL) {
    .             out = &throwaway;
    .           }
    .         
   80 (0.0%)    if (!CBS_get_any_asn1_element(cbs, out, &tag, &header_len) ||
    8 (0.0%)        tag != tag_value) {
    .             return 0;
    .           }
    .         
   72 (0.0%)    if (skip_header && !CBS_skip(out, header_len)) {
    .             assert(0);
    .             return 0;
    .           }
    .         
    8 (0.0%)    return 1;
   40 (0.0%)  }
    .         
   56 (0.0%)  int CBS_get_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value) {
   48 (0.0%)    return cbs_get_asn1(cbs, out, tag_value, 1 /* skip header */);
   16 (0.0%)  }
    .         
    .         int CBS_get_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value) {
    .           return cbs_get_asn1(cbs, out, tag_value, 0 /* include header */);
    .         }
    .         
    .         int CBS_peek_asn1_tag(const CBS *cbs, CBS_ASN1_TAG tag_value) {
    .           CBS copy = *cbs;
    .           CBS_ASN1_TAG actual_tag;
-- line 483 ----------------------------------------
-- line 670 ----------------------------------------
    .         
    .           // Unused bits are zero, and this function does not distinguish between
    .           // missing and unset bits. Thus it is sufficient to do a byte-level length
    .           // check.
    .           return byte_num < CBS_len(cbs) &&
    .                  (CBS_data(cbs)[byte_num] & (1 << bit_num)) != 0;
    .         }
    .         
   36 (0.0%)  int CBS_is_valid_asn1_integer(const CBS *cbs, int *out_is_negative) {
   20 (0.0%)    CBS copy = *cbs;
    .           uint8_t first_byte, second_byte;
   28 (0.0%)    if (!CBS_get_u8(&copy, &first_byte)) {
    .             return 0;  // INTEGERs may not be empty.
    .           }
    8 (0.0%)    if (out_is_negative != NULL) {
   20 (0.0%)      *out_is_negative = (first_byte & 0x80) != 0;
    .           }
   28 (0.0%)    if (!CBS_get_u8(&copy, &second_byte)) {
    2 (0.0%)      return 1;  // One byte INTEGERs are always minimal.
    .           }
   15 (0.0%)    if ((first_byte == 0x00 && (second_byte & 0x80) == 0) ||
    3 (0.0%)        (first_byte == 0xff && (second_byte & 0x80) != 0)) {
    .             return 0;  // The value is minimal iff the first 9 bits are not all equal.
    .           }
    3 (0.0%)    return 1;
   20 (0.0%)  }
    .         
    .         int CBS_is_unsigned_asn1_integer(const CBS *cbs) {
    .           int is_negative;
    .           return CBS_is_valid_asn1_integer(cbs, &is_negative) && !is_negative;
    .         }
    .         
    .         static int add_decimal(CBB *out, uint64_t v) {
    .           char buf[DECIMAL_SIZE(uint64_t) + 1];
    .           snprintf(buf, sizeof(buf), "%" PRIu64, v);
    .           return CBB_add_bytes(out, (const uint8_t *)buf, strlen(buf));
    .         }
    .         
  160 (0.0%)  int CBS_is_valid_asn1_oid(const CBS *cbs) {
  100 (0.0%)    if (CBS_len(cbs) == 0) {
    .             return 0;  // OID encodings cannot be empty.
    .           }
    .         
  100 (0.0%)    CBS copy = *cbs;
   20 (0.0%)    uint8_t v, prev = 0;
  713 (0.0%)    while (CBS_get_u8(&copy, &v)) {
    .             // OID encodings are a sequence of minimally-encoded base-128 integers (see
    .             // |parse_base128_integer|). If |prev|'s MSB was clear, it was the last byte
    .             // of an integer (or |v| is the first byte). |v| is then the first byte of
    .             // the next integer. If first byte of an integer is 0x80, it is not
    .             // minimally-encoded.
  450 (0.0%)      if ((prev & 0x80) == 0 && v == 0x80) {
    .               return 0;
    .             }
  158 (0.0%)      prev = v;
    .           }
    .         
    .           // The last byte should must end an integer encoding.
   80 (0.0%)    return (prev & 0x80) == 0;
  100 (0.0%)  }
    .         
    .         char *CBS_asn1_oid_to_text(const CBS *cbs) {
    .           CBB cbb;
    .           if (!CBB_init(&cbb, 32)) {
    .             goto err;
    .           }
    .         
    .           CBS copy = *cbs;
-- line 737 ----------------------------------------
-- line 766 ----------------------------------------
    .         
    .           return (char *)txt;
    .         
    .         err:
    .           CBB_cleanup(&cbb);
    .           return NULL;
    .         }
    .         
  351 (0.0%)  static int cbs_get_two_digits(CBS *cbs, int *out) {
    .           uint8_t first_digit, second_digit;
  273 (0.0%)    if (!CBS_get_u8(cbs, &first_digit)) {
    .             return 0;
    .           }
  234 (0.0%)    if (!OPENSSL_isdigit(first_digit)) {
    .             return 0;
    .           }
  273 (0.0%)    if (!CBS_get_u8(cbs, &second_digit)) {
    .             return 0;
    .           }
  234 (0.0%)    if (!OPENSSL_isdigit(second_digit)) {
    .             return 0;
    .           }
  546 (0.0%)    *out = (first_digit - '0') * 10 + (second_digit - '0');
   39 (0.0%)    return 1;
  195 (0.0%)  }
    .         
   36 (0.0%)  static int is_valid_day(int year, int month, int day) {
   12 (0.0%)    if (day < 1) {
    .             return 0;
    .           }
  108 (0.0%)    switch (month) {
    .             case 1:
    .             case 3:
    .             case 5:
    .             case 7:
    .             case 8:
    .             case 10:
    .             case 12:
   12 (0.0%)        return day <= 31;
    .             case 4:
    .             case 6:
    .             case 9:
    .             case 11:
   12 (0.0%)        return day <= 30;
    .             case 2:
    .               if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
    .                 return day <= 29;
    .               } else {
    .                 return day <= 28;
    .               }
    .             default:
    .               return 0;
    .           }
   12 (0.0%)  }
    .         
    .         static int CBS_parse_rfc5280_time_internal(const CBS *cbs, int is_gentime,
    .                                                    int allow_timezone_offset,
   66 (0.0%)                                             struct tm *out_tm) {
    .           int year, month, day, hour, min, sec, tmp;
   30 (0.0%)    CBS copy = *cbs;
    .           uint8_t tz;
    .         
   12 (0.0%)    if (is_gentime) {
   21 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
    .               return 0;
    .             }
    9 (0.0%)      year = tmp * 100;
   21 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
    .               return 0;
    .             }
    9 (0.0%)      year += tmp;
    .           } else {
    3 (0.0%)      year = 1900;
   21 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
    .               return 0;
    .             }
    6 (0.0%)      year += tmp;
    6 (0.0%)      if (year < 1950) {
    3 (0.0%)        year += 100;
    .             }
    6 (0.0%)      if (year >= 2050) {
    .               return 0;  // A Generalized time must be used.
    .             }
    .           }
   72 (0.0%)    if (!cbs_get_two_digits(&copy, &month) || month < 1 ||
   18 (0.0%)        month > 12 ||  // Reject invalid months.
   42 (0.0%)        !cbs_get_two_digits(&copy, &day) ||
   48 (0.0%)        !is_valid_day(year, month, day) ||  // Reject invalid days.
   42 (0.0%)        !cbs_get_two_digits(&copy, &hour) ||
   18 (0.0%)        hour > 23 ||  // Reject invalid hours.
   42 (0.0%)        !cbs_get_two_digits(&copy, &min) ||
   18 (0.0%)        min > 59 ||  // Reject invalid minutes.
   90 (0.0%)        !cbs_get_two_digits(&copy, &sec) || sec > 59 || !CBS_get_u8(&copy, &tz)) {
    .             return 0;
    .           }
    .         
    6 (0.0%)    int offset_sign = 0;
   24 (0.0%)    switch (tz) {
    .             case 'Z':
    6 (0.0%)        break;  // We correctly have 'Z' on the end as per spec.
    .             case '+':
    .               offset_sign = 1;
    .               break;  // Should not be allowed per RFC 5280.
    .             case '-':
    .               offset_sign = -1;
    .               break;  // Should not be allowed per RFC 5280.
    .             default:
    .               return 0;  // Reject anything else after the time.
-- line 873 ----------------------------------------
-- line 880 ----------------------------------------
    .           // are now difficult to change. These certificates were generated with the
    .           // 'openssl' command that permissively allowed the creation of certificates
    .           // with notBefore and notAfter times specified as strings for direct
    .           // certificate inclusion on the command line. For context see cl/237068815.
    .           //
    .           // TODO(bbe): This has been expunged from public web-pki as the ecosystem has
    .           // managed to encourage CA compliance with standards. We should find a way to
    .           // get rid of this or make it off by default.
    6 (0.0%)    int offset_seconds = 0;
   12 (0.0%)    if (offset_sign != 0) {
    .             if (!allow_timezone_offset) {
    .               return 0;
    .             }
    .             int offset_hours, offset_minutes;
    .             if (!cbs_get_two_digits(&copy, &offset_hours) ||
    .                 offset_hours > 23 ||  // Reject invalid hours.
    .                 !cbs_get_two_digits(&copy, &offset_minutes) ||
    .                 offset_minutes > 59) {  // Reject invalid minutes.
    .               return 0;
    .             }
    .             offset_seconds = offset_sign * (offset_hours * 3600 + offset_minutes * 60);
    .           }
    .         
   30 (0.0%)    if (CBS_len(&copy) != 0) {
    .             return 0;  // Reject invalid lengths.
    .           }
    .         
   12 (0.0%)    if (out_tm != NULL) {
    .             // Fill in the tm fields corresponding to what we validated.
   16 (0.0%)      out_tm->tm_year = year - 1900;
   16 (0.0%)      out_tm->tm_mon = month - 1;
   12 (0.0%)      out_tm->tm_mday = day;
   12 (0.0%)      out_tm->tm_hour = hour;
   12 (0.0%)      out_tm->tm_min = min;
   12 (0.0%)      out_tm->tm_sec = sec;
    8 (0.0%)      if (offset_seconds && !OPENSSL_gmtime_adj(out_tm, 0, offset_seconds)) {
    .               return 0;
    .             }
    .           }
    6 (0.0%)    return 1;
   30 (0.0%)  }
    .         
    .         int CBS_parse_generalized_time(const CBS *cbs, struct tm *out_tm,
   21 (0.0%)                                 int allow_timezone_offset) {
   18 (0.0%)    return CBS_parse_rfc5280_time_internal(cbs, 1, allow_timezone_offset, out_tm);
    6 (0.0%)  }
    .         
    .         int CBS_parse_utc_time(const CBS *cbs, struct tm *out_tm,
   21 (0.0%)                         int allow_timezone_offset) {
   18 (0.0%)    return CBS_parse_rfc5280_time_internal(cbs, 0, allow_timezone_offset, out_tm);
    6 (0.0%)  }
    .         
    .         int CBS_get_optional_asn1_int64(CBS *cbs, int64_t *out, CBS_ASN1_TAG tag,
    .                                         int64_t default_value) {
    .           CBS child;
    .           int present;
    .           if (!CBS_get_optional_asn1(cbs, &child, &present, tag)) {
    .             return 0;
    .           }
-- line 938 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h
--------------------------------------------------------------------------------
Ir___________ 

-- line 218 ----------------------------------------
     .         #define OPENSSL_HAS_BUILTIN(x) 0
     .         #endif
     .         
     .         
     .         // Pointer utility functions.
     .         
     .         // buffers_alias returns one if |a| and |b| alias and zero otherwise.
     .         static inline int buffers_alias(const uint8_t *a, size_t a_len,
    90 (0.0%)                                  const uint8_t *b, size_t b_len) {
     .           // Cast |a| and |b| to integers. In C, pointer comparisons between unrelated
     .           // objects are undefined whereas pointer to integer conversions are merely
     .           // implementation-defined. We assume the implementation defined it in a sane
     .           // way.
    30 (0.0%)    uintptr_t a_u = (uintptr_t)a;
    30 (0.0%)    uintptr_t b_u = (uintptr_t)b;
   180 (0.0%)    return a_u + a_len > b_u && b_u + b_len > a_u;
    30 (0.0%)  }
     .         
     .         typedef uint8_t stack_align_type;
     .         OPENSSL_STATIC_ASSERT(sizeof(stack_align_type) == 1,
     .                               stack_align_type_is_not_8_bits_long)
     .         
     .         // align_pointer returns |ptr|, advanced to |alignment|. |alignment| must be a
     .         // power of two, and |ptr| must have at least |alignment - 1| bytes of scratch
     .         // space.
   800 (0.0%)  static inline void *align_pointer(void *ptr, size_t alignment) {
     .           // |alignment| must be a power of two.
 1,120 (0.0%)    assert(alignment != 0 && (alignment & (alignment - 1)) == 0);
     .           // Instead of aligning |ptr| as a |uintptr_t| and casting back, compute the
     .           // offset and advance in pointer space. C guarantees that casting from pointer
     .           // to |uintptr_t| and back gives the same pointer, but general
     .           // integer-to-pointer conversions are implementation-defined. GCC does define
     .           // it in the useful way, but this makes fewer assumptions.
 1,120 (0.0%)    uintptr_t offset = (0u - (uintptr_t)ptr) & (alignment - 1);
   320 (0.0%)    ptr = (char *)ptr + offset;
   960 (0.0%)    assert(((uintptr_t)ptr & (alignment - 1)) == 0);
   160 (0.0%)    return ptr;
   320 (0.0%)  }
     .         
     .         
     .         // Constant-time utility functions.
     .         //
     .         // The following methods return a bitmask of all ones (0xff...f) for true and 0
     .         // for false. This is useful for choosing a value based on the result of a
     .         // conditional in constant time. For example,
     .         //
-- line 263 ----------------------------------------
-- line 293 ----------------------------------------
     .         
     .         // value_barrier_w returns |a|, but prevents GCC and Clang from reasoning about
     .         // the returned value. This is used to mitigate compilers undoing constant-time
     .         // code, until we can express our requirements directly in the language.
     .         //
     .         // Note the compiler is aware that |value_barrier_w| has no side effects and
     .         // always has the same output for a given input. This allows it to eliminate
     .         // dead code, move computations across loops, and vectorize.
 2,328 (0.0%)  static inline crypto_word_t value_barrier_w(crypto_word_t a) {
     .         #if defined(__GNUC__) || defined(__clang__)
 1,552 (0.0%)    __asm__("" : "+r"(a) : /* no inputs */);
     .         #endif
   776 (0.0%)    return a;
 1,552 (0.0%)  }
     .         
     .         // value_barrier_u32 behaves like |value_barrier_w| but takes a |uint32_t|.
    30 (0.0%)  static inline uint32_t value_barrier_u32(uint32_t a) {
     .         #if defined(__GNUC__) || defined(__clang__)
    20 (0.0%)    __asm__("" : "+r"(a) : /* no inputs */);
     .         #endif
    10 (0.0%)    return a;
    20 (0.0%)  }
     .         
     .         // value_barrier_u64 behaves like |value_barrier_w| but takes a |uint64_t|.
     .         static inline uint64_t value_barrier_u64(uint64_t a) {
     .         #if defined(__GNUC__) || defined(__clang__)
     .           __asm__("" : "+r"(a) : /* no inputs */);
     .         #endif
     .           return a;
     .         }
     .         
     .         // constant_time_msb_w returns the given value with the MSB copied to all the
     .         // other bits.
   468 (0.0%)  static inline crypto_word_t constant_time_msb_w(crypto_word_t a) {
   312 (0.0%)    return 0u - (a >> (sizeof(a) * 8 - 1));
   312 (0.0%)  }
     .         
     .         // constant_time_lt_w returns 0xff..f if a < b and 0 otherwise.
     .         static inline crypto_word_t constant_time_lt_w(crypto_word_t a,
   315 (0.0%)                                                 crypto_word_t b) {
     .           // Consider the two cases of the problem:
     .           //   msb(a) == msb(b): a < b iff the MSB of a - b is set.
     .           //   msb(a) != msb(b): a < b iff the MSB of b is set.
     .           //
     .           // If msb(a) == msb(b) then the following evaluates as:
     .           //   msb(a^((a^b)|((a-b)^a))) ==
     .           //   msb(a^((a-b) ^ a))       ==   (because msb(a^b) == 0)
     .           //   msb(a^a^(a-b))           ==   (rearranging)
-- line 340 ----------------------------------------
-- line 355 ----------------------------------------
     .           // )
     .           //
     .           // (declare-fun a () (_ BitVec 32))
     .           // (declare-fun b () (_ BitVec 32))
     .           //
     .           // (assert (not (= (= #x00000001 (bvlshr (lt a b) #x0000001f)) (bvult a b))))
     .           // (check-sat)
     .           // (get-model)
   630 (0.0%)    return constant_time_msb_w(a^((a^b)|((a-b)^a)));
   126 (0.0%)  }
     .         
     .         // constant_time_lt_8 acts like |constant_time_lt_w| but returns an 8-bit
     .         // mask.
     .         static inline uint8_t constant_time_lt_8(crypto_word_t a, crypto_word_t b) {
     .           return (uint8_t)(constant_time_lt_w(a, b));
     .         }
     .         
     .         // constant_time_ge_w returns 0xff..f if a >= b and 0 otherwise.
-- line 372 ----------------------------------------
-- line 377 ----------------------------------------
     .         
     .         // constant_time_ge_8 acts like |constant_time_ge_w| but returns an 8-bit
     .         // mask.
     .         static inline uint8_t constant_time_ge_8(crypto_word_t a, crypto_word_t b) {
     .           return (uint8_t)(constant_time_ge_w(a, b));
     .         }
     .         
     .         // constant_time_is_zero returns 0xff..f if a == 0 and 0 otherwise.
   372 (0.0%)  static inline crypto_word_t constant_time_is_zero_w(crypto_word_t a) {
     .           // Here is an SMT-LIB verification of this formula:
     .           //
     .           // (define-fun is_zero ((a (_ BitVec 32))) (_ BitVec 32)
     .           //   (bvand (bvnot a) (bvsub a #x00000001))
     .           // )
     .           //
     .           // (declare-fun a () (_ BitVec 32))
     .           //
     .           // (assert (not (= (= #x00000001 (bvlshr (is_zero a) #x0000001f)) (= a #x00000000))))
     .           // (check-sat)
     .           // (get-model)
   744 (0.0%)    return constant_time_msb_w(~a & (a - 1));
   186 (0.0%)  }
     .         
     .         // constant_time_is_zero_8 acts like |constant_time_is_zero_w| but returns an
     .         // 8-bit mask.
     .         static inline uint8_t constant_time_is_zero_8(crypto_word_t a) {
     .           return (uint8_t)(constant_time_is_zero_w(a));
     .         }
     .         
     .         // constant_time_eq_w returns 0xff..f if a == b and 0 otherwise.
     .         static inline crypto_word_t constant_time_eq_w(crypto_word_t a,
   300 (0.0%)                                                 crypto_word_t b) {
   240 (0.0%)    return constant_time_is_zero_w(a ^ b);
   120 (0.0%)  }
     .         
     .         // constant_time_eq_8 acts like |constant_time_eq_w| but returns an 8-bit
     .         // mask.
     .         static inline uint8_t constant_time_eq_8(crypto_word_t a, crypto_word_t b) {
     .           return (uint8_t)(constant_time_eq_w(a, b));
     .         }
     .         
     .         // constant_time_eq_int acts like |constant_time_eq_w| but works on int
-- line 418 ----------------------------------------
-- line 427 ----------------------------------------
     .           return constant_time_eq_8((crypto_word_t)(a), (crypto_word_t)(b));
     .         }
     .         
     .         // constant_time_select_w returns (mask & a) | (~mask & b). When |mask| is all
     .         // 1s or all 0s (as returned by the methods above), the select methods return
     .         // either |a| (if |mask| is nonzero) or |b| (if |mask| is zero).
     .         static inline crypto_word_t constant_time_select_w(crypto_word_t mask,
     .                                                            crypto_word_t a,
 2,716 (0.0%)                                                     crypto_word_t b) {
     .           // Clang recognizes this pattern as a select. While it usually transforms it
     .           // to a cmov, it sometimes further transforms it into a branch, which we do
     .           // not want.
     .           //
     .           // Adding barriers to both |mask| and |~mask| breaks the relationship between
     .           // the two, which makes the compiler stick with bitmasks.
 4,268 (0.1%)    return (value_barrier_w(mask) & a) | (value_barrier_w(~mask) & b);
 1,164 (0.0%)  }
     .         
     .         // constant_time_select_8 acts like |constant_time_select| but operates on
     .         // 8-bit values.
     .         static inline uint8_t constant_time_select_8(uint8_t mask, uint8_t a,
     .                                                      uint8_t b) {
     .           return (uint8_t)(constant_time_select_w(mask, a, b));
     .         }
     .         
     .         // constant_time_select_int acts like |constant_time_select| but operates on
     .         // ints.
   720 (0.0%)  static inline int constant_time_select_int(crypto_word_t mask, int a, int b) {
   960 (0.0%)    return (int)(constant_time_select_w(mask, (crypto_word_t)(a),
     .                                               (crypto_word_t)(b)));
   240 (0.0%)  }
     .         
     .         #if defined(BORINGSSL_CONSTANT_TIME_VALIDATION)
     .         
     .         // CONSTTIME_SECRET takes a pointer and a number of bytes and marks that region
     .         // of memory as secret. Secret data is tracked as it flows to registers and
     .         // other parts of a memory. If secret data is used as a condition for a branch,
     .         // or as a memory index, it will trigger warnings in valgrind.
     .         #define CONSTTIME_SECRET(ptr, len) VALGRIND_MAKE_MEM_UNDEFINED(ptr, len)
-- line 465 ----------------------------------------
-- line 487 ----------------------------------------
     .           // significantly impact optimizations.
     .           //
     .           // Thus, to be safe, stick a value barrier, in hopes of comparably inhibiting
     .           // compiler analysis.
     .           CONSTTIME_DECLASSIFY(&v, sizeof(v));
     .           return value_barrier_w(v);
     .         }
     .         
    40 (0.0%)  static inline int constant_time_declassify_int(int v) {
     .           OPENSSL_STATIC_ASSERT(sizeof(uint32_t) == sizeof(int),
     .                         int_is_not_the_same_size_as_uint32_t);
     .           // See comment above.
     .           CONSTTIME_DECLASSIFY(&v, sizeof(v));
    30 (0.0%)    return value_barrier_u32(v);
    20 (0.0%)  }
     .         
     .         
     .         // Thread-safe initialisation.
     .         
     .         #if !defined(OPENSSL_THREADS)
     .         typedef uint32_t CRYPTO_once_t;
     .         #define CRYPTO_ONCE_INIT 0
     .         #elif defined(OPENSSL_WINDOWS_THREADS)
-- line 509 ----------------------------------------
-- line 800 ----------------------------------------
     .         static inline uint64_t CRYPTO_bswap8(uint64_t x) {
     .           return _byteswap_uint64(x);
     .         }
     .         #else
     .         static inline uint16_t CRYPTO_bswap2(uint16_t x) {
     .           return (x >> 8) | (x << 8);
     .         }
     .         
 4,164 (0.1%)  static inline uint32_t CRYPTO_bswap4(uint32_t x) {
 1,388 (0.0%)    x = (x >> 16) | (x << 16);
12,492 (0.2%)    x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);
 1,388 (0.0%)    return x;
 2,776 (0.0%)  }
     .         
   555 (0.0%)  static inline uint64_t CRYPTO_bswap8(uint64_t x) {
 1,221 (0.0%)    return CRYPTO_bswap4(x >> 32) | (((uint64_t)CRYPTO_bswap4(x)) << 32);
   333 (0.0%)  }
     .         #endif
     .         
     .         
     .         // Language bug workarounds.
     .         //
     .         // Most C standard library functions are undefined if passed NULL, even when the
     .         // corresponding length is zero. This gives them (and, in turn, all functions
     .         // which call them) surprising behavior on empty arrays. Some compilers will
-- line 824 ----------------------------------------
-- line 858 ----------------------------------------
     .             return NULL;
     .           }
     .         
     .           return memchr(s, c, n);
     .         }
     .         
     .         #endif  // __cplusplus
     .         
    12 (0.0%)  static inline int OPENSSL_memcmp(const void *s1, const void *s2, size_t n) {
     4 (0.0%)    if (n == 0) {
     .             return 0;
     .           }
     .         
    12 (0.0%)    return memcmp(s1, s2, n);
     4 (0.0%)  }
     .         
10,698 (0.2%)  static inline void *OPENSSL_memcpy(void *dst, const void *src, size_t n) {
 3,566 (0.1%)    if (n == 0) {
    16 (0.0%)      return dst;
     .           }
     .         
10,650 (0.2%)    return memcpy(dst, src, n);
 3,566 (0.1%)  }
     .         
    12 (0.0%)  static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
     4 (0.0%)    if (n == 0) {
     .             return dst;
     .           }
     .         
    12 (0.0%)    return memmove(dst, src, n);
     4 (0.0%)  }
     .         
 3,444 (0.1%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
 1,148 (0.0%)    if (n == 0) {
    54 (0.0%)      return dst;
     .           }
     .         
 3,282 (0.1%)    return memset(dst, c, n);
 1,148 (0.0%)  }
     .         
     .         
     .         // Loads and stores.
     .         //
     .         // The following functions load and store sized integers with the specified
     .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
     .         // requirements on the input and output pointers.
     .         
-- line 904 ----------------------------------------
-- line 949 ----------------------------------------
     .         static inline void CRYPTO_store_u32_le(void *out, uint32_t v) {
     .         #if defined(OPENSSL_BIG_ENDIAN)
     .           v = CRYPTO_bswap4(v);
     .         #endif
     .           OPENSSL_memcpy(out, &v, sizeof(v));
     .         
     .         }
     .         
   238 (0.0%)  static inline uint32_t CRYPTO_load_u32_be(const void *in) {
     .           uint32_t v;
   204 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
     .         #if defined(OPENSSL_BIG_ENDIAN)
     .           return v;
     .         #else
   102 (0.0%)    return CRYPTO_bswap4(v);
     .         #endif
   170 (0.0%)  }
     .         
 5,660 (0.1%)  static inline void CRYPTO_store_u32_be(void *out, uint32_t v) {
     .         
     .         #if !defined(OPENSSL_BIG_ENDIAN)
 4,528 (0.1%)    v = CRYPTO_bswap4(v);
     .         #endif
 6,792 (0.1%)    OPENSSL_memcpy(out, &v, sizeof(v));
     .         
 3,396 (0.1%)  }
     .         
     .         static inline uint64_t CRYPTO_load_u64_le(const void *in) {
     .           uint64_t v;
     .           OPENSSL_memcpy(&v, in, sizeof(v));
     .         #if defined(OPENSSL_BIG_ENDIAN)
     .           return CRYPTO_bswap8(v);
     .         #else
     .           return v;
-- line 982 ----------------------------------------
-- line 986 ----------------------------------------
     .         static inline void CRYPTO_store_u64_le(void *out, uint64_t v) {
     .         #if defined(OPENSSL_BIG_ENDIAN)
     .           v = CRYPTO_bswap8(v);
     .         #endif
     .           OPENSSL_memcpy(out, &v, sizeof(v));
     .         
     .         }
     .         
   147 (0.0%)  static inline uint64_t CRYPTO_load_u64_be(const void *ptr) {
     .           uint64_t ret;
   126 (0.0%)    OPENSSL_memcpy(&ret, ptr, sizeof(ret));
     .         #if defined(OPENSSL_BIG_ENDIAN)
     .           return ret;
     .         #else
    63 (0.0%)    return CRYPTO_bswap8(ret);
     .         #endif
   105 (0.0%)  }
     .         
   150 (0.0%)  static inline void CRYPTO_store_u64_be(void *out, uint64_t v) {
     .         #if defined(OPENSSL_BIG_ENDIAN)
     .         #else
   120 (0.0%)    v = CRYPTO_bswap8(v);
     .         #endif
   180 (0.0%)    OPENSSL_memcpy(out, &v, sizeof(v));
     .         
    90 (0.0%)  }
     .         
   560 (0.0%)  static inline crypto_word_t CRYPTO_load_word_le(const void *in) {
     .         
     .           crypto_word_t v;
   480 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
     .         #if defined(OPENSSL_BIG_ENDIAN)
     .           return CRYPTO_bswap_word(v);
     .         #else
    80 (0.0%)    return v;
     .         #endif
   400 (0.0%)  }
     .         
   200 (0.0%)  static inline void CRYPTO_store_word_le(void *out, crypto_word_t v) {
     .         
     .         
     .         #if defined(OPENSSL_BIG_ENDIAN)
     .           v = CRYPTO_bswap_word(v);
     .         #endif
   240 (0.0%)    OPENSSL_memcpy(out, &v, sizeof(v));
     .         
   120 (0.0%)  }
     .         
   420 (0.0%)  static inline crypto_word_t CRYPTO_load_word_be(const void *in) {
     .           crypto_word_t v;
   360 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
     .         #if defined(OPENSSL_BIG_ENDIAN)
     .           return v;
     .         #else
     .         #if defined(OPENSSL_64_BIT)
     .           assert(sizeof(v) == 8);
   180 (0.0%)    return CRYPTO_bswap8(v);
     .         #else
     .           assert(sizeof(v) == 4);
     .           return CRYPTO_bswap4(v);
     .         #endif
     .         #endif
   300 (0.0%)  }
     .         
     .         // Bit rotation functions.
     .         //
     .         // Note these functions use |(-shift) & 31|, etc., because shifting by the bit
     .         // width is undefined. Both Clang and GCC recognize this pattern as a rotation,
     .         // but MSVC does not. Instead, we call MSVC's built-in functions.
     .         
     .         static inline uint32_t CRYPTO_rotl_u32(uint32_t value, int shift) {
-- line 1056 ----------------------------------------
-- line 1236 ----------------------------------------
     .         // if unsuccessful.
     .         void boringssl_ensure_ffdh_self_test(void);
     .         
     .         #else
     .         
     .         // Outside of FIPS mode, the lazy tests are no-ops.
     .         
     .         OPENSSL_INLINE void boringssl_ensure_rsa_self_test(void) {}
    20 (0.0%)  OPENSSL_INLINE void boringssl_ensure_ecc_self_test(void) {}
     .         OPENSSL_INLINE void boringssl_ensure_ffdh_self_test(void) {}
     .         
     .         #endif  // FIPS
     .         
     .         // boringssl_self_test_sha256 performs a SHA-256 KAT.
     .         int boringssl_self_test_sha256(void);
     .         
     .         // boringssl_self_test_hmac_sha256 performs an HMAC-SHA-256 KAT.
     .         int boringssl_self_test_hmac_sha256(void);
     .         
     .         #if defined(BORINGSSL_FIPS_COUNTERS)
     .         void boringssl_fips_inc_counter(enum fips_counter_t counter);
     .         #else
    48 (0.0%)  OPENSSL_INLINE void boringssl_fips_inc_counter(enum fips_counter_t counter) {}
     .         #endif
     .         
     .         #if defined(BORINGSSL_FIPS_BREAK_TESTS)
     .         OPENSSL_INLINE int boringssl_fips_break_test(const char *test) {
     .           const char *const value = getenv("BORINGSSL_FIPS_BREAK_TEST");
     .           return value != NULL && strcmp(value, test) == 0;
     .         }
     .         #else
-- line 1266 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bn.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 66 ----------------------------------------
    .         #include "../delocate.h"
    .         
    .         
    .         // BN_MAX_WORDS is the maximum number of words allowed in a |BIGNUM|. It is
    .         // sized so byte and bit counts of a |BIGNUM| always fit in |int|, with room to
    .         // spare.
    .         #define BN_MAX_WORDS (INT_MAX / (4 * BN_BITS2))
    .         
   32 (0.0%)  BIGNUM *BN_new(void) {
   24 (0.0%)    BIGNUM *bn = OPENSSL_zalloc(sizeof(BIGNUM));
    .         
   16 (0.0%)    if (bn == NULL) {
    .             return NULL;
    .           }
    .         
   16 (0.0%)    bn->flags = BN_FLG_MALLOCED;
    .         
    8 (0.0%)    return bn;
   16 (0.0%)  }
    .         
    .         BIGNUM *BN_secure_new(void) { return BN_new(); }
    .         
    .         void BN_init(BIGNUM *bn) {
    .           OPENSSL_memset(bn, 0, sizeof(BIGNUM));
    .         }
    .         
   40 (0.0%)  void BN_free(BIGNUM *bn) {
   16 (0.0%)    if (bn == NULL) {
    .             return;
    .           }
    .         
   40 (0.0%)    if ((bn->flags & BN_FLG_STATIC_DATA) == 0) {
   32 (0.0%)      OPENSSL_free(bn->d);
    .           }
    .         
   40 (0.0%)    if (bn->flags & BN_FLG_MALLOCED) {
   32 (0.0%)      OPENSSL_free(bn);
    .           } else {
    .             bn->d = NULL;
    .           }
   16 (0.0%)  }
    .         
    .         void BN_clear_free(BIGNUM *bn) {
    .           BN_free(bn);
    .         }
    .         
    .         BIGNUM *BN_dup(const BIGNUM *src) {
    .           BIGNUM *copy;
    .         
-- line 114 ----------------------------------------
-- line 160 ----------------------------------------
    .           out->width = 1;
    .           out->dmax = 1;
    .           out->neg = 0;
    .           out->flags = BN_FLG_STATIC_DATA;
    .         }
    .         
    .         // BN_num_bits_word returns the minimum number of bits needed to represent the
    .         // value in |l|.
  200 (0.0%)  unsigned BN_num_bits_word(BN_ULONG l) {
    .           // |BN_num_bits| is often called on RSA prime factors. These have public bit
    .           // lengths, but all bits beyond the high bit are secret, so count bits in
    .           // constant time.
    .           BN_ULONG x, mask;
  200 (0.0%)    int bits = (l != 0);
    .         
    .         #if BN_BITS2 > 32
    .           // Look at the upper half of |x|. |x| is at most 64 bits long.
  150 (0.0%)    x = l >> 32;
    .           // Set |mask| to all ones if |x| (the top 32 bits of |l|) is non-zero and all
    .           // all zeros otherwise.
  150 (0.0%)    mask = 0u - x;
  150 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
    .           // If |x| is non-zero, the lower half is included in the bit count in full,
    .           // and we count the upper half. Otherwise, we count the lower half.
  300 (0.0%)    bits += 32 & mask;
  200 (0.0%)    l ^= (x ^ l) & mask;  // |l| is |x| if |mask| and remains |l| otherwise.
    .         #endif
    .         
    .           // The remaining blocks are analogous iterations at lower powers of two.
  150 (0.0%)    x = l >> 16;
  150 (0.0%)    mask = 0u - x;
  150 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
  300 (0.0%)    bits += 16 & mask;
  200 (0.0%)    l ^= (x ^ l) & mask;
    .         
  150 (0.0%)    x = l >> 8;
  150 (0.0%)    mask = 0u - x;
  150 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
  300 (0.0%)    bits += 8 & mask;
  200 (0.0%)    l ^= (x ^ l) & mask;
    .         
  150 (0.0%)    x = l >> 4;
  150 (0.0%)    mask = 0u - x;
  150 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
  300 (0.0%)    bits += 4 & mask;
  200 (0.0%)    l ^= (x ^ l) & mask;
    .         
  150 (0.0%)    x = l >> 2;
  150 (0.0%)    mask = 0u - x;
  150 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
  300 (0.0%)    bits += 2 & mask;
  200 (0.0%)    l ^= (x ^ l) & mask;
    .         
  150 (0.0%)    x = l >> 1;
  150 (0.0%)    mask = 0u - x;
  150 (0.0%)    mask = (0u - (mask >> (BN_BITS2 - 1)));
  300 (0.0%)    bits += 1 & mask;
    .         
   50 (0.0%)    return bits;
  100 (0.0%)  }
    .         
  300 (0.0%)  unsigned BN_num_bits(const BIGNUM *bn) {
  200 (0.0%)    const int width = bn_minimal_width(bn);
  100 (0.0%)    if (width == 0) {
    .             return 0;
    .           }
    .         
  750 (0.0%)    return (width - 1) * BN_BITS2 + BN_num_bits_word(bn->d[width - 1]);
  150 (0.0%)  }
    .         
  185 (0.0%)  unsigned BN_num_bytes(const BIGNUM *bn) {
  185 (0.0%)    return (BN_num_bits(bn) + 7) / 8;
   74 (0.0%)  }
    .         
    .         void BN_zero(BIGNUM *bn) {
    .           bn->width = bn->neg = 0;
    .         }
    .         
    .         int BN_one(BIGNUM *bn) {
    .           return BN_set_word(bn, 1);
    .         }
-- line 240 ----------------------------------------
-- line 272 ----------------------------------------
    .           bn->d[1] = (BN_ULONG)(value >> 32);
    .           bn->width = 2;
    .           return 1;
    .         #else
    .         #error "BN_BITS2 must be 32 or 64."
    .         #endif
    .         }
    .         
   14 (0.0%)  int bn_set_words(BIGNUM *bn, const BN_ULONG *words, size_t num) {
   14 (0.0%)    if (!bn_wexpand(bn, num)) {
    .             return 0;
    .           }
   16 (0.0%)    OPENSSL_memmove(bn->d, words, num * sizeof(BN_ULONG));
    .           // |bn_wexpand| verified that |num| isn't too large.
    8 (0.0%)    bn->width = (int)num;
    4 (0.0%)    bn->neg = 0;
    2 (0.0%)    return 1;
    4 (0.0%)  }
    .         
    .         void bn_set_static_words(BIGNUM *bn, const BN_ULONG *words, size_t num) {
    .           if ((bn->flags & BN_FLG_STATIC_DATA) == 0) {
    .             OPENSSL_free(bn->d);
    .           }
    .           bn->d = (BN_ULONG *)words;
    .         
    .           assert(num <= BN_MAX_WORDS);
    .           bn->width = (int)num;
    .           bn->dmax = (int)num;
    .           bn->neg = 0;
    .           bn->flags |= BN_FLG_STATIC_DATA;
    .         }
    .         
   10 (0.0%)  int bn_fits_in_words(const BIGNUM *bn, size_t num) {
    .           // All words beyond |num| must be zero.
    2 (0.0%)    BN_ULONG mask = 0;
   64 (0.0%)    for (size_t i = num; i < (size_t)bn->width; i++) {
   56 (0.0%)      mask |= bn->d[i];
    .           }
    6 (0.0%)    return mask == 0;
    4 (0.0%)  }
    .         
   14 (0.0%)  int bn_copy_words(BN_ULONG *out, size_t num, const BIGNUM *bn) {
    8 (0.0%)    if (bn->neg) {
    .             OPENSSL_PUT_ERROR(BN, BN_R_NEGATIVE_NUMBER);
    .             return 0;
    .           }
    .         
    8 (0.0%)    size_t width = (size_t)bn->width;
    6 (0.0%)    if (width > num) {
    .             if (!bn_fits_in_words(bn, num)) {
    .               OPENSSL_PUT_ERROR(BN, BN_R_BIGNUM_TOO_LONG);
    .               return 0;
    .             }
    .             width = num;
    .           }
    .         
   12 (0.0%)    OPENSSL_memset(out, 0, sizeof(BN_ULONG) * num);
   16 (0.0%)    OPENSSL_memcpy(out, bn->d, sizeof(BN_ULONG) * width);
    2 (0.0%)    return 1;
    4 (0.0%)  }
    .         
   32 (0.0%)  int BN_is_negative(const BIGNUM *bn) {
   40 (0.0%)    return bn->neg != 0;
   16 (0.0%)  }
    .         
    .         void BN_set_negative(BIGNUM *bn, int sign) {
    .           if (sign && !BN_is_zero(bn)) {
    .             bn->neg = 1;
    .           } else {
    .             bn->neg = 0;
    .           }
    .         }
    .         
   48 (0.0%)  int bn_wexpand(BIGNUM *bn, size_t words) {
    .           BN_ULONG *a;
    .         
   40 (0.0%)    if (words <= (size_t)bn->dmax) {
    .             return 1;
    .           }
    .         
   16 (0.0%)    if (words > BN_MAX_WORDS) {
    .             OPENSSL_PUT_ERROR(BN, BN_R_BIGNUM_TOO_LONG);
    .             return 0;
    .           }
    .         
   40 (0.0%)    if (bn->flags & BN_FLG_STATIC_DATA) {
    .             OPENSSL_PUT_ERROR(BN, BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);
    .             return 0;
    .           }
    .         
   40 (0.0%)    a = OPENSSL_calloc(words, sizeof(BN_ULONG));
   16 (0.0%)    if (a == NULL) {
    .             return 0;
    .           }
    .         
   80 (0.0%)    OPENSSL_memcpy(a, bn->d, sizeof(BN_ULONG) * bn->width);
    .         
   32 (0.0%)    OPENSSL_free(bn->d);
   24 (0.0%)    bn->d = a;
   32 (0.0%)    bn->dmax = (int)words;
    .         
    8 (0.0%)    return 1;
   16 (0.0%)  }
    .         
    .         int bn_expand(BIGNUM *bn, size_t bits) {
    .           if (bits + BN_BITS2 - 1 < bits) {
    .             OPENSSL_PUT_ERROR(BN, BN_R_BIGNUM_TOO_LONG);
    .             return 0;
    .           }
    .           return bn_wexpand(bn, (bits+BN_BITS2-1)/BN_BITS2);
    .         }
-- line 382 ----------------------------------------
-- line 414 ----------------------------------------
    .             OPENSSL_PUT_ERROR(BN, BN_R_BIGNUM_TOO_LONG);
    .             return 0;
    .           }
    .           bn->width = (int)words;
    .           return 1;
    .         }
    .         
    .         void bn_select_words(BN_ULONG *r, BN_ULONG mask, const BN_ULONG *a,
  670 (0.0%)                       const BN_ULONG *b, size_t num) {
1,407 (0.0%)    for (size_t i = 0; i < num; i++) {
    .             OPENSSL_STATIC_ASSERT(sizeof(BN_ULONG) <= sizeof(crypto_word_t),
    .                                   crypto_word_t_is_too_small)
5,092 (0.1%)      r[i] = constant_time_select_w(mask, a[i], b[i]);
    .           }
  335 (0.0%)  }
    .         
  200 (0.0%)  int bn_minimal_width(const BIGNUM *bn) {
  150 (0.0%)    int ret = bn->width;
  650 (0.0%)    while (ret > 0 && bn->d[ret - 1] == 0) {
    .             ret--;
    .           }
   50 (0.0%)    return ret;
  100 (0.0%)  }
    .         
    .         void bn_set_minimal_width(BIGNUM *bn) {
    .           bn->width = bn_minimal_width(bn);
    .           if (bn->width == 0) {
    .             bn->neg = 0;
    .           }
    .         }
    .         
-- line 444 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/bn/bytes.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 57 ----------------------------------------
    .         #include <openssl/bn.h>
    .         
    .         #include <assert.h>
    .         #include <limits.h>
    .         
    .         #include "internal.h"
    .         
    .         void bn_big_endian_to_words(BN_ULONG *out, size_t out_len, const uint8_t *in,
  135 (0.0%)                              size_t in_len) {
  315 (0.0%)    for (size_t i = 0; i < out_len; i++) {
  122 (0.0%)      if (in_len < sizeof(BN_ULONG)) {
    .               // Load the last partial word.
    1 (0.0%)        BN_ULONG word = 0;
    5 (0.0%)        for (size_t j = 0; j < in_len; j++) {
    .                 word = (word << 8) | in[j];
    .               }
    1 (0.0%)        in_len = 0;
    6 (0.0%)        out[i] = word;
    .               // Fill the remainder with zeros.
   12 (0.0%)        OPENSSL_memset(out + i + 1, 0, (out_len - i - 1) * sizeof(BN_ULONG));
    1 (0.0%)        break;
    .             }
    .         
   60 (0.0%)      in_len -= sizeof(BN_ULONG);
  600 (0.0%)      out[i] = CRYPTO_load_word_be(in + in_len);
    .           }
    .         
    .           // The caller should have sized the output to avoid truncation.
   30 (0.0%)    assert(in_len == 0);
   60 (0.0%)  }
    .         
   42 (0.0%)  BIGNUM *BN_bin2bn(const uint8_t *in, size_t len, BIGNUM *ret) {
    6 (0.0%)    BIGNUM *bn = NULL;
   12 (0.0%)    if (ret == NULL) {
    .             bn = BN_new();
    .             if (bn == NULL) {
    .               return NULL;
    .             }
    .             ret = bn;
    .           }
    .         
   12 (0.0%)    if (len == 0) {
    .             ret->width = 0;
    .             return ret;
    .           }
    .         
   30 (0.0%)    size_t num_words = ((len - 1) / BN_BYTES) + 1;
   42 (0.0%)    if (!bn_wexpand(ret, num_words)) {
    .             BN_free(bn);
    .             return NULL;
    .           }
    .         
    .           // |bn_wexpand| must check bounds on |num_words| to write it into
    .           // |ret->dmax|.
   18 (0.0%)    assert(num_words <= INT_MAX);
   24 (0.0%)    ret->width = (int)num_words;
   12 (0.0%)    ret->neg = 0;
    .         
   54 (0.0%)    bn_big_endian_to_words(ret->d, ret->width, in, len);
    6 (0.0%)    return ret;
   12 (0.0%)  }
    .         
    .         BIGNUM *BN_le2bn(const uint8_t *in, size_t len, BIGNUM *ret) {
    .           BIGNUM *bn = NULL;
    .           if (ret == NULL) {
    .             bn = BN_new();
    .             if (bn == NULL) {
    .               return NULL;
    .             }
-- line 125 ----------------------------------------
-- line 176 ----------------------------------------
    .           // Fill the remainder with zeros.
    .           OPENSSL_memset( ((uint8_t*)out) + in_len, 0, sizeof(BN_ULONG)*out_len - in_len);
    .         #endif
    .         }
    .         
    .         // fits_in_bytes returns one if the |num_words| words in |words| can be
    .         // represented in |num_bytes| bytes.
    .         static int fits_in_bytes(const BN_ULONG *words, size_t num_words,
  114 (0.0%)                           size_t num_bytes) {
   19 (0.0%)    uint8_t mask = 0;
    .         #ifdef OPENSSL_BIG_ENDIAN
    .           for (size_t i = num_bytes / BN_BYTES; i < num_words; i++) {
    .             BN_ULONG word = words[i];
    .             for (size_t j = 0; j < BN_BYTES; j++) {
    .               if ((i * BN_BYTES) + j < num_bytes) {
    .                 // For the first word we don't need to check any bytes shorter than len
    .                 continue ;
    .               } else {
    .                 mask |= (word >> (j * 8)) & 0xff;
    .               }
    .             }
    .           }
    .         #else
   38 (0.0%)    const uint8_t *bytes = (const uint8_t *)words;
   57 (0.0%)    size_t tot_bytes = num_words * sizeof(BN_ULONG);
  114 (0.0%)    for (size_t i = num_bytes; i < tot_bytes; i++) {
    .             mask |= bytes[i];
    .           }
    .         #endif
   57 (0.0%)    return mask == 0;
   38 (0.0%)  }
    .         
    .         // Asserts that the BIGNUM can be represented within |num| bytes.
    .         // The logic is consistent with `fits_in_bytes` but assertions will fail when false.
    .         void bn_assert_fits_in_bytes(const BIGNUM *bn, size_t num) {
    .           const uint8_t *bytes = (const uint8_t *)bn->d;
    .           size_t tot_bytes = bn->width * sizeof(BN_ULONG);
    .           if (tot_bytes > num) {
    .             CONSTTIME_DECLASSIFY(bytes + num, tot_bytes - num);
-- line 214 ----------------------------------------
-- line 234 ----------------------------------------
    .             }
    .         #endif
    .         #endif
    .             (void)bytes;
    .           }
    .         }
    .         
    .         void bn_words_to_big_endian(uint8_t *out, size_t out_len, const BN_ULONG *in,
  120 (0.0%)                              size_t in_len) {
    .           // The caller should have selected an output length without truncation.
  120 (0.0%)    assert(fits_in_bytes(in, in_len, out_len));
   45 (0.0%)    size_t num_bytes = in_len * sizeof(BN_ULONG);
   45 (0.0%)    if (out_len < num_bytes) {
    .             num_bytes = out_len;
    .           }
    .         
    .         #ifdef OPENSSL_BIG_ENDIAN
    .           for (size_t i = 0; i < num_bytes; i++) {
    .             BN_ULONG l = in[i / BN_BYTES];
    .             out[out_len - i - 1] = (uint8_t)(l >> (8 * (i % BN_BYTES))) & 0xff;
    .           }
    .         #else
   30 (0.0%)    const uint8_t *bytes = (const uint8_t *)in;
1,995 (0.0%)    for (size_t i = 0; i < num_bytes; i++) {
4,800 (0.1%)      out[out_len - i - 1] = bytes[i];
    .           }
    .         #endif
    .           // Pad out the rest of the buffer with zeroes.
  105 (0.0%)    OPENSSL_memset(out, 0, out_len - num_bytes);
   45 (0.0%)  }
    .         
    .         size_t BN_bn2bin(const BIGNUM *in, uint8_t *out) {
    .           size_t n = BN_num_bytes(in);
    .           bn_words_to_big_endian(out, n, in->d, in->width);
    .           return n;
    .         }
    .         
    .         void bn_words_to_little_endian(uint8_t *out, size_t out_len, const BN_ULONG *in, const size_t in_len) {
-- line 271 ----------------------------------------
-- line 296 ----------------------------------------
    .         int BN_bn2le_padded(uint8_t *out, size_t len, const BIGNUM *in) {
    .           if (!fits_in_bytes(in->d, in->width, len)) {
    .             return 0;
    .           }
    .           bn_words_to_little_endian(out, len, in->d, in->width);
    .           return 1;
    .         }
    .         
   28 (0.0%)  int BN_bn2bin_padded(uint8_t *out, size_t len, const BIGNUM *in) {
   44 (0.0%)    if (!fits_in_bytes(in->d, in->width, len)) {
    .             return 0;
    .           }
    .         
   36 (0.0%)    bn_words_to_big_endian(out, len, in->d, in->width);
    4 (0.0%)    return 1;
    8 (0.0%)  }
    .         
    .         BN_ULONG BN_get_word(const BIGNUM *bn) {
    .           switch (bn_minimal_width(bn)) {
    .             case 0:
    .               return 0;
    .             case 1:
    .               return bn->d[0];
    .             default:
-- line 319 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/ec/p256-nistz.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 44 ----------------------------------------
    .             TOBN(0xffffffff, 0xffffffff), TOBN(0x00000000, 0xfffffffe),
    .         };
    .         
    .         // Precomputed tables for the default generator
    .         #include "p256-nistz-table.h"
    .         
    .         // Recode window to a signed digit, see |ec_GFp_nistp_recode_scalar_bits| in
    .         // util.c for details
  624 (0.0%)  static crypto_word_t booth_recode_w5(crypto_word_t in) {
    .           crypto_word_t s, d;
    .         
  624 (0.0%)    s = ~((in >> 5) - 1);
  468 (0.0%)    d = (1 << 6) - in - 1;
1,248 (0.0%)    d = (d & s) | (in & ~s);
1,092 (0.0%)    d = (d >> 1) + (d & 1);
    .         
  780 (0.0%)    return (d << 1) + (s & 1);
  312 (0.0%)  }
    .         
  592 (0.0%)  static crypto_word_t booth_recode_w7(crypto_word_t in) {
    .           crypto_word_t s, d;
    .         
  592 (0.0%)    s = ~((in >> 7) - 1);
  444 (0.0%)    d = (1 << 8) - in - 1;
1,184 (0.0%)    d = (d & s) | (in & ~s);
1,036 (0.0%)    d = (d >> 1) + (d & 1);
    .         
  740 (0.0%)    return (d << 1) + (s & 1);
  296 (0.0%)  }
    .         
    .         // copy_conditional copies |src| to |dst| if |move| is one and leaves it as-is
    .         // if |move| is zero.
    .         //
    .         // WARNING: this breaks the usual convention of constant-time functions
    .         // returning masks.
    .         static void copy_conditional(BN_ULONG dst[P256_LIMBS],
1,602 (0.0%)                               const BN_ULONG src[P256_LIMBS], BN_ULONG move) {
  801 (0.0%)    BN_ULONG mask1 = ((BN_ULONG)0) - move;
  801 (0.0%)    BN_ULONG mask2 = ~mask1;
    .         
2,670 (0.0%)    dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);
3,738 (0.1%)    dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);
3,738 (0.1%)    dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);
3,738 (0.1%)    dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);
    .           if (P256_LIMBS == 8) {
    .             dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);
    .             dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);
    .             dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);
    .             dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);
    .           }
  801 (0.0%)  }
    .         
    .         // is_not_zero returns one iff in != 0 and zero otherwise.
    .         //
    .         // WARNING: this breaks the usual convention of constant-time functions
    .         // returning masks.
    .         //
    .         // (define-fun is_not_zero ((in (_ BitVec 64))) (_ BitVec 64)
    .         //   (bvlshr (bvor in (bvsub #x0000000000000000 in)) #x000000000000003f)
-- line 102 ----------------------------------------
-- line 105 ----------------------------------------
    .         // (declare-fun x () (_ BitVec 64))
    .         //
    .         // (assert (and (= x #x0000000000000000) (= (is_not_zero x) #x0000000000000001)))
    .         // (check-sat)
    .         //
    .         // (assert (and (not (= x #x0000000000000000)) (= (is_not_zero x) #x0000000000000000)))
    .         // (check-sat)
    .         //
   12 (0.0%)  static BN_ULONG is_not_zero(BN_ULONG in) {
    9 (0.0%)    in |= (0 - in);
    3 (0.0%)    in >>= BN_BITS2 - 1;
    3 (0.0%)    return in;
    6 (0.0%)  }
    .         
    .         // ecp_nistz256_mod_inverse_sqr_mont sets |r| to (|in| * 2^-256)^-2 * 2^256 mod
    .         // p. That is, |r| is the modular inverse square of |in| for input and output in
    .         // the Montgomery domain.
    .         static void ecp_nistz256_mod_inverse_sqr_mont(BN_ULONG r[P256_LIMBS],
   45 (0.0%)                                                const BN_ULONG in[P256_LIMBS]) {
    .           // This implements the addition chain described in
    .           // https://briansmith.org/ecc-inversion-addition-chains-01#p256_field_inversion
    .           BN_ULONG x2[P256_LIMBS], x3[P256_LIMBS], x6[P256_LIMBS], x12[P256_LIMBS],
    .               x15[P256_LIMBS], x30[P256_LIMBS], x32[P256_LIMBS];
   25 (0.0%)    ecp_nistz256_sqr_mont(x2, in);      // 2^2 - 2^1
   30 (0.0%)    ecp_nistz256_mul_mont(x2, x2, in);  // 2^2 - 2^0
    .         
   25 (0.0%)    ecp_nistz256_sqr_mont(x3, x2);      // 2^3 - 2^1
   30 (0.0%)    ecp_nistz256_mul_mont(x3, x3, in);  // 2^3 - 2^0
    .         
   25 (0.0%)    ecp_nistz256_sqr_mont(x6, x3);
   50 (0.0%)    for (int i = 1; i < 3; i++) {
   50 (0.0%)      ecp_nistz256_sqr_mont(x6, x6);
    .           }                                   // 2^6 - 2^3
   30 (0.0%)    ecp_nistz256_mul_mont(x6, x6, x3);  // 2^6 - 2^0
    .         
   25 (0.0%)    ecp_nistz256_sqr_mont(x12, x6);
   95 (0.0%)    for (int i = 1; i < 6; i++) {
  125 (0.0%)      ecp_nistz256_sqr_mont(x12, x12);
    .           }                                     // 2^12 - 2^6
   30 (0.0%)    ecp_nistz256_mul_mont(x12, x12, x6);  // 2^12 - 2^0
    .         
   25 (0.0%)    ecp_nistz256_sqr_mont(x15, x12);
   50 (0.0%)    for (int i = 1; i < 3; i++) {
   50 (0.0%)      ecp_nistz256_sqr_mont(x15, x15);
    .           }                                     // 2^15 - 2^3
   30 (0.0%)    ecp_nistz256_mul_mont(x15, x15, x3);  // 2^15 - 2^0
    .         
   25 (0.0%)    ecp_nistz256_sqr_mont(x30, x15);
  230 (0.0%)    for (int i = 1; i < 15; i++) {
  350 (0.0%)      ecp_nistz256_sqr_mont(x30, x30);
    .           }                                      // 2^30 - 2^15
   30 (0.0%)    ecp_nistz256_mul_mont(x30, x30, x15);  // 2^30 - 2^0
    .         
   25 (0.0%)    ecp_nistz256_sqr_mont(x32, x30);
   25 (0.0%)    ecp_nistz256_sqr_mont(x32, x32);      // 2^32 - 2^2
   30 (0.0%)    ecp_nistz256_mul_mont(x32, x32, x2);  // 2^32 - 2^0
    .         
    .           BN_ULONG ret[P256_LIMBS];
   25 (0.0%)    ecp_nistz256_sqr_mont(ret, x32);
  485 (0.0%)    for (int i = 1; i < 31 + 1; i++) {
  775 (0.0%)      ecp_nistz256_sqr_mont(ret, ret);
    .           }                                     // 2^64 - 2^32
   30 (0.0%)    ecp_nistz256_mul_mont(ret, ret, in);  // 2^64 - 2^32 + 2^0
    .         
1,940 (0.0%)    for (int i = 0; i < 96 + 32; i++) {
3,200 (0.1%)      ecp_nistz256_sqr_mont(ret, ret);
    .           }                                      // 2^192 - 2^160 + 2^128
   30 (0.0%)    ecp_nistz256_mul_mont(ret, ret, x32);  // 2^192 - 2^160 + 2^128 + 2^32 - 2^0
    .         
  500 (0.0%)    for (int i = 0; i < 32; i++) {
  800 (0.0%)      ecp_nistz256_sqr_mont(ret, ret);
    .           }                                      // 2^224 - 2^192 + 2^160 + 2^64 - 2^32
   30 (0.0%)    ecp_nistz256_mul_mont(ret, ret, x32);  // 2^224 - 2^192 + 2^160 + 2^64 - 2^0
    .         
  470 (0.0%)    for (int i = 0; i < 30; i++) {
  750 (0.0%)      ecp_nistz256_sqr_mont(ret, ret);
    .           }                                      // 2^254 - 2^222 + 2^190 + 2^94 - 2^30
   30 (0.0%)    ecp_nistz256_mul_mont(ret, ret, x30);  // 2^254 - 2^222 + 2^190 + 2^94 - 2^0
    .         
   25 (0.0%)    ecp_nistz256_sqr_mont(ret, ret);
   25 (0.0%)    ecp_nistz256_sqr_mont(r, ret);  // 2^256 - 2^224 + 2^192 + 2^96 - 2^2
   30 (0.0%)  }
    .         
    .         // r = p * p_scalar
    .         static void ecp_nistz256_windowed_mul(const EC_GROUP *group, P256_POINT *r,
    .                                               const EC_JACOBIAN *p,
   33 (0.0%)                                        const EC_SCALAR *p_scalar) {
    6 (0.0%)    assert(p != NULL);
    6 (0.0%)    assert(p_scalar != NULL);
   12 (0.0%)    assert(group->field.N.width == P256_LIMBS);
    .         
    .           static const size_t kWindowSize = 5;
    .           static const crypto_word_t kMask = (1 << (5 /* kWindowSize */ + 1)) - 1;
    .         
    .           // A |P256_POINT| is (3 * 32) = 96 bytes, and the 64-byte alignment should
    .           // add no more than 63 bytes of overhead. Thus, |table| should require
    .           // ~1599 ((96 * 16) + 63) bytes of stack space.
    .           stack_align_type table_buffer[64 + (sizeof(P256_POINT) * 16)];
   15 (0.0%)    P256_POINT *aligned_table = (P256_POINT *) align_pointer(table_buffer, 64);
    .           uint8_t p_str[33];
   18 (0.0%)    OPENSSL_memcpy(p_str, p_scalar->words, 32);
    3 (0.0%)    p_str[32] = 0;
    .         
    .           // table[0] is implicitly (0,0,0) (the point at infinity), therefore it is
    .           // not stored. All other values are actually stored with an offset of -1 in
    .           // table.
    6 (0.0%)    P256_POINT *row = aligned_table;
   12 (0.0%)    assert(group->field.N.width == P256_LIMBS);
   18 (0.0%)    OPENSSL_memcpy(row[1 - 1].X, p->X.words, P256_LIMBS * sizeof(BN_ULONG));
   24 (0.0%)    OPENSSL_memcpy(row[1 - 1].Y, p->Y.words, P256_LIMBS * sizeof(BN_ULONG));
   24 (0.0%)    OPENSSL_memcpy(row[1 - 1].Z, p->Z.words, P256_LIMBS * sizeof(BN_ULONG));
    .         
   18 (0.0%)    ecp_nistz256_point_double(&row[2 - 1], &row[1 - 1]);
   24 (0.0%)    ecp_nistz256_point_add(&row[3 - 1], &row[2 - 1], &row[1 - 1]);
   21 (0.0%)    ecp_nistz256_point_double(&row[4 - 1], &row[2 - 1]);
   21 (0.0%)    ecp_nistz256_point_double(&row[6 - 1], &row[3 - 1]);
   21 (0.0%)    ecp_nistz256_point_double(&row[8 - 1], &row[4 - 1]);
   21 (0.0%)    ecp_nistz256_point_double(&row[12 - 1], &row[6 - 1]);
   24 (0.0%)    ecp_nistz256_point_add(&row[5 - 1], &row[4 - 1], &row[1 - 1]);
   24 (0.0%)    ecp_nistz256_point_add(&row[7 - 1], &row[6 - 1], &row[1 - 1]);
   24 (0.0%)    ecp_nistz256_point_add(&row[9 - 1], &row[8 - 1], &row[1 - 1]);
   24 (0.0%)    ecp_nistz256_point_add(&row[13 - 1], &row[12 - 1], &row[1 - 1]);
   21 (0.0%)    ecp_nistz256_point_double(&row[14 - 1], &row[7 - 1]);
   21 (0.0%)    ecp_nistz256_point_double(&row[10 - 1], &row[5 - 1]);
   24 (0.0%)    ecp_nistz256_point_add(&row[15 - 1], &row[14 - 1], &row[1 - 1]);
   24 (0.0%)    ecp_nistz256_point_add(&row[11 - 1], &row[10 - 1], &row[1 - 1]);
   21 (0.0%)    ecp_nistz256_point_double(&row[16 - 1], &row[8 - 1]);
    .         
    .           BN_ULONG tmp[P256_LIMBS];
    .           stack_align_type buffer_h[32 + sizeof(P256_POINT)];
   15 (0.0%)    P256_POINT *aligned_h = (P256_POINT *) align_pointer(buffer_h, 32);
    3 (0.0%)    size_t index = 255;
   18 (0.0%)    crypto_word_t wvalue = p_str[(index - 1) / 8];
   27 (0.0%)    wvalue = (wvalue >> ((index - 1) % 8)) & kMask;
    .         
   30 (0.0%)    ecp_nistz256_select_w5(r, aligned_table, booth_recode_w5(wvalue) >> 1);
    .         
  315 (0.0%)    while (index >= 5) {
  306 (0.0%)      if (index != 255) {
  600 (0.0%)        size_t off = (index - 1) / 8;
    .         
1,800 (0.0%)        wvalue = (crypto_word_t)p_str[off] | (crypto_word_t)p_str[off + 1] << 8;
1,350 (0.0%)        wvalue = (wvalue >> ((index - 1) % 8)) & kMask;
    .         
  600 (0.0%)        wvalue = booth_recode_w5(wvalue);
    .         
1,200 (0.0%)        ecp_nistz256_select_w5(aligned_h, aligned_table, wvalue >> 1);
    .         
  900 (0.0%)        ecp_nistz256_neg(tmp, aligned_h->Y);
1,350 (0.0%)        copy_conditional(aligned_h->Y, tmp, (wvalue & 1));
    .         
  900 (0.0%)        ecp_nistz256_point_add(r, r, aligned_h);
    .             }
    .         
  306 (0.0%)      index -= kWindowSize;
    .         
  765 (0.0%)      ecp_nistz256_point_double(r, r);
  765 (0.0%)      ecp_nistz256_point_double(r, r);
  765 (0.0%)      ecp_nistz256_point_double(r, r);
  765 (0.0%)      ecp_nistz256_point_double(r, r);
  765 (0.0%)      ecp_nistz256_point_double(r, r);
    .           }
    .         
    .           // Final window
    9 (0.0%)    wvalue = p_str[0];
   15 (0.0%)    wvalue = (wvalue << 1) & kMask;
    .         
   12 (0.0%)    wvalue = booth_recode_w5(wvalue);
    .         
   24 (0.0%)    ecp_nistz256_select_w5(aligned_h, aligned_table, wvalue >> 1);
    .         
   18 (0.0%)    ecp_nistz256_neg(tmp, aligned_h->Y);
   27 (0.0%)    copy_conditional(aligned_h->Y, tmp, wvalue & 1);
    .         
   18 (0.0%)    ecp_nistz256_point_add(r, r, aligned_h);
   18 (0.0%)  }
    .         
   24 (0.0%)  static crypto_word_t calc_first_wvalue(size_t *index, const uint8_t p_str[33]) {
    .           static const size_t kWindowSize = 7;
    .           static const crypto_word_t kMask = (1 << (7 /* kWindowSize */ + 1)) - 1;
   12 (0.0%)    *index = kWindowSize;
    .         
   32 (0.0%)    crypto_word_t wvalue = (p_str[0] << 1) & kMask;
   12 (0.0%)    return booth_recode_w7(wvalue);
    8 (0.0%)  }
    .         
  864 (0.0%)  static crypto_word_t calc_wvalue(size_t *index, const uint8_t p_str[33]) {
    .           static const size_t kWindowSize = 7;
    .           static const crypto_word_t kMask = (1 << (7 /* kWindowSize */ + 1)) - 1;
    .         
  720 (0.0%)    const size_t off = (*index - 1) / 8;
  288 (0.0%)    crypto_word_t wvalue =
1,728 (0.0%)        (crypto_word_t)p_str[off] | (crypto_word_t)p_str[off + 1] << 8;
1,440 (0.0%)    wvalue = (wvalue >> ((*index - 1) % 8)) & kMask;
  864 (0.0%)    *index += kWindowSize;
    .         
  432 (0.0%)    return booth_recode_w7(wvalue);
  288 (0.0%)  }
    .         
    .         static void ecp_nistz256_point_mul(const EC_GROUP *group, EC_JACOBIAN *r,
    .                                            const EC_JACOBIAN *p,
   22 (0.0%)                                     const EC_SCALAR *scalar) {
    .           stack_align_type buffer_out[32 + sizeof(P256_POINT)];
   10 (0.0%)    P256_POINT *aligned_out = (P256_POINT *) align_pointer(buffer_out, 32);
   12 (0.0%)    ecp_nistz256_windowed_mul(group, aligned_out, p, scalar);
    .         
    8 (0.0%)    assert(group->field.N.width == P256_LIMBS);
   12 (0.0%)    OPENSSL_memcpy(r->X.words, aligned_out->X, P256_LIMBS * sizeof(BN_ULONG));
   16 (0.0%)    OPENSSL_memcpy(r->Y.words, aligned_out->Y, P256_LIMBS * sizeof(BN_ULONG));
   16 (0.0%)    OPENSSL_memcpy(r->Z.words, aligned_out->Z, P256_LIMBS * sizeof(BN_ULONG));
   12 (0.0%)  }
    .         
    .         static void ecp_nistz256_point_mul_base(const EC_GROUP *group, EC_JACOBIAN *r,
   30 (0.0%)                                          const EC_SCALAR *scalar) {
    .         
    .           stack_align_type buffer_t[32 + sizeof(P256_POINT_AFFINE)];
   15 (0.0%)    P256_POINT_AFFINE *aligned_t = (P256_POINT_AFFINE *) align_pointer(buffer_t, 32);
    .           stack_align_type buffer_p[32 + sizeof(P256_POINT)];
   15 (0.0%)    P256_POINT *aligned_p = (P256_POINT *) align_pointer(buffer_p, 32);
    .         
    .           uint8_t p_str[33];
   18 (0.0%)    OPENSSL_memcpy(p_str, scalar->words, 32);
    3 (0.0%)    p_str[32] = 0;
    .         
    .           // First window
    3 (0.0%)    size_t index = 0;
   18 (0.0%)    crypto_word_t wvalue = calc_first_wvalue(&index, p_str);
    .         
   24 (0.0%)    ecp_nistz256_select_w7(aligned_t, ecp_nistz256_precomputed[0], wvalue >> 1);
   21 (0.0%)    ecp_nistz256_neg(aligned_p->Z, aligned_t->Y);
   30 (0.0%)    copy_conditional(aligned_t->Y, aligned_p->Z, wvalue & 1);
    .         
    .           // Convert |t| from affine to Jacobian coordinates. We set Z to zero if |t|
    .           // is infinity and |ONE| otherwise. |t| was computed from the table, so it
    .           // is infinity iff |wvalue >> 1| is zero.
   18 (0.0%)    OPENSSL_memcpy(aligned_p->X, aligned_t->X, sizeof(aligned_p->X));
   24 (0.0%)    OPENSSL_memcpy(aligned_p->Y, aligned_t->Y, sizeof(aligned_p->Y));
   18 (0.0%)    OPENSSL_memset(aligned_p->Z, 0, sizeof(aligned_p->Z));
   33 (0.0%)    copy_conditional(aligned_p->Z, ONE, is_not_zero(wvalue >> 1));
    .         
  336 (0.0%)    for (int i = 1; i < 37; i++) {
  648 (0.0%)      wvalue = calc_wvalue(&index, p_str);
    .         
1,512 (0.0%)      ecp_nistz256_select_w7(aligned_t, ecp_nistz256_precomputed[i], wvalue >> 1);
    .         
    .             stack_align_type buffer_neg_y[32 + (sizeof(BN_ULONG) * P256_LIMBS)];
  540 (0.0%)      BN_ULONG *aligned_neg_y = (BN_ULONG *) align_pointer(buffer_neg_y, 32);
  648 (0.0%)      ecp_nistz256_neg(aligned_neg_y, aligned_t->Y);
  972 (0.0%)      copy_conditional(aligned_t->Y, aligned_neg_y, wvalue & 1);
    .         
    .             // Note |ecp_nistz256_point_add_affine| does not work if |p.p| and |t.a|
    .             // are the same non-infinity point.
  648 (0.0%)      ecp_nistz256_point_add_affine(aligned_p, aligned_p, aligned_t);
    .           }
    .         
   12 (0.0%)    assert(group->field.N.width == P256_LIMBS);
   18 (0.0%)    OPENSSL_memcpy(r->X.words, aligned_p->X, P256_LIMBS * sizeof(BN_ULONG));
   24 (0.0%)    OPENSSL_memcpy(r->Y.words, aligned_p->Y, P256_LIMBS * sizeof(BN_ULONG));
   24 (0.0%)    OPENSSL_memcpy(r->Z.words, aligned_p->Z, P256_LIMBS * sizeof(BN_ULONG));
   18 (0.0%)  }
    .         
    .         static void ecp_nistz256_points_mul_public(const EC_GROUP *group,
    .                                                    EC_JACOBIAN *r,
    .                                                    const EC_SCALAR *g_scalar,
    .                                                    const EC_JACOBIAN *p_,
   12 (0.0%)                                             const EC_SCALAR *p_scalar) {
    6 (0.0%)    assert(p_ != NULL && p_scalar != NULL && g_scalar != NULL);
    .         
    .           stack_align_type buffer_p[32 + sizeof(P256_POINT)];
    5 (0.0%)    P256_POINT *aligned_p = (P256_POINT *) align_pointer(buffer_p, 32);
    .         
    .           uint8_t p_str[33];
    6 (0.0%)    OPENSSL_memcpy(p_str, g_scalar->words, 32);
    1 (0.0%)    p_str[32] = 0;
    .         
    .           // First window
    1 (0.0%)    size_t index = 0;
    6 (0.0%)    size_t wvalue = calc_first_wvalue(&index, p_str);
    .         
    .           // Convert |p| from affine to Jacobian coordinates. We set Z to zero if |p|
    .           // is infinity and |ONE| otherwise. |p| was computed from the table, so it
    .           // is infinity iff |wvalue >> 1| is zero.
    4 (0.0%)    if ((wvalue >> 1) != 0) {
   12 (0.0%)      OPENSSL_memcpy(aligned_p->X, &ecp_nistz256_precomputed[0][(wvalue >> 1) - 1].X,
    .                            sizeof(aligned_p->X));
   13 (0.0%)      OPENSSL_memcpy(aligned_p->Y, &ecp_nistz256_precomputed[0][(wvalue >> 1) - 1].Y,
    .                            sizeof(aligned_p->Y));
    8 (0.0%)      OPENSSL_memcpy(aligned_p->Z, ONE, sizeof(aligned_p->Z));
    .           } else {
    .             OPENSSL_memset(aligned_p->X, 0, sizeof(aligned_p->X));
    .             OPENSSL_memset(aligned_p->Y, 0, sizeof(aligned_p->X));
    .             OPENSSL_memset(aligned_p->Z, 0, sizeof(aligned_p->Z));
    .           }
    .         
    4 (0.0%)    if ((wvalue & 1) == 1) {
    .             ecp_nistz256_neg(aligned_p->Y, aligned_p->Y);
    .           }
    .         
  112 (0.0%)    for (int i = 1; i < 37; i++) {
  216 (0.0%)      wvalue = calc_wvalue(&index, p_str);
  144 (0.0%)      if ((wvalue >> 1) == 0) {
    .               continue;
    .             }
    .         
    .             stack_align_type buffer_t[32 + sizeof(P256_POINT_AFFINE)];
  180 (0.0%)      P256_POINT_AFFINE *aligned_t = (P256_POINT_AFFINE *) align_pointer(buffer_t, 32);
    .         
  576 (0.0%)      OPENSSL_memcpy(aligned_t, &ecp_nistz256_precomputed[i][(wvalue >> 1) - 1],
    .                            sizeof(*aligned_t));
    .         
  144 (0.0%)      if ((wvalue & 1) == 1) {
  112 (0.0%)        ecp_nistz256_neg(aligned_t->Y, aligned_t->Y);
    .             }
    .         
    .             // Note |ecp_nistz256_point_add_affine| does not work if |p| and |t| are
    .             // the same non-infinity point, so it is important that we compute the
    .             // |g_scalar| term before the |p_scalar| term.
  252 (0.0%)      ecp_nistz256_point_add_affine(aligned_p, aligned_p, aligned_t);
    .           }
    .         
    .           stack_align_type buffer_tmp[32 + sizeof(P256_POINT)];
    5 (0.0%)    P256_POINT *aligned_tmp = (P256_POINT *) align_pointer(buffer_tmp, 32);
    .         
    6 (0.0%)    ecp_nistz256_windowed_mul(group, aligned_tmp, p_, p_scalar);
    6 (0.0%)    ecp_nistz256_point_add(aligned_p, aligned_p, aligned_tmp);
    .         
    4 (0.0%)    assert(group->field.N.width == P256_LIMBS);
    6 (0.0%)    OPENSSL_memcpy(r->X.words, aligned_p->X, P256_LIMBS * sizeof(BN_ULONG));
    8 (0.0%)    OPENSSL_memcpy(r->Y.words, aligned_p->Y, P256_LIMBS * sizeof(BN_ULONG));
    8 (0.0%)    OPENSSL_memcpy(r->Z.words, aligned_p->Z, P256_LIMBS * sizeof(BN_ULONG));
    6 (0.0%)  }
    .         
    .         static int ecp_nistz256_get_affine(const EC_GROUP *group,
    .                                            const EC_JACOBIAN *point, EC_FELEM *x,
   55 (0.0%)                                     EC_FELEM *y) {
   45 (0.0%)    if (constant_time_declassify_int(
    .                   ec_GFp_simple_is_at_infinity(group, point))) {
    .             OPENSSL_PUT_ERROR(EC, EC_R_POINT_AT_INFINITY);
    .             return 0;
    .           }
    .         
    .           BN_ULONG z_inv2[P256_LIMBS];
   20 (0.0%)    assert(group->field.N.width == P256_LIMBS);
   30 (0.0%)    ecp_nistz256_mod_inverse_sqr_mont(z_inv2, point->Z.words);
    .         
   10 (0.0%)    if (x != NULL) {
   30 (0.0%)      ecp_nistz256_mul_mont(x->words, z_inv2, point->X.words);
    .           }
    .         
   10 (0.0%)    if (y != NULL) {
   10 (0.0%)      ecp_nistz256_sqr_mont(z_inv2, z_inv2);                            // z^-4
   16 (0.0%)      ecp_nistz256_mul_mont(y->words, point->Y.words, point->Z.words);  // y * z
   12 (0.0%)      ecp_nistz256_mul_mont(y->words, y->words, z_inv2);  // y * z^-3
    .           }
    .         
    5 (0.0%)    return 1;
   25 (0.0%)  }
    .         
    .         static void ecp_nistz256_add(const EC_GROUP *group, EC_JACOBIAN *r,
    .                                      const EC_JACOBIAN *a_, const EC_JACOBIAN *b_) {
    .           P256_POINT a, b;
    .           OPENSSL_memcpy(a.X, a_->X.words, P256_LIMBS * sizeof(BN_ULONG));
    .           OPENSSL_memcpy(a.Y, a_->Y.words, P256_LIMBS * sizeof(BN_ULONG));
    .           OPENSSL_memcpy(a.Z, a_->Z.words, P256_LIMBS * sizeof(BN_ULONG));
    .           OPENSSL_memcpy(b.X, b_->X.words, P256_LIMBS * sizeof(BN_ULONG));
-- line 469 ----------------------------------------
-- line 483 ----------------------------------------
    .           OPENSSL_memcpy(a.Z, a_->Z.words, P256_LIMBS * sizeof(BN_ULONG));
    .           ecp_nistz256_point_double(&a, &a);
    .           OPENSSL_memcpy(r->X.words, a.X, P256_LIMBS * sizeof(BN_ULONG));
    .           OPENSSL_memcpy(r->Y.words, a.Y, P256_LIMBS * sizeof(BN_ULONG));
    .           OPENSSL_memcpy(r->Z.words, a.Z, P256_LIMBS * sizeof(BN_ULONG));
    .         }
    .         
    .         static void ecp_nistz256_inv0_mod_ord(const EC_GROUP *group, EC_SCALAR *out,
   10 (0.0%)                                        const EC_SCALAR *in) {
    .           // table[i] stores a power of |in| corresponding to the matching enum value.
    .           enum {
    .             // The following indices specify the power in binary.
    .             i_1 = 0,
    .             i_10,
    .             i_11,
    .             i_101,
    .             i_111,
-- line 499 ----------------------------------------
-- line 513 ----------------------------------------
    .           // https://briansmith.org/ecc-inversion-addition-chains-01#p256_scalar_inversion
    .           //
    .           // Even though this code path spares 12 squarings, 4.5%, and 13
    .           // multiplications, 25%, the overall sign operation is not that much faster,
    .           // not more that 2%. Most of the performance of this function comes from the
    .           // scalar operations.
    .         
    .           // Pre-calculate powers.
    6 (0.0%)    OPENSSL_memcpy(table[i_1], in->words, P256_LIMBS * sizeof(BN_ULONG));
    .         
    7 (0.0%)    ecp_nistz256_ord_sqr_mont(table[i_10], table[i_1], 1);
    .         
    8 (0.0%)    ecp_nistz256_ord_mul_mont(table[i_11], table[i_1], table[i_10]);
    .         
    9 (0.0%)    ecp_nistz256_ord_mul_mont(table[i_101], table[i_11], table[i_10]);
    .         
    9 (0.0%)    ecp_nistz256_ord_mul_mont(table[i_111], table[i_101], table[i_10]);
    .         
    8 (0.0%)    ecp_nistz256_ord_sqr_mont(table[i_1010], table[i_101], 1);
    .         
    9 (0.0%)    ecp_nistz256_ord_mul_mont(table[i_1111], table[i_1010], table[i_101]);
    .         
    8 (0.0%)    ecp_nistz256_ord_sqr_mont(table[i_10101], table[i_1010], 1);
    8 (0.0%)    ecp_nistz256_ord_mul_mont(table[i_10101], table[i_10101], table[i_1]);
    .         
    8 (0.0%)    ecp_nistz256_ord_sqr_mont(table[i_101010], table[i_10101], 1);
    .         
    9 (0.0%)    ecp_nistz256_ord_mul_mont(table[i_101111], table[i_101010], table[i_101]);
    .         
    9 (0.0%)    ecp_nistz256_ord_mul_mont(table[i_x6], table[i_101010], table[i_10101]);
    .         
    8 (0.0%)    ecp_nistz256_ord_sqr_mont(table[i_x8], table[i_x6], 2);
    9 (0.0%)    ecp_nistz256_ord_mul_mont(table[i_x8], table[i_x8], table[i_11]);
    .         
    8 (0.0%)    ecp_nistz256_ord_sqr_mont(table[i_x16], table[i_x8], 8);
    9 (0.0%)    ecp_nistz256_ord_mul_mont(table[i_x16], table[i_x16], table[i_x8]);
    .         
    8 (0.0%)    ecp_nistz256_ord_sqr_mont(table[i_x32], table[i_x16], 16);
    9 (0.0%)    ecp_nistz256_ord_mul_mont(table[i_x32], table[i_x32], table[i_x16]);
    .         
    .           // Compute |in| raised to the order-2.
    7 (0.0%)    ecp_nistz256_ord_sqr_mont(out->words, table[i_x32], 64);
    7 (0.0%)    ecp_nistz256_ord_mul_mont(out->words, out->words, table[i_x32]);
    .           static const struct {
    .             uint8_t p, i;
    .           } kChain[27] = {{32, i_x32},    {6, i_101111}, {5, i_111},    {4, i_11},
    .                           {5, i_1111},    {5, i_10101},  {4, i_101},    {3, i_101},
    .                           {3, i_101},     {5, i_111},    {9, i_101111}, {6, i_1111},
    .                           {2, i_1},       {5, i_1},      {6, i_1111},   {5, i_111},
    .                           {4, i_111},     {5, i_111},    {5, i_101},    {3, i_11},
    .                           {10, i_101111}, {2, i_11},     {5, i_11},     {5, i_11},
    .                           {3, i_1},       {7, i_10101},  {6, i_1111}};
   85 (0.0%)    for (size_t i = 0; i < OPENSSL_ARRAY_SIZE(kChain); i++) {
  270 (0.0%)      ecp_nistz256_ord_sqr_mont(out->words, out->words, kChain[i].p);
  378 (0.0%)      ecp_nistz256_ord_mul_mont(out->words, out->words, table[kChain[i].i]);
    .           }
    6 (0.0%)  }
    .         
    .         static int ecp_nistz256_scalar_to_montgomery_inv_vartime(const EC_GROUP *group,
    .                                                          EC_SCALAR *out,
    7 (0.0%)                                                   const EC_SCALAR *in) {
    .         
    .         #if defined(MY_ASSEMBLER_IS_TOO_OLD_FOR_AVX)
    .             return ec_simple_scalar_to_montgomery_inv_vartime(group, out, in);
    .         #else
    .         
    .         #if defined(OPENSSL_X86_64)
    3 (0.0%)    if (!CRYPTO_is_AVX_capable()) {
    .             // No AVX support; fallback to generic code.
    .             return ec_simple_scalar_to_montgomery_inv_vartime(group, out, in);
    .           }
    .         #endif
    .         
    4 (0.0%)    assert(group->order.N.width == P256_LIMBS);
    9 (0.0%)    if (!beeu_mod_inverse_vartime(out->words, in->words, group->order.N.d)) {
    .             return 0;
    .           }
    .         
    .           // The result should be returned in the Montgomery domain.
    6 (0.0%)    ec_scalar_to_montgomery(group, out, out);
    1 (0.0%)    return 1;
    .         
    .         #endif
    2 (0.0%)  }
    .         
    .         static int ecp_nistz256_cmp_x_coordinate(const EC_GROUP *group,
    .                                                  const EC_JACOBIAN *p,
   10 (0.0%)                                           const EC_SCALAR *r) {
    7 (0.0%)    if (ec_GFp_simple_is_at_infinity(group, p)) {
    .             return 0;
    .           }
    .         
    4 (0.0%)    assert(group->order.N.width == P256_LIMBS);
    4 (0.0%)    assert(group->field.N.width == P256_LIMBS);
    .         
    .           // We wish to compare X/Z^2 with r. This is equivalent to comparing X with
    .           // r*Z^2. Note that X and Z are represented in Montgomery form, while r is
    .           // not.
    .           BN_ULONG r_Z2[P256_LIMBS], Z2_mont[P256_LIMBS], X[P256_LIMBS];
    8 (0.0%)    ecp_nistz256_mul_mont(Z2_mont, p->Z.words, p->Z.words);
    6 (0.0%)    ecp_nistz256_mul_mont(r_Z2, r->words, Z2_mont);
    5 (0.0%)    ecp_nistz256_from_mont(X, p->X.words);
    .         
    8 (0.0%)    if (OPENSSL_memcmp(r_Z2, X, sizeof(r_Z2)) == 0) {
    2 (0.0%)      return 1;
    .           }
    .         
    .           // During signing the x coefficient is reduced modulo the group order.
    .           // Therefore there is a small possibility, less than 1/2^128, that group_order
    .           // < p.x < P. in that case we need not only to compare against |r| but also to
    .           // compare against r+group_order.
    .           BN_ULONG carry = bn_add_words(r_Z2, r->words, group->order.N.d, P256_LIMBS);
    .           if (carry == 0 && bn_less_than_words(r_Z2, group->field.N.d, P256_LIMBS)) {
-- line 625 ----------------------------------------
-- line 626 ----------------------------------------
    .             // r + group_order < p, so compare (r + group_order) * Z^2 against X.
    .             ecp_nistz256_mul_mont(r_Z2, r_Z2, Z2_mont);
    .             if (OPENSSL_memcmp(r_Z2, X, sizeof(r_Z2)) == 0) {
    .               return 1;
    .             }
    .           }
    .         
    .           return 0;
    5 (0.0%)  }
    .         
    .         DEFINE_METHOD_FUNCTION(EC_METHOD, EC_GFp_nistz256_method) {
    .           out->point_get_affine_coordinates = ecp_nistz256_get_affine;
    .           out->add = ecp_nistz256_add;
    .           out->dbl = ecp_nistz256_dbl;
    .           out->mul = ecp_nistz256_point_mul;
    .           out->mul_base = ecp_nistz256_point_mul_base;
    .           out->mul_public = ecp_nistz256_points_mul_public;
-- line 642 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/md4/../digest/md32_common.h
--------------------------------------------------------------------------------
Ir__________ 

-- line 94 ----------------------------------------
    .         // partial block. This function combines the partial block with |in| and
    .         // incorporates any complete blocks into the digest state |h|. It then updates
    .         // |data| and |*num| with the new partial block and updates |*Nh| and |*Nl| with
    .         // the data consumed.
    .         static inline void crypto_md32_update(crypto_md32_block_func block_func,
    .                                               uint32_t *h, uint8_t *data,
    .                                               size_t block_size, unsigned *num,
    .                                               uint32_t *Nh, uint32_t *Nl,
2,457 (0.0%)                                        const uint8_t *in, size_t len) {
  546 (0.0%)    if (len == 0) {
    .             return;
    .           }
    .         
1,638 (0.0%)    uint32_t l = *Nl + (((uint32_t)len) << 3);
1,092 (0.0%)    if (l < *Nl) {
    .             // Handle carries.
    .             (*Nh)++;
    .           }
1,911 (0.0%)    *Nh += (uint32_t)(len >> 29);
  819 (0.0%)    *Nl = l;
    .         
1,092 (0.0%)    size_t n = *num;
  546 (0.0%)    if (n != 0) {
  519 (0.0%)      if (len >= block_size || len + n >= block_size) {
  280 (0.0%)        OPENSSL_memcpy(data + n, in, block_size - n);
  196 (0.0%)        block_func(h, data, 1);
   84 (0.0%)        n = block_size - n;
   56 (0.0%)        in += n;
   56 (0.0%)        len -= n;
   56 (0.0%)        *num = 0;
    .               // Keep |data| zeroed when unused.
  168 (0.0%)        OPENSSL_memset(data, 0, block_size);
    .             } else {
  400 (0.0%)        OPENSSL_memcpy(data + n, in, len);
  300 (0.0%)        *num += (unsigned)len;
   50 (0.0%)        return;
    .             }
    .           }
    .         
  892 (0.0%)    n = len / block_size;
  446 (0.0%)    if (n > 0) {
  819 (0.0%)      block_func(h, in, n);
  351 (0.0%)      n *= block_size;
  234 (0.0%)      in += n;
  234 (0.0%)      len -= n;
    .           }
    .         
  446 (0.0%)    if (len != 0) {
  524 (0.0%)      *num = (unsigned)len;
  917 (0.0%)      OPENSSL_memcpy(data, in, len);
    .           }
  546 (0.0%)  }
    .         
    .         // crypto_md32_final incorporates the partial block and trailing length into the
    .         // digest state |h|. The trailing length is encoded in little-endian if
    .         // |is_big_endian| is zero and big-endian otherwise. |data| must be a buffer of
    .         // length |block_size| with the first |*num| bytes containing a partial block.
    .         // |Nh| and |Nl| contain the total number of bits processed. On return, this
    .         // function clears the partial block in |data| and
    .         // |*num|.
    .         //
    .         // This function does not serialize |h| into a final digest. This is the
    .         // responsibility of the caller.
    .         static inline void crypto_md32_final(crypto_md32_block_func block_func,
    .                                              uint32_t *h, uint8_t *data,
    .                                              size_t block_size, unsigned *num,
    .                                              uint32_t Nh, uint32_t Nl,
  972 (0.0%)                                       int is_big_endian) {
    .           // |data| always has room for at least one byte. A full block would have
    .           // been consumed.
  432 (0.0%)    size_t n = *num;
  324 (0.0%)    assert(n < block_size);
  432 (0.0%)    data[n] = 0x80;
  108 (0.0%)    n++;
    .         
    .           // Fill the block with zeros if there isn't room for a 64-bit length.
  432 (0.0%)    if (n > block_size - 8) {
    .             OPENSSL_memset(data + n, 0, block_size - n);
    .             n = 0;
    .             block_func(h, data, 1);
    .           }
  972 (0.0%)    OPENSSL_memset(data + n, 0, block_size - 8 - n);
    .         
    .           // Append a 64-bit length to the block and process it.
  216 (0.0%)    if (is_big_endian) {
  864 (0.0%)      CRYPTO_store_u32_be(data + block_size - 8, Nh);
  972 (0.0%)      CRYPTO_store_u32_be(data + block_size - 4, Nl);
    .           } else {
    .             CRYPTO_store_u32_le(data + block_size - 8, Nl);
    .             CRYPTO_store_u32_le(data + block_size - 4, Nh);
    .           }
  756 (0.0%)    block_func(h, data, 1);
  216 (0.0%)    *num = 0;
  540 (0.0%)    OPENSSL_memset(data, 0, block_size);
  324 (0.0%)  }
    .         
    .         
    .         #if defined(__cplusplus)
    .         }  // extern C
    .         #endif
    .         
    .         #endif  // OPENSSL_HEADER_DIGEST_MD32_COMMON_H

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/sha/sha256.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 60 ----------------------------------------
    .         
    .         #include <openssl/mem.h>
    .         
    .         #include "../../internal.h"
    .         #include "../digest/md32_common.h"
    .         #include "internal.h"
    .         
    .         
   20 (0.0%)  int SHA224_Init(SHA256_CTX *sha) {
   20 (0.0%)    OPENSSL_memset(sha, 0, sizeof(SHA256_CTX));
    8 (0.0%)    sha->h[0] = 0xc1059ed8UL;
    8 (0.0%)    sha->h[1] = 0x367cd507UL;
    8 (0.0%)    sha->h[2] = 0x3070dd17UL;
    8 (0.0%)    sha->h[3] = 0xf70e5939UL;
    8 (0.0%)    sha->h[4] = 0xffc00b31UL;
    8 (0.0%)    sha->h[5] = 0x68581511UL;
    8 (0.0%)    sha->h[6] = 0x64f98fa7UL;
    8 (0.0%)    sha->h[7] = 0xbefa4fa4UL;
    8 (0.0%)    sha->md_len = SHA224_DIGEST_LENGTH;
    4 (0.0%)    return 1;
    8 (0.0%)  }
    .         
  970 (0.0%)  int SHA256_Init(SHA256_CTX *sha) {
  970 (0.0%)    OPENSSL_memset(sha, 0, sizeof(SHA256_CTX));
  388 (0.0%)    sha->h[0] = 0x6a09e667UL;
  388 (0.0%)    sha->h[1] = 0xbb67ae85UL;
  388 (0.0%)    sha->h[2] = 0x3c6ef372UL;
  388 (0.0%)    sha->h[3] = 0xa54ff53aUL;
  388 (0.0%)    sha->h[4] = 0x510e527fUL;
  388 (0.0%)    sha->h[5] = 0x9b05688cUL;
  388 (0.0%)    sha->h[6] = 0x1f83d9abUL;
  388 (0.0%)    sha->h[7] = 0x5be0cd19UL;
  388 (0.0%)    sha->md_len = SHA256_DIGEST_LENGTH;
  194 (0.0%)    return 1;
  388 (0.0%)  }
    .         
    .         uint8_t *SHA224(const uint8_t *data, size_t len,
    .                         uint8_t out[SHA224_DIGEST_LENGTH]) {
    .           // We have to verify that all the SHA services actually succeed before
    .           // updating the indicator state, so we lock the state here.
    .           FIPS_service_indicator_lock_state();
    .           SHA256_CTX ctx;
    .           const int ok = SHA224_Init(&ctx) &&
-- line 102 ----------------------------------------
-- line 131 ----------------------------------------
    .         static void sha256_block_data_order(uint32_t *state, const uint8_t *in,
    .                                             size_t num);
    .         #endif
    .         
    .         void SHA256_Transform(SHA256_CTX *c, const uint8_t data[SHA256_CBLOCK]) {
    .           sha256_block_data_order(c->h, data, 1);
    .         }
    .         
1,715 (0.0%)  int SHA256_Update(SHA256_CTX *c, const void *data, size_t len) {
5,145 (0.1%)    crypto_md32_update(&sha256_block_data_order, c->h, c->data, SHA256_CBLOCK,
    .                              &c->num, &c->Nh, &c->Nl, data, len);
  245 (0.0%)    return 1;
  490 (0.0%)  }
    .         
   49 (0.0%)  int SHA224_Update(SHA256_CTX *ctx, const void *data, size_t len) {
   42 (0.0%)    return SHA256_Update(ctx, data, len);
   14 (0.0%)  }
    .         
  756 (0.0%)  static int sha256_final_impl(uint8_t *out, size_t md_len, SHA256_CTX *c) {
2,052 (0.0%)    crypto_md32_final(&sha256_block_data_order, c->h, c->data, SHA256_CBLOCK,
    .                             &c->num, c->Nh, c->Nl, /*is_big_endian=*/1);
  540 (0.0%)    if (c->md_len != md_len) {
    .             return 0;
    .           }
    .         
  432 (0.0%)    assert(md_len % 4 == 0);
  324 (0.0%)    const size_t out_words = md_len / 4;
3,996 (0.1%)    for (size_t i = 0; i < out_words; i++) {
6,048 (0.1%)      CRYPTO_store_u32_be(out, c->h[i]);
  864 (0.0%)      out += 4;
    .           }
  108 (0.0%)    FIPS_service_indicator_update_state();
  108 (0.0%)    return 1;
  216 (0.0%)  }
    .         
  648 (0.0%)  int SHA256_Final(uint8_t out[SHA256_DIGEST_LENGTH], SHA256_CTX *c) {
  540 (0.0%)    return sha256_final_impl(out, SHA256_DIGEST_LENGTH, c);
  216 (0.0%)  }
    .         
    .         int SHA224_Final(uint8_t out[SHA224_DIGEST_LENGTH], SHA256_CTX *ctx) {
    .           return sha256_final_impl(out, SHA224_DIGEST_LENGTH, ctx);
    .         }
    .         
    .         #ifndef SHA256_ASM
    .         static const uint32_t K256[64] = {
    .             0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL, 0x3956c25bUL,
-- line 176 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h
--------------------------------------------------------------------------------
Ir__________ 

-- line 866 ----------------------------------------
    .         static inline int OPENSSL_memcmp(const void *s1, const void *s2, size_t n) {
    .           if (n == 0) {
    .             return 0;
    .           }
    .         
    .           return memcmp(s1, s2, n);
    .         }
    .         
  222 (0.0%)  static inline void *OPENSSL_memcpy(void *dst, const void *src, size_t n) {
   74 (0.0%)    if (n == 0) {
    .             return dst;
    .           }
    .         
  222 (0.0%)    return memcpy(dst, src, n);
   74 (0.0%)  }
    .         
    .         static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
    .           if (n == 0) {
    .             return dst;
    .           }
    .         
    .           return memmove(dst, src, n);
    .         }
    .         
3,078 (0.0%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
1,026 (0.0%)    if (n == 0) {
    .             return dst;
    .           }
    .         
3,078 (0.0%)    return memset(dst, c, n);
1,026 (0.0%)  }
    .         
    .         
    .         // Loads and stores.
    .         //
    .         // The following functions load and store sized integers with the specified
    .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
    .         // requirements on the input and output pointers.
    .         
-- line 904 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 77 ----------------------------------------
    .         #define OPENSSL_MALLOC_PREFIX 8
    .         OPENSSL_STATIC_ASSERT(OPENSSL_MALLOC_PREFIX >= sizeof(size_t),
    .                               size_t_too_large)
    .         
    .         #if defined(OPENSSL_ASAN)
    .         void __asan_poison_memory_region(const volatile void *addr, size_t size);
    .         void __asan_unpoison_memory_region(const volatile void *addr, size_t size);
    .         #else
3,240 (0.1%)  static void __asan_poison_memory_region(const void *addr, size_t size) {}
1,880 (0.0%)  static void __asan_unpoison_memory_region(const void *addr, size_t size) {}
    .         #endif
    .         
    .         // Windows doesn't really support weak symbols as of May 2019, and Clang on
    .         // Windows will emit strong symbols instead. See
    .         // https://bugs.llvm.org/show_bug.cgi?id=37598
    .         #if defined(__ELF__) && defined(__GNUC__)
    .         #define WEAK_SYMBOL_FUNC(rettype, name, args) \
    .           rettype name args __attribute__((weak));
-- line 94 ----------------------------------------
-- line 157 ----------------------------------------
    .             return 0;
    .           }
    .           malloc_impl = m;
    .           realloc_impl = r;
    .           free_impl = f;
    .           return 1;
    .         }
    .         
1,965 (0.0%)  void *OPENSSL_malloc(size_t size) {
1,179 (0.0%)    if (malloc_impl != NULL) {
    .             assert(OPENSSL_memory_alloc == NULL);
    .             assert(OPENSSL_memory_realloc == NULL);
    .             assert(OPENSSL_memory_free == NULL);
    .             assert(OPENSSL_memory_get_size == NULL);
    .             assert(realloc_impl != NULL);
    .             assert(free_impl != NULL);
    .             return malloc_impl(size, AWSLC_FILE, AWSLC_LINE);
    .           }
1,179 (0.0%)    if (OPENSSL_memory_alloc != NULL) {
    .             assert(OPENSSL_memory_free != NULL);
    .             assert(OPENSSL_memory_get_size != NULL);
    .             void *ptr = OPENSSL_memory_alloc(size);
    .             if (ptr == NULL && size != 0) {
    .               goto err;
    .             }
    .             return ptr;
    .           }
    .         
  786 (0.0%)    if (size + OPENSSL_MALLOC_PREFIX < size) {
    .             goto err;
    .           }
    .         
1,965 (0.0%)    void *ptr = malloc(size + OPENSSL_MALLOC_PREFIX);
  786 (0.0%)    if (ptr == NULL) {
    .             goto err;
    .           }
    .         
1,179 (0.0%)    *(size_t *)ptr = size;
    .         
1,572 (0.0%)    __asan_poison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
1,179 (0.0%)    return ((uint8_t *)ptr) + OPENSSL_MALLOC_PREFIX;
    .         
    .          err:
    .           // This only works because ERR does not call OPENSSL_malloc.
    .           OPENSSL_PUT_ERROR(CRYPTO, ERR_R_MALLOC_FAILURE);
    .           return NULL;
  786 (0.0%)  }
    .         
1,345 (0.0%)  void *OPENSSL_zalloc(size_t size) {
1,076 (0.0%)    void *ret = OPENSSL_malloc(size);
  538 (0.0%)    if (ret != NULL) {
1,345 (0.0%)      OPENSSL_memset(ret, 0, size);
    .           }
  269 (0.0%)    return ret;
  538 (0.0%)  }
    .         
  306 (0.0%)  void *OPENSSL_calloc(size_t num, size_t size) {
  459 (0.0%)    if (size != 0 && num > SIZE_MAX / size) {
    .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
    .             return NULL;
    .           }
    .         
  204 (0.0%)    return OPENSSL_zalloc(num * size);
  102 (0.0%)  }
    .         
1,375 (0.0%)  void OPENSSL_free(void *orig_ptr) {
  550 (0.0%)    if (orig_ptr == NULL) {
   52 (0.0%)      return;
    .           }
  669 (0.0%)    if (free_impl != NULL) {
    .             assert(OPENSSL_memory_alloc == NULL);
    .             assert(OPENSSL_memory_realloc == NULL);
    .             assert(OPENSSL_memory_free == NULL);
    .             assert(OPENSSL_memory_get_size == NULL);
    .             assert(malloc_impl != NULL);
    .             assert(realloc_impl != NULL);
    .             free_impl(orig_ptr, AWSLC_FILE, AWSLC_LINE);
    .             return;
    .           }
    .         
  669 (0.0%)    if (OPENSSL_memory_free != NULL) {
    .             OPENSSL_memory_free(orig_ptr);
    .             return;
    .           }
    .         
  669 (0.0%)    void *ptr = ((uint8_t *)orig_ptr) - OPENSSL_MALLOC_PREFIX;
  892 (0.0%)    __asan_unpoison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
    .         
  669 (0.0%)    size_t size = *(size_t *)ptr;
1,338 (0.0%)    OPENSSL_cleanse(ptr, size + OPENSSL_MALLOC_PREFIX);
    .         
    .         // ASan knows to intercept malloc and free, but not sdallocx.
    .         #if defined(OPENSSL_ASAN)
    .           (void)sdallocx;
    .           free(ptr);
    .           (void) sdallocx;
    .         #else
  669 (0.0%)    if (sdallocx) {
    .             sdallocx(ptr, size + OPENSSL_MALLOC_PREFIX, 0 /* flags */);
    .           } else {
  892 (0.0%)      free(ptr);
    .           }
    .         #endif
  550 (0.0%)  }
    .         
   84 (0.0%)  void *OPENSSL_realloc(void *orig_ptr, size_t new_size) {
   28 (0.0%)    if (orig_ptr == NULL) {
    8 (0.0%)      return OPENSSL_malloc(new_size);
    .           }
   36 (0.0%)    if (realloc_impl != NULL) {
    .             assert(OPENSSL_memory_alloc == NULL);
    .             assert(OPENSSL_memory_realloc == NULL);
    .             assert(OPENSSL_memory_free == NULL);
    .             assert(OPENSSL_memory_get_size == NULL);
    .             assert(malloc_impl != NULL);
    .             assert(free_impl != NULL);
    .             return realloc_impl(orig_ptr, new_size, AWSLC_FILE, AWSLC_LINE);
    .           }
   36 (0.0%)    if (OPENSSL_memory_realloc != NULL) {
    .             assert(OPENSSL_memory_alloc != NULL);
    .             assert(OPENSSL_memory_free != NULL);
    .             assert(OPENSSL_memory_get_size != NULL);
    .             return OPENSSL_memory_realloc(orig_ptr, new_size);
    .           }
    .           size_t old_size;
   36 (0.0%)    if (OPENSSL_memory_get_size != NULL) {
    .             old_size = OPENSSL_memory_get_size(orig_ptr);
    .           } else {
   36 (0.0%)      void *ptr = ((uint8_t *)orig_ptr) - OPENSSL_MALLOC_PREFIX;
   48 (0.0%)      __asan_unpoison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
   36 (0.0%)      old_size = *(size_t *)ptr;
   48 (0.0%)      __asan_poison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
    .           }
    .         
   48 (0.0%)    void *ret = OPENSSL_malloc(new_size);
   24 (0.0%)    if (ret == NULL) {
    .             return NULL;
    .           }
    .         
   24 (0.0%)    size_t to_copy = new_size;
   36 (0.0%)    if (old_size < to_copy) {
   24 (0.0%)      to_copy = old_size;
    .           }
    .         
   72 (0.0%)    memcpy(ret, orig_ptr, to_copy);
   36 (0.0%)    OPENSSL_free(orig_ptr);
    .         
   12 (0.0%)    return ret;
   28 (0.0%)  }
    .         
1,464 (0.0%)  void OPENSSL_cleanse(void *ptr, size_t len) {
    .         #if defined(OPENSSL_WINDOWS)
    .           SecureZeroMemory(ptr, len);
    .         #else
1,220 (0.0%)    OPENSSL_memset(ptr, 0, len);
    .         
    .         #if !defined(OPENSSL_NO_ASM)
    .           /* As best as we can tell, this is sufficient to break any optimisations that
    .              might try to eliminate "superfluous" memsets. If there's an easy way to
    .              detect memset_s, it would be better to use that. */
  244 (0.0%)    __asm__ __volatile__("" : : "r"(ptr) : "memory");
    .         #endif
    .         #endif  // !OPENSSL_NO_ASM
  732 (0.0%)  }
    .         
    .         void OPENSSL_clear_free(void *ptr, size_t unused) { OPENSSL_free(ptr); }
    .         
    .         int CRYPTO_secure_malloc_init(size_t size, size_t min_size) { return 0; }
    .         
    .         int CRYPTO_secure_malloc_initialized(void) { return 0; }
    .         
    .         size_t CRYPTO_secure_used(void) { return 0; }
-- line 328 ----------------------------------------
-- line 330 ----------------------------------------
    .         void *OPENSSL_secure_malloc(size_t size) { return OPENSSL_malloc(size); }
    .         
    .         void *OPENSSL_secure_zalloc(size_t size) { return OPENSSL_zalloc(size); }
    .         
    .         void OPENSSL_secure_clear_free(void *ptr, size_t len) {
    .           OPENSSL_clear_free(ptr, len);
    .         }
    .         
   66 (0.0%)  int CRYPTO_memcmp(const void *in_a, const void *in_b, size_t len) {
   22 (0.0%)    const uint8_t *a = in_a;
   22 (0.0%)    const uint8_t *b = in_b;
   11 (0.0%)    uint8_t x = 0;
    .         
1,047 (0.0%)    for (size_t i = 0; i < len; i++) {
2,480 (0.0%)      x |= a[i] ^ b[i];
    .           }
    .         
   11 (0.0%)    return x;
   22 (0.0%)  }
    .         
    .         uint32_t OPENSSL_hash32(const void *ptr, size_t len) {
    .           // These are the FNV-1a parameters for 32 bits.
    .           static const uint32_t kPrime = 16777619u;
    .           static const uint32_t kOffsetBasis = 2166136261u;
    .         
    .           const uint8_t *in = ptr;
    .           uint32_t h = kOffsetBasis;
-- line 356 ----------------------------------------
-- line 387 ----------------------------------------
    .           OPENSSL_memcpy(ret, s, len);
    .           return ret;
    .         }
    .         
    .         int OPENSSL_isalpha(int c) {
    .           return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
    .         }
    .         
  936 (0.0%)  int OPENSSL_isdigit(int c) { return c >= '0' && c <= '9'; }
    .         
    .         int OPENSSL_isxdigit(int c) {
    .           return OPENSSL_isdigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
    .         }
    .         
    .         int OPENSSL_fromxdigit(uint8_t *out, int c) {
    .           if (OPENSSL_isdigit(c)) {
    .             *out = c - '0';
-- line 403 ----------------------------------------
-- line 411 ----------------------------------------
    .             *out = c - 'A' + 10;
    .             return 1;
    .           }
    .           return 0;
    .         }
    .         
    .         int OPENSSL_isalnum(int c) { return OPENSSL_isalpha(c) || OPENSSL_isdigit(c); }
    .         
  232 (0.0%)  int OPENSSL_tolower(int c) {
  228 (0.0%)    if (c >= 'A' && c <= 'Z') {
   36 (0.0%)      return c + ('a' - 'A');
    .           }
   46 (0.0%)    return c;
  116 (0.0%)  }
    .         
  328 (0.0%)  int OPENSSL_isspace(int c) {
1,066 (0.0%)    return c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r' ||
    .                  c == ' ';
  164 (0.0%)  }
    .         
    .         int OPENSSL_strcasecmp(const char *a, const char *b) {
    .           for (size_t i = 0;; i++) {
    .             const int aa = OPENSSL_tolower(a[i]);
    .             const int bb = OPENSSL_tolower(b[i]);
    .         
    .             if (aa < bb) {
    .               return -1;
-- line 437 ----------------------------------------
-- line 565 ----------------------------------------
    .         size_t OPENSSL_strlcat(char *dst, const char *src, size_t dst_size) {
    .           size_t l = 0;
    .           for (; dst_size > 0 && *dst; dst_size--, dst++) {
    .             l++;
    .           }
    .           return l + OPENSSL_strlcpy(dst, src, dst_size);
    .         }
    .         
  222 (0.0%)  void *OPENSSL_memdup(const void *data, size_t size) {
   74 (0.0%)    if (size == 0) {
    .             return NULL;
    .           }
    .         
  148 (0.0%)    void *ret = OPENSSL_malloc(size);
   74 (0.0%)    if (ret == NULL) {
    .             return NULL;
    .           }
    .         
  222 (0.0%)    OPENSSL_memcpy(ret, data, size);
   37 (0.0%)    return ret;
   74 (0.0%)  }
    .         
    .         void *CRYPTO_malloc(size_t size, const char *file, int line) {
    .           return OPENSSL_malloc(size);
    .         }
    .         
    .         void *CRYPTO_realloc(void *ptr, size_t new_size, const char *file, int line) {
    .           return OPENSSL_realloc(ptr, new_size);
    .         }
-- line 593 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/../internal.h
--------------------------------------------------------------------------------
Ir__________ 

-- line 858 ----------------------------------------
    .             return NULL;
    .           }
    .         
    .           return memchr(s, c, n);
    .         }
    .         
    .         #endif  // __cplusplus
    .         
3,492 (0.1%)  static inline int OPENSSL_memcmp(const void *s1, const void *s2, size_t n) {
1,164 (0.0%)    if (n == 0) {
    .             return 0;
    .           }
    .         
3,492 (0.1%)    return memcmp(s1, s2, n);
1,164 (0.0%)  }
    .         
    .         static inline void *OPENSSL_memcpy(void *dst, const void *src, size_t n) {
    .           if (n == 0) {
    .             return dst;
    .           }
    .         
    .           return memcpy(dst, src, n);
    .         }
-- line 880 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 97 ----------------------------------------
    .         
    .           CRYPTO_STATIC_MUTEX_lock_write(&global_next_nid_lock);
    .           ret = global_next_nid++;
    .           CRYPTO_STATIC_MUTEX_unlock_write(&global_next_nid_lock);
    .         
    .           return ret;
    .         }
    .         
  160 (0.0%)  ASN1_OBJECT *OBJ_dup(const ASN1_OBJECT *o) {
    .           ASN1_OBJECT *r;
   32 (0.0%)    unsigned char *data = NULL;
   64 (0.0%)    char *sn = NULL, *ln = NULL;
    .         
   64 (0.0%)    if (o == NULL) {
    .             return NULL;
    .           }
    .         
  160 (0.0%)    if (!(o->flags & ASN1_OBJECT_FLAG_DYNAMIC)) {
    .             // TODO(fork): this is a little dangerous.
    .             return (ASN1_OBJECT *)o;
    .           }
    .         
   64 (0.0%)    r = ASN1_OBJECT_new();
   64 (0.0%)    if (r == NULL) {
    .             OPENSSL_PUT_ERROR(OBJ, ERR_R_ASN1_LIB);
    .             return NULL;
    .           }
  192 (0.0%)    r->ln = r->sn = NULL;
    .         
    .           // once data is attached to an object, it remains const
  320 (0.0%)    r->data = OPENSSL_memdup(o->data, o->length);
  256 (0.0%)    if (o->length != 0 && r->data == NULL) {
    .             goto err;
    .           }
    .         
  128 (0.0%)    r->length = o->length;
  128 (0.0%)    r->nid = o->nid;
    .         
  128 (0.0%)    if (o->ln != NULL) {
    .             ln = OPENSSL_strdup(o->ln);
    .             if (ln == NULL) {
    .               goto err;
    .             }
    .           }
    .         
  128 (0.0%)    if (o->sn != NULL) {
    .             sn = OPENSSL_strdup(o->sn);
    .             if (sn == NULL) {
    .               goto err;
    .             }
    .           }
    .         
   96 (0.0%)    r->sn = sn;
   96 (0.0%)    r->ln = ln;
    .         
   64 (0.0%)    r->flags =
  128 (0.0%)        o->flags | (ASN1_OBJECT_FLAG_DYNAMIC | ASN1_OBJECT_FLAG_DYNAMIC_STRINGS |
    .                           ASN1_OBJECT_FLAG_DYNAMIC_DATA);
   64 (0.0%)    return r;
    .         
    .         err:
    .           OPENSSL_free(ln);
    .           OPENSSL_free(sn);
    .           OPENSSL_free(data);
    .           OPENSSL_free(r);
    .           return NULL;
   64 (0.0%)  }
    .         
5,082 (0.1%)  int OBJ_cmp(const ASN1_OBJECT *a, const ASN1_OBJECT *b) {
5,082 (0.1%)    if (a->length < b->length) {
  530 (0.0%)      return -1;
3,492 (0.1%)    } else if (a->length > b->length) {
    .             return 1;
    .           }
5,820 (0.1%)    return OPENSSL_memcmp(a->data, b->data, a->length);
1,694 (0.0%)  }
    .         
    .         const uint8_t *OBJ_get0_data(const ASN1_OBJECT *obj) {
    .           if (obj == NULL) {
    .             return NULL;
    .           }
    .         
    .           return obj->data;
    .         }
-- line 180 ----------------------------------------
-- line 182 ----------------------------------------
    .         size_t OBJ_length(const ASN1_OBJECT *obj) {
    .           if (obj == NULL || obj->length < 0) {
    .             return 0;
    .           }
    .         
    .           return (size_t)obj->length;
    .         }
    .         
4,690 (0.1%)  static const ASN1_OBJECT *get_builtin_object(int nid) {
    .           // |NID_undef| is stored separately, so all the indices are off by one. The
    .           // caller of this function must have a valid built-in, non-undef NID.
3,752 (0.1%)    BSSL_CHECK(nid > 0 && nid < NUM_NID);
8,442 (0.1%)    return &kObjects[nid - 1];
1,876 (0.0%)  }
    .         
    .         // obj_cmp is called to search the kNIDsInOIDOrder array. The |key| argument is
    .         // an |ASN1_OBJECT|* that we're looking for and |element| is a pointer to an
    .         // unsigned int in the array.
5,082 (0.1%)  static int obj_cmp(const void *key, const void *element) {
2,541 (0.0%)    uint16_t nid = *((const uint16_t *)element);
6,776 (0.1%)    return OBJ_cmp(key, get_builtin_object(nid));
1,694 (0.0%)  }
    .         
  455 (0.0%)  int OBJ_obj2nid(const ASN1_OBJECT *obj) {
  182 (0.0%)    if (obj == NULL) {
    .             return NID_undef;
    .           }
    .         
  364 (0.0%)    if (obj->nid != 0) {
    .             return obj->nid;
    .           }
    .         
  273 (0.0%)    CRYPTO_STATIC_MUTEX_lock_read(&global_added_lock);
  273 (0.0%)    if (global_added_by_data != NULL) {
    .             ASN1_OBJECT *match;
    .         
    .             match = lh_ASN1_OBJECT_retrieve(global_added_by_data, obj);
    .             if (match != NULL) {
    .               CRYPTO_STATIC_MUTEX_unlock_read(&global_added_lock);
    .               return match->nid;
    .             }
    .           }
  273 (0.0%)    CRYPTO_STATIC_MUTEX_unlock_read(&global_added_lock);
    .         
    .           const uint16_t *nid_ptr =
  728 (0.0%)        bsearch(obj, kNIDsInOIDOrder, OPENSSL_ARRAY_SIZE(kNIDsInOIDOrder),
    .                       sizeof(kNIDsInOIDOrder[0]), obj_cmp);
  182 (0.0%)    if (nid_ptr == NULL) {
    .             return NID_undef;
    .           }
    .         
  546 (0.0%)    return get_builtin_object(*nid_ptr)->nid;
  182 (0.0%)  }
    .         
    .         int OBJ_cbs2nid(const CBS *cbs) {
    .           if (CBS_len(cbs) > INT_MAX) {
    .             return NID_undef;
    .           }
    .         
    .           ASN1_OBJECT obj;
    .           OPENSSL_memset(&obj, 0, sizeof(obj));
-- line 242 ----------------------------------------
-- line 334 ----------------------------------------
    .               !CBB_add_bytes(&oid, obj->data, obj->length) ||
    .               !CBB_flush(out)) {
    .             return 0;
    .           }
    .         
    .           return 1;
    .         }
    .         
   93 (0.0%)  const ASN1_OBJECT *OBJ_get_undef(void) {
    .           static const ASN1_OBJECT kUndef = {
    .               /*sn=*/SN_undef,
    .               /*ln=*/LN_undef,
    .               /*nid=*/NID_undef,
    .               /*length=*/0,
    .               /*data=*/NULL,
    .               /*flags=*/0,
    .           };
   31 (0.0%)    return &kUndef;
   62 (0.0%)  }
    .         
    .         ASN1_OBJECT *OBJ_nid2obj(int nid) {
    .           if (nid == NID_undef) {
    .             return (ASN1_OBJECT *)OBJ_get_undef();
    .           }
    .         
    .           if (nid > 0 && nid < NUM_NID) {
    .             const ASN1_OBJECT *obj = get_builtin_object(nid);
-- line 360 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 69 ----------------------------------------
    .         #include "../internal.h"
    .         #include "internal.h"
    .         
    .         
    .         int X509_issuer_name_cmp(const X509 *a, const X509 *b) {
    .           return (X509_NAME_cmp(a->cert_info->issuer, b->cert_info->issuer));
    .         }
    .         
3,114 (0.0%)  int X509_subject_name_cmp(const X509 *a, const X509 *b) {
4,671 (0.1%)    return (X509_NAME_cmp(a->cert_info->subject, b->cert_info->subject));
1,038 (0.0%)  }
    .         
    .         int X509_CRL_cmp(const X509_CRL *a, const X509_CRL *b) {
    .           return (X509_NAME_cmp(a->crl->issuer, b->crl->issuer));
    .         }
    .         
    .         int X509_CRL_match(const X509_CRL *a, const X509_CRL *b) {
    .           return OPENSSL_memcmp(a->crl_hash, b->crl_hash, SHA256_DIGEST_LENGTH);
    .         }
    .         
   28 (0.0%)  X509_NAME *X509_get_issuer_name(const X509 *a) {
   21 (0.0%)    return a->cert_info->issuer;
   14 (0.0%)  }
    .         
    .         uint32_t X509_issuer_name_hash(X509 *x) {
    .           return X509_NAME_hash(x->cert_info->issuer);
    .         }
    .         
    .         uint32_t X509_issuer_name_hash_old(X509 *x) {
    .           return (X509_NAME_hash_old(x->cert_info->issuer));
    .         }
    .         
   24 (0.0%)  X509_NAME *X509_get_subject_name(const X509 *a) {
   18 (0.0%)    return a->cert_info->subject;
   12 (0.0%)  }
    .         
    .         ASN1_INTEGER *X509_get_serialNumber(X509 *a) {
    .           return a->cert_info->serialNumber;
    .         }
    .         
    .         const ASN1_INTEGER *X509_get0_serialNumber(const X509 *x509) {
    .           return x509->cert_info->serialNumber;
    .         }
-- line 111 ----------------------------------------
-- line 119 ----------------------------------------
    .         }
    .         
    .         // Compare two certificates: they must be identical for this to work. NB:
    .         // Although "cmp" operations are generally prototyped to take "const"
    .         // arguments (eg. for use in STACKs), the way X509 handling is - these
    .         // operations may involve ensuring the hashes are up-to-date and ensuring
    .         // certain cert information is cached. So this is the point where the
    .         // "depth-first" constification tree has to halt with an evil cast.
    6 (0.0%)  int X509_cmp(const X509 *a, const X509 *b) {
    .           // Fill in the |cert_hash| fields.
    .           //
    .           // TODO(davidben): This may fail, in which case the the hash will be all
    .           // zeros. This produces a consistent comparison (failures are sticky), but
    .           // not a good one. OpenSSL now returns -2, but this is not a consistent
    .           // comparison and may cause misbehaving sorts by transitivity. For now, we
    .           // retain the old OpenSSL behavior, which was to ignore the error. See
    .           // https://crbug.com/boringssl/355.
    3 (0.0%)    x509v3_cache_extensions((X509 *)a);
    3 (0.0%)    x509v3_cache_extensions((X509 *)b);
    .         
    8 (0.0%)    return OPENSSL_memcmp(a->cert_hash, b->cert_hash, SHA256_DIGEST_LENGTH);
    2 (0.0%)  }
    .         
3,150 (0.1%)  int X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b) {
    .           int ret;
    .         
    .           // Ensure canonical encoding is present and up to date
    .         
4,200 (0.1%)    if (!a->canon_enc || a->modified) {
    .             ret = i2d_X509_NAME((X509_NAME *)a, NULL);
    .             if (ret < 0) {
    .               return -2;
    .             }
    .           }
    .         
4,200 (0.1%)    if (!b->canon_enc || b->modified) {
    .             ret = i2d_X509_NAME((X509_NAME *)b, NULL);
    .             if (ret < 0) {
    .               return -2;
    .             }
    .           }
    .         
3,150 (0.1%)    ret = a->canon_enclen - b->canon_enclen;
    .         
1,050 (0.0%)    if (ret) {
  810 (0.0%)      return ret;
    .           }
    .         
1,200 (0.0%)    return OPENSSL_memcmp(a->canon_enc, b->canon_enc, a->canon_enclen);
1,050 (0.0%)  }
    .         
    .         uint32_t X509_NAME_hash(X509_NAME *x) {
    .           // Make sure the X509_NAME structure contains a valid cached encoding.
    .           if (i2d_X509_NAME(x, NULL) < 0) {
    .             return 0;
    .           }
    .         
    .           uint8_t md[SHA_DIGEST_LENGTH];
-- line 176 ----------------------------------------
-- line 220 ----------------------------------------
    .         
    .         EVP_PKEY *X509_get0_pubkey(const X509 *x) {
    .           if (x == NULL) {
    .             return NULL;
    .           }
    .           return X509_PUBKEY_get0(x->cert_info->key);
    .         }
    .         
   15 (0.0%)  EVP_PKEY *X509_get_pubkey(const X509 *x) {
    6 (0.0%)    if (x == NULL) {
    .             return NULL;
    .           }
   15 (0.0%)    return X509_PUBKEY_get(x->cert_info->key);
    6 (0.0%)  }
    .         
    .         ASN1_BIT_STRING *X509_get0_pubkey_bitstr(const X509 *x) {
    .           if (!x) {
    .             return NULL;
    .           }
    .           return x->cert_info->key->public_key;
    .         }
    .         
-- line 241 ----------------------------------------
-- line 263 ----------------------------------------
    .           }
    .         
    .           return 0;
    .         }
    .         
    .         // Not strictly speaking an "up_ref" as a STACK doesn't have a reference
    .         // count but it has the same effect by duping the STACK and upping the ref of
    .         // each X509 structure.
    5 (0.0%)  STACK_OF(X509) *X509_chain_up_ref(STACK_OF(X509) *chain) {
    4 (0.0%)    STACK_OF(X509) *ret = sk_X509_dup(chain);
    2 (0.0%)    if (ret == NULL) {
    .             return NULL;
    .           }
   13 (0.0%)    for (size_t i = 0; i < sk_X509_num(ret); i++) {
    7 (0.0%)      X509_up_ref(sk_X509_value(ret, i));
    .           }
    1 (0.0%)    return ret;
    2 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 123 ----------------------------------------
    .           }
    .           // Note |get_by_subject| leaves |ret| in an inconsistent state. It has
    .           // pointers to an |X509| or |X509_CRL|, but has not bumped the refcount yet.
    .           // For now, the caller is expected to fix this, but ideally we'd fix the
    .           // |X509_LOOKUP| convention itself.
    .           return ctx->method->get_by_subject(ctx, type, name, ret) > 0;
    .         }
    .         
3,114 (0.0%)  static int x509_object_cmp(const X509_OBJECT *a, const X509_OBJECT *b) {
3,114 (0.0%)    int ret = a->type - b->type;
1,038 (0.0%)    if (ret) {
    .             return ret;
    .           }
2,076 (0.0%)    switch (a->type) {
    .             case X509_LU_X509:
4,152 (0.1%)        return X509_subject_name_cmp(a->data.x509, b->data.x509);
    .             case X509_LU_CRL:
    .               return X509_CRL_cmp(a->data.crl, b->data.crl);
    .             default:
    .               // abort();
    .               return 0;
    .           }
1,038 (0.0%)  }
    .         
    .         static int x509_object_cmp_sk(const X509_OBJECT *const *a,
3,114 (0.0%)                                const X509_OBJECT *const *b) {
3,633 (0.1%)    return x509_object_cmp(*a, *b);
1,038 (0.0%)  }
    .         
    .         static CRYPTO_EX_DATA_CLASS g_ex_data_class =
    .             CRYPTO_EX_DATA_CLASS_INIT_WITH_APP_DATA;
    .         
    .         X509_STORE *X509_STORE_new(void) {
    .           X509_STORE *ret = OPENSSL_zalloc(sizeof(X509_STORE));
    .           if (ret == NULL) {
    .             return NULL;
-- line 158 ----------------------------------------
-- line 226 ----------------------------------------
    .             X509_LOOKUP_free(lu);
    .             return NULL;
    .           }
    .         
    .           return lu;
    .         }
    .         
    .         int X509_STORE_CTX_get_by_subject(X509_STORE_CTX *vs, int type, X509_NAME *name,
   11 (0.0%)                                    X509_OBJECT *ret) {
    3 (0.0%)    X509_STORE *ctx = vs->ctx;
    .           X509_OBJECT stmp;
    4 (0.0%)    CRYPTO_MUTEX_lock_write(&ctx->objs_lock);
    8 (0.0%)    X509_OBJECT *tmp = X509_OBJECT_retrieve_by_subject(ctx->objs, type, name);
    4 (0.0%)    CRYPTO_MUTEX_unlock_write(&ctx->objs_lock);
    .         
    4 (0.0%)    if (tmp == NULL || type == X509_LU_CRL) {
    .             for (size_t i = 0; i < sk_X509_LOOKUP_num(ctx->get_cert_methods); i++) {
    .               X509_LOOKUP *lu = sk_X509_LOOKUP_value(ctx->get_cert_methods, i);
    .               if (X509_LOOKUP_by_subject(lu, type, name, &stmp)) {
    .                 tmp = &stmp;
    .                 break;
    .               }
    .             }
    .             if (tmp == NULL) {
    .               return 0;
    .             }
    .           }
    .         
    .           // if (ret->data.ptr != NULL) X509_OBJECT_free_contents(ret);
    .         
    4 (0.0%)    ret->type = tmp->type;
    4 (0.0%)    ret->data.ptr = tmp->data.ptr;
    .         
    3 (0.0%)    X509_OBJECT_up_ref_count(ret);
    .         
    1 (0.0%)    return 1;
    5 (0.0%)  }
    .         
    .         static int x509_store_add(X509_STORE *ctx, void *x, int is_crl) {
    .           if (x == NULL) {
    .             return 0;
    .           }
    .         
    .           X509_OBJECT *const obj = X509_OBJECT_new();
    .           if (obj == NULL) {
-- line 270 ----------------------------------------
-- line 313 ----------------------------------------
    .         void X509_OBJECT_free(X509_OBJECT *obj) {
    .           if (obj == NULL) {
    .             return;
    .           }
    .           X509_OBJECT_free_contents(obj);
    .           OPENSSL_free(obj);
    .         }
    .         
    5 (0.0%)  static int X509_OBJECT_up_ref_count(X509_OBJECT *a) {
    4 (0.0%)    switch (a->type) {
    .             case X509_LU_X509:
    4 (0.0%)        X509_up_ref(a->data.x509);
    1 (0.0%)        break;
    .             case X509_LU_CRL:
    .               X509_CRL_up_ref(a->data.crl);
    .               break;
    .           }
    1 (0.0%)    return 1;
    2 (0.0%)  }
    .         
    .         void X509_OBJECT_free_contents(X509_OBJECT *a) {
    .           switch (a->type) {
    .             case X509_LU_X509:
    .               X509_free(a->data.x509);
    .               break;
    .             case X509_LU_CRL:
    .               X509_CRL_free(a->data.crl);
-- line 339 ----------------------------------------
-- line 377 ----------------------------------------
    .         
    .             X509_OBJECT_free_contents(a);
    .             a->type = X509_LU_CRL;
    .             a->data.crl = obj;
    .             return 1;
    .         }
    .         
    .         static int x509_object_idx_cnt(STACK_OF(X509_OBJECT) *h, int type,
   11 (0.0%)                                 X509_NAME *name, int *pnmatch) {
    .           X509_OBJECT stmp;
    .           X509 x509_s;
    .           X509_CINF cinf_s;
    .           X509_CRL crl_s;
    .           X509_CRL_INFO crl_info_s;
    .         
    2 (0.0%)    stmp.type = type;
    2 (0.0%)    switch (type) {
    .             case X509_LU_X509:
    2 (0.0%)        stmp.data.x509 = &x509_s;
    2 (0.0%)        x509_s.cert_info = &cinf_s;
    2 (0.0%)        cinf_s.subject = name;
    1 (0.0%)        break;
    .             case X509_LU_CRL:
    .               stmp.data.crl = &crl_s;
    .               crl_s.crl = &crl_info_s;
    .               crl_info_s.issuer = name;
    .               break;
    .             default:
    .               // abort();
    .               return -1;
    .           }
    .         
    .           size_t idx;
    3 (0.0%)    sk_X509_OBJECT_sort(h);
    8 (0.0%)    if (!sk_X509_OBJECT_find_awslc(h, &idx, &stmp)) {
    .             return -1;
    .           }
    .         
    2 (0.0%)    if (pnmatch != NULL) {
    .             *pnmatch = 1;
    .             for (size_t tidx = idx + 1; tidx < sk_X509_OBJECT_num(h); tidx++) {
    .               const X509_OBJECT *tobj = sk_X509_OBJECT_value(h, tidx);
    .               if (x509_object_cmp(tobj, &stmp)) {
    .                 break;
    .               }
    .               (*pnmatch)++;
    .             }
    .           }
    .         
    1 (0.0%)    return (int)idx;
    5 (0.0%)  }
    .         
    .         static int X509_OBJECT_idx_by_subject(STACK_OF(X509_OBJECT) *h, int type,
    7 (0.0%)                                        X509_NAME *name) {
    6 (0.0%)    return x509_object_idx_cnt(h, type, name, NULL);
    2 (0.0%)  }
    .         
    .         X509_OBJECT *X509_OBJECT_retrieve_by_subject(STACK_OF(X509_OBJECT) *h,
    7 (0.0%)                                                      int type, X509_NAME *name) {
    .           int idx;
    7 (0.0%)    idx = X509_OBJECT_idx_by_subject(h, type, name);
    2 (0.0%)    if (idx == -1) {
    .             return NULL;
    .           }
    6 (0.0%)    return sk_X509_OBJECT_value(h, idx);
    2 (0.0%)  }
    .         
    .         STACK_OF(X509_OBJECT) *X509_STORE_get0_objects(X509_STORE *st) {
    .           return st->objs;
    .         }
    .         
    .         STACK_OF(X509) *X509_STORE_CTX_get1_certs(X509_STORE_CTX *ctx, X509_NAME *nm) {
    .           int cnt;
    .           STACK_OF(X509) *sk = sk_X509_new_null();
-- line 450 ----------------------------------------
-- line 553 ----------------------------------------
    .           return NULL;
    .         }
    .         
    .         // Try to get issuer certificate from store. Due to limitations of the API
    .         // this can only retrieve a single certificate matching a given subject name.
    .         // However it will fill the cache with all matching certificates, so we can
    .         // examine the cache for all matches. Return values are: 1 lookup
    .         // successful.  0 certificate not found. -1 some other error.
   10 (0.0%)  int X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x) {
    .           X509_NAME *xn;
    .           X509_OBJECT obj, *pobj;
    .           int idx, ret;
    .           size_t i;
    2 (0.0%)    *issuer = NULL;
    4 (0.0%)    xn = X509_get_issuer_name(x);
    8 (0.0%)    if (!X509_STORE_CTX_get_by_subject(ctx, X509_LU_X509, xn, &obj)) {
    .             return 0;
    .           }
    .           // If certificate matches all OK
    8 (0.0%)    if (x509_check_issued_with_callback(ctx, x, obj.data.x509)) {
    8 (0.0%)      if (x509_check_cert_time(ctx, obj.data.x509, /*suppress_error*/1)) {
    3 (0.0%)        *issuer = obj.data.x509;
    2 (0.0%)        return 1;
    .             }
    .           }
    .           X509_OBJECT_free_contents(&obj);
    .         
    .           // Else find index of first cert accepted by
    .           // |x509_check_issued_with_callback|.
    .           ret = 0;
    .           CRYPTO_MUTEX_lock_write(&ctx->ctx->objs_lock);
-- line 583 ----------------------------------------
-- line 607 ----------------------------------------
    .               }
    .             }
    .           }
    .           CRYPTO_MUTEX_unlock_write(&ctx->ctx->objs_lock);
    .           if(*issuer) {
    .             X509_up_ref(*issuer);
    .           }
    .           return ret;
    5 (0.0%)  }
    .         
    .         int X509_STORE_set_flags(X509_STORE *ctx, unsigned long flags) {
    .           return X509_VERIFY_PARAM_set_flags(ctx->param, flags);
    .         }
    .         
    .         int X509_STORE_set_depth(X509_STORE *ctx, int depth) {
    .           X509_VERIFY_PARAM_set_depth(ctx->param, depth);
    .           return 1;
-- line 623 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/md5-x86_64.S
--------------------------------------------------------------------------------
Ir_______ 

-- line 7 ----------------------------------------
 .         .text	
 .         .align	16
 .         
 .         .globl	md5_block_asm_data_order
 .         .hidden md5_block_asm_data_order
 .         .type	md5_block_asm_data_order,@function
 .         md5_block_asm_data_order:
 .         .cfi_startproc	
14 (0.0%)  	pushq	%rbp
 .         .cfi_adjust_cfa_offset	8
 .         .cfi_offset	rbp,-16
14 (0.0%)  	pushq	%rbx
 .         .cfi_adjust_cfa_offset	8
 .         .cfi_offset	rbx,-24
14 (0.0%)  	pushq	%r12
 .         .cfi_adjust_cfa_offset	8
 .         .cfi_offset	r12,-32
14 (0.0%)  	pushq	%r14
 .         .cfi_adjust_cfa_offset	8
 .         .cfi_offset	r14,-40
14 (0.0%)  	pushq	%r15
 .         .cfi_adjust_cfa_offset	8
 .         .cfi_offset	r15,-48
 .         .Lprologue:
 .         
 .         
 .         
 .         
14 (0.0%)  	movq	%rdi,%rbp
14 (0.0%)  	shlq	$6,%rdx
14 (0.0%)  	leaq	(%rsi,%rdx,1),%rdi
14 (0.0%)  	movl	0(%rbp),%eax
14 (0.0%)  	movl	4(%rbp),%ebx
14 (0.0%)  	movl	8(%rbp),%ecx
14 (0.0%)  	movl	12(%rbp),%edx
 .         
 .         
 .         
 .         
 .         
 .         
 .         
14 (0.0%)  	cmpq	%rdi,%rsi
14 (0.0%)  	je	.Lend
 .         
 .         
 .         .Lloop:
34 (0.0%)  	movl	%eax,%r8d
34 (0.0%)  	movl	%ebx,%r9d
34 (0.0%)  	movl	%ecx,%r14d
34 (0.0%)  	movl	%edx,%r15d
34 (0.0%)  	movl	0(%rsi),%r10d
34 (0.0%)  	movl	%edx,%r11d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	leal	-680876936(%rax,%r10,1),%eax
34 (0.0%)  	andl	%ebx,%r11d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	movl	4(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%eax
34 (0.0%)  	roll	$7,%eax
34 (0.0%)  	movl	%ecx,%r11d
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	leal	-389564586(%rdx,%r10,1),%edx
34 (0.0%)  	andl	%eax,%r11d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	movl	8(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%edx
34 (0.0%)  	roll	$12,%edx
34 (0.0%)  	movl	%ebx,%r11d
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	leal	606105819(%rcx,%r10,1),%ecx
34 (0.0%)  	andl	%edx,%r11d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	movl	12(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%ecx
34 (0.0%)  	roll	$17,%ecx
34 (0.0%)  	movl	%eax,%r11d
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	leal	-1044525330(%rbx,%r10,1),%ebx
34 (0.0%)  	andl	%ecx,%r11d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	movl	16(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%ebx
34 (0.0%)  	roll	$22,%ebx
34 (0.0%)  	movl	%edx,%r11d
34 (0.0%)  	addl	%ecx,%ebx
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	leal	-176418897(%rax,%r10,1),%eax
34 (0.0%)  	andl	%ebx,%r11d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	movl	20(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%eax
34 (0.0%)  	roll	$7,%eax
34 (0.0%)  	movl	%ecx,%r11d
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	leal	1200080426(%rdx,%r10,1),%edx
34 (0.0%)  	andl	%eax,%r11d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	movl	24(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%edx
34 (0.0%)  	roll	$12,%edx
34 (0.0%)  	movl	%ebx,%r11d
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	leal	-1473231341(%rcx,%r10,1),%ecx
34 (0.0%)  	andl	%edx,%r11d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	movl	28(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%ecx
34 (0.0%)  	roll	$17,%ecx
34 (0.0%)  	movl	%eax,%r11d
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	leal	-45705983(%rbx,%r10,1),%ebx
34 (0.0%)  	andl	%ecx,%r11d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	movl	32(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%ebx
34 (0.0%)  	roll	$22,%ebx
34 (0.0%)  	movl	%edx,%r11d
34 (0.0%)  	addl	%ecx,%ebx
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	leal	1770035416(%rax,%r10,1),%eax
34 (0.0%)  	andl	%ebx,%r11d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	movl	36(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%eax
34 (0.0%)  	roll	$7,%eax
34 (0.0%)  	movl	%ecx,%r11d
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	leal	-1958414417(%rdx,%r10,1),%edx
34 (0.0%)  	andl	%eax,%r11d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	movl	40(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%edx
34 (0.0%)  	roll	$12,%edx
34 (0.0%)  	movl	%ebx,%r11d
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	leal	-42063(%rcx,%r10,1),%ecx
34 (0.0%)  	andl	%edx,%r11d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	movl	44(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%ecx
34 (0.0%)  	roll	$17,%ecx
34 (0.0%)  	movl	%eax,%r11d
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	leal	-1990404162(%rbx,%r10,1),%ebx
34 (0.0%)  	andl	%ecx,%r11d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	movl	48(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%ebx
34 (0.0%)  	roll	$22,%ebx
34 (0.0%)  	movl	%edx,%r11d
34 (0.0%)  	addl	%ecx,%ebx
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	leal	1804603682(%rax,%r10,1),%eax
34 (0.0%)  	andl	%ebx,%r11d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	movl	52(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%eax
34 (0.0%)  	roll	$7,%eax
34 (0.0%)  	movl	%ecx,%r11d
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	leal	-40341101(%rdx,%r10,1),%edx
34 (0.0%)  	andl	%eax,%r11d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	movl	56(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%edx
34 (0.0%)  	roll	$12,%edx
34 (0.0%)  	movl	%ebx,%r11d
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	leal	-1502002290(%rcx,%r10,1),%ecx
34 (0.0%)  	andl	%edx,%r11d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	movl	60(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%ecx
34 (0.0%)  	roll	$17,%ecx
34 (0.0%)  	movl	%eax,%r11d
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	leal	1236535329(%rbx,%r10,1),%ebx
34 (0.0%)  	andl	%ecx,%r11d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	movl	0(%rsi),%r10d
34 (0.0%)  	addl	%r11d,%ebx
34 (0.0%)  	roll	$22,%ebx
34 (0.0%)  	movl	%edx,%r11d
34 (0.0%)  	addl	%ecx,%ebx
34 (0.0%)  	movl	4(%rsi),%r10d
34 (0.0%)  	movl	%edx,%r11d
34 (0.0%)  	movl	%edx,%r12d
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	-165796510(%rax,%r10,1),%eax
34 (0.0%)  	andl	%ebx,%r12d
34 (0.0%)  	andl	%ecx,%r11d
34 (0.0%)  	movl	24(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%ecx,%r11d
34 (0.0%)  	addl	%r12d,%eax
34 (0.0%)  	movl	%ecx,%r12d
34 (0.0%)  	roll	$5,%eax
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	-1069501632(%rdx,%r10,1),%edx
34 (0.0%)  	andl	%eax,%r12d
34 (0.0%)  	andl	%ebx,%r11d
34 (0.0%)  	movl	44(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%ebx,%r11d
34 (0.0%)  	addl	%r12d,%edx
34 (0.0%)  	movl	%ebx,%r12d
34 (0.0%)  	roll	$9,%edx
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	643717713(%rcx,%r10,1),%ecx
34 (0.0%)  	andl	%edx,%r12d
34 (0.0%)  	andl	%eax,%r11d
34 (0.0%)  	movl	0(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%eax,%r11d
34 (0.0%)  	addl	%r12d,%ecx
34 (0.0%)  	movl	%eax,%r12d
34 (0.0%)  	roll	$14,%ecx
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	-373897302(%rbx,%r10,1),%ebx
34 (0.0%)  	andl	%ecx,%r12d
34 (0.0%)  	andl	%edx,%r11d
34 (0.0%)  	movl	20(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%edx,%r11d
34 (0.0%)  	addl	%r12d,%ebx
34 (0.0%)  	movl	%edx,%r12d
34 (0.0%)  	roll	$20,%ebx
34 (0.0%)  	addl	%ecx,%ebx
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	-701558691(%rax,%r10,1),%eax
34 (0.0%)  	andl	%ebx,%r12d
34 (0.0%)  	andl	%ecx,%r11d
34 (0.0%)  	movl	40(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%ecx,%r11d
34 (0.0%)  	addl	%r12d,%eax
34 (0.0%)  	movl	%ecx,%r12d
34 (0.0%)  	roll	$5,%eax
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	38016083(%rdx,%r10,1),%edx
34 (0.0%)  	andl	%eax,%r12d
34 (0.0%)  	andl	%ebx,%r11d
34 (0.0%)  	movl	60(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%ebx,%r11d
34 (0.0%)  	addl	%r12d,%edx
34 (0.0%)  	movl	%ebx,%r12d
34 (0.0%)  	roll	$9,%edx
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	-660478335(%rcx,%r10,1),%ecx
34 (0.0%)  	andl	%edx,%r12d
34 (0.0%)  	andl	%eax,%r11d
34 (0.0%)  	movl	16(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%eax,%r11d
34 (0.0%)  	addl	%r12d,%ecx
34 (0.0%)  	movl	%eax,%r12d
34 (0.0%)  	roll	$14,%ecx
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	-405537848(%rbx,%r10,1),%ebx
34 (0.0%)  	andl	%ecx,%r12d
34 (0.0%)  	andl	%edx,%r11d
34 (0.0%)  	movl	36(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%edx,%r11d
34 (0.0%)  	addl	%r12d,%ebx
34 (0.0%)  	movl	%edx,%r12d
34 (0.0%)  	roll	$20,%ebx
34 (0.0%)  	addl	%ecx,%ebx
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	568446438(%rax,%r10,1),%eax
34 (0.0%)  	andl	%ebx,%r12d
34 (0.0%)  	andl	%ecx,%r11d
34 (0.0%)  	movl	56(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%ecx,%r11d
34 (0.0%)  	addl	%r12d,%eax
34 (0.0%)  	movl	%ecx,%r12d
34 (0.0%)  	roll	$5,%eax
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	-1019803690(%rdx,%r10,1),%edx
34 (0.0%)  	andl	%eax,%r12d
34 (0.0%)  	andl	%ebx,%r11d
34 (0.0%)  	movl	12(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%ebx,%r11d
34 (0.0%)  	addl	%r12d,%edx
34 (0.0%)  	movl	%ebx,%r12d
34 (0.0%)  	roll	$9,%edx
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	-187363961(%rcx,%r10,1),%ecx
34 (0.0%)  	andl	%edx,%r12d
34 (0.0%)  	andl	%eax,%r11d
34 (0.0%)  	movl	32(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%eax,%r11d
34 (0.0%)  	addl	%r12d,%ecx
34 (0.0%)  	movl	%eax,%r12d
34 (0.0%)  	roll	$14,%ecx
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	1163531501(%rbx,%r10,1),%ebx
34 (0.0%)  	andl	%ecx,%r12d
34 (0.0%)  	andl	%edx,%r11d
34 (0.0%)  	movl	52(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%edx,%r11d
34 (0.0%)  	addl	%r12d,%ebx
34 (0.0%)  	movl	%edx,%r12d
34 (0.0%)  	roll	$20,%ebx
34 (0.0%)  	addl	%ecx,%ebx
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	-1444681467(%rax,%r10,1),%eax
34 (0.0%)  	andl	%ebx,%r12d
34 (0.0%)  	andl	%ecx,%r11d
34 (0.0%)  	movl	8(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%ecx,%r11d
34 (0.0%)  	addl	%r12d,%eax
34 (0.0%)  	movl	%ecx,%r12d
34 (0.0%)  	roll	$5,%eax
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	-51403784(%rdx,%r10,1),%edx
34 (0.0%)  	andl	%eax,%r12d
34 (0.0%)  	andl	%ebx,%r11d
34 (0.0%)  	movl	28(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%ebx,%r11d
34 (0.0%)  	addl	%r12d,%edx
34 (0.0%)  	movl	%ebx,%r12d
34 (0.0%)  	roll	$9,%edx
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	1735328473(%rcx,%r10,1),%ecx
34 (0.0%)  	andl	%edx,%r12d
34 (0.0%)  	andl	%eax,%r11d
34 (0.0%)  	movl	48(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%eax,%r11d
34 (0.0%)  	addl	%r12d,%ecx
34 (0.0%)  	movl	%eax,%r12d
34 (0.0%)  	roll	$14,%ecx
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	notl	%r11d
34 (0.0%)  	leal	-1926607734(%rbx,%r10,1),%ebx
34 (0.0%)  	andl	%ecx,%r12d
34 (0.0%)  	andl	%edx,%r11d
34 (0.0%)  	movl	0(%rsi),%r10d
34 (0.0%)  	orl	%r11d,%r12d
34 (0.0%)  	movl	%edx,%r11d
34 (0.0%)  	addl	%r12d,%ebx
34 (0.0%)  	movl	%edx,%r12d
34 (0.0%)  	roll	$20,%ebx
34 (0.0%)  	addl	%ecx,%ebx
34 (0.0%)  	movl	20(%rsi),%r10d
34 (0.0%)  	movl	%ecx,%r11d
34 (0.0%)  	leal	-378558(%rax,%r10,1),%eax
34 (0.0%)  	movl	32(%rsi),%r10d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	addl	%r11d,%eax
34 (0.0%)  	roll	$4,%eax
34 (0.0%)  	movl	%ebx,%r11d
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	leal	-2022574463(%rdx,%r10,1),%edx
34 (0.0%)  	movl	44(%rsi),%r10d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	addl	%r11d,%edx
34 (0.0%)  	roll	$11,%edx
34 (0.0%)  	movl	%eax,%r11d
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	leal	1839030562(%rcx,%r10,1),%ecx
34 (0.0%)  	movl	56(%rsi),%r10d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	addl	%r11d,%ecx
34 (0.0%)  	roll	$16,%ecx
34 (0.0%)  	movl	%edx,%r11d
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	leal	-35309556(%rbx,%r10,1),%ebx
34 (0.0%)  	movl	4(%rsi),%r10d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	addl	%r11d,%ebx
34 (0.0%)  	roll	$23,%ebx
34 (0.0%)  	movl	%ecx,%r11d
34 (0.0%)  	addl	%ecx,%ebx
34 (0.0%)  	leal	-1530992060(%rax,%r10,1),%eax
34 (0.0%)  	movl	16(%rsi),%r10d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	addl	%r11d,%eax
34 (0.0%)  	roll	$4,%eax
34 (0.0%)  	movl	%ebx,%r11d
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	leal	1272893353(%rdx,%r10,1),%edx
34 (0.0%)  	movl	28(%rsi),%r10d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	addl	%r11d,%edx
34 (0.0%)  	roll	$11,%edx
34 (0.0%)  	movl	%eax,%r11d
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	leal	-155497632(%rcx,%r10,1),%ecx
34 (0.0%)  	movl	40(%rsi),%r10d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	addl	%r11d,%ecx
34 (0.0%)  	roll	$16,%ecx
34 (0.0%)  	movl	%edx,%r11d
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	leal	-1094730640(%rbx,%r10,1),%ebx
34 (0.0%)  	movl	52(%rsi),%r10d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	addl	%r11d,%ebx
34 (0.0%)  	roll	$23,%ebx
34 (0.0%)  	movl	%ecx,%r11d
34 (0.0%)  	addl	%ecx,%ebx
34 (0.0%)  	leal	681279174(%rax,%r10,1),%eax
34 (0.0%)  	movl	0(%rsi),%r10d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	addl	%r11d,%eax
34 (0.0%)  	roll	$4,%eax
34 (0.0%)  	movl	%ebx,%r11d
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	leal	-358537222(%rdx,%r10,1),%edx
34 (0.0%)  	movl	12(%rsi),%r10d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	addl	%r11d,%edx
34 (0.0%)  	roll	$11,%edx
34 (0.0%)  	movl	%eax,%r11d
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	leal	-722521979(%rcx,%r10,1),%ecx
34 (0.0%)  	movl	24(%rsi),%r10d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	addl	%r11d,%ecx
34 (0.0%)  	roll	$16,%ecx
34 (0.0%)  	movl	%edx,%r11d
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	leal	76029189(%rbx,%r10,1),%ebx
34 (0.0%)  	movl	36(%rsi),%r10d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	addl	%r11d,%ebx
34 (0.0%)  	roll	$23,%ebx
34 (0.0%)  	movl	%ecx,%r11d
34 (0.0%)  	addl	%ecx,%ebx
34 (0.0%)  	leal	-640364487(%rax,%r10,1),%eax
34 (0.0%)  	movl	48(%rsi),%r10d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	addl	%r11d,%eax
34 (0.0%)  	roll	$4,%eax
34 (0.0%)  	movl	%ebx,%r11d
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	leal	-421815835(%rdx,%r10,1),%edx
34 (0.0%)  	movl	60(%rsi),%r10d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	addl	%r11d,%edx
34 (0.0%)  	roll	$11,%edx
34 (0.0%)  	movl	%eax,%r11d
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	leal	530742520(%rcx,%r10,1),%ecx
34 (0.0%)  	movl	8(%rsi),%r10d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	addl	%r11d,%ecx
34 (0.0%)  	roll	$16,%ecx
34 (0.0%)  	movl	%edx,%r11d
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	leal	-995338651(%rbx,%r10,1),%ebx
34 (0.0%)  	movl	0(%rsi),%r10d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	addl	%r11d,%ebx
34 (0.0%)  	roll	$23,%ebx
34 (0.0%)  	movl	%ecx,%r11d
34 (0.0%)  	addl	%ecx,%ebx
34 (0.0%)  	movl	0(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	leal	-198630844(%rax,%r10,1),%eax
34 (0.0%)  	orl	%ebx,%r11d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	addl	%r11d,%eax
34 (0.0%)  	movl	28(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$6,%eax
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	leal	1126891415(%rdx,%r10,1),%edx
34 (0.0%)  	orl	%eax,%r11d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	addl	%r11d,%edx
34 (0.0%)  	movl	56(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$10,%edx
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	leal	-1416354905(%rcx,%r10,1),%ecx
34 (0.0%)  	orl	%edx,%r11d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	addl	%r11d,%ecx
34 (0.0%)  	movl	20(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$15,%ecx
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	leal	-57434055(%rbx,%r10,1),%ebx
34 (0.0%)  	orl	%ecx,%r11d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	addl	%r11d,%ebx
34 (0.0%)  	movl	48(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$21,%ebx
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	addl	%ecx,%ebx
34 (0.0%)  	leal	1700485571(%rax,%r10,1),%eax
34 (0.0%)  	orl	%ebx,%r11d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	addl	%r11d,%eax
34 (0.0%)  	movl	12(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$6,%eax
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	leal	-1894986606(%rdx,%r10,1),%edx
34 (0.0%)  	orl	%eax,%r11d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	addl	%r11d,%edx
34 (0.0%)  	movl	40(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$10,%edx
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	leal	-1051523(%rcx,%r10,1),%ecx
34 (0.0%)  	orl	%edx,%r11d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	addl	%r11d,%ecx
34 (0.0%)  	movl	4(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$15,%ecx
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	leal	-2054922799(%rbx,%r10,1),%ebx
34 (0.0%)  	orl	%ecx,%r11d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	addl	%r11d,%ebx
34 (0.0%)  	movl	32(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$21,%ebx
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	addl	%ecx,%ebx
34 (0.0%)  	leal	1873313359(%rax,%r10,1),%eax
34 (0.0%)  	orl	%ebx,%r11d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	addl	%r11d,%eax
34 (0.0%)  	movl	60(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$6,%eax
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	leal	-30611744(%rdx,%r10,1),%edx
34 (0.0%)  	orl	%eax,%r11d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	addl	%r11d,%edx
34 (0.0%)  	movl	24(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$10,%edx
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	leal	-1560198380(%rcx,%r10,1),%ecx
34 (0.0%)  	orl	%edx,%r11d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	addl	%r11d,%ecx
34 (0.0%)  	movl	52(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$15,%ecx
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	leal	1309151649(%rbx,%r10,1),%ebx
34 (0.0%)  	orl	%ecx,%r11d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	addl	%r11d,%ebx
34 (0.0%)  	movl	16(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$21,%ebx
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	addl	%ecx,%ebx
34 (0.0%)  	leal	-145523070(%rax,%r10,1),%eax
34 (0.0%)  	orl	%ebx,%r11d
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	addl	%r11d,%eax
34 (0.0%)  	movl	44(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$6,%eax
34 (0.0%)  	xorl	%ecx,%r11d
34 (0.0%)  	addl	%ebx,%eax
34 (0.0%)  	leal	-1120210379(%rdx,%r10,1),%edx
34 (0.0%)  	orl	%eax,%r11d
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	addl	%r11d,%edx
34 (0.0%)  	movl	8(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$10,%edx
34 (0.0%)  	xorl	%ebx,%r11d
34 (0.0%)  	addl	%eax,%edx
34 (0.0%)  	leal	718787259(%rcx,%r10,1),%ecx
34 (0.0%)  	orl	%edx,%r11d
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	addl	%r11d,%ecx
34 (0.0%)  	movl	36(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$15,%ecx
34 (0.0%)  	xorl	%eax,%r11d
34 (0.0%)  	addl	%edx,%ecx
34 (0.0%)  	leal	-343485551(%rbx,%r10,1),%ebx
34 (0.0%)  	orl	%ecx,%r11d
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	addl	%r11d,%ebx
34 (0.0%)  	movl	0(%rsi),%r10d
34 (0.0%)  	movl	$0xffffffff,%r11d
34 (0.0%)  	roll	$21,%ebx
34 (0.0%)  	xorl	%edx,%r11d
34 (0.0%)  	addl	%ecx,%ebx
 .         
34 (0.0%)  	addl	%r8d,%eax
34 (0.0%)  	addl	%r9d,%ebx
34 (0.0%)  	addl	%r14d,%ecx
34 (0.0%)  	addl	%r15d,%edx
 .         
 .         
34 (0.0%)  	addq	$64,%rsi
34 (0.0%)  	cmpq	%rdi,%rsi
34 (0.0%)  	jb	.Lloop
 .         
 .         
 .         .Lend:
14 (0.0%)  	movl	%eax,0(%rbp)
14 (0.0%)  	movl	%ebx,4(%rbp)
14 (0.0%)  	movl	%ecx,8(%rbp)
14 (0.0%)  	movl	%edx,12(%rbp)
 .         
14 (0.0%)  	movq	(%rsp),%r15
 .         .cfi_restore	r15
14 (0.0%)  	movq	8(%rsp),%r14
 .         .cfi_restore	r14
14 (0.0%)  	movq	16(%rsp),%r12
 .         .cfi_restore	r12
14 (0.0%)  	movq	24(%rsp),%rbx
 .         .cfi_restore	rbx
14 (0.0%)  	movq	32(%rsp),%rbp
 .         .cfi_restore	rbp
28 (0.0%)  	addq	$40,%rsp
 .         .cfi_adjust_cfa_offset	-40
 .         .Lepilogue:
 .         	.byte	0xf3,0xc3
 .         .cfi_endproc	
 .         .size	md5_block_asm_data_order,.-md5_block_asm_data_order
 .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256-x86_64-asm.S
--------------------------------------------------------------------------------
Ir___________ 

-- line 33 ----------------------------------------
     .         
     .         
     .         .globl	ecp_nistz256_neg
     .         .hidden ecp_nistz256_neg
     .         .type	ecp_nistz256_neg,@function
     .         .align	32
     .         ecp_nistz256_neg:
     .         .cfi_startproc	
   280 (0.0%)  	pushq	%r12
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r12,-16
   280 (0.0%)  	pushq	%r13
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r13,-24
     .         .Lneg_body:
     .         
   280 (0.0%)  	xorq	%r8,%r8
   280 (0.0%)  	xorq	%r9,%r9
   280 (0.0%)  	xorq	%r10,%r10
   280 (0.0%)  	xorq	%r11,%r11
   280 (0.0%)  	xorq	%r13,%r13
     .         
   280 (0.0%)  	subq	0(%rsi),%r8
   280 (0.0%)  	sbbq	8(%rsi),%r9
   280 (0.0%)  	sbbq	16(%rsi),%r10
   280 (0.0%)  	movq	%r8,%rax
   280 (0.0%)  	sbbq	24(%rsi),%r11
   280 (0.0%)  	leaq	.Lpoly(%rip),%rsi
   280 (0.0%)  	movq	%r9,%rdx
   280 (0.0%)  	sbbq	$0,%r13
     .         
   280 (0.0%)  	addq	0(%rsi),%r8
   280 (0.0%)  	movq	%r10,%rcx
   280 (0.0%)  	adcq	8(%rsi),%r9
   280 (0.0%)  	adcq	16(%rsi),%r10
   280 (0.0%)  	movq	%r11,%r12
   280 (0.0%)  	adcq	24(%rsi),%r11
   280 (0.0%)  	testq	%r13,%r13
     .         
   280 (0.0%)  	cmovzq	%rax,%r8
   280 (0.0%)  	cmovzq	%rdx,%r9
   280 (0.0%)  	movq	%r8,0(%rdi)
   280 (0.0%)  	cmovzq	%rcx,%r10
   280 (0.0%)  	movq	%r9,8(%rdi)
   280 (0.0%)  	cmovzq	%r12,%r11
   280 (0.0%)  	movq	%r10,16(%rdi)
   280 (0.0%)  	movq	%r11,24(%rdi)
     .         
   280 (0.0%)  	movq	0(%rsp),%r13
     .         .cfi_restore	%r13
   280 (0.0%)  	movq	8(%rsp),%r12
     .         .cfi_restore	%r12
   560 (0.0%)  	leaq	16(%rsp),%rsp
     .         .cfi_adjust_cfa_offset	-16
     .         .Lneg_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	ecp_nistz256_neg,.-ecp_nistz256_neg
     .         
     .         
     .         
-- line 93 ----------------------------------------
-- line 95 ----------------------------------------
     .         
     .         
     .         .globl	ecp_nistz256_ord_mul_mont
     .         .hidden ecp_nistz256_ord_mul_mont
     .         .type	ecp_nistz256_ord_mul_mont,@function
     .         .align	32
     .         ecp_nistz256_ord_mul_mont:
     .         .cfi_startproc	
    38 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
    38 (0.0%)  	movq	8(%rcx),%rcx
    38 (0.0%)  	andl	$0x80100,%ecx
    38 (0.0%)  	cmpl	$0x80100,%ecx
    38 (0.0%)  	je	.Lecp_nistz256_ord_mul_montx
    38 (0.0%)  	pushq	%rbp
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%rbp,-16
    38 (0.0%)  	pushq	%rbx
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%rbx,-24
    38 (0.0%)  	pushq	%r12
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r12,-32
    38 (0.0%)  	pushq	%r13
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r13,-40
    38 (0.0%)  	pushq	%r14
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r14,-48
    38 (0.0%)  	pushq	%r15
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r15,-56
     .         .Lord_mul_body:
     .         
    38 (0.0%)  	movq	0(%rdx),%rax
    38 (0.0%)  	movq	%rdx,%rbx
    38 (0.0%)  	leaq	.Lord(%rip),%r14
    38 (0.0%)  	movq	.LordK(%rip),%r15
     .         
     .         
    38 (0.0%)  	movq	%rax,%rcx
    38 (0.0%)  	mulq	0(%rsi)
    38 (0.0%)  	movq	%rax,%r8
    38 (0.0%)  	movq	%rcx,%rax
    38 (0.0%)  	movq	%rdx,%r9
     .         
    38 (0.0%)  	mulq	8(%rsi)
    38 (0.0%)  	addq	%rax,%r9
    38 (0.0%)  	movq	%rcx,%rax
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	movq	%rdx,%r10
     .         
    38 (0.0%)  	mulq	16(%rsi)
    38 (0.0%)  	addq	%rax,%r10
    38 (0.0%)  	movq	%rcx,%rax
    38 (0.0%)  	adcq	$0,%rdx
     .         
    38 (0.0%)  	movq	%r8,%r13
    38 (0.0%)  	imulq	%r15,%r8
     .         
    38 (0.0%)  	movq	%rdx,%r11
    38 (0.0%)  	mulq	24(%rsi)
    38 (0.0%)  	addq	%rax,%r11
    38 (0.0%)  	movq	%r8,%rax
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	movq	%rdx,%r12
     .         
     .         
    38 (0.0%)  	mulq	0(%r14)
    38 (0.0%)  	movq	%r8,%rbp
    38 (0.0%)  	addq	%rax,%r13
    38 (0.0%)  	movq	%r8,%rax
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	movq	%rdx,%rcx
     .         
    38 (0.0%)  	subq	%r8,%r10
    38 (0.0%)  	sbbq	$0,%r8
     .         
    38 (0.0%)  	mulq	8(%r14)
    38 (0.0%)  	addq	%rcx,%r9
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	addq	%rax,%r9
    38 (0.0%)  	movq	%rbp,%rax
    38 (0.0%)  	adcq	%rdx,%r10
    38 (0.0%)  	movq	%rbp,%rdx
    38 (0.0%)  	adcq	$0,%r8
     .         
    38 (0.0%)  	shlq	$32,%rax
    38 (0.0%)  	shrq	$32,%rdx
    38 (0.0%)  	subq	%rax,%r11
    38 (0.0%)  	movq	8(%rbx),%rax
    38 (0.0%)  	sbbq	%rdx,%rbp
     .         
    38 (0.0%)  	addq	%r8,%r11
    38 (0.0%)  	adcq	%rbp,%r12
    38 (0.0%)  	adcq	$0,%r13
     .         
     .         
    38 (0.0%)  	movq	%rax,%rcx
    38 (0.0%)  	mulq	0(%rsi)
    38 (0.0%)  	addq	%rax,%r9
    38 (0.0%)  	movq	%rcx,%rax
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	movq	%rdx,%rbp
     .         
    38 (0.0%)  	mulq	8(%rsi)
    38 (0.0%)  	addq	%rbp,%r10
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	addq	%rax,%r10
    38 (0.0%)  	movq	%rcx,%rax
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	movq	%rdx,%rbp
     .         
    38 (0.0%)  	mulq	16(%rsi)
    38 (0.0%)  	addq	%rbp,%r11
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	addq	%rax,%r11
    38 (0.0%)  	movq	%rcx,%rax
    38 (0.0%)  	adcq	$0,%rdx
     .         
    38 (0.0%)  	movq	%r9,%rcx
    38 (0.0%)  	imulq	%r15,%r9
     .         
    38 (0.0%)  	movq	%rdx,%rbp
    38 (0.0%)  	mulq	24(%rsi)
    38 (0.0%)  	addq	%rbp,%r12
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	xorq	%r8,%r8
    38 (0.0%)  	addq	%rax,%r12
    38 (0.0%)  	movq	%r9,%rax
    38 (0.0%)  	adcq	%rdx,%r13
    38 (0.0%)  	adcq	$0,%r8
     .         
     .         
    38 (0.0%)  	mulq	0(%r14)
    38 (0.0%)  	movq	%r9,%rbp
    38 (0.0%)  	addq	%rax,%rcx
    38 (0.0%)  	movq	%r9,%rax
    38 (0.0%)  	adcq	%rdx,%rcx
     .         
    38 (0.0%)  	subq	%r9,%r11
    38 (0.0%)  	sbbq	$0,%r9
     .         
    38 (0.0%)  	mulq	8(%r14)
    38 (0.0%)  	addq	%rcx,%r10
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	addq	%rax,%r10
    38 (0.0%)  	movq	%rbp,%rax
    38 (0.0%)  	adcq	%rdx,%r11
    38 (0.0%)  	movq	%rbp,%rdx
    38 (0.0%)  	adcq	$0,%r9
     .         
    38 (0.0%)  	shlq	$32,%rax
    38 (0.0%)  	shrq	$32,%rdx
    38 (0.0%)  	subq	%rax,%r12
    38 (0.0%)  	movq	16(%rbx),%rax
    38 (0.0%)  	sbbq	%rdx,%rbp
     .         
    38 (0.0%)  	addq	%r9,%r12
    38 (0.0%)  	adcq	%rbp,%r13
    38 (0.0%)  	adcq	$0,%r8
     .         
     .         
    38 (0.0%)  	movq	%rax,%rcx
    38 (0.0%)  	mulq	0(%rsi)
    38 (0.0%)  	addq	%rax,%r10
    38 (0.0%)  	movq	%rcx,%rax
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	movq	%rdx,%rbp
     .         
    38 (0.0%)  	mulq	8(%rsi)
    38 (0.0%)  	addq	%rbp,%r11
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	addq	%rax,%r11
    38 (0.0%)  	movq	%rcx,%rax
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	movq	%rdx,%rbp
     .         
    38 (0.0%)  	mulq	16(%rsi)
    38 (0.0%)  	addq	%rbp,%r12
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	addq	%rax,%r12
    38 (0.0%)  	movq	%rcx,%rax
    38 (0.0%)  	adcq	$0,%rdx
     .         
    38 (0.0%)  	movq	%r10,%rcx
    38 (0.0%)  	imulq	%r15,%r10
     .         
    38 (0.0%)  	movq	%rdx,%rbp
    38 (0.0%)  	mulq	24(%rsi)
    38 (0.0%)  	addq	%rbp,%r13
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	xorq	%r9,%r9
    38 (0.0%)  	addq	%rax,%r13
    38 (0.0%)  	movq	%r10,%rax
    38 (0.0%)  	adcq	%rdx,%r8
    38 (0.0%)  	adcq	$0,%r9
     .         
     .         
    38 (0.0%)  	mulq	0(%r14)
    38 (0.0%)  	movq	%r10,%rbp
    38 (0.0%)  	addq	%rax,%rcx
    38 (0.0%)  	movq	%r10,%rax
    38 (0.0%)  	adcq	%rdx,%rcx
     .         
    38 (0.0%)  	subq	%r10,%r12
    38 (0.0%)  	sbbq	$0,%r10
     .         
    38 (0.0%)  	mulq	8(%r14)
    38 (0.0%)  	addq	%rcx,%r11
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	addq	%rax,%r11
    38 (0.0%)  	movq	%rbp,%rax
    38 (0.0%)  	adcq	%rdx,%r12
    38 (0.0%)  	movq	%rbp,%rdx
    38 (0.0%)  	adcq	$0,%r10
     .         
    38 (0.0%)  	shlq	$32,%rax
    38 (0.0%)  	shrq	$32,%rdx
    38 (0.0%)  	subq	%rax,%r13
    38 (0.0%)  	movq	24(%rbx),%rax
    38 (0.0%)  	sbbq	%rdx,%rbp
     .         
    38 (0.0%)  	addq	%r10,%r13
    38 (0.0%)  	adcq	%rbp,%r8
    38 (0.0%)  	adcq	$0,%r9
     .         
     .         
    38 (0.0%)  	movq	%rax,%rcx
    38 (0.0%)  	mulq	0(%rsi)
    38 (0.0%)  	addq	%rax,%r11
    38 (0.0%)  	movq	%rcx,%rax
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	movq	%rdx,%rbp
     .         
    38 (0.0%)  	mulq	8(%rsi)
    38 (0.0%)  	addq	%rbp,%r12
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	addq	%rax,%r12
    38 (0.0%)  	movq	%rcx,%rax
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	movq	%rdx,%rbp
     .         
    38 (0.0%)  	mulq	16(%rsi)
    38 (0.0%)  	addq	%rbp,%r13
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	addq	%rax,%r13
    38 (0.0%)  	movq	%rcx,%rax
    38 (0.0%)  	adcq	$0,%rdx
     .         
    38 (0.0%)  	movq	%r11,%rcx
    38 (0.0%)  	imulq	%r15,%r11
     .         
    38 (0.0%)  	movq	%rdx,%rbp
    38 (0.0%)  	mulq	24(%rsi)
    38 (0.0%)  	addq	%rbp,%r8
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	xorq	%r10,%r10
    38 (0.0%)  	addq	%rax,%r8
    38 (0.0%)  	movq	%r11,%rax
    38 (0.0%)  	adcq	%rdx,%r9
    38 (0.0%)  	adcq	$0,%r10
     .         
     .         
    38 (0.0%)  	mulq	0(%r14)
    38 (0.0%)  	movq	%r11,%rbp
    38 (0.0%)  	addq	%rax,%rcx
    38 (0.0%)  	movq	%r11,%rax
    38 (0.0%)  	adcq	%rdx,%rcx
     .         
    38 (0.0%)  	subq	%r11,%r13
    38 (0.0%)  	sbbq	$0,%r11
     .         
    38 (0.0%)  	mulq	8(%r14)
    38 (0.0%)  	addq	%rcx,%r12
    38 (0.0%)  	adcq	$0,%rdx
    38 (0.0%)  	addq	%rax,%r12
    38 (0.0%)  	movq	%rbp,%rax
    38 (0.0%)  	adcq	%rdx,%r13
    38 (0.0%)  	movq	%rbp,%rdx
    38 (0.0%)  	adcq	$0,%r11
     .         
    38 (0.0%)  	shlq	$32,%rax
    38 (0.0%)  	shrq	$32,%rdx
    38 (0.0%)  	subq	%rax,%r8
    38 (0.0%)  	sbbq	%rdx,%rbp
     .         
    38 (0.0%)  	addq	%r11,%r8
    38 (0.0%)  	adcq	%rbp,%r9
    38 (0.0%)  	adcq	$0,%r10
     .         
     .         
    38 (0.0%)  	movq	%r12,%rsi
    38 (0.0%)  	subq	0(%r14),%r12
    38 (0.0%)  	movq	%r13,%r11
    38 (0.0%)  	sbbq	8(%r14),%r13
    38 (0.0%)  	movq	%r8,%rcx
    38 (0.0%)  	sbbq	16(%r14),%r8
    38 (0.0%)  	movq	%r9,%rbp
    38 (0.0%)  	sbbq	24(%r14),%r9
    38 (0.0%)  	sbbq	$0,%r10
     .         
    38 (0.0%)  	cmovcq	%rsi,%r12
    38 (0.0%)  	cmovcq	%r11,%r13
    38 (0.0%)  	cmovcq	%rcx,%r8
    38 (0.0%)  	cmovcq	%rbp,%r9
     .         
    38 (0.0%)  	movq	%r12,0(%rdi)
    38 (0.0%)  	movq	%r13,8(%rdi)
    38 (0.0%)  	movq	%r8,16(%rdi)
    38 (0.0%)  	movq	%r9,24(%rdi)
     .         
    38 (0.0%)  	movq	0(%rsp),%r15
     .         .cfi_restore	%r15
    38 (0.0%)  	movq	8(%rsp),%r14
     .         .cfi_restore	%r14
    38 (0.0%)  	movq	16(%rsp),%r13
     .         .cfi_restore	%r13
    38 (0.0%)  	movq	24(%rsp),%r12
     .         .cfi_restore	%r12
    38 (0.0%)  	movq	32(%rsp),%rbx
     .         .cfi_restore	%rbx
    38 (0.0%)  	movq	40(%rsp),%rbp
     .         .cfi_restore	%rbp
    76 (0.0%)  	leaq	48(%rsp),%rsp
     .         .cfi_adjust_cfa_offset	-48
     .         .Lord_mul_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	ecp_nistz256_ord_mul_mont,.-ecp_nistz256_ord_mul_mont
     .         
     .         
     .         
-- line 426 ----------------------------------------
-- line 429 ----------------------------------------
     .         
     .         
     .         .globl	ecp_nistz256_ord_sqr_mont
     .         .hidden ecp_nistz256_ord_sqr_mont
     .         .type	ecp_nistz256_ord_sqr_mont,@function
     .         .align	32
     .         ecp_nistz256_ord_sqr_mont:
     .         .cfi_startproc	
    35 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
    35 (0.0%)  	movq	8(%rcx),%rcx
    35 (0.0%)  	andl	$0x80100,%ecx
    35 (0.0%)  	cmpl	$0x80100,%ecx
    35 (0.0%)  	je	.Lecp_nistz256_ord_sqr_montx
    35 (0.0%)  	pushq	%rbp
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%rbp,-16
    35 (0.0%)  	pushq	%rbx
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%rbx,-24
    35 (0.0%)  	pushq	%r12
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r12,-32
    35 (0.0%)  	pushq	%r13
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r13,-40
    35 (0.0%)  	pushq	%r14
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r14,-48
    35 (0.0%)  	pushq	%r15
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r15,-56
     .         .Lord_sqr_body:
     .         
    35 (0.0%)  	movq	0(%rsi),%r8
    35 (0.0%)  	movq	8(%rsi),%rax
    35 (0.0%)  	movq	16(%rsi),%r14
    35 (0.0%)  	movq	24(%rsi),%r15
    35 (0.0%)  	leaq	.Lord(%rip),%rsi
    35 (0.0%)  	movq	%rdx,%rbx
    35 (0.0%)  	jmp	.Loop_ord_sqr
     .         
     .         .align	32
     .         .Loop_ord_sqr:
     .         
   254 (0.0%)  	movq	%rax,%rbp
   254 (0.0%)  	mulq	%r8
   508 (0.0%)  	movq	%rax,%r9
     .         .byte	102,72,15,110,205
   254 (0.0%)  	movq	%r14,%rax
   254 (0.0%)  	movq	%rdx,%r10
     .         
   254 (0.0%)  	mulq	%r8
   254 (0.0%)  	addq	%rax,%r10
   508 (0.0%)  	movq	%r15,%rax
     .         .byte	102,73,15,110,214
   254 (0.0%)  	adcq	$0,%rdx
   254 (0.0%)  	movq	%rdx,%r11
     .         
   254 (0.0%)  	mulq	%r8
   254 (0.0%)  	addq	%rax,%r11
   508 (0.0%)  	movq	%r15,%rax
     .         .byte	102,73,15,110,223
   254 (0.0%)  	adcq	$0,%rdx
   254 (0.0%)  	movq	%rdx,%r12
     .         
     .         
   254 (0.0%)  	mulq	%r14
   254 (0.0%)  	movq	%rax,%r13
   254 (0.0%)  	movq	%r14,%rax
   254 (0.0%)  	movq	%rdx,%r14
     .         
     .         
   254 (0.0%)  	mulq	%rbp
   254 (0.0%)  	addq	%rax,%r11
   254 (0.0%)  	movq	%r15,%rax
   254 (0.0%)  	adcq	$0,%rdx
   254 (0.0%)  	movq	%rdx,%r15
     .         
   254 (0.0%)  	mulq	%rbp
   254 (0.0%)  	addq	%rax,%r12
   254 (0.0%)  	adcq	$0,%rdx
     .         
   254 (0.0%)  	addq	%r15,%r12
   254 (0.0%)  	adcq	%rdx,%r13
   254 (0.0%)  	adcq	$0,%r14
     .         
     .         
   254 (0.0%)  	xorq	%r15,%r15
   254 (0.0%)  	movq	%r8,%rax
   254 (0.0%)  	addq	%r9,%r9
   254 (0.0%)  	adcq	%r10,%r10
   254 (0.0%)  	adcq	%r11,%r11
   254 (0.0%)  	adcq	%r12,%r12
   254 (0.0%)  	adcq	%r13,%r13
   254 (0.0%)  	adcq	%r14,%r14
   254 (0.0%)  	adcq	$0,%r15
     .         
     .         
   254 (0.0%)  	mulq	%rax
   508 (0.0%)  	movq	%rax,%r8
     .         .byte	102,72,15,126,200
   254 (0.0%)  	movq	%rdx,%rbp
     .         
   254 (0.0%)  	mulq	%rax
   254 (0.0%)  	addq	%rbp,%r9
   508 (0.0%)  	adcq	%rax,%r10
     .         .byte	102,72,15,126,208
   254 (0.0%)  	adcq	$0,%rdx
   254 (0.0%)  	movq	%rdx,%rbp
     .         
   254 (0.0%)  	mulq	%rax
   254 (0.0%)  	addq	%rbp,%r11
   508 (0.0%)  	adcq	%rax,%r12
     .         .byte	102,72,15,126,216
   254 (0.0%)  	adcq	$0,%rdx
   254 (0.0%)  	movq	%rdx,%rbp
     .         
   254 (0.0%)  	movq	%r8,%rcx
   254 (0.0%)  	imulq	32(%rsi),%r8
     .         
   254 (0.0%)  	mulq	%rax
   254 (0.0%)  	addq	%rbp,%r13
   254 (0.0%)  	adcq	%rax,%r14
   254 (0.0%)  	movq	0(%rsi),%rax
   254 (0.0%)  	adcq	%rdx,%r15
     .         
     .         
   254 (0.0%)  	mulq	%r8
   254 (0.0%)  	movq	%r8,%rbp
   254 (0.0%)  	addq	%rax,%rcx
   254 (0.0%)  	movq	8(%rsi),%rax
   254 (0.0%)  	adcq	%rdx,%rcx
     .         
   254 (0.0%)  	subq	%r8,%r10
   254 (0.0%)  	sbbq	$0,%rbp
     .         
   254 (0.0%)  	mulq	%r8
   254 (0.0%)  	addq	%rcx,%r9
   254 (0.0%)  	adcq	$0,%rdx
   254 (0.0%)  	addq	%rax,%r9
   254 (0.0%)  	movq	%r8,%rax
   254 (0.0%)  	adcq	%rdx,%r10
   254 (0.0%)  	movq	%r8,%rdx
   254 (0.0%)  	adcq	$0,%rbp
     .         
   254 (0.0%)  	movq	%r9,%rcx
   254 (0.0%)  	imulq	32(%rsi),%r9
     .         
   254 (0.0%)  	shlq	$32,%rax
   254 (0.0%)  	shrq	$32,%rdx
   254 (0.0%)  	subq	%rax,%r11
   254 (0.0%)  	movq	0(%rsi),%rax
   254 (0.0%)  	sbbq	%rdx,%r8
     .         
   254 (0.0%)  	addq	%rbp,%r11
   254 (0.0%)  	adcq	$0,%r8
     .         
     .         
   254 (0.0%)  	mulq	%r9
   254 (0.0%)  	movq	%r9,%rbp
   254 (0.0%)  	addq	%rax,%rcx
   254 (0.0%)  	movq	8(%rsi),%rax
   254 (0.0%)  	adcq	%rdx,%rcx
     .         
   254 (0.0%)  	subq	%r9,%r11
   254 (0.0%)  	sbbq	$0,%rbp
     .         
   254 (0.0%)  	mulq	%r9
   254 (0.0%)  	addq	%rcx,%r10
   254 (0.0%)  	adcq	$0,%rdx
   254 (0.0%)  	addq	%rax,%r10
   254 (0.0%)  	movq	%r9,%rax
   254 (0.0%)  	adcq	%rdx,%r11
   254 (0.0%)  	movq	%r9,%rdx
   254 (0.0%)  	adcq	$0,%rbp
     .         
   254 (0.0%)  	movq	%r10,%rcx
   254 (0.0%)  	imulq	32(%rsi),%r10
     .         
   254 (0.0%)  	shlq	$32,%rax
   254 (0.0%)  	shrq	$32,%rdx
   254 (0.0%)  	subq	%rax,%r8
   254 (0.0%)  	movq	0(%rsi),%rax
   254 (0.0%)  	sbbq	%rdx,%r9
     .         
   254 (0.0%)  	addq	%rbp,%r8
   254 (0.0%)  	adcq	$0,%r9
     .         
     .         
   254 (0.0%)  	mulq	%r10
   254 (0.0%)  	movq	%r10,%rbp
   254 (0.0%)  	addq	%rax,%rcx
   254 (0.0%)  	movq	8(%rsi),%rax
   254 (0.0%)  	adcq	%rdx,%rcx
     .         
   254 (0.0%)  	subq	%r10,%r8
   254 (0.0%)  	sbbq	$0,%rbp
     .         
   254 (0.0%)  	mulq	%r10
   254 (0.0%)  	addq	%rcx,%r11
   254 (0.0%)  	adcq	$0,%rdx
   254 (0.0%)  	addq	%rax,%r11
   254 (0.0%)  	movq	%r10,%rax
   254 (0.0%)  	adcq	%rdx,%r8
   254 (0.0%)  	movq	%r10,%rdx
   254 (0.0%)  	adcq	$0,%rbp
     .         
   254 (0.0%)  	movq	%r11,%rcx
   254 (0.0%)  	imulq	32(%rsi),%r11
     .         
   254 (0.0%)  	shlq	$32,%rax
   254 (0.0%)  	shrq	$32,%rdx
   254 (0.0%)  	subq	%rax,%r9
   254 (0.0%)  	movq	0(%rsi),%rax
   254 (0.0%)  	sbbq	%rdx,%r10
     .         
   254 (0.0%)  	addq	%rbp,%r9
   254 (0.0%)  	adcq	$0,%r10
     .         
     .         
   254 (0.0%)  	mulq	%r11
   254 (0.0%)  	movq	%r11,%rbp
   254 (0.0%)  	addq	%rax,%rcx
   254 (0.0%)  	movq	8(%rsi),%rax
   254 (0.0%)  	adcq	%rdx,%rcx
     .         
   254 (0.0%)  	subq	%r11,%r9
   254 (0.0%)  	sbbq	$0,%rbp
     .         
   254 (0.0%)  	mulq	%r11
   254 (0.0%)  	addq	%rcx,%r8
   254 (0.0%)  	adcq	$0,%rdx
   254 (0.0%)  	addq	%rax,%r8
   254 (0.0%)  	movq	%r11,%rax
   254 (0.0%)  	adcq	%rdx,%r9
   254 (0.0%)  	movq	%r11,%rdx
   254 (0.0%)  	adcq	$0,%rbp
     .         
   254 (0.0%)  	shlq	$32,%rax
   254 (0.0%)  	shrq	$32,%rdx
   254 (0.0%)  	subq	%rax,%r10
   254 (0.0%)  	sbbq	%rdx,%r11
     .         
   254 (0.0%)  	addq	%rbp,%r10
   254 (0.0%)  	adcq	$0,%r11
     .         
     .         
   254 (0.0%)  	xorq	%rdx,%rdx
   254 (0.0%)  	addq	%r12,%r8
   254 (0.0%)  	adcq	%r13,%r9
   254 (0.0%)  	movq	%r8,%r12
   254 (0.0%)  	adcq	%r14,%r10
   254 (0.0%)  	adcq	%r15,%r11
   254 (0.0%)  	movq	%r9,%rax
   254 (0.0%)  	adcq	$0,%rdx
     .         
     .         
   254 (0.0%)  	subq	0(%rsi),%r8
   254 (0.0%)  	movq	%r10,%r14
   254 (0.0%)  	sbbq	8(%rsi),%r9
   254 (0.0%)  	sbbq	16(%rsi),%r10
   254 (0.0%)  	movq	%r11,%r15
   254 (0.0%)  	sbbq	24(%rsi),%r11
   254 (0.0%)  	sbbq	$0,%rdx
     .         
   254 (0.0%)  	cmovcq	%r12,%r8
   254 (0.0%)  	cmovncq	%r9,%rax
   254 (0.0%)  	cmovncq	%r10,%r14
   254 (0.0%)  	cmovncq	%r11,%r15
     .         
   254 (0.0%)  	decq	%rbx
   254 (0.0%)  	jnz	.Loop_ord_sqr
     .         
    35 (0.0%)  	movq	%r8,0(%rdi)
    35 (0.0%)  	movq	%rax,8(%rdi)
    35 (0.0%)  	pxor	%xmm1,%xmm1
    35 (0.0%)  	movq	%r14,16(%rdi)
    35 (0.0%)  	pxor	%xmm2,%xmm2
    35 (0.0%)  	movq	%r15,24(%rdi)
    35 (0.0%)  	pxor	%xmm3,%xmm3
     .         
    35 (0.0%)  	movq	0(%rsp),%r15
     .         .cfi_restore	%r15
    35 (0.0%)  	movq	8(%rsp),%r14
     .         .cfi_restore	%r14
    35 (0.0%)  	movq	16(%rsp),%r13
     .         .cfi_restore	%r13
    35 (0.0%)  	movq	24(%rsp),%r12
     .         .cfi_restore	%r12
    35 (0.0%)  	movq	32(%rsp),%rbx
     .         .cfi_restore	%rbx
    35 (0.0%)  	movq	40(%rsp),%rbp
     .         .cfi_restore	%rbp
    70 (0.0%)  	leaq	48(%rsp),%rsp
     .         .cfi_adjust_cfa_offset	-48
     .         .Lord_sqr_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	ecp_nistz256_ord_sqr_mont,.-ecp_nistz256_ord_sqr_mont
     .         
     .         .type	ecp_nistz256_ord_mul_montx,@function
     .         .align	32
-- line 730 ----------------------------------------
-- line 1188 ----------------------------------------
     .         
     .         
     .         .globl	ecp_nistz256_mul_mont
     .         .hidden ecp_nistz256_mul_mont
     .         .type	ecp_nistz256_mul_mont,@function
     .         .align	32
     .         ecp_nistz256_mul_mont:
     .         .cfi_startproc	
    67 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
    67 (0.0%)  	movq	8(%rcx),%rcx
    67 (0.0%)  	andl	$0x80100,%ecx
     .         .Lmul_mont:
    67 (0.0%)  	pushq	%rbp
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%rbp,-16
    67 (0.0%)  	pushq	%rbx
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%rbx,-24
    67 (0.0%)  	pushq	%r12
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r12,-32
    67 (0.0%)  	pushq	%r13
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r13,-40
    67 (0.0%)  	pushq	%r14
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r14,-48
    67 (0.0%)  	pushq	%r15
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r15,-56
     .         .Lmul_body:
    67 (0.0%)  	cmpl	$0x80100,%ecx
    67 (0.0%)  	je	.Lmul_montx
    67 (0.0%)  	movq	%rdx,%rbx
    67 (0.0%)  	movq	0(%rdx),%rax
    67 (0.0%)  	movq	0(%rsi),%r9
    67 (0.0%)  	movq	8(%rsi),%r10
    67 (0.0%)  	movq	16(%rsi),%r11
    67 (0.0%)  	movq	24(%rsi),%r12
     .         
    67 (0.0%)  	call	__ecp_nistz256_mul_montq
    67 (0.0%)  	jmp	.Lmul_mont_done
     .         
     .         .align	32
     .         .Lmul_montx:
     .         	movq	%rdx,%rbx
     .         	movq	0(%rdx),%rdx
     .         	movq	0(%rsi),%r9
     .         	movq	8(%rsi),%r10
     .         	movq	16(%rsi),%r11
     .         	movq	24(%rsi),%r12
     .         	leaq	-128(%rsi),%rsi
     .         
     .         	call	__ecp_nistz256_mul_montx
     .         .Lmul_mont_done:
    67 (0.0%)  	movq	0(%rsp),%r15
     .         .cfi_restore	%r15
    67 (0.0%)  	movq	8(%rsp),%r14
     .         .cfi_restore	%r14
    67 (0.0%)  	movq	16(%rsp),%r13
     .         .cfi_restore	%r13
    67 (0.0%)  	movq	24(%rsp),%r12
     .         .cfi_restore	%r12
    67 (0.0%)  	movq	32(%rsp),%rbx
     .         .cfi_restore	%rbx
    67 (0.0%)  	movq	40(%rsp),%rbp
     .         .cfi_restore	%rbp
   134 (0.0%)  	leaq	48(%rsp),%rsp
     .         .cfi_adjust_cfa_offset	-48
     .         .Lmul_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	ecp_nistz256_mul_mont,.-ecp_nistz256_mul_mont
     .         
     .         .type	__ecp_nistz256_mul_montq,@function
     .         .align	32
     .         __ecp_nistz256_mul_montq:
     .         .cfi_startproc	
     .         
     .         
 6,475 (0.1%)  	movq	%rax,%rbp
 6,475 (0.1%)  	mulq	%r9
 6,475 (0.1%)  	movq	.Lpoly+8(%rip),%r14
 6,475 (0.1%)  	movq	%rax,%r8
 6,475 (0.1%)  	movq	%rbp,%rax
 6,475 (0.1%)  	movq	%rdx,%r9
     .         
 6,475 (0.1%)  	mulq	%r10
 6,475 (0.1%)  	movq	.Lpoly+24(%rip),%r15
 6,475 (0.1%)  	addq	%rax,%r9
 6,475 (0.1%)  	movq	%rbp,%rax
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	movq	%rdx,%r10
     .         
 6,475 (0.1%)  	mulq	%r11
 6,475 (0.1%)  	addq	%rax,%r10
 6,475 (0.1%)  	movq	%rbp,%rax
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	movq	%rdx,%r11
     .         
 6,475 (0.1%)  	mulq	%r12
 6,475 (0.1%)  	addq	%rax,%r11
 6,475 (0.1%)  	movq	%r8,%rax
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	xorq	%r13,%r13
 6,475 (0.1%)  	movq	%rdx,%r12
     .         
     .         
     .         
     .         
     .         
     .         
     .         
     .         
     .         
     .         
 6,475 (0.1%)  	movq	%r8,%rbp
 6,475 (0.1%)  	shlq	$32,%r8
 6,475 (0.1%)  	mulq	%r15
 6,475 (0.1%)  	shrq	$32,%rbp
 6,475 (0.1%)  	addq	%r8,%r9
 6,475 (0.1%)  	adcq	%rbp,%r10
 6,475 (0.1%)  	adcq	%rax,%r11
 6,475 (0.1%)  	movq	8(%rbx),%rax
 6,475 (0.1%)  	adcq	%rdx,%r12
 6,475 (0.1%)  	adcq	$0,%r13
 6,475 (0.1%)  	xorq	%r8,%r8
     .         
     .         
     .         
 6,475 (0.1%)  	movq	%rax,%rbp
 6,475 (0.1%)  	mulq	0(%rsi)
 6,475 (0.1%)  	addq	%rax,%r9
 6,475 (0.1%)  	movq	%rbp,%rax
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	movq	%rdx,%rcx
     .         
 6,475 (0.1%)  	mulq	8(%rsi)
 6,475 (0.1%)  	addq	%rcx,%r10
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	addq	%rax,%r10
 6,475 (0.1%)  	movq	%rbp,%rax
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	movq	%rdx,%rcx
     .         
 6,475 (0.1%)  	mulq	16(%rsi)
 6,475 (0.1%)  	addq	%rcx,%r11
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	addq	%rax,%r11
 6,475 (0.1%)  	movq	%rbp,%rax
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	movq	%rdx,%rcx
     .         
 6,475 (0.1%)  	mulq	24(%rsi)
 6,475 (0.1%)  	addq	%rcx,%r12
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	addq	%rax,%r12
 6,475 (0.1%)  	movq	%r9,%rax
 6,475 (0.1%)  	adcq	%rdx,%r13
 6,475 (0.1%)  	adcq	$0,%r8
     .         
     .         
     .         
 6,475 (0.1%)  	movq	%r9,%rbp
 6,475 (0.1%)  	shlq	$32,%r9
 6,475 (0.1%)  	mulq	%r15
 6,475 (0.1%)  	shrq	$32,%rbp
 6,475 (0.1%)  	addq	%r9,%r10
 6,475 (0.1%)  	adcq	%rbp,%r11
 6,475 (0.1%)  	adcq	%rax,%r12
 6,475 (0.1%)  	movq	16(%rbx),%rax
 6,475 (0.1%)  	adcq	%rdx,%r13
 6,475 (0.1%)  	adcq	$0,%r8
 6,475 (0.1%)  	xorq	%r9,%r9
     .         
     .         
     .         
 6,475 (0.1%)  	movq	%rax,%rbp
 6,475 (0.1%)  	mulq	0(%rsi)
 6,475 (0.1%)  	addq	%rax,%r10
 6,475 (0.1%)  	movq	%rbp,%rax
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	movq	%rdx,%rcx
     .         
 6,475 (0.1%)  	mulq	8(%rsi)
 6,475 (0.1%)  	addq	%rcx,%r11
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	addq	%rax,%r11
 6,475 (0.1%)  	movq	%rbp,%rax
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	movq	%rdx,%rcx
     .         
 6,475 (0.1%)  	mulq	16(%rsi)
 6,475 (0.1%)  	addq	%rcx,%r12
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	addq	%rax,%r12
 6,475 (0.1%)  	movq	%rbp,%rax
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	movq	%rdx,%rcx
     .         
 6,475 (0.1%)  	mulq	24(%rsi)
 6,475 (0.1%)  	addq	%rcx,%r13
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	addq	%rax,%r13
 6,475 (0.1%)  	movq	%r10,%rax
 6,475 (0.1%)  	adcq	%rdx,%r8
 6,475 (0.1%)  	adcq	$0,%r9
     .         
     .         
     .         
 6,475 (0.1%)  	movq	%r10,%rbp
 6,475 (0.1%)  	shlq	$32,%r10
 6,475 (0.1%)  	mulq	%r15
 6,475 (0.1%)  	shrq	$32,%rbp
 6,475 (0.1%)  	addq	%r10,%r11
 6,475 (0.1%)  	adcq	%rbp,%r12
 6,475 (0.1%)  	adcq	%rax,%r13
 6,475 (0.1%)  	movq	24(%rbx),%rax
 6,475 (0.1%)  	adcq	%rdx,%r8
 6,475 (0.1%)  	adcq	$0,%r9
 6,475 (0.1%)  	xorq	%r10,%r10
     .         
     .         
     .         
 6,475 (0.1%)  	movq	%rax,%rbp
 6,475 (0.1%)  	mulq	0(%rsi)
 6,475 (0.1%)  	addq	%rax,%r11
 6,475 (0.1%)  	movq	%rbp,%rax
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	movq	%rdx,%rcx
     .         
 6,475 (0.1%)  	mulq	8(%rsi)
 6,475 (0.1%)  	addq	%rcx,%r12
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	addq	%rax,%r12
 6,475 (0.1%)  	movq	%rbp,%rax
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	movq	%rdx,%rcx
     .         
 6,475 (0.1%)  	mulq	16(%rsi)
 6,475 (0.1%)  	addq	%rcx,%r13
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	addq	%rax,%r13
 6,475 (0.1%)  	movq	%rbp,%rax
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	movq	%rdx,%rcx
     .         
 6,475 (0.1%)  	mulq	24(%rsi)
 6,475 (0.1%)  	addq	%rcx,%r8
 6,475 (0.1%)  	adcq	$0,%rdx
 6,475 (0.1%)  	addq	%rax,%r8
 6,475 (0.1%)  	movq	%r11,%rax
 6,475 (0.1%)  	adcq	%rdx,%r9
 6,475 (0.1%)  	adcq	$0,%r10
     .         
     .         
     .         
 6,475 (0.1%)  	movq	%r11,%rbp
 6,475 (0.1%)  	shlq	$32,%r11
 6,475 (0.1%)  	mulq	%r15
 6,475 (0.1%)  	shrq	$32,%rbp
 6,475 (0.1%)  	addq	%r11,%r12
 6,475 (0.1%)  	adcq	%rbp,%r13
 6,475 (0.1%)  	movq	%r12,%rcx
 6,475 (0.1%)  	adcq	%rax,%r8
 6,475 (0.1%)  	adcq	%rdx,%r9
 6,475 (0.1%)  	movq	%r13,%rbp
 6,475 (0.1%)  	adcq	$0,%r10
     .         
     .         
     .         
 6,475 (0.1%)  	subq	$-1,%r12
 6,475 (0.1%)  	movq	%r8,%rbx
 6,475 (0.1%)  	sbbq	%r14,%r13
 6,475 (0.1%)  	sbbq	$0,%r8
 6,475 (0.1%)  	movq	%r9,%rdx
 6,475 (0.1%)  	sbbq	%r15,%r9
 6,475 (0.1%)  	sbbq	$0,%r10
     .         
 6,475 (0.1%)  	cmovcq	%rcx,%r12
 6,475 (0.1%)  	cmovcq	%rbp,%r13
 6,475 (0.1%)  	movq	%r12,0(%rdi)
 6,475 (0.1%)  	cmovcq	%rbx,%r8
 6,475 (0.1%)  	movq	%r13,8(%rdi)
 6,475 (0.1%)  	cmovcq	%rdx,%r9
 6,475 (0.1%)  	movq	%r8,16(%rdi)
12,950 (0.2%)  	movq	%r9,24(%rdi)
     .         
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	__ecp_nistz256_mul_montq,.-__ecp_nistz256_mul_montq
     .         
     .         
     .         
     .         
-- line 1482 ----------------------------------------
-- line 1485 ----------------------------------------
     .         
     .         
     .         .globl	ecp_nistz256_sqr_mont
     .         .hidden ecp_nistz256_sqr_mont
     .         .type	ecp_nistz256_sqr_mont,@function
     .         .align	32
     .         ecp_nistz256_sqr_mont:
     .         .cfi_startproc	
 1,277 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
 1,277 (0.0%)  	movq	8(%rcx),%rcx
 1,277 (0.0%)  	andl	$0x80100,%ecx
 1,277 (0.0%)  	pushq	%rbp
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%rbp,-16
 1,277 (0.0%)  	pushq	%rbx
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%rbx,-24
 1,277 (0.0%)  	pushq	%r12
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r12,-32
 1,277 (0.0%)  	pushq	%r13
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r13,-40
 1,277 (0.0%)  	pushq	%r14
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r14,-48
 1,277 (0.0%)  	pushq	%r15
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r15,-56
     .         .Lsqr_body:
 1,277 (0.0%)  	cmpl	$0x80100,%ecx
 1,277 (0.0%)  	je	.Lsqr_montx
 1,277 (0.0%)  	movq	0(%rsi),%rax
 1,277 (0.0%)  	movq	8(%rsi),%r14
 1,277 (0.0%)  	movq	16(%rsi),%r15
 1,277 (0.0%)  	movq	24(%rsi),%r8
     .         
 1,277 (0.0%)  	call	__ecp_nistz256_sqr_montq
 1,277 (0.0%)  	jmp	.Lsqr_mont_done
     .         
     .         .align	32
     .         .Lsqr_montx:
     .         	movq	0(%rsi),%rdx
     .         	movq	8(%rsi),%r14
     .         	movq	16(%rsi),%r15
     .         	movq	24(%rsi),%r8
     .         	leaq	-128(%rsi),%rsi
     .         
     .         	call	__ecp_nistz256_sqr_montx
     .         .Lsqr_mont_done:
 1,277 (0.0%)  	movq	0(%rsp),%r15
     .         .cfi_restore	%r15
 1,277 (0.0%)  	movq	8(%rsp),%r14
     .         .cfi_restore	%r14
 1,277 (0.0%)  	movq	16(%rsp),%r13
     .         .cfi_restore	%r13
 1,277 (0.0%)  	movq	24(%rsp),%r12
     .         .cfi_restore	%r12
 1,277 (0.0%)  	movq	32(%rsp),%rbx
     .         .cfi_restore	%rbx
 1,277 (0.0%)  	movq	40(%rsp),%rbp
     .         .cfi_restore	%rbp
 2,554 (0.0%)  	leaq	48(%rsp),%rsp
     .         .cfi_adjust_cfa_offset	-48
     .         .Lsqr_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	ecp_nistz256_sqr_mont,.-ecp_nistz256_sqr_mont
     .         
     .         .type	__ecp_nistz256_sqr_montq,@function
     .         .align	32
     .         __ecp_nistz256_sqr_montq:
     .         .cfi_startproc	
 5,565 (0.1%)  	movq	%rax,%r13
 5,565 (0.1%)  	mulq	%r14
 5,565 (0.1%)  	movq	%rax,%r9
 5,565 (0.1%)  	movq	%r15,%rax
 5,565 (0.1%)  	movq	%rdx,%r10
     .         
 5,565 (0.1%)  	mulq	%r13
 5,565 (0.1%)  	addq	%rax,%r10
 5,565 (0.1%)  	movq	%r8,%rax
 5,565 (0.1%)  	adcq	$0,%rdx
 5,565 (0.1%)  	movq	%rdx,%r11
     .         
 5,565 (0.1%)  	mulq	%r13
 5,565 (0.1%)  	addq	%rax,%r11
 5,565 (0.1%)  	movq	%r15,%rax
 5,565 (0.1%)  	adcq	$0,%rdx
 5,565 (0.1%)  	movq	%rdx,%r12
     .         
     .         
 5,565 (0.1%)  	mulq	%r14
 5,565 (0.1%)  	addq	%rax,%r11
 5,565 (0.1%)  	movq	%r8,%rax
 5,565 (0.1%)  	adcq	$0,%rdx
 5,565 (0.1%)  	movq	%rdx,%rbp
     .         
 5,565 (0.1%)  	mulq	%r14
 5,565 (0.1%)  	addq	%rax,%r12
 5,565 (0.1%)  	movq	%r8,%rax
 5,565 (0.1%)  	adcq	$0,%rdx
 5,565 (0.1%)  	addq	%rbp,%r12
 5,565 (0.1%)  	movq	%rdx,%r13
 5,565 (0.1%)  	adcq	$0,%r13
     .         
     .         
 5,565 (0.1%)  	mulq	%r15
 5,565 (0.1%)  	xorq	%r15,%r15
 5,565 (0.1%)  	addq	%rax,%r13
 5,565 (0.1%)  	movq	0(%rsi),%rax
 5,565 (0.1%)  	movq	%rdx,%r14
 5,565 (0.1%)  	adcq	$0,%r14
     .         
 5,565 (0.1%)  	addq	%r9,%r9
 5,565 (0.1%)  	adcq	%r10,%r10
 5,565 (0.1%)  	adcq	%r11,%r11
 5,565 (0.1%)  	adcq	%r12,%r12
 5,565 (0.1%)  	adcq	%r13,%r13
 5,565 (0.1%)  	adcq	%r14,%r14
 5,565 (0.1%)  	adcq	$0,%r15
     .         
 5,565 (0.1%)  	mulq	%rax
 5,565 (0.1%)  	movq	%rax,%r8
 5,565 (0.1%)  	movq	8(%rsi),%rax
 5,565 (0.1%)  	movq	%rdx,%rcx
     .         
 5,565 (0.1%)  	mulq	%rax
 5,565 (0.1%)  	addq	%rcx,%r9
 5,565 (0.1%)  	adcq	%rax,%r10
 5,565 (0.1%)  	movq	16(%rsi),%rax
 5,565 (0.1%)  	adcq	$0,%rdx
 5,565 (0.1%)  	movq	%rdx,%rcx
     .         
 5,565 (0.1%)  	mulq	%rax
 5,565 (0.1%)  	addq	%rcx,%r11
 5,565 (0.1%)  	adcq	%rax,%r12
 5,565 (0.1%)  	movq	24(%rsi),%rax
 5,565 (0.1%)  	adcq	$0,%rdx
 5,565 (0.1%)  	movq	%rdx,%rcx
     .         
 5,565 (0.1%)  	mulq	%rax
 5,565 (0.1%)  	addq	%rcx,%r13
 5,565 (0.1%)  	adcq	%rax,%r14
 5,565 (0.1%)  	movq	%r8,%rax
 5,565 (0.1%)  	adcq	%rdx,%r15
     .         
 5,565 (0.1%)  	movq	.Lpoly+8(%rip),%rsi
 5,565 (0.1%)  	movq	.Lpoly+24(%rip),%rbp
     .         
     .         
     .         
     .         
 5,565 (0.1%)  	movq	%r8,%rcx
 5,565 (0.1%)  	shlq	$32,%r8
 5,565 (0.1%)  	mulq	%rbp
 5,565 (0.1%)  	shrq	$32,%rcx
 5,565 (0.1%)  	addq	%r8,%r9
 5,565 (0.1%)  	adcq	%rcx,%r10
 5,565 (0.1%)  	adcq	%rax,%r11
 5,565 (0.1%)  	movq	%r9,%rax
 5,565 (0.1%)  	adcq	$0,%rdx
     .         
     .         
     .         
 5,565 (0.1%)  	movq	%r9,%rcx
 5,565 (0.1%)  	shlq	$32,%r9
 5,565 (0.1%)  	movq	%rdx,%r8
 5,565 (0.1%)  	mulq	%rbp
 5,565 (0.1%)  	shrq	$32,%rcx
 5,565 (0.1%)  	addq	%r9,%r10
 5,565 (0.1%)  	adcq	%rcx,%r11
 5,565 (0.1%)  	adcq	%rax,%r8
 5,565 (0.1%)  	movq	%r10,%rax
 5,565 (0.1%)  	adcq	$0,%rdx
     .         
     .         
     .         
 5,565 (0.1%)  	movq	%r10,%rcx
 5,565 (0.1%)  	shlq	$32,%r10
 5,565 (0.1%)  	movq	%rdx,%r9
 5,565 (0.1%)  	mulq	%rbp
 5,565 (0.1%)  	shrq	$32,%rcx
 5,565 (0.1%)  	addq	%r10,%r11
 5,565 (0.1%)  	adcq	%rcx,%r8
 5,565 (0.1%)  	adcq	%rax,%r9
 5,565 (0.1%)  	movq	%r11,%rax
 5,565 (0.1%)  	adcq	$0,%rdx
     .         
     .         
     .         
 5,565 (0.1%)  	movq	%r11,%rcx
 5,565 (0.1%)  	shlq	$32,%r11
 5,565 (0.1%)  	movq	%rdx,%r10
 5,565 (0.1%)  	mulq	%rbp
 5,565 (0.1%)  	shrq	$32,%rcx
 5,565 (0.1%)  	addq	%r11,%r8
 5,565 (0.1%)  	adcq	%rcx,%r9
 5,565 (0.1%)  	adcq	%rax,%r10
 5,565 (0.1%)  	adcq	$0,%rdx
 5,565 (0.1%)  	xorq	%r11,%r11
     .         
     .         
     .         
 5,565 (0.1%)  	addq	%r8,%r12
 5,565 (0.1%)  	adcq	%r9,%r13
 5,565 (0.1%)  	movq	%r12,%r8
 5,565 (0.1%)  	adcq	%r10,%r14
 5,565 (0.1%)  	adcq	%rdx,%r15
 5,565 (0.1%)  	movq	%r13,%r9
 5,565 (0.1%)  	adcq	$0,%r11
     .         
 5,565 (0.1%)  	subq	$-1,%r12
 5,565 (0.1%)  	movq	%r14,%r10
 5,565 (0.1%)  	sbbq	%rsi,%r13
 5,565 (0.1%)  	sbbq	$0,%r14
 5,565 (0.1%)  	movq	%r15,%rcx
 5,565 (0.1%)  	sbbq	%rbp,%r15
 5,565 (0.1%)  	sbbq	$0,%r11
     .         
 5,565 (0.1%)  	cmovcq	%r8,%r12
 5,565 (0.1%)  	cmovcq	%r9,%r13
 5,565 (0.1%)  	movq	%r12,0(%rdi)
 5,565 (0.1%)  	cmovcq	%r10,%r14
 5,565 (0.1%)  	movq	%r13,8(%rdi)
 5,565 (0.1%)  	cmovcq	%rcx,%r15
 5,565 (0.1%)  	movq	%r14,16(%rdi)
11,130 (0.2%)  	movq	%r15,24(%rdi)
     .         
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	__ecp_nistz256_sqr_montq,.-__ecp_nistz256_sqr_montq
     .         .type	__ecp_nistz256_mul_montx,@function
     .         .align	32
     .         __ecp_nistz256_mul_montx:
     .         .cfi_startproc	
-- line 1720 ----------------------------------------
-- line 2015 ----------------------------------------
     .         
     .         
     .         .globl	ecp_nistz256_select_w5
     .         .hidden ecp_nistz256_select_w5
     .         .type	ecp_nistz256_select_w5,@function
     .         .align	32
     .         ecp_nistz256_select_w5:
     .         .cfi_startproc	
   156 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rax
   156 (0.0%)  	movq	8(%rax),%rax
   156 (0.0%)  	testl	$32,%eax
   156 (0.0%)  	jnz	.Lavx2_select_w5
     .         	movdqa	.LOne(%rip),%xmm0
     .         	movd	%edx,%xmm1
     .         
     .         	pxor	%xmm2,%xmm2
     .         	pxor	%xmm3,%xmm3
     .         	pxor	%xmm4,%xmm4
     .         	pxor	%xmm5,%xmm5
     .         	pxor	%xmm6,%xmm6
-- line 2034 ----------------------------------------
-- line 2082 ----------------------------------------
     .         
     .         
     .         .globl	ecp_nistz256_select_w7
     .         .hidden ecp_nistz256_select_w7
     .         .type	ecp_nistz256_select_w7,@function
     .         .align	32
     .         ecp_nistz256_select_w7:
     .         .cfi_startproc	
   111 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rax
   111 (0.0%)  	movq	8(%rax),%rax
   111 (0.0%)  	testl	$32,%eax
   111 (0.0%)  	jnz	.Lavx2_select_w7
     .         	movdqa	.LOne(%rip),%xmm8
     .         	movd	%edx,%xmm1
     .         
     .         	pxor	%xmm2,%xmm2
     .         	pxor	%xmm3,%xmm3
     .         	pxor	%xmm4,%xmm4
     .         	pxor	%xmm5,%xmm5
     .         
-- line 2101 ----------------------------------------
-- line 2136 ----------------------------------------
     .         .size	ecp_nistz256_select_w7,.-ecp_nistz256_select_w7
     .         
     .         
     .         .type	ecp_nistz256_avx2_select_w5,@function
     .         .align	32
     .         ecp_nistz256_avx2_select_w5:
     .         .cfi_startproc	
     .         .Lavx2_select_w5:
   156 (0.0%)  	vzeroupper
   156 (0.0%)  	vmovdqa	.LTwo(%rip),%ymm0
     .         
   156 (0.0%)  	vpxor	%ymm2,%ymm2,%ymm2
   156 (0.0%)  	vpxor	%ymm3,%ymm3,%ymm3
   156 (0.0%)  	vpxor	%ymm4,%ymm4,%ymm4
     .         
   156 (0.0%)  	vmovdqa	.LOne(%rip),%ymm5
   156 (0.0%)  	vmovdqa	.LTwo(%rip),%ymm10
     .         
   156 (0.0%)  	vmovd	%edx,%xmm1
   156 (0.0%)  	vpermd	%ymm1,%ymm2,%ymm1
     .         
   156 (0.0%)  	movq	$8,%rax
     .         .Lselect_loop_avx2_w5:
     .         
 1,248 (0.0%)  	vmovdqa	0(%rsi),%ymm6
 1,248 (0.0%)  	vmovdqa	32(%rsi),%ymm7
 1,248 (0.0%)  	vmovdqa	64(%rsi),%ymm8
     .         
 1,248 (0.0%)  	vmovdqa	96(%rsi),%ymm11
 1,248 (0.0%)  	vmovdqa	128(%rsi),%ymm12
 1,248 (0.0%)  	vmovdqa	160(%rsi),%ymm13
     .         
 1,248 (0.0%)  	vpcmpeqd	%ymm1,%ymm5,%ymm9
 1,248 (0.0%)  	vpcmpeqd	%ymm1,%ymm10,%ymm14
     .         
 1,248 (0.0%)  	vpaddd	%ymm0,%ymm5,%ymm5
 1,248 (0.0%)  	vpaddd	%ymm0,%ymm10,%ymm10
 1,248 (0.0%)  	leaq	192(%rsi),%rsi
     .         
 1,248 (0.0%)  	vpand	%ymm9,%ymm6,%ymm6
 1,248 (0.0%)  	vpand	%ymm9,%ymm7,%ymm7
 1,248 (0.0%)  	vpand	%ymm9,%ymm8,%ymm8
 1,248 (0.0%)  	vpand	%ymm14,%ymm11,%ymm11
 1,248 (0.0%)  	vpand	%ymm14,%ymm12,%ymm12
 1,248 (0.0%)  	vpand	%ymm14,%ymm13,%ymm13
     .         
 1,248 (0.0%)  	vpxor	%ymm6,%ymm2,%ymm2
 1,248 (0.0%)  	vpxor	%ymm7,%ymm3,%ymm3
 1,248 (0.0%)  	vpxor	%ymm8,%ymm4,%ymm4
 1,248 (0.0%)  	vpxor	%ymm11,%ymm2,%ymm2
 1,248 (0.0%)  	vpxor	%ymm12,%ymm3,%ymm3
 1,248 (0.0%)  	vpxor	%ymm13,%ymm4,%ymm4
     .         
 1,248 (0.0%)  	decq	%rax
 1,248 (0.0%)  	jnz	.Lselect_loop_avx2_w5
     .         
   156 (0.0%)  	vmovdqu	%ymm2,0(%rdi)
   156 (0.0%)  	vmovdqu	%ymm3,32(%rdi)
   156 (0.0%)  	vmovdqu	%ymm4,64(%rdi)
   312 (0.0%)  	vzeroupper
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .LSEH_end_ecp_nistz256_avx2_select_w5:
     .         .size	ecp_nistz256_avx2_select_w5,.-ecp_nistz256_avx2_select_w5
     .         
     .         
     .         
     .         .globl	ecp_nistz256_avx2_select_w7
     .         .hidden ecp_nistz256_avx2_select_w7
     .         .type	ecp_nistz256_avx2_select_w7,@function
     .         .align	32
     .         ecp_nistz256_avx2_select_w7:
     .         .cfi_startproc	
     .         .Lavx2_select_w7:
   111 (0.0%)  	vzeroupper
   111 (0.0%)  	vmovdqa	.LThree(%rip),%ymm0
     .         
   111 (0.0%)  	vpxor	%ymm2,%ymm2,%ymm2
   111 (0.0%)  	vpxor	%ymm3,%ymm3,%ymm3
     .         
   111 (0.0%)  	vmovdqa	.LOne(%rip),%ymm4
   111 (0.0%)  	vmovdqa	.LTwo(%rip),%ymm8
   111 (0.0%)  	vmovdqa	.LThree(%rip),%ymm12
     .         
   111 (0.0%)  	vmovd	%edx,%xmm1
   111 (0.0%)  	vpermd	%ymm1,%ymm2,%ymm1
     .         
     .         
   111 (0.0%)  	movq	$21,%rax
     .         .Lselect_loop_avx2_w7:
     .         
 2,331 (0.0%)  	vmovdqa	0(%rsi),%ymm5
 2,331 (0.0%)  	vmovdqa	32(%rsi),%ymm6
     .         
 2,331 (0.0%)  	vmovdqa	64(%rsi),%ymm9
 2,331 (0.0%)  	vmovdqa	96(%rsi),%ymm10
     .         
 2,331 (0.0%)  	vmovdqa	128(%rsi),%ymm13
 2,331 (0.0%)  	vmovdqa	160(%rsi),%ymm14
     .         
 2,331 (0.0%)  	vpcmpeqd	%ymm1,%ymm4,%ymm7
 2,331 (0.0%)  	vpcmpeqd	%ymm1,%ymm8,%ymm11
 2,331 (0.0%)  	vpcmpeqd	%ymm1,%ymm12,%ymm15
     .         
 2,331 (0.0%)  	vpaddd	%ymm0,%ymm4,%ymm4
 2,331 (0.0%)  	vpaddd	%ymm0,%ymm8,%ymm8
 2,331 (0.0%)  	vpaddd	%ymm0,%ymm12,%ymm12
 2,331 (0.0%)  	leaq	192(%rsi),%rsi
     .         
 2,331 (0.0%)  	vpand	%ymm7,%ymm5,%ymm5
 2,331 (0.0%)  	vpand	%ymm7,%ymm6,%ymm6
 2,331 (0.0%)  	vpand	%ymm11,%ymm9,%ymm9
 2,331 (0.0%)  	vpand	%ymm11,%ymm10,%ymm10
 2,331 (0.0%)  	vpand	%ymm15,%ymm13,%ymm13
 2,331 (0.0%)  	vpand	%ymm15,%ymm14,%ymm14
     .         
 2,331 (0.0%)  	vpxor	%ymm5,%ymm2,%ymm2
 2,331 (0.0%)  	vpxor	%ymm6,%ymm3,%ymm3
 2,331 (0.0%)  	vpxor	%ymm9,%ymm2,%ymm2
 2,331 (0.0%)  	vpxor	%ymm10,%ymm3,%ymm3
 2,331 (0.0%)  	vpxor	%ymm13,%ymm2,%ymm2
 2,331 (0.0%)  	vpxor	%ymm14,%ymm3,%ymm3
     .         
 2,331 (0.0%)  	decq	%rax
 2,331 (0.0%)  	jnz	.Lselect_loop_avx2_w7
     .         
     .         
   111 (0.0%)  	vmovdqa	0(%rsi),%ymm5
   111 (0.0%)  	vmovdqa	32(%rsi),%ymm6
     .         
   111 (0.0%)  	vpcmpeqd	%ymm1,%ymm4,%ymm7
     .         
   111 (0.0%)  	vpand	%ymm7,%ymm5,%ymm5
   111 (0.0%)  	vpand	%ymm7,%ymm6,%ymm6
     .         
   111 (0.0%)  	vpxor	%ymm5,%ymm2,%ymm2
   111 (0.0%)  	vpxor	%ymm6,%ymm3,%ymm3
     .         
   111 (0.0%)  	vmovdqu	%ymm2,0(%rdi)
   111 (0.0%)  	vmovdqu	%ymm3,32(%rdi)
   222 (0.0%)  	vzeroupper
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .LSEH_end_ecp_nistz256_avx2_select_w7:
     .         .size	ecp_nistz256_avx2_select_w7,.-ecp_nistz256_avx2_select_w7
     .         .type	__ecp_nistz256_add_toq,@function
     .         .align	32
     .         __ecp_nistz256_add_toq:
     .         .cfi_startproc	
 1,578 (0.0%)  	xorq	%r11,%r11
 1,578 (0.0%)  	addq	0(%rbx),%r12
 1,578 (0.0%)  	adcq	8(%rbx),%r13
 1,578 (0.0%)  	movq	%r12,%rax
 1,578 (0.0%)  	adcq	16(%rbx),%r8
 1,578 (0.0%)  	adcq	24(%rbx),%r9
 1,578 (0.0%)  	movq	%r13,%rbp
 1,578 (0.0%)  	adcq	$0,%r11
     .         
 1,578 (0.0%)  	subq	$-1,%r12
 1,578 (0.0%)  	movq	%r8,%rcx
 1,578 (0.0%)  	sbbq	%r14,%r13
 1,578 (0.0%)  	sbbq	$0,%r8
 1,578 (0.0%)  	movq	%r9,%r10
 1,578 (0.0%)  	sbbq	%r15,%r9
 1,578 (0.0%)  	sbbq	$0,%r11
     .         
 1,578 (0.0%)  	cmovcq	%rax,%r12
 1,578 (0.0%)  	cmovcq	%rbp,%r13
 1,578 (0.0%)  	movq	%r12,0(%rdi)
 1,578 (0.0%)  	cmovcq	%rcx,%r8
 1,578 (0.0%)  	movq	%r13,8(%rdi)
 1,578 (0.0%)  	cmovcq	%r10,%r9
 1,578 (0.0%)  	movq	%r8,16(%rdi)
 3,156 (0.1%)  	movq	%r9,24(%rdi)
     .         
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	__ecp_nistz256_add_toq,.-__ecp_nistz256_add_toq
     .         
     .         .type	__ecp_nistz256_sub_fromq,@function
     .         .align	32
     .         __ecp_nistz256_sub_fromq:
     .         .cfi_startproc	
 3,643 (0.1%)  	subq	0(%rbx),%r12
 3,643 (0.1%)  	sbbq	8(%rbx),%r13
 3,643 (0.1%)  	movq	%r12,%rax
 3,643 (0.1%)  	sbbq	16(%rbx),%r8
 3,643 (0.1%)  	sbbq	24(%rbx),%r9
 3,643 (0.1%)  	movq	%r13,%rbp
 3,643 (0.1%)  	sbbq	%r11,%r11
     .         
 3,643 (0.1%)  	addq	$-1,%r12
 3,643 (0.1%)  	movq	%r8,%rcx
 3,643 (0.1%)  	adcq	%r14,%r13
 3,643 (0.1%)  	adcq	$0,%r8
 3,643 (0.1%)  	movq	%r9,%r10
 3,643 (0.1%)  	adcq	%r15,%r9
 3,643 (0.1%)  	testq	%r11,%r11
     .         
 3,643 (0.1%)  	cmovzq	%rax,%r12
 3,643 (0.1%)  	cmovzq	%rbp,%r13
 3,643 (0.1%)  	movq	%r12,0(%rdi)
 3,643 (0.1%)  	cmovzq	%rcx,%r8
 3,643 (0.1%)  	movq	%r13,8(%rdi)
 3,643 (0.1%)  	cmovzq	%r10,%r9
 3,643 (0.1%)  	movq	%r8,16(%rdi)
 7,286 (0.1%)  	movq	%r9,24(%rdi)
     .         
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	__ecp_nistz256_sub_fromq,.-__ecp_nistz256_sub_fromq
     .         
     .         .type	__ecp_nistz256_subq,@function
     .         .align	32
     .         __ecp_nistz256_subq:
     .         .cfi_startproc	
 1,427 (0.0%)  	subq	%r12,%rax
 1,427 (0.0%)  	sbbq	%r13,%rbp
 1,427 (0.0%)  	movq	%rax,%r12
 1,427 (0.0%)  	sbbq	%r8,%rcx
 1,427 (0.0%)  	sbbq	%r9,%r10
 1,427 (0.0%)  	movq	%rbp,%r13
 1,427 (0.0%)  	sbbq	%r11,%r11
     .         
 1,427 (0.0%)  	addq	$-1,%rax
 1,427 (0.0%)  	movq	%rcx,%r8
 1,427 (0.0%)  	adcq	%r14,%rbp
 1,427 (0.0%)  	adcq	$0,%rcx
 1,427 (0.0%)  	movq	%r10,%r9
 1,427 (0.0%)  	adcq	%r15,%r10
 1,427 (0.0%)  	testq	%r11,%r11
     .         
 1,427 (0.0%)  	cmovnzq	%rax,%r12
 1,427 (0.0%)  	cmovnzq	%rbp,%r13
 1,427 (0.0%)  	cmovnzq	%rcx,%r8
 2,854 (0.0%)  	cmovnzq	%r10,%r9
     .         
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	__ecp_nistz256_subq,.-__ecp_nistz256_subq
     .         
     .         .type	__ecp_nistz256_mul_by_2q,@function
     .         .align	32
     .         __ecp_nistz256_mul_by_2q:
     .         .cfi_startproc	
 3,156 (0.1%)  	xorq	%r11,%r11
 3,156 (0.1%)  	addq	%r12,%r12
 3,156 (0.1%)  	adcq	%r13,%r13
 3,156 (0.1%)  	movq	%r12,%rax
 3,156 (0.1%)  	adcq	%r8,%r8
 3,156 (0.1%)  	adcq	%r9,%r9
 3,156 (0.1%)  	movq	%r13,%rbp
 3,156 (0.1%)  	adcq	$0,%r11
     .         
 3,156 (0.1%)  	subq	$-1,%r12
 3,156 (0.1%)  	movq	%r8,%rcx
 3,156 (0.1%)  	sbbq	%r14,%r13
 3,156 (0.1%)  	sbbq	$0,%r8
 3,156 (0.1%)  	movq	%r9,%r10
 3,156 (0.1%)  	sbbq	%r15,%r9
 3,156 (0.1%)  	sbbq	$0,%r11
     .         
 3,156 (0.1%)  	cmovcq	%rax,%r12
 3,156 (0.1%)  	cmovcq	%rbp,%r13
 3,156 (0.1%)  	movq	%r12,0(%rdi)
 3,156 (0.1%)  	cmovcq	%rcx,%r8
 3,156 (0.1%)  	movq	%r13,8(%rdi)
 3,156 (0.1%)  	cmovcq	%r10,%r9
 3,156 (0.1%)  	movq	%r8,16(%rdi)
 6,312 (0.1%)  	movq	%r9,24(%rdi)
     .         
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	__ecp_nistz256_mul_by_2q,.-__ecp_nistz256_mul_by_2q
     .         .globl	ecp_nistz256_point_double
     .         .hidden ecp_nistz256_point_double
     .         .type	ecp_nistz256_point_double,@function
     .         .align	32
     .         ecp_nistz256_point_double:
     .         .cfi_startproc	
   789 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
   789 (0.0%)  	movq	8(%rcx),%rcx
   789 (0.0%)  	andl	$0x80100,%ecx
   789 (0.0%)  	cmpl	$0x80100,%ecx
   789 (0.0%)  	je	.Lpoint_doublex
   789 (0.0%)  	pushq	%rbp
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%rbp,-16
   789 (0.0%)  	pushq	%rbx
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%rbx,-24
   789 (0.0%)  	pushq	%r12
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r12,-32
   789 (0.0%)  	pushq	%r13
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r13,-40
   789 (0.0%)  	pushq	%r14
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r14,-48
   789 (0.0%)  	pushq	%r15
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r15,-56
   789 (0.0%)  	subq	$160+8,%rsp
     .         .cfi_adjust_cfa_offset	32*5+8
     .         .Lpoint_doubleq_body:
     .         
     .         .Lpoint_double_shortcutq:
   789 (0.0%)  	movdqu	0(%rsi),%xmm0
   789 (0.0%)  	movq	%rsi,%rbx
   789 (0.0%)  	movdqu	16(%rsi),%xmm1
   789 (0.0%)  	movq	32+0(%rsi),%r12
   789 (0.0%)  	movq	32+8(%rsi),%r13
   789 (0.0%)  	movq	32+16(%rsi),%r8
   789 (0.0%)  	movq	32+24(%rsi),%r9
   789 (0.0%)  	movq	.Lpoly+8(%rip),%r14
   789 (0.0%)  	movq	.Lpoly+24(%rip),%r15
   789 (0.0%)  	movdqa	%xmm0,96(%rsp)
   789 (0.0%)  	movdqa	%xmm1,96+16(%rsp)
   789 (0.0%)  	leaq	32(%rdi),%r10
 3,156 (0.1%)  	leaq	64(%rdi),%r11
     .         .byte	102,72,15,110,199
     .         .byte	102,73,15,110,202
     .         .byte	102,73,15,110,211
     .         
   789 (0.0%)  	leaq	0(%rsp),%rdi
   789 (0.0%)  	call	__ecp_nistz256_mul_by_2q
     .         
   789 (0.0%)  	movq	64+0(%rsi),%rax
   789 (0.0%)  	movq	64+8(%rsi),%r14
   789 (0.0%)  	movq	64+16(%rsi),%r15
   789 (0.0%)  	movq	64+24(%rsi),%r8
   789 (0.0%)  	leaq	64-0(%rsi),%rsi
   789 (0.0%)  	leaq	64(%rsp),%rdi
   789 (0.0%)  	call	__ecp_nistz256_sqr_montq
     .         
   789 (0.0%)  	movq	0+0(%rsp),%rax
   789 (0.0%)  	movq	8+0(%rsp),%r14
   789 (0.0%)  	leaq	0+0(%rsp),%rsi
   789 (0.0%)  	movq	16+0(%rsp),%r15
   789 (0.0%)  	movq	24+0(%rsp),%r8
   789 (0.0%)  	leaq	0(%rsp),%rdi
   789 (0.0%)  	call	__ecp_nistz256_sqr_montq
     .         
   789 (0.0%)  	movq	32(%rbx),%rax
   789 (0.0%)  	movq	64+0(%rbx),%r9
   789 (0.0%)  	movq	64+8(%rbx),%r10
   789 (0.0%)  	movq	64+16(%rbx),%r11
   789 (0.0%)  	movq	64+24(%rbx),%r12
   789 (0.0%)  	leaq	64-0(%rbx),%rsi
 1,578 (0.0%)  	leaq	32(%rbx),%rbx
     .         .byte	102,72,15,126,215
   789 (0.0%)  	call	__ecp_nistz256_mul_montq
   789 (0.0%)  	call	__ecp_nistz256_mul_by_2q
     .         
   789 (0.0%)  	movq	96+0(%rsp),%r12
   789 (0.0%)  	movq	96+8(%rsp),%r13
   789 (0.0%)  	leaq	64(%rsp),%rbx
   789 (0.0%)  	movq	96+16(%rsp),%r8
   789 (0.0%)  	movq	96+24(%rsp),%r9
   789 (0.0%)  	leaq	32(%rsp),%rdi
   789 (0.0%)  	call	__ecp_nistz256_add_toq
     .         
   789 (0.0%)  	movq	96+0(%rsp),%r12
   789 (0.0%)  	movq	96+8(%rsp),%r13
   789 (0.0%)  	leaq	64(%rsp),%rbx
   789 (0.0%)  	movq	96+16(%rsp),%r8
   789 (0.0%)  	movq	96+24(%rsp),%r9
   789 (0.0%)  	leaq	64(%rsp),%rdi
   789 (0.0%)  	call	__ecp_nistz256_sub_fromq
     .         
   789 (0.0%)  	movq	0+0(%rsp),%rax
   789 (0.0%)  	movq	8+0(%rsp),%r14
   789 (0.0%)  	leaq	0+0(%rsp),%rsi
   789 (0.0%)  	movq	16+0(%rsp),%r15
 1,578 (0.0%)  	movq	24+0(%rsp),%r8
     .         .byte	102,72,15,126,207
   789 (0.0%)  	call	__ecp_nistz256_sqr_montq
   789 (0.0%)  	xorq	%r9,%r9
   789 (0.0%)  	movq	%r12,%rax
   789 (0.0%)  	addq	$-1,%r12
   789 (0.0%)  	movq	%r13,%r10
   789 (0.0%)  	adcq	%rsi,%r13
   789 (0.0%)  	movq	%r14,%rcx
   789 (0.0%)  	adcq	$0,%r14
   789 (0.0%)  	movq	%r15,%r8
   789 (0.0%)  	adcq	%rbp,%r15
   789 (0.0%)  	adcq	$0,%r9
   789 (0.0%)  	xorq	%rsi,%rsi
   789 (0.0%)  	testq	$1,%rax
     .         
   789 (0.0%)  	cmovzq	%rax,%r12
   789 (0.0%)  	cmovzq	%r10,%r13
   789 (0.0%)  	cmovzq	%rcx,%r14
   789 (0.0%)  	cmovzq	%r8,%r15
   789 (0.0%)  	cmovzq	%rsi,%r9
     .         
   789 (0.0%)  	movq	%r13,%rax
   789 (0.0%)  	shrq	$1,%r12
   789 (0.0%)  	shlq	$63,%rax
   789 (0.0%)  	movq	%r14,%r10
   789 (0.0%)  	shrq	$1,%r13
   789 (0.0%)  	orq	%rax,%r12
   789 (0.0%)  	shlq	$63,%r10
   789 (0.0%)  	movq	%r15,%rcx
   789 (0.0%)  	shrq	$1,%r14
   789 (0.0%)  	orq	%r10,%r13
   789 (0.0%)  	shlq	$63,%rcx
   789 (0.0%)  	movq	%r12,0(%rdi)
   789 (0.0%)  	shrq	$1,%r15
   789 (0.0%)  	movq	%r13,8(%rdi)
   789 (0.0%)  	shlq	$63,%r9
   789 (0.0%)  	orq	%rcx,%r14
   789 (0.0%)  	orq	%r9,%r15
   789 (0.0%)  	movq	%r14,16(%rdi)
   789 (0.0%)  	movq	%r15,24(%rdi)
   789 (0.0%)  	movq	64(%rsp),%rax
   789 (0.0%)  	leaq	64(%rsp),%rbx
   789 (0.0%)  	movq	0+32(%rsp),%r9
   789 (0.0%)  	movq	8+32(%rsp),%r10
   789 (0.0%)  	leaq	0+32(%rsp),%rsi
   789 (0.0%)  	movq	16+32(%rsp),%r11
   789 (0.0%)  	movq	24+32(%rsp),%r12
   789 (0.0%)  	leaq	32(%rsp),%rdi
   789 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   789 (0.0%)  	leaq	128(%rsp),%rdi
   789 (0.0%)  	call	__ecp_nistz256_mul_by_2q
     .         
   789 (0.0%)  	leaq	32(%rsp),%rbx
   789 (0.0%)  	leaq	32(%rsp),%rdi
   789 (0.0%)  	call	__ecp_nistz256_add_toq
     .         
   789 (0.0%)  	movq	96(%rsp),%rax
   789 (0.0%)  	leaq	96(%rsp),%rbx
   789 (0.0%)  	movq	0+0(%rsp),%r9
   789 (0.0%)  	movq	8+0(%rsp),%r10
   789 (0.0%)  	leaq	0+0(%rsp),%rsi
   789 (0.0%)  	movq	16+0(%rsp),%r11
   789 (0.0%)  	movq	24+0(%rsp),%r12
   789 (0.0%)  	leaq	0(%rsp),%rdi
   789 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   789 (0.0%)  	leaq	128(%rsp),%rdi
   789 (0.0%)  	call	__ecp_nistz256_mul_by_2q
     .         
   789 (0.0%)  	movq	0+32(%rsp),%rax
   789 (0.0%)  	movq	8+32(%rsp),%r14
   789 (0.0%)  	leaq	0+32(%rsp),%rsi
   789 (0.0%)  	movq	16+32(%rsp),%r15
 1,578 (0.0%)  	movq	24+32(%rsp),%r8
     .         .byte	102,72,15,126,199
   789 (0.0%)  	call	__ecp_nistz256_sqr_montq
     .         
   789 (0.0%)  	leaq	128(%rsp),%rbx
   789 (0.0%)  	movq	%r14,%r8
   789 (0.0%)  	movq	%r15,%r9
   789 (0.0%)  	movq	%rsi,%r14
   789 (0.0%)  	movq	%rbp,%r15
   789 (0.0%)  	call	__ecp_nistz256_sub_fromq
     .         
   789 (0.0%)  	movq	0+0(%rsp),%rax
   789 (0.0%)  	movq	0+8(%rsp),%rbp
   789 (0.0%)  	movq	0+16(%rsp),%rcx
   789 (0.0%)  	movq	0+24(%rsp),%r10
   789 (0.0%)  	leaq	0(%rsp),%rdi
   789 (0.0%)  	call	__ecp_nistz256_subq
     .         
   789 (0.0%)  	movq	32(%rsp),%rax
   789 (0.0%)  	leaq	32(%rsp),%rbx
   789 (0.0%)  	movq	%r12,%r14
   789 (0.0%)  	xorl	%ecx,%ecx
   789 (0.0%)  	movq	%r12,0+0(%rsp)
   789 (0.0%)  	movq	%r13,%r10
   789 (0.0%)  	movq	%r13,0+8(%rsp)
   789 (0.0%)  	cmovzq	%r8,%r11
   789 (0.0%)  	movq	%r8,0+16(%rsp)
   789 (0.0%)  	leaq	0-0(%rsp),%rsi
   789 (0.0%)  	cmovzq	%r9,%r12
   789 (0.0%)  	movq	%r9,0+24(%rsp)
   789 (0.0%)  	movq	%r14,%r9
   789 (0.0%)  	leaq	0(%rsp),%rdi
 2,367 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
     .         .byte	102,72,15,126,203
     .         .byte	102,72,15,126,207
   789 (0.0%)  	call	__ecp_nistz256_sub_fromq
     .         
   789 (0.0%)  	leaq	160+56(%rsp),%rsi
     .         .cfi_def_cfa	%rsi,8
   789 (0.0%)  	movq	-48(%rsi),%r15
     .         .cfi_restore	%r15
   789 (0.0%)  	movq	-40(%rsi),%r14
     .         .cfi_restore	%r14
   789 (0.0%)  	movq	-32(%rsi),%r13
     .         .cfi_restore	%r13
   789 (0.0%)  	movq	-24(%rsi),%r12
     .         .cfi_restore	%r12
   789 (0.0%)  	movq	-16(%rsi),%rbx
     .         .cfi_restore	%rbx
   789 (0.0%)  	movq	-8(%rsi),%rbp
     .         .cfi_restore	%rbp
 1,578 (0.0%)  	leaq	(%rsi),%rsp
     .         .cfi_def_cfa_register	%rsp
     .         .Lpoint_doubleq_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	ecp_nistz256_point_double,.-ecp_nistz256_point_double
     .         .globl	ecp_nistz256_point_add
     .         .hidden ecp_nistz256_point_add
     .         .type	ecp_nistz256_point_add,@function
     .         .align	32
     .         ecp_nistz256_point_add:
     .         .cfi_startproc	
   175 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
   175 (0.0%)  	movq	8(%rcx),%rcx
   175 (0.0%)  	andl	$0x80100,%ecx
   175 (0.0%)  	cmpl	$0x80100,%ecx
   175 (0.0%)  	je	.Lpoint_addx
   175 (0.0%)  	pushq	%rbp
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%rbp,-16
   175 (0.0%)  	pushq	%rbx
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%rbx,-24
   175 (0.0%)  	pushq	%r12
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r12,-32
   175 (0.0%)  	pushq	%r13
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r13,-40
   175 (0.0%)  	pushq	%r14
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r14,-48
   175 (0.0%)  	pushq	%r15
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r15,-56
   175 (0.0%)  	subq	$576+8,%rsp
     .         .cfi_adjust_cfa_offset	32*18+8
     .         .Lpoint_addq_body:
     .         
   175 (0.0%)  	movdqu	0(%rsi),%xmm0
   175 (0.0%)  	movdqu	16(%rsi),%xmm1
   175 (0.0%)  	movdqu	32(%rsi),%xmm2
   175 (0.0%)  	movdqu	48(%rsi),%xmm3
   175 (0.0%)  	movdqu	64(%rsi),%xmm4
   175 (0.0%)  	movdqu	80(%rsi),%xmm5
   175 (0.0%)  	movq	%rsi,%rbx
   175 (0.0%)  	movq	%rdx,%rsi
   175 (0.0%)  	movdqa	%xmm0,384(%rsp)
   175 (0.0%)  	movdqa	%xmm1,384+16(%rsp)
   175 (0.0%)  	movdqa	%xmm2,416(%rsp)
   175 (0.0%)  	movdqa	%xmm3,416+16(%rsp)
   175 (0.0%)  	movdqa	%xmm4,448(%rsp)
   175 (0.0%)  	movdqa	%xmm5,448+16(%rsp)
   175 (0.0%)  	por	%xmm4,%xmm5
     .         
   175 (0.0%)  	movdqu	0(%rsi),%xmm0
   175 (0.0%)  	pshufd	$0xb1,%xmm5,%xmm3
   175 (0.0%)  	movdqu	16(%rsi),%xmm1
   175 (0.0%)  	movdqu	32(%rsi),%xmm2
   175 (0.0%)  	por	%xmm3,%xmm5
   175 (0.0%)  	movdqu	48(%rsi),%xmm3
   175 (0.0%)  	movq	64+0(%rsi),%rax
   175 (0.0%)  	movq	64+8(%rsi),%r14
   175 (0.0%)  	movq	64+16(%rsi),%r15
   175 (0.0%)  	movq	64+24(%rsi),%r8
   175 (0.0%)  	movdqa	%xmm0,480(%rsp)
   175 (0.0%)  	pshufd	$0x1e,%xmm5,%xmm4
   175 (0.0%)  	movdqa	%xmm1,480+16(%rsp)
   175 (0.0%)  	movdqu	64(%rsi),%xmm0
   175 (0.0%)  	movdqu	80(%rsi),%xmm1
   175 (0.0%)  	movdqa	%xmm2,512(%rsp)
   175 (0.0%)  	movdqa	%xmm3,512+16(%rsp)
   175 (0.0%)  	por	%xmm4,%xmm5
   175 (0.0%)  	pxor	%xmm4,%xmm4
   350 (0.0%)  	por	%xmm0,%xmm1
     .         .byte	102,72,15,110,199
     .         
   175 (0.0%)  	leaq	64-0(%rsi),%rsi
   175 (0.0%)  	movq	%rax,544+0(%rsp)
   175 (0.0%)  	movq	%r14,544+8(%rsp)
   175 (0.0%)  	movq	%r15,544+16(%rsp)
   175 (0.0%)  	movq	%r8,544+24(%rsp)
   175 (0.0%)  	leaq	96(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_sqr_montq
     .         
   175 (0.0%)  	pcmpeqd	%xmm4,%xmm5
   175 (0.0%)  	pshufd	$0xb1,%xmm1,%xmm4
   175 (0.0%)  	por	%xmm1,%xmm4
   175 (0.0%)  	pshufd	$0,%xmm5,%xmm5
   175 (0.0%)  	pshufd	$0x1e,%xmm4,%xmm3
   175 (0.0%)  	por	%xmm3,%xmm4
   175 (0.0%)  	pxor	%xmm3,%xmm3
   175 (0.0%)  	pcmpeqd	%xmm3,%xmm4
   175 (0.0%)  	pshufd	$0,%xmm4,%xmm4
   175 (0.0%)  	movq	64+0(%rbx),%rax
   175 (0.0%)  	movq	64+8(%rbx),%r14
   175 (0.0%)  	movq	64+16(%rbx),%r15
   350 (0.0%)  	movq	64+24(%rbx),%r8
     .         .byte	102,72,15,110,203
     .         
   175 (0.0%)  	leaq	64-0(%rbx),%rsi
   175 (0.0%)  	leaq	32(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_sqr_montq
     .         
   175 (0.0%)  	movq	544(%rsp),%rax
   175 (0.0%)  	leaq	544(%rsp),%rbx
   175 (0.0%)  	movq	0+96(%rsp),%r9
   175 (0.0%)  	movq	8+96(%rsp),%r10
   175 (0.0%)  	leaq	0+96(%rsp),%rsi
   175 (0.0%)  	movq	16+96(%rsp),%r11
   175 (0.0%)  	movq	24+96(%rsp),%r12
   175 (0.0%)  	leaq	224(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   175 (0.0%)  	movq	448(%rsp),%rax
   175 (0.0%)  	leaq	448(%rsp),%rbx
   175 (0.0%)  	movq	0+32(%rsp),%r9
   175 (0.0%)  	movq	8+32(%rsp),%r10
   175 (0.0%)  	leaq	0+32(%rsp),%rsi
   175 (0.0%)  	movq	16+32(%rsp),%r11
   175 (0.0%)  	movq	24+32(%rsp),%r12
   175 (0.0%)  	leaq	256(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   175 (0.0%)  	movq	416(%rsp),%rax
   175 (0.0%)  	leaq	416(%rsp),%rbx
   175 (0.0%)  	movq	0+224(%rsp),%r9
   175 (0.0%)  	movq	8+224(%rsp),%r10
   175 (0.0%)  	leaq	0+224(%rsp),%rsi
   175 (0.0%)  	movq	16+224(%rsp),%r11
   175 (0.0%)  	movq	24+224(%rsp),%r12
   175 (0.0%)  	leaq	224(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   175 (0.0%)  	movq	512(%rsp),%rax
   175 (0.0%)  	leaq	512(%rsp),%rbx
   175 (0.0%)  	movq	0+256(%rsp),%r9
   175 (0.0%)  	movq	8+256(%rsp),%r10
   175 (0.0%)  	leaq	0+256(%rsp),%rsi
   175 (0.0%)  	movq	16+256(%rsp),%r11
   175 (0.0%)  	movq	24+256(%rsp),%r12
   175 (0.0%)  	leaq	256(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   175 (0.0%)  	leaq	224(%rsp),%rbx
   175 (0.0%)  	leaq	64(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_sub_fromq
     .         
   175 (0.0%)  	orq	%r13,%r12
   175 (0.0%)  	movdqa	%xmm4,%xmm2
   175 (0.0%)  	orq	%r8,%r12
   175 (0.0%)  	orq	%r9,%r12
   350 (0.0%)  	por	%xmm5,%xmm2
     .         .byte	102,73,15,110,220
     .         
   175 (0.0%)  	movq	384(%rsp),%rax
   175 (0.0%)  	leaq	384(%rsp),%rbx
   175 (0.0%)  	movq	0+96(%rsp),%r9
   175 (0.0%)  	movq	8+96(%rsp),%r10
   175 (0.0%)  	leaq	0+96(%rsp),%rsi
   175 (0.0%)  	movq	16+96(%rsp),%r11
   175 (0.0%)  	movq	24+96(%rsp),%r12
   175 (0.0%)  	leaq	160(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   175 (0.0%)  	movq	480(%rsp),%rax
   175 (0.0%)  	leaq	480(%rsp),%rbx
   175 (0.0%)  	movq	0+32(%rsp),%r9
   175 (0.0%)  	movq	8+32(%rsp),%r10
   175 (0.0%)  	leaq	0+32(%rsp),%rsi
   175 (0.0%)  	movq	16+32(%rsp),%r11
   175 (0.0%)  	movq	24+32(%rsp),%r12
   175 (0.0%)  	leaq	192(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   175 (0.0%)  	leaq	160(%rsp),%rbx
   175 (0.0%)  	leaq	0(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_sub_fromq
     .         
   175 (0.0%)  	orq	%r13,%r12
   175 (0.0%)  	orq	%r8,%r12
   525 (0.0%)  	orq	%r9,%r12
     .         
     .         .byte	102,73,15,126,208
     .         .byte	102,73,15,126,217
   350 (0.0%)  	orq	%r8,%r12
     .         .byte	0x3e
     .         	jnz	.Ladd_proceedq
     .         
     .         
     .         
     .         	testq	%r9,%r9
     .         	jz	.Ladd_doubleq
     .         
-- line 2831 ----------------------------------------
-- line 2850 ----------------------------------------
     .         .byte	102,72,15,126,199
     .         	addq	$416,%rsp
     .         .cfi_adjust_cfa_offset	-416
     .         	jmp	.Lpoint_double_shortcutq
     .         .cfi_adjust_cfa_offset	416
     .         
     .         .align	32
     .         .Ladd_proceedq:
   175 (0.0%)  	movq	0+64(%rsp),%rax
   175 (0.0%)  	movq	8+64(%rsp),%r14
   175 (0.0%)  	leaq	0+64(%rsp),%rsi
   175 (0.0%)  	movq	16+64(%rsp),%r15
   175 (0.0%)  	movq	24+64(%rsp),%r8
   175 (0.0%)  	leaq	96(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_sqr_montq
     .         
   175 (0.0%)  	movq	448(%rsp),%rax
   175 (0.0%)  	leaq	448(%rsp),%rbx
   175 (0.0%)  	movq	0+0(%rsp),%r9
   175 (0.0%)  	movq	8+0(%rsp),%r10
   175 (0.0%)  	leaq	0+0(%rsp),%rsi
   175 (0.0%)  	movq	16+0(%rsp),%r11
   175 (0.0%)  	movq	24+0(%rsp),%r12
   175 (0.0%)  	leaq	352(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   175 (0.0%)  	movq	0+0(%rsp),%rax
   175 (0.0%)  	movq	8+0(%rsp),%r14
   175 (0.0%)  	leaq	0+0(%rsp),%rsi
   175 (0.0%)  	movq	16+0(%rsp),%r15
   175 (0.0%)  	movq	24+0(%rsp),%r8
   175 (0.0%)  	leaq	32(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_sqr_montq
     .         
   175 (0.0%)  	movq	544(%rsp),%rax
   175 (0.0%)  	leaq	544(%rsp),%rbx
   175 (0.0%)  	movq	0+352(%rsp),%r9
   175 (0.0%)  	movq	8+352(%rsp),%r10
   175 (0.0%)  	leaq	0+352(%rsp),%rsi
   175 (0.0%)  	movq	16+352(%rsp),%r11
   175 (0.0%)  	movq	24+352(%rsp),%r12
   175 (0.0%)  	leaq	352(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   175 (0.0%)  	movq	0(%rsp),%rax
   175 (0.0%)  	leaq	0(%rsp),%rbx
   175 (0.0%)  	movq	0+32(%rsp),%r9
   175 (0.0%)  	movq	8+32(%rsp),%r10
   175 (0.0%)  	leaq	0+32(%rsp),%rsi
   175 (0.0%)  	movq	16+32(%rsp),%r11
   175 (0.0%)  	movq	24+32(%rsp),%r12
   175 (0.0%)  	leaq	128(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   175 (0.0%)  	movq	160(%rsp),%rax
   175 (0.0%)  	leaq	160(%rsp),%rbx
   175 (0.0%)  	movq	0+32(%rsp),%r9
   175 (0.0%)  	movq	8+32(%rsp),%r10
   175 (0.0%)  	leaq	0+32(%rsp),%rsi
   175 (0.0%)  	movq	16+32(%rsp),%r11
   175 (0.0%)  	movq	24+32(%rsp),%r12
   175 (0.0%)  	leaq	192(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
     .         
     .         
     .         
   175 (0.0%)  	xorq	%r11,%r11
   175 (0.0%)  	addq	%r12,%r12
   175 (0.0%)  	leaq	96(%rsp),%rsi
   175 (0.0%)  	adcq	%r13,%r13
   175 (0.0%)  	movq	%r12,%rax
   175 (0.0%)  	adcq	%r8,%r8
   175 (0.0%)  	adcq	%r9,%r9
   175 (0.0%)  	movq	%r13,%rbp
   175 (0.0%)  	adcq	$0,%r11
     .         
   175 (0.0%)  	subq	$-1,%r12
   175 (0.0%)  	movq	%r8,%rcx
   175 (0.0%)  	sbbq	%r14,%r13
   175 (0.0%)  	sbbq	$0,%r8
   175 (0.0%)  	movq	%r9,%r10
   175 (0.0%)  	sbbq	%r15,%r9
   175 (0.0%)  	sbbq	$0,%r11
     .         
   175 (0.0%)  	cmovcq	%rax,%r12
   175 (0.0%)  	movq	0(%rsi),%rax
   175 (0.0%)  	cmovcq	%rbp,%r13
   175 (0.0%)  	movq	8(%rsi),%rbp
   175 (0.0%)  	cmovcq	%rcx,%r8
   175 (0.0%)  	movq	16(%rsi),%rcx
   175 (0.0%)  	cmovcq	%r10,%r9
   175 (0.0%)  	movq	24(%rsi),%r10
     .         
   175 (0.0%)  	call	__ecp_nistz256_subq
     .         
   175 (0.0%)  	leaq	128(%rsp),%rbx
   175 (0.0%)  	leaq	288(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_sub_fromq
     .         
   175 (0.0%)  	movq	192+0(%rsp),%rax
   175 (0.0%)  	movq	192+8(%rsp),%rbp
   175 (0.0%)  	movq	192+16(%rsp),%rcx
   175 (0.0%)  	movq	192+24(%rsp),%r10
   175 (0.0%)  	leaq	320(%rsp),%rdi
     .         
   175 (0.0%)  	call	__ecp_nistz256_subq
     .         
   175 (0.0%)  	movq	%r12,0(%rdi)
   175 (0.0%)  	movq	%r13,8(%rdi)
   175 (0.0%)  	movq	%r8,16(%rdi)
   175 (0.0%)  	movq	%r9,24(%rdi)
   175 (0.0%)  	movq	128(%rsp),%rax
   175 (0.0%)  	leaq	128(%rsp),%rbx
   175 (0.0%)  	movq	0+224(%rsp),%r9
   175 (0.0%)  	movq	8+224(%rsp),%r10
   175 (0.0%)  	leaq	0+224(%rsp),%rsi
   175 (0.0%)  	movq	16+224(%rsp),%r11
   175 (0.0%)  	movq	24+224(%rsp),%r12
   175 (0.0%)  	leaq	256(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   175 (0.0%)  	movq	320(%rsp),%rax
   175 (0.0%)  	leaq	320(%rsp),%rbx
   175 (0.0%)  	movq	0+64(%rsp),%r9
   175 (0.0%)  	movq	8+64(%rsp),%r10
   175 (0.0%)  	leaq	0+64(%rsp),%rsi
   175 (0.0%)  	movq	16+64(%rsp),%r11
   175 (0.0%)  	movq	24+64(%rsp),%r12
   175 (0.0%)  	leaq	320(%rsp),%rdi
   175 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   175 (0.0%)  	leaq	256(%rsp),%rbx
   175 (0.0%)  	leaq	320(%rsp),%rdi
   350 (0.0%)  	call	__ecp_nistz256_sub_fromq
     .         
     .         .byte	102,72,15,126,199
     .         
   175 (0.0%)  	movdqa	%xmm5,%xmm0
   175 (0.0%)  	movdqa	%xmm5,%xmm1
   175 (0.0%)  	pandn	352(%rsp),%xmm0
   175 (0.0%)  	movdqa	%xmm5,%xmm2
   175 (0.0%)  	pandn	352+16(%rsp),%xmm1
   175 (0.0%)  	movdqa	%xmm5,%xmm3
   175 (0.0%)  	pand	544(%rsp),%xmm2
   175 (0.0%)  	pand	544+16(%rsp),%xmm3
   175 (0.0%)  	por	%xmm0,%xmm2
   175 (0.0%)  	por	%xmm1,%xmm3
     .         
   175 (0.0%)  	movdqa	%xmm4,%xmm0
   175 (0.0%)  	movdqa	%xmm4,%xmm1
   175 (0.0%)  	pandn	%xmm2,%xmm0
   175 (0.0%)  	movdqa	%xmm4,%xmm2
   175 (0.0%)  	pandn	%xmm3,%xmm1
   175 (0.0%)  	movdqa	%xmm4,%xmm3
   175 (0.0%)  	pand	448(%rsp),%xmm2
   175 (0.0%)  	pand	448+16(%rsp),%xmm3
   175 (0.0%)  	por	%xmm0,%xmm2
   175 (0.0%)  	por	%xmm1,%xmm3
   175 (0.0%)  	movdqu	%xmm2,64(%rdi)
   175 (0.0%)  	movdqu	%xmm3,80(%rdi)
     .         
   175 (0.0%)  	movdqa	%xmm5,%xmm0
   175 (0.0%)  	movdqa	%xmm5,%xmm1
   175 (0.0%)  	pandn	288(%rsp),%xmm0
   175 (0.0%)  	movdqa	%xmm5,%xmm2
   175 (0.0%)  	pandn	288+16(%rsp),%xmm1
   175 (0.0%)  	movdqa	%xmm5,%xmm3
   175 (0.0%)  	pand	480(%rsp),%xmm2
   175 (0.0%)  	pand	480+16(%rsp),%xmm3
   175 (0.0%)  	por	%xmm0,%xmm2
   175 (0.0%)  	por	%xmm1,%xmm3
     .         
   175 (0.0%)  	movdqa	%xmm4,%xmm0
   175 (0.0%)  	movdqa	%xmm4,%xmm1
   175 (0.0%)  	pandn	%xmm2,%xmm0
   175 (0.0%)  	movdqa	%xmm4,%xmm2
   175 (0.0%)  	pandn	%xmm3,%xmm1
   175 (0.0%)  	movdqa	%xmm4,%xmm3
   175 (0.0%)  	pand	384(%rsp),%xmm2
   175 (0.0%)  	pand	384+16(%rsp),%xmm3
   175 (0.0%)  	por	%xmm0,%xmm2
   175 (0.0%)  	por	%xmm1,%xmm3
   175 (0.0%)  	movdqu	%xmm2,0(%rdi)
   175 (0.0%)  	movdqu	%xmm3,16(%rdi)
     .         
   175 (0.0%)  	movdqa	%xmm5,%xmm0
   175 (0.0%)  	movdqa	%xmm5,%xmm1
   175 (0.0%)  	pandn	320(%rsp),%xmm0
   175 (0.0%)  	movdqa	%xmm5,%xmm2
   175 (0.0%)  	pandn	320+16(%rsp),%xmm1
   175 (0.0%)  	movdqa	%xmm5,%xmm3
   175 (0.0%)  	pand	512(%rsp),%xmm2
   175 (0.0%)  	pand	512+16(%rsp),%xmm3
   175 (0.0%)  	por	%xmm0,%xmm2
   175 (0.0%)  	por	%xmm1,%xmm3
     .         
   175 (0.0%)  	movdqa	%xmm4,%xmm0
   175 (0.0%)  	movdqa	%xmm4,%xmm1
   175 (0.0%)  	pandn	%xmm2,%xmm0
   175 (0.0%)  	movdqa	%xmm4,%xmm2
   175 (0.0%)  	pandn	%xmm3,%xmm1
   175 (0.0%)  	movdqa	%xmm4,%xmm3
   175 (0.0%)  	pand	416(%rsp),%xmm2
   175 (0.0%)  	pand	416+16(%rsp),%xmm3
   175 (0.0%)  	por	%xmm0,%xmm2
   175 (0.0%)  	por	%xmm1,%xmm3
   175 (0.0%)  	movdqu	%xmm2,32(%rdi)
   175 (0.0%)  	movdqu	%xmm3,48(%rdi)
     .         
     .         .Ladd_doneq:
   175 (0.0%)  	leaq	576+56(%rsp),%rsi
     .         .cfi_def_cfa	%rsi,8
   175 (0.0%)  	movq	-48(%rsi),%r15
     .         .cfi_restore	%r15
   175 (0.0%)  	movq	-40(%rsi),%r14
     .         .cfi_restore	%r14
   175 (0.0%)  	movq	-32(%rsi),%r13
     .         .cfi_restore	%r13
   175 (0.0%)  	movq	-24(%rsi),%r12
     .         .cfi_restore	%r12
   175 (0.0%)  	movq	-16(%rsi),%rbx
     .         .cfi_restore	%rbx
   175 (0.0%)  	movq	-8(%rsi),%rbp
     .         .cfi_restore	%rbp
   350 (0.0%)  	leaq	(%rsi),%rsp
     .         .cfi_def_cfa_register	%rsp
     .         .Lpoint_addq_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	ecp_nistz256_point_add,.-ecp_nistz256_point_add
     .         .globl	ecp_nistz256_point_add_affine
     .         .hidden ecp_nistz256_point_add_affine
     .         .type	ecp_nistz256_point_add_affine,@function
     .         .align	32
     .         ecp_nistz256_point_add_affine:
     .         .cfi_startproc	
   144 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%rcx
   144 (0.0%)  	movq	8(%rcx),%rcx
   144 (0.0%)  	andl	$0x80100,%ecx
   144 (0.0%)  	cmpl	$0x80100,%ecx
   144 (0.0%)  	je	.Lpoint_add_affinex
   144 (0.0%)  	pushq	%rbp
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%rbp,-16
   144 (0.0%)  	pushq	%rbx
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%rbx,-24
   144 (0.0%)  	pushq	%r12
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r12,-32
   144 (0.0%)  	pushq	%r13
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r13,-40
   144 (0.0%)  	pushq	%r14
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r14,-48
   144 (0.0%)  	pushq	%r15
     .         .cfi_adjust_cfa_offset	8
     .         .cfi_offset	%r15,-56
   144 (0.0%)  	subq	$480+8,%rsp
     .         .cfi_adjust_cfa_offset	32*15+8
     .         .Ladd_affineq_body:
     .         
   144 (0.0%)  	movdqu	0(%rsi),%xmm0
   144 (0.0%)  	movq	%rdx,%rbx
   144 (0.0%)  	movdqu	16(%rsi),%xmm1
   144 (0.0%)  	movdqu	32(%rsi),%xmm2
   144 (0.0%)  	movdqu	48(%rsi),%xmm3
   144 (0.0%)  	movdqu	64(%rsi),%xmm4
   144 (0.0%)  	movdqu	80(%rsi),%xmm5
   144 (0.0%)  	movq	64+0(%rsi),%rax
   144 (0.0%)  	movq	64+8(%rsi),%r14
   144 (0.0%)  	movq	64+16(%rsi),%r15
   144 (0.0%)  	movq	64+24(%rsi),%r8
   144 (0.0%)  	movdqa	%xmm0,320(%rsp)
   144 (0.0%)  	movdqa	%xmm1,320+16(%rsp)
   144 (0.0%)  	movdqa	%xmm2,352(%rsp)
   144 (0.0%)  	movdqa	%xmm3,352+16(%rsp)
   144 (0.0%)  	movdqa	%xmm4,384(%rsp)
   144 (0.0%)  	movdqa	%xmm5,384+16(%rsp)
   144 (0.0%)  	por	%xmm4,%xmm5
     .         
   144 (0.0%)  	movdqu	0(%rbx),%xmm0
   144 (0.0%)  	pshufd	$0xb1,%xmm5,%xmm3
   144 (0.0%)  	movdqu	16(%rbx),%xmm1
   144 (0.0%)  	movdqu	32(%rbx),%xmm2
   144 (0.0%)  	por	%xmm3,%xmm5
   144 (0.0%)  	movdqu	48(%rbx),%xmm3
   144 (0.0%)  	movdqa	%xmm0,416(%rsp)
   144 (0.0%)  	pshufd	$0x1e,%xmm5,%xmm4
   144 (0.0%)  	movdqa	%xmm1,416+16(%rsp)
   288 (0.0%)  	por	%xmm0,%xmm1
     .         .byte	102,72,15,110,199
   144 (0.0%)  	movdqa	%xmm2,448(%rsp)
   144 (0.0%)  	movdqa	%xmm3,448+16(%rsp)
   144 (0.0%)  	por	%xmm2,%xmm3
   144 (0.0%)  	por	%xmm4,%xmm5
   144 (0.0%)  	pxor	%xmm4,%xmm4
   144 (0.0%)  	por	%xmm1,%xmm3
     .         
   144 (0.0%)  	leaq	64-0(%rsi),%rsi
   144 (0.0%)  	leaq	32(%rsp),%rdi
   144 (0.0%)  	call	__ecp_nistz256_sqr_montq
     .         
   144 (0.0%)  	pcmpeqd	%xmm4,%xmm5
   144 (0.0%)  	pshufd	$0xb1,%xmm3,%xmm4
   144 (0.0%)  	movq	0(%rbx),%rax
     .         
   144 (0.0%)  	movq	%r12,%r9
   144 (0.0%)  	por	%xmm3,%xmm4
   144 (0.0%)  	pshufd	$0,%xmm5,%xmm5
   144 (0.0%)  	pshufd	$0x1e,%xmm4,%xmm3
   144 (0.0%)  	movq	%r13,%r10
   144 (0.0%)  	por	%xmm3,%xmm4
   144 (0.0%)  	pxor	%xmm3,%xmm3
   144 (0.0%)  	movq	%r14,%r11
   144 (0.0%)  	pcmpeqd	%xmm3,%xmm4
   144 (0.0%)  	pshufd	$0,%xmm4,%xmm4
     .         
   144 (0.0%)  	leaq	32-0(%rsp),%rsi
   144 (0.0%)  	movq	%r15,%r12
   144 (0.0%)  	leaq	0(%rsp),%rdi
   144 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   144 (0.0%)  	leaq	320(%rsp),%rbx
   144 (0.0%)  	leaq	64(%rsp),%rdi
   144 (0.0%)  	call	__ecp_nistz256_sub_fromq
     .         
   144 (0.0%)  	movq	384(%rsp),%rax
   144 (0.0%)  	leaq	384(%rsp),%rbx
   144 (0.0%)  	movq	0+32(%rsp),%r9
   144 (0.0%)  	movq	8+32(%rsp),%r10
   144 (0.0%)  	leaq	0+32(%rsp),%rsi
   144 (0.0%)  	movq	16+32(%rsp),%r11
   144 (0.0%)  	movq	24+32(%rsp),%r12
   144 (0.0%)  	leaq	32(%rsp),%rdi
   144 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   144 (0.0%)  	movq	384(%rsp),%rax
   144 (0.0%)  	leaq	384(%rsp),%rbx
   144 (0.0%)  	movq	0+64(%rsp),%r9
   144 (0.0%)  	movq	8+64(%rsp),%r10
   144 (0.0%)  	leaq	0+64(%rsp),%rsi
   144 (0.0%)  	movq	16+64(%rsp),%r11
   144 (0.0%)  	movq	24+64(%rsp),%r12
   144 (0.0%)  	leaq	288(%rsp),%rdi
   144 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   144 (0.0%)  	movq	448(%rsp),%rax
   144 (0.0%)  	leaq	448(%rsp),%rbx
   144 (0.0%)  	movq	0+32(%rsp),%r9
   144 (0.0%)  	movq	8+32(%rsp),%r10
   144 (0.0%)  	leaq	0+32(%rsp),%rsi
   144 (0.0%)  	movq	16+32(%rsp),%r11
   144 (0.0%)  	movq	24+32(%rsp),%r12
   144 (0.0%)  	leaq	32(%rsp),%rdi
   144 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   144 (0.0%)  	leaq	352(%rsp),%rbx
   144 (0.0%)  	leaq	96(%rsp),%rdi
   144 (0.0%)  	call	__ecp_nistz256_sub_fromq
     .         
   144 (0.0%)  	movq	0+64(%rsp),%rax
   144 (0.0%)  	movq	8+64(%rsp),%r14
   144 (0.0%)  	leaq	0+64(%rsp),%rsi
   144 (0.0%)  	movq	16+64(%rsp),%r15
   144 (0.0%)  	movq	24+64(%rsp),%r8
   144 (0.0%)  	leaq	128(%rsp),%rdi
   144 (0.0%)  	call	__ecp_nistz256_sqr_montq
     .         
   144 (0.0%)  	movq	0+96(%rsp),%rax
   144 (0.0%)  	movq	8+96(%rsp),%r14
   144 (0.0%)  	leaq	0+96(%rsp),%rsi
   144 (0.0%)  	movq	16+96(%rsp),%r15
   144 (0.0%)  	movq	24+96(%rsp),%r8
   144 (0.0%)  	leaq	192(%rsp),%rdi
   144 (0.0%)  	call	__ecp_nistz256_sqr_montq
     .         
   144 (0.0%)  	movq	128(%rsp),%rax
   144 (0.0%)  	leaq	128(%rsp),%rbx
   144 (0.0%)  	movq	0+64(%rsp),%r9
   144 (0.0%)  	movq	8+64(%rsp),%r10
   144 (0.0%)  	leaq	0+64(%rsp),%rsi
   144 (0.0%)  	movq	16+64(%rsp),%r11
   144 (0.0%)  	movq	24+64(%rsp),%r12
   144 (0.0%)  	leaq	160(%rsp),%rdi
   144 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   144 (0.0%)  	movq	320(%rsp),%rax
   144 (0.0%)  	leaq	320(%rsp),%rbx
   144 (0.0%)  	movq	0+128(%rsp),%r9
   144 (0.0%)  	movq	8+128(%rsp),%r10
   144 (0.0%)  	leaq	0+128(%rsp),%rsi
   144 (0.0%)  	movq	16+128(%rsp),%r11
   144 (0.0%)  	movq	24+128(%rsp),%r12
   144 (0.0%)  	leaq	0(%rsp),%rdi
   144 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
     .         
     .         
     .         
   144 (0.0%)  	xorq	%r11,%r11
   144 (0.0%)  	addq	%r12,%r12
   144 (0.0%)  	leaq	192(%rsp),%rsi
   144 (0.0%)  	adcq	%r13,%r13
   144 (0.0%)  	movq	%r12,%rax
   144 (0.0%)  	adcq	%r8,%r8
   144 (0.0%)  	adcq	%r9,%r9
   144 (0.0%)  	movq	%r13,%rbp
   144 (0.0%)  	adcq	$0,%r11
     .         
   144 (0.0%)  	subq	$-1,%r12
   144 (0.0%)  	movq	%r8,%rcx
   144 (0.0%)  	sbbq	%r14,%r13
   144 (0.0%)  	sbbq	$0,%r8
   144 (0.0%)  	movq	%r9,%r10
   144 (0.0%)  	sbbq	%r15,%r9
   144 (0.0%)  	sbbq	$0,%r11
     .         
   144 (0.0%)  	cmovcq	%rax,%r12
   144 (0.0%)  	movq	0(%rsi),%rax
   144 (0.0%)  	cmovcq	%rbp,%r13
   144 (0.0%)  	movq	8(%rsi),%rbp
   144 (0.0%)  	cmovcq	%rcx,%r8
   144 (0.0%)  	movq	16(%rsi),%rcx
   144 (0.0%)  	cmovcq	%r10,%r9
   144 (0.0%)  	movq	24(%rsi),%r10
     .         
   144 (0.0%)  	call	__ecp_nistz256_subq
     .         
   144 (0.0%)  	leaq	160(%rsp),%rbx
   144 (0.0%)  	leaq	224(%rsp),%rdi
   144 (0.0%)  	call	__ecp_nistz256_sub_fromq
     .         
   144 (0.0%)  	movq	0+0(%rsp),%rax
   144 (0.0%)  	movq	0+8(%rsp),%rbp
   144 (0.0%)  	movq	0+16(%rsp),%rcx
   144 (0.0%)  	movq	0+24(%rsp),%r10
   144 (0.0%)  	leaq	64(%rsp),%rdi
     .         
   144 (0.0%)  	call	__ecp_nistz256_subq
     .         
   144 (0.0%)  	movq	%r12,0(%rdi)
   144 (0.0%)  	movq	%r13,8(%rdi)
   144 (0.0%)  	movq	%r8,16(%rdi)
   144 (0.0%)  	movq	%r9,24(%rdi)
   144 (0.0%)  	movq	352(%rsp),%rax
   144 (0.0%)  	leaq	352(%rsp),%rbx
   144 (0.0%)  	movq	0+160(%rsp),%r9
   144 (0.0%)  	movq	8+160(%rsp),%r10
   144 (0.0%)  	leaq	0+160(%rsp),%rsi
   144 (0.0%)  	movq	16+160(%rsp),%r11
   144 (0.0%)  	movq	24+160(%rsp),%r12
   144 (0.0%)  	leaq	32(%rsp),%rdi
   144 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   144 (0.0%)  	movq	96(%rsp),%rax
   144 (0.0%)  	leaq	96(%rsp),%rbx
   144 (0.0%)  	movq	0+64(%rsp),%r9
   144 (0.0%)  	movq	8+64(%rsp),%r10
   144 (0.0%)  	leaq	0+64(%rsp),%rsi
   144 (0.0%)  	movq	16+64(%rsp),%r11
   144 (0.0%)  	movq	24+64(%rsp),%r12
   144 (0.0%)  	leaq	64(%rsp),%rdi
   144 (0.0%)  	call	__ecp_nistz256_mul_montq
     .         
   144 (0.0%)  	leaq	32(%rsp),%rbx
   144 (0.0%)  	leaq	256(%rsp),%rdi
   288 (0.0%)  	call	__ecp_nistz256_sub_fromq
     .         
     .         .byte	102,72,15,126,199
     .         
   144 (0.0%)  	movdqa	%xmm5,%xmm0
   144 (0.0%)  	movdqa	%xmm5,%xmm1
   144 (0.0%)  	pandn	288(%rsp),%xmm0
   144 (0.0%)  	movdqa	%xmm5,%xmm2
   144 (0.0%)  	pandn	288+16(%rsp),%xmm1
   144 (0.0%)  	movdqa	%xmm5,%xmm3
   144 (0.0%)  	pand	.LONE_mont(%rip),%xmm2
   144 (0.0%)  	pand	.LONE_mont+16(%rip),%xmm3
   144 (0.0%)  	por	%xmm0,%xmm2
   144 (0.0%)  	por	%xmm1,%xmm3
     .         
   144 (0.0%)  	movdqa	%xmm4,%xmm0
   144 (0.0%)  	movdqa	%xmm4,%xmm1
   144 (0.0%)  	pandn	%xmm2,%xmm0
   144 (0.0%)  	movdqa	%xmm4,%xmm2
   144 (0.0%)  	pandn	%xmm3,%xmm1
   144 (0.0%)  	movdqa	%xmm4,%xmm3
   144 (0.0%)  	pand	384(%rsp),%xmm2
   144 (0.0%)  	pand	384+16(%rsp),%xmm3
   144 (0.0%)  	por	%xmm0,%xmm2
   144 (0.0%)  	por	%xmm1,%xmm3
   144 (0.0%)  	movdqu	%xmm2,64(%rdi)
   144 (0.0%)  	movdqu	%xmm3,80(%rdi)
     .         
   144 (0.0%)  	movdqa	%xmm5,%xmm0
   144 (0.0%)  	movdqa	%xmm5,%xmm1
   144 (0.0%)  	pandn	224(%rsp),%xmm0
   144 (0.0%)  	movdqa	%xmm5,%xmm2
   144 (0.0%)  	pandn	224+16(%rsp),%xmm1
   144 (0.0%)  	movdqa	%xmm5,%xmm3
   144 (0.0%)  	pand	416(%rsp),%xmm2
   144 (0.0%)  	pand	416+16(%rsp),%xmm3
   144 (0.0%)  	por	%xmm0,%xmm2
   144 (0.0%)  	por	%xmm1,%xmm3
     .         
   144 (0.0%)  	movdqa	%xmm4,%xmm0
   144 (0.0%)  	movdqa	%xmm4,%xmm1
   144 (0.0%)  	pandn	%xmm2,%xmm0
   144 (0.0%)  	movdqa	%xmm4,%xmm2
   144 (0.0%)  	pandn	%xmm3,%xmm1
   144 (0.0%)  	movdqa	%xmm4,%xmm3
   144 (0.0%)  	pand	320(%rsp),%xmm2
   144 (0.0%)  	pand	320+16(%rsp),%xmm3
   144 (0.0%)  	por	%xmm0,%xmm2
   144 (0.0%)  	por	%xmm1,%xmm3
   144 (0.0%)  	movdqu	%xmm2,0(%rdi)
   144 (0.0%)  	movdqu	%xmm3,16(%rdi)
     .         
   144 (0.0%)  	movdqa	%xmm5,%xmm0
   144 (0.0%)  	movdqa	%xmm5,%xmm1
   144 (0.0%)  	pandn	256(%rsp),%xmm0
   144 (0.0%)  	movdqa	%xmm5,%xmm2
   144 (0.0%)  	pandn	256+16(%rsp),%xmm1
   144 (0.0%)  	movdqa	%xmm5,%xmm3
   144 (0.0%)  	pand	448(%rsp),%xmm2
   144 (0.0%)  	pand	448+16(%rsp),%xmm3
   144 (0.0%)  	por	%xmm0,%xmm2
   144 (0.0%)  	por	%xmm1,%xmm3
     .         
   144 (0.0%)  	movdqa	%xmm4,%xmm0
   144 (0.0%)  	movdqa	%xmm4,%xmm1
   144 (0.0%)  	pandn	%xmm2,%xmm0
   144 (0.0%)  	movdqa	%xmm4,%xmm2
   144 (0.0%)  	pandn	%xmm3,%xmm1
   144 (0.0%)  	movdqa	%xmm4,%xmm3
   144 (0.0%)  	pand	352(%rsp),%xmm2
   144 (0.0%)  	pand	352+16(%rsp),%xmm3
   144 (0.0%)  	por	%xmm0,%xmm2
   144 (0.0%)  	por	%xmm1,%xmm3
   144 (0.0%)  	movdqu	%xmm2,32(%rdi)
   144 (0.0%)  	movdqu	%xmm3,48(%rdi)
     .         
   144 (0.0%)  	leaq	480+56(%rsp),%rsi
     .         .cfi_def_cfa	%rsi,8
   144 (0.0%)  	movq	-48(%rsi),%r15
     .         .cfi_restore	%r15
   144 (0.0%)  	movq	-40(%rsi),%r14
     .         .cfi_restore	%r14
   144 (0.0%)  	movq	-32(%rsi),%r13
     .         .cfi_restore	%r13
   144 (0.0%)  	movq	-24(%rsi),%r12
     .         .cfi_restore	%r12
   144 (0.0%)  	movq	-16(%rsi),%rbx
     .         .cfi_restore	%rbx
   144 (0.0%)  	movq	-8(%rsi),%rbp
     .         .cfi_restore	%rbp
   288 (0.0%)  	leaq	(%rsi),%rsp
     .         .cfi_def_cfa_register	%rsp
     .         .Ladd_affineq_epilogue:
     .         	.byte	0xf3,0xc3
     .         .cfi_endproc	
     .         .size	ecp_nistz256_point_add_affine,.-ecp_nistz256_point_add_affine
     .         .type	__ecp_nistz256_add_tox,@function
     .         .align	32
     .         __ecp_nistz256_add_tox:
-- line 3417 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/p256_beeu-x86_64-asm.S
--------------------------------------------------------------------------------
Ir________ 

-- line 8 ----------------------------------------
  .         
  .         .type	beeu_mod_inverse_vartime,@function
  .         .hidden	beeu_mod_inverse_vartime
  .         .globl	beeu_mod_inverse_vartime
  .         .hidden beeu_mod_inverse_vartime
  .         .align	32
  .         beeu_mod_inverse_vartime:
  .         .cfi_startproc	
  1 (0.0%)  	pushq	%rbp
  .         .cfi_adjust_cfa_offset	8
  .         .cfi_offset	rbp,-16
  1 (0.0%)  	pushq	%r12
  .         .cfi_adjust_cfa_offset	8
  .         .cfi_offset	r12,-24
  1 (0.0%)  	pushq	%r13
  .         .cfi_adjust_cfa_offset	8
  .         .cfi_offset	r13,-32
  1 (0.0%)  	pushq	%r14
  .         .cfi_adjust_cfa_offset	8
  .         .cfi_offset	r14,-40
  1 (0.0%)  	pushq	%r15
  .         .cfi_adjust_cfa_offset	8
  .         .cfi_offset	r15,-48
  1 (0.0%)  	pushq	%rbx
  .         .cfi_adjust_cfa_offset	8
  .         .cfi_offset	rbx,-56
  1 (0.0%)  	pushq	%rsi
  .         .cfi_adjust_cfa_offset	8
  .         .cfi_offset	rsi,-64
  .         
  1 (0.0%)  	subq	$80,%rsp
  .         .cfi_adjust_cfa_offset	80
  1 (0.0%)  	movq	%rdi,0(%rsp)
  .         
  .         
  1 (0.0%)  	movq	$1,%r8
  1 (0.0%)  	xorq	%r9,%r9
  1 (0.0%)  	xorq	%r10,%r10
  1 (0.0%)  	xorq	%r11,%r11
  1 (0.0%)  	xorq	%rdi,%rdi
  .         
  1 (0.0%)  	xorq	%r12,%r12
  1 (0.0%)  	xorq	%r13,%r13
  1 (0.0%)  	xorq	%r14,%r14
  1 (0.0%)  	xorq	%r15,%r15
  1 (0.0%)  	xorq	%rbp,%rbp
  .         
  .         
  1 (0.0%)  	vmovdqu	0(%rsi),%xmm0
  1 (0.0%)  	vmovdqu	16(%rsi),%xmm1
  1 (0.0%)  	vmovdqu	%xmm0,48(%rsp)
  1 (0.0%)  	vmovdqu	%xmm1,64(%rsp)
  .         
  1 (0.0%)  	vmovdqu	0(%rdx),%xmm0
  1 (0.0%)  	vmovdqu	16(%rdx),%xmm1
  1 (0.0%)  	vmovdqu	%xmm0,16(%rsp)
  1 (0.0%)  	vmovdqu	%xmm1,32(%rsp)
  .         
  .         .Lbeeu_loop:
187 (0.0%)  	xorq	%rbx,%rbx
187 (0.0%)  	orq	48(%rsp),%rbx
187 (0.0%)  	orq	56(%rsp),%rbx
187 (0.0%)  	orq	64(%rsp),%rbx
187 (0.0%)  	orq	72(%rsp),%rbx
187 (0.0%)  	jz	.Lbeeu_loop_end
  .         
  .         
  .         
  .         
  .         
  .         
  .         
  .         
  .         
  .         
186 (0.0%)  	movq	$1,%rcx
  .         
  .         
  .         .Lbeeu_shift_loop_XB:
380 (0.0%)  	movq	%rcx,%rbx
380 (0.0%)  	andq	48(%rsp),%rbx
380 (0.0%)  	jnz	.Lbeeu_shift_loop_end_XB
  .         
  .         
194 (0.0%)  	movq	$1,%rbx
194 (0.0%)  	andq	%r8,%rbx
194 (0.0%)  	jz	.Lshift1_0
 85 (0.0%)  	addq	0(%rdx),%r8
 85 (0.0%)  	adcq	8(%rdx),%r9
 85 (0.0%)  	adcq	16(%rdx),%r10
 85 (0.0%)  	adcq	24(%rdx),%r11
 85 (0.0%)  	adcq	$0,%rdi
  .         
  .         .Lshift1_0:
194 (0.0%)  	shrdq	$1,%r9,%r8
194 (0.0%)  	shrdq	$1,%r10,%r9
194 (0.0%)  	shrdq	$1,%r11,%r10
194 (0.0%)  	shrdq	$1,%rdi,%r11
194 (0.0%)  	shrq	$1,%rdi
  .         
194 (0.0%)  	shlq	$1,%rcx
  .         
  .         
  .         
  .         
  .         
194 (0.0%)  	cmpq	$0x8000000,%rcx
194 (0.0%)  	jne	.Lbeeu_shift_loop_XB
  .         
  .         .Lbeeu_shift_loop_end_XB:
186 (0.0%)  	bsfq	%rcx,%rcx
186 (0.0%)  	testq	%rcx,%rcx
186 (0.0%)  	jz	.Lbeeu_no_shift_XB
  .         
  .         
  .         
103 (0.0%)  	movq	8+48(%rsp),%rax
103 (0.0%)  	movq	16+48(%rsp),%rbx
103 (0.0%)  	movq	24+48(%rsp),%rsi
  .         
103 (0.0%)  	shrdq	%cl,%rax,0+48(%rsp)
103 (0.0%)  	shrdq	%cl,%rbx,8+48(%rsp)
103 (0.0%)  	shrdq	%cl,%rsi,16+48(%rsp)
  .         
103 (0.0%)  	shrq	%cl,%rsi
103 (0.0%)  	movq	%rsi,24+48(%rsp)
  .         
  .         
  .         .Lbeeu_no_shift_XB:
  .         
186 (0.0%)  	movq	$1,%rcx
  .         
  .         
  .         .Lbeeu_shift_loop_YA:
354 (0.0%)  	movq	%rcx,%rbx
354 (0.0%)  	andq	16(%rsp),%rbx
354 (0.0%)  	jnz	.Lbeeu_shift_loop_end_YA
  .         
  .         
168 (0.0%)  	movq	$1,%rbx
168 (0.0%)  	andq	%r12,%rbx
168 (0.0%)  	jz	.Lshift1_1
 83 (0.0%)  	addq	0(%rdx),%r12
 83 (0.0%)  	adcq	8(%rdx),%r13
 83 (0.0%)  	adcq	16(%rdx),%r14
 83 (0.0%)  	adcq	24(%rdx),%r15
 83 (0.0%)  	adcq	$0,%rbp
  .         
  .         .Lshift1_1:
168 (0.0%)  	shrdq	$1,%r13,%r12
168 (0.0%)  	shrdq	$1,%r14,%r13
168 (0.0%)  	shrdq	$1,%r15,%r14
168 (0.0%)  	shrdq	$1,%rbp,%r15
168 (0.0%)  	shrq	$1,%rbp
  .         
168 (0.0%)  	shlq	$1,%rcx
  .         
  .         
  .         
  .         
  .         
168 (0.0%)  	cmpq	$0x8000000,%rcx
168 (0.0%)  	jne	.Lbeeu_shift_loop_YA
  .         
  .         .Lbeeu_shift_loop_end_YA:
186 (0.0%)  	bsfq	%rcx,%rcx
186 (0.0%)  	testq	%rcx,%rcx
186 (0.0%)  	jz	.Lbeeu_no_shift_YA
  .         
  .         
  .         
 82 (0.0%)  	movq	8+16(%rsp),%rax
 82 (0.0%)  	movq	16+16(%rsp),%rbx
 82 (0.0%)  	movq	24+16(%rsp),%rsi
  .         
 82 (0.0%)  	shrdq	%cl,%rax,0+16(%rsp)
 82 (0.0%)  	shrdq	%cl,%rbx,8+16(%rsp)
 82 (0.0%)  	shrdq	%cl,%rsi,16+16(%rsp)
  .         
 82 (0.0%)  	shrq	%cl,%rsi
 82 (0.0%)  	movq	%rsi,24+16(%rsp)
  .         
  .         
  .         .Lbeeu_no_shift_YA:
  .         
186 (0.0%)  	movq	48(%rsp),%rax
186 (0.0%)  	movq	56(%rsp),%rbx
186 (0.0%)  	movq	64(%rsp),%rsi
186 (0.0%)  	movq	72(%rsp),%rcx
186 (0.0%)  	subq	16(%rsp),%rax
186 (0.0%)  	sbbq	24(%rsp),%rbx
186 (0.0%)  	sbbq	32(%rsp),%rsi
186 (0.0%)  	sbbq	40(%rsp),%rcx
186 (0.0%)  	jnc	.Lbeeu_B_bigger_than_A
  .         
  .         
 82 (0.0%)  	movq	16(%rsp),%rax
 82 (0.0%)  	movq	24(%rsp),%rbx
 82 (0.0%)  	movq	32(%rsp),%rsi
 82 (0.0%)  	movq	40(%rsp),%rcx
 82 (0.0%)  	subq	48(%rsp),%rax
 82 (0.0%)  	sbbq	56(%rsp),%rbx
 82 (0.0%)  	sbbq	64(%rsp),%rsi
 82 (0.0%)  	sbbq	72(%rsp),%rcx
 82 (0.0%)  	movq	%rax,16(%rsp)
 82 (0.0%)  	movq	%rbx,24(%rsp)
 82 (0.0%)  	movq	%rsi,32(%rsp)
 82 (0.0%)  	movq	%rcx,40(%rsp)
  .         
  .         
 82 (0.0%)  	addq	%r8,%r12
 82 (0.0%)  	adcq	%r9,%r13
 82 (0.0%)  	adcq	%r10,%r14
 82 (0.0%)  	adcq	%r11,%r15
 82 (0.0%)  	adcq	%rdi,%rbp
 82 (0.0%)  	jmp	.Lbeeu_loop
  .         
  .         .Lbeeu_B_bigger_than_A:
  .         
104 (0.0%)  	movq	%rax,48(%rsp)
104 (0.0%)  	movq	%rbx,56(%rsp)
104 (0.0%)  	movq	%rsi,64(%rsp)
104 (0.0%)  	movq	%rcx,72(%rsp)
  .         
  .         
104 (0.0%)  	addq	%r12,%r8
104 (0.0%)  	adcq	%r13,%r9
104 (0.0%)  	adcq	%r14,%r10
104 (0.0%)  	adcq	%r15,%r11
104 (0.0%)  	adcq	%rbp,%rdi
  .         
104 (0.0%)  	jmp	.Lbeeu_loop
  .         
  .         .Lbeeu_loop_end:
  .         
  .         
  .         
  .         
  1 (0.0%)  	movq	16(%rsp),%rbx
  1 (0.0%)  	subq	$1,%rbx
  1 (0.0%)  	orq	24(%rsp),%rbx
  1 (0.0%)  	orq	32(%rsp),%rbx
  1 (0.0%)  	orq	40(%rsp),%rbx
  .         
  1 (0.0%)  	jnz	.Lbeeu_err
  .         
  .         
  .         
  .         
  1 (0.0%)  	movq	0(%rdx),%r8
  1 (0.0%)  	movq	8(%rdx),%r9
  1 (0.0%)  	movq	16(%rdx),%r10
  1 (0.0%)  	movq	24(%rdx),%r11
  1 (0.0%)  	xorq	%rdi,%rdi
  .         
  .         .Lbeeu_reduction_loop:
  2 (0.0%)  	movq	%r12,16(%rsp)
  2 (0.0%)  	movq	%r13,24(%rsp)
  2 (0.0%)  	movq	%r14,32(%rsp)
  2 (0.0%)  	movq	%r15,40(%rsp)
  2 (0.0%)  	movq	%rbp,48(%rsp)
  .         
  .         
  2 (0.0%)  	subq	%r8,%r12
  2 (0.0%)  	sbbq	%r9,%r13
  2 (0.0%)  	sbbq	%r10,%r14
  2 (0.0%)  	sbbq	%r11,%r15
  2 (0.0%)  	sbbq	$0,%rbp
  .         
  .         
  2 (0.0%)  	cmovcq	16(%rsp),%r12
  2 (0.0%)  	cmovcq	24(%rsp),%r13
  2 (0.0%)  	cmovcq	32(%rsp),%r14
  2 (0.0%)  	cmovcq	40(%rsp),%r15
  2 (0.0%)  	jnc	.Lbeeu_reduction_loop
  .         
  .         
  1 (0.0%)  	subq	%r12,%r8
  1 (0.0%)  	sbbq	%r13,%r9
  1 (0.0%)  	sbbq	%r14,%r10
  1 (0.0%)  	sbbq	%r15,%r11
  .         
  .         .Lbeeu_save:
  .         
  1 (0.0%)  	movq	0(%rsp),%rdi
  .         
  1 (0.0%)  	movq	%r8,0(%rdi)
  1 (0.0%)  	movq	%r9,8(%rdi)
  1 (0.0%)  	movq	%r10,16(%rdi)
  1 (0.0%)  	movq	%r11,24(%rdi)
  .         
  .         
  1 (0.0%)  	movq	$1,%rax
  1 (0.0%)  	jmp	.Lbeeu_finish
  .         
  .         .Lbeeu_err:
  .         
  .         	xorq	%rax,%rax
  .         
  .         .Lbeeu_finish:
  1 (0.0%)  	addq	$80,%rsp
  .         .cfi_adjust_cfa_offset	-80
  1 (0.0%)  	popq	%rsi
  .         .cfi_adjust_cfa_offset	-8
  .         .cfi_restore	rsi
  1 (0.0%)  	popq	%rbx
  .         .cfi_adjust_cfa_offset	-8
  .         .cfi_restore	rbx
  1 (0.0%)  	popq	%r15
  .         .cfi_adjust_cfa_offset	-8
  .         .cfi_restore	r15
  1 (0.0%)  	popq	%r14
  .         .cfi_adjust_cfa_offset	-8
  .         .cfi_restore	r14
  1 (0.0%)  	popq	%r13
  .         .cfi_adjust_cfa_offset	-8
  .         .cfi_restore	r13
  1 (0.0%)  	popq	%r12
  .         .cfi_adjust_cfa_offset	-8
  .         .cfi_restore	r12
  2 (0.0%)  	popq	%rbp
  .         .cfi_adjust_cfa_offset	-8
  .         .cfi_restore	rbp
  .         	.byte	0xf3,0xc3
  .         .cfi_endproc	
  .         
  .         .size	beeu_mod_inverse_vartime, .-beeu_mod_inverse_vartime
  .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha1-x86_64.S
--------------------------------------------------------------------------------
Ir_______ 

-- line 9 ----------------------------------------
 .         .hidden OPENSSL_ia32cap_P
 .         
 .         .globl	sha1_block_data_order
 .         .hidden sha1_block_data_order
 .         .type	sha1_block_data_order,@function
 .         .align	16
 .         sha1_block_data_order:
 .         .cfi_startproc	
14 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r10
14 (0.0%)  	movl	0(%r10),%r9d
14 (0.0%)  	movl	4(%r10),%r8d
14 (0.0%)  	movl	8(%r10),%r10d
14 (0.0%)  	testl	$512,%r8d
14 (0.0%)  	jz	.Lialu
14 (0.0%)  	testl	$536870912,%r10d
14 (0.0%)  	jnz	_shaext_shortcut
14 (0.0%)  	andl	$296,%r10d
14 (0.0%)  	cmpl	$296,%r10d
14 (0.0%)  	je	_avx2_shortcut
 .         	andl	$268435456,%r8d
 .         	andl	$1073741824,%r9d
 .         	orl	%r9d,%r8d
 .         	cmpl	$1342177280,%r8d
 .         	je	_avx_shortcut
 .         	jmp	_ssse3_shortcut
 .         
 .         .align	16
-- line 35 ----------------------------------------
-- line 3750 ----------------------------------------
 .         	.byte	0xf3,0xc3
 .         .cfi_endproc	
 .         .size	sha1_block_data_order_avx,.-sha1_block_data_order_avx
 .         .type	sha1_block_data_order_avx2,@function
 .         .align	16
 .         sha1_block_data_order_avx2:
 .         _avx2_shortcut:
 .         .cfi_startproc	
14 (0.0%)  	movq	%rsp,%r11
 .         .cfi_def_cfa_register	%r11
14 (0.0%)  	pushq	%rbx
 .         .cfi_offset	%rbx,-16
14 (0.0%)  	pushq	%rbp
 .         .cfi_offset	%rbp,-24
14 (0.0%)  	pushq	%r12
 .         .cfi_offset	%r12,-32
14 (0.0%)  	pushq	%r13
 .         .cfi_offset	%r13,-40
14 (0.0%)  	pushq	%r14
 .         .cfi_offset	%r14,-48
14 (0.0%)  	vzeroupper
14 (0.0%)  	movq	%rdi,%r8
14 (0.0%)  	movq	%rsi,%r9
14 (0.0%)  	movq	%rdx,%r10
 .         
14 (0.0%)  	leaq	-640(%rsp),%rsp
14 (0.0%)  	shlq	$6,%r10
14 (0.0%)  	leaq	64(%r9),%r13
14 (0.0%)  	andq	$-128,%rsp
14 (0.0%)  	addq	%r9,%r10
14 (0.0%)  	leaq	K_XX_XX+64(%rip),%r14
 .         
14 (0.0%)  	movl	0(%r8),%eax
14 (0.0%)  	cmpq	%r10,%r13
14 (0.0%)  	cmovaeq	%r9,%r13
14 (0.0%)  	movl	4(%r8),%ebp
14 (0.0%)  	movl	8(%r8),%ecx
14 (0.0%)  	movl	12(%r8),%edx
14 (0.0%)  	movl	16(%r8),%esi
14 (0.0%)  	vmovdqu	64(%r14),%ymm6
 .         
14 (0.0%)  	vmovdqu	(%r9),%xmm0
14 (0.0%)  	vmovdqu	16(%r9),%xmm1
14 (0.0%)  	vmovdqu	32(%r9),%xmm2
14 (0.0%)  	vmovdqu	48(%r9),%xmm3
14 (0.0%)  	leaq	64(%r9),%r9
14 (0.0%)  	vinserti128	$1,(%r13),%ymm0,%ymm0
14 (0.0%)  	vinserti128	$1,16(%r13),%ymm1,%ymm1
14 (0.0%)  	vpshufb	%ymm6,%ymm0,%ymm0
14 (0.0%)  	vinserti128	$1,32(%r13),%ymm2,%ymm2
14 (0.0%)  	vpshufb	%ymm6,%ymm1,%ymm1
14 (0.0%)  	vinserti128	$1,48(%r13),%ymm3,%ymm3
14 (0.0%)  	vpshufb	%ymm6,%ymm2,%ymm2
14 (0.0%)  	vmovdqu	-64(%r14),%ymm11
14 (0.0%)  	vpshufb	%ymm6,%ymm3,%ymm3
 .         
14 (0.0%)  	vpaddd	%ymm11,%ymm0,%ymm4
14 (0.0%)  	vpaddd	%ymm11,%ymm1,%ymm5
14 (0.0%)  	vmovdqu	%ymm4,0(%rsp)
14 (0.0%)  	vpaddd	%ymm11,%ymm2,%ymm6
14 (0.0%)  	vmovdqu	%ymm5,32(%rsp)
14 (0.0%)  	vpaddd	%ymm11,%ymm3,%ymm7
14 (0.0%)  	vmovdqu	%ymm6,64(%rsp)
14 (0.0%)  	vmovdqu	%ymm7,96(%rsp)
14 (0.0%)  	vpalignr	$8,%ymm0,%ymm1,%ymm4
14 (0.0%)  	vpsrldq	$4,%ymm3,%ymm8
14 (0.0%)  	vpxor	%ymm0,%ymm4,%ymm4
14 (0.0%)  	vpxor	%ymm2,%ymm8,%ymm8
14 (0.0%)  	vpxor	%ymm8,%ymm4,%ymm4
14 (0.0%)  	vpsrld	$31,%ymm4,%ymm8
14 (0.0%)  	vpslldq	$12,%ymm4,%ymm10
14 (0.0%)  	vpaddd	%ymm4,%ymm4,%ymm4
14 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
14 (0.0%)  	vpor	%ymm8,%ymm4,%ymm4
14 (0.0%)  	vpslld	$2,%ymm10,%ymm10
14 (0.0%)  	vpxor	%ymm9,%ymm4,%ymm4
14 (0.0%)  	vpxor	%ymm10,%ymm4,%ymm4
14 (0.0%)  	vpaddd	%ymm11,%ymm4,%ymm9
14 (0.0%)  	vmovdqu	%ymm9,128(%rsp)
14 (0.0%)  	vpalignr	$8,%ymm1,%ymm2,%ymm5
14 (0.0%)  	vpsrldq	$4,%ymm4,%ymm8
14 (0.0%)  	vpxor	%ymm1,%ymm5,%ymm5
14 (0.0%)  	vpxor	%ymm3,%ymm8,%ymm8
14 (0.0%)  	vpxor	%ymm8,%ymm5,%ymm5
14 (0.0%)  	vpsrld	$31,%ymm5,%ymm8
14 (0.0%)  	vmovdqu	-32(%r14),%ymm11
14 (0.0%)  	vpslldq	$12,%ymm5,%ymm10
14 (0.0%)  	vpaddd	%ymm5,%ymm5,%ymm5
14 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
14 (0.0%)  	vpor	%ymm8,%ymm5,%ymm5
14 (0.0%)  	vpslld	$2,%ymm10,%ymm10
14 (0.0%)  	vpxor	%ymm9,%ymm5,%ymm5
14 (0.0%)  	vpxor	%ymm10,%ymm5,%ymm5
14 (0.0%)  	vpaddd	%ymm11,%ymm5,%ymm9
14 (0.0%)  	vmovdqu	%ymm9,160(%rsp)
14 (0.0%)  	vpalignr	$8,%ymm2,%ymm3,%ymm6
14 (0.0%)  	vpsrldq	$4,%ymm5,%ymm8
14 (0.0%)  	vpxor	%ymm2,%ymm6,%ymm6
14 (0.0%)  	vpxor	%ymm4,%ymm8,%ymm8
14 (0.0%)  	vpxor	%ymm8,%ymm6,%ymm6
14 (0.0%)  	vpsrld	$31,%ymm6,%ymm8
14 (0.0%)  	vpslldq	$12,%ymm6,%ymm10
14 (0.0%)  	vpaddd	%ymm6,%ymm6,%ymm6
14 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
14 (0.0%)  	vpor	%ymm8,%ymm6,%ymm6
14 (0.0%)  	vpslld	$2,%ymm10,%ymm10
14 (0.0%)  	vpxor	%ymm9,%ymm6,%ymm6
14 (0.0%)  	vpxor	%ymm10,%ymm6,%ymm6
14 (0.0%)  	vpaddd	%ymm11,%ymm6,%ymm9
14 (0.0%)  	vmovdqu	%ymm9,192(%rsp)
14 (0.0%)  	vpalignr	$8,%ymm3,%ymm4,%ymm7
14 (0.0%)  	vpsrldq	$4,%ymm6,%ymm8
14 (0.0%)  	vpxor	%ymm3,%ymm7,%ymm7
14 (0.0%)  	vpxor	%ymm5,%ymm8,%ymm8
14 (0.0%)  	vpxor	%ymm8,%ymm7,%ymm7
14 (0.0%)  	vpsrld	$31,%ymm7,%ymm8
14 (0.0%)  	vpslldq	$12,%ymm7,%ymm10
14 (0.0%)  	vpaddd	%ymm7,%ymm7,%ymm7
14 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
14 (0.0%)  	vpor	%ymm8,%ymm7,%ymm7
14 (0.0%)  	vpslld	$2,%ymm10,%ymm10
14 (0.0%)  	vpxor	%ymm9,%ymm7,%ymm7
14 (0.0%)  	vpxor	%ymm10,%ymm7,%ymm7
14 (0.0%)  	vpaddd	%ymm11,%ymm7,%ymm9
14 (0.0%)  	vmovdqu	%ymm9,224(%rsp)
14 (0.0%)  	leaq	128(%rsp),%r13
14 (0.0%)  	jmp	.Loop_avx2
 .         .align	32
 .         .Loop_avx2:
22 (0.0%)  	rorxl	$2,%ebp,%ebx
22 (0.0%)  	andnl	%edx,%ebp,%edi
22 (0.0%)  	andl	%ecx,%ebp
22 (0.0%)  	xorl	%edi,%ebp
22 (0.0%)  	jmp	.Lalign32_1
 .         .align	32
 .         .Lalign32_1:
22 (0.0%)  	vpalignr	$8,%ymm6,%ymm7,%ymm8
22 (0.0%)  	vpxor	%ymm4,%ymm0,%ymm0
22 (0.0%)  	addl	-128(%r13),%esi
22 (0.0%)  	andnl	%ecx,%eax,%edi
22 (0.0%)  	vpxor	%ymm1,%ymm0,%ymm0
22 (0.0%)  	addl	%ebp,%esi
22 (0.0%)  	rorxl	$27,%eax,%r12d
22 (0.0%)  	rorxl	$2,%eax,%ebp
22 (0.0%)  	vpxor	%ymm8,%ymm0,%ymm0
22 (0.0%)  	andl	%ebx,%eax
22 (0.0%)  	addl	%r12d,%esi
22 (0.0%)  	xorl	%edi,%eax
22 (0.0%)  	vpsrld	$30,%ymm0,%ymm8
22 (0.0%)  	vpslld	$2,%ymm0,%ymm0
22 (0.0%)  	addl	-124(%r13),%edx
22 (0.0%)  	andnl	%ebx,%esi,%edi
22 (0.0%)  	addl	%eax,%edx
22 (0.0%)  	rorxl	$27,%esi,%r12d
22 (0.0%)  	rorxl	$2,%esi,%eax
22 (0.0%)  	andl	%ebp,%esi
22 (0.0%)  	vpor	%ymm8,%ymm0,%ymm0
22 (0.0%)  	addl	%r12d,%edx
22 (0.0%)  	xorl	%edi,%esi
22 (0.0%)  	addl	-120(%r13),%ecx
22 (0.0%)  	andnl	%ebp,%edx,%edi
22 (0.0%)  	vpaddd	%ymm11,%ymm0,%ymm9
22 (0.0%)  	addl	%esi,%ecx
22 (0.0%)  	rorxl	$27,%edx,%r12d
22 (0.0%)  	rorxl	$2,%edx,%esi
22 (0.0%)  	andl	%eax,%edx
22 (0.0%)  	vmovdqu	%ymm9,256(%rsp)
22 (0.0%)  	addl	%r12d,%ecx
22 (0.0%)  	xorl	%edi,%edx
22 (0.0%)  	addl	-116(%r13),%ebx
22 (0.0%)  	andnl	%eax,%ecx,%edi
22 (0.0%)  	addl	%edx,%ebx
22 (0.0%)  	rorxl	$27,%ecx,%r12d
22 (0.0%)  	rorxl	$2,%ecx,%edx
22 (0.0%)  	andl	%esi,%ecx
22 (0.0%)  	addl	%r12d,%ebx
22 (0.0%)  	xorl	%edi,%ecx
22 (0.0%)  	addl	-96(%r13),%ebp
22 (0.0%)  	andnl	%esi,%ebx,%edi
22 (0.0%)  	addl	%ecx,%ebp
22 (0.0%)  	rorxl	$27,%ebx,%r12d
22 (0.0%)  	rorxl	$2,%ebx,%ecx
22 (0.0%)  	andl	%edx,%ebx
22 (0.0%)  	addl	%r12d,%ebp
22 (0.0%)  	xorl	%edi,%ebx
22 (0.0%)  	vpalignr	$8,%ymm7,%ymm0,%ymm8
22 (0.0%)  	vpxor	%ymm5,%ymm1,%ymm1
22 (0.0%)  	addl	-92(%r13),%eax
22 (0.0%)  	andnl	%edx,%ebp,%edi
22 (0.0%)  	vpxor	%ymm2,%ymm1,%ymm1
22 (0.0%)  	addl	%ebx,%eax
22 (0.0%)  	rorxl	$27,%ebp,%r12d
22 (0.0%)  	rorxl	$2,%ebp,%ebx
22 (0.0%)  	vpxor	%ymm8,%ymm1,%ymm1
22 (0.0%)  	andl	%ecx,%ebp
22 (0.0%)  	addl	%r12d,%eax
22 (0.0%)  	xorl	%edi,%ebp
22 (0.0%)  	vpsrld	$30,%ymm1,%ymm8
22 (0.0%)  	vpslld	$2,%ymm1,%ymm1
22 (0.0%)  	addl	-88(%r13),%esi
22 (0.0%)  	andnl	%ecx,%eax,%edi
22 (0.0%)  	addl	%ebp,%esi
22 (0.0%)  	rorxl	$27,%eax,%r12d
22 (0.0%)  	rorxl	$2,%eax,%ebp
22 (0.0%)  	andl	%ebx,%eax
22 (0.0%)  	vpor	%ymm8,%ymm1,%ymm1
22 (0.0%)  	addl	%r12d,%esi
22 (0.0%)  	xorl	%edi,%eax
22 (0.0%)  	addl	-84(%r13),%edx
22 (0.0%)  	andnl	%ebx,%esi,%edi
22 (0.0%)  	vpaddd	%ymm11,%ymm1,%ymm9
22 (0.0%)  	addl	%eax,%edx
22 (0.0%)  	rorxl	$27,%esi,%r12d
22 (0.0%)  	rorxl	$2,%esi,%eax
22 (0.0%)  	andl	%ebp,%esi
22 (0.0%)  	vmovdqu	%ymm9,288(%rsp)
22 (0.0%)  	addl	%r12d,%edx
22 (0.0%)  	xorl	%edi,%esi
22 (0.0%)  	addl	-64(%r13),%ecx
22 (0.0%)  	andnl	%ebp,%edx,%edi
22 (0.0%)  	addl	%esi,%ecx
22 (0.0%)  	rorxl	$27,%edx,%r12d
22 (0.0%)  	rorxl	$2,%edx,%esi
22 (0.0%)  	andl	%eax,%edx
22 (0.0%)  	addl	%r12d,%ecx
22 (0.0%)  	xorl	%edi,%edx
22 (0.0%)  	addl	-60(%r13),%ebx
22 (0.0%)  	andnl	%eax,%ecx,%edi
22 (0.0%)  	addl	%edx,%ebx
22 (0.0%)  	rorxl	$27,%ecx,%r12d
22 (0.0%)  	rorxl	$2,%ecx,%edx
22 (0.0%)  	andl	%esi,%ecx
22 (0.0%)  	addl	%r12d,%ebx
22 (0.0%)  	xorl	%edi,%ecx
22 (0.0%)  	vpalignr	$8,%ymm0,%ymm1,%ymm8
22 (0.0%)  	vpxor	%ymm6,%ymm2,%ymm2
22 (0.0%)  	addl	-56(%r13),%ebp
22 (0.0%)  	andnl	%esi,%ebx,%edi
22 (0.0%)  	vpxor	%ymm3,%ymm2,%ymm2
22 (0.0%)  	vmovdqu	0(%r14),%ymm11
22 (0.0%)  	addl	%ecx,%ebp
22 (0.0%)  	rorxl	$27,%ebx,%r12d
22 (0.0%)  	rorxl	$2,%ebx,%ecx
22 (0.0%)  	vpxor	%ymm8,%ymm2,%ymm2
22 (0.0%)  	andl	%edx,%ebx
22 (0.0%)  	addl	%r12d,%ebp
22 (0.0%)  	xorl	%edi,%ebx
22 (0.0%)  	vpsrld	$30,%ymm2,%ymm8
22 (0.0%)  	vpslld	$2,%ymm2,%ymm2
22 (0.0%)  	addl	-52(%r13),%eax
22 (0.0%)  	andnl	%edx,%ebp,%edi
22 (0.0%)  	addl	%ebx,%eax
22 (0.0%)  	rorxl	$27,%ebp,%r12d
22 (0.0%)  	rorxl	$2,%ebp,%ebx
22 (0.0%)  	andl	%ecx,%ebp
22 (0.0%)  	vpor	%ymm8,%ymm2,%ymm2
22 (0.0%)  	addl	%r12d,%eax
22 (0.0%)  	xorl	%edi,%ebp
22 (0.0%)  	addl	-32(%r13),%esi
22 (0.0%)  	andnl	%ecx,%eax,%edi
22 (0.0%)  	vpaddd	%ymm11,%ymm2,%ymm9
22 (0.0%)  	addl	%ebp,%esi
22 (0.0%)  	rorxl	$27,%eax,%r12d
22 (0.0%)  	rorxl	$2,%eax,%ebp
22 (0.0%)  	andl	%ebx,%eax
22 (0.0%)  	vmovdqu	%ymm9,320(%rsp)
22 (0.0%)  	addl	%r12d,%esi
22 (0.0%)  	xorl	%edi,%eax
22 (0.0%)  	addl	-28(%r13),%edx
22 (0.0%)  	andnl	%ebx,%esi,%edi
22 (0.0%)  	addl	%eax,%edx
22 (0.0%)  	rorxl	$27,%esi,%r12d
22 (0.0%)  	rorxl	$2,%esi,%eax
22 (0.0%)  	andl	%ebp,%esi
22 (0.0%)  	addl	%r12d,%edx
22 (0.0%)  	xorl	%edi,%esi
22 (0.0%)  	addl	-24(%r13),%ecx
22 (0.0%)  	andnl	%ebp,%edx,%edi
22 (0.0%)  	addl	%esi,%ecx
22 (0.0%)  	rorxl	$27,%edx,%r12d
22 (0.0%)  	rorxl	$2,%edx,%esi
22 (0.0%)  	andl	%eax,%edx
22 (0.0%)  	addl	%r12d,%ecx
22 (0.0%)  	xorl	%edi,%edx
22 (0.0%)  	vpalignr	$8,%ymm1,%ymm2,%ymm8
22 (0.0%)  	vpxor	%ymm7,%ymm3,%ymm3
22 (0.0%)  	addl	-20(%r13),%ebx
22 (0.0%)  	andnl	%eax,%ecx,%edi
22 (0.0%)  	vpxor	%ymm4,%ymm3,%ymm3
22 (0.0%)  	addl	%edx,%ebx
22 (0.0%)  	rorxl	$27,%ecx,%r12d
22 (0.0%)  	rorxl	$2,%ecx,%edx
22 (0.0%)  	vpxor	%ymm8,%ymm3,%ymm3
22 (0.0%)  	andl	%esi,%ecx
22 (0.0%)  	addl	%r12d,%ebx
22 (0.0%)  	xorl	%edi,%ecx
22 (0.0%)  	vpsrld	$30,%ymm3,%ymm8
22 (0.0%)  	vpslld	$2,%ymm3,%ymm3
22 (0.0%)  	addl	0(%r13),%ebp
22 (0.0%)  	andnl	%esi,%ebx,%edi
22 (0.0%)  	addl	%ecx,%ebp
22 (0.0%)  	rorxl	$27,%ebx,%r12d
22 (0.0%)  	rorxl	$2,%ebx,%ecx
22 (0.0%)  	andl	%edx,%ebx
22 (0.0%)  	vpor	%ymm8,%ymm3,%ymm3
22 (0.0%)  	addl	%r12d,%ebp
22 (0.0%)  	xorl	%edi,%ebx
22 (0.0%)  	addl	4(%r13),%eax
22 (0.0%)  	andnl	%edx,%ebp,%edi
22 (0.0%)  	vpaddd	%ymm11,%ymm3,%ymm9
22 (0.0%)  	addl	%ebx,%eax
22 (0.0%)  	rorxl	$27,%ebp,%r12d
22 (0.0%)  	rorxl	$2,%ebp,%ebx
22 (0.0%)  	andl	%ecx,%ebp
22 (0.0%)  	vmovdqu	%ymm9,352(%rsp)
22 (0.0%)  	addl	%r12d,%eax
22 (0.0%)  	xorl	%edi,%ebp
22 (0.0%)  	addl	8(%r13),%esi
22 (0.0%)  	andnl	%ecx,%eax,%edi
22 (0.0%)  	addl	%ebp,%esi
22 (0.0%)  	rorxl	$27,%eax,%r12d
22 (0.0%)  	rorxl	$2,%eax,%ebp
22 (0.0%)  	andl	%ebx,%eax
22 (0.0%)  	addl	%r12d,%esi
22 (0.0%)  	xorl	%edi,%eax
22 (0.0%)  	addl	12(%r13),%edx
22 (0.0%)  	leal	(%rdx,%rax,1),%edx
22 (0.0%)  	rorxl	$27,%esi,%r12d
22 (0.0%)  	rorxl	$2,%esi,%eax
22 (0.0%)  	xorl	%ebp,%esi
22 (0.0%)  	addl	%r12d,%edx
22 (0.0%)  	xorl	%ebx,%esi
22 (0.0%)  	vpalignr	$8,%ymm2,%ymm3,%ymm8
22 (0.0%)  	vpxor	%ymm0,%ymm4,%ymm4
22 (0.0%)  	addl	32(%r13),%ecx
22 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
22 (0.0%)  	vpxor	%ymm5,%ymm4,%ymm4
22 (0.0%)  	rorxl	$27,%edx,%r12d
22 (0.0%)  	rorxl	$2,%edx,%esi
22 (0.0%)  	xorl	%eax,%edx
22 (0.0%)  	vpxor	%ymm8,%ymm4,%ymm4
22 (0.0%)  	addl	%r12d,%ecx
22 (0.0%)  	xorl	%ebp,%edx
22 (0.0%)  	addl	36(%r13),%ebx
22 (0.0%)  	vpsrld	$30,%ymm4,%ymm8
22 (0.0%)  	vpslld	$2,%ymm4,%ymm4
22 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
22 (0.0%)  	rorxl	$27,%ecx,%r12d
22 (0.0%)  	rorxl	$2,%ecx,%edx
22 (0.0%)  	xorl	%esi,%ecx
22 (0.0%)  	addl	%r12d,%ebx
22 (0.0%)  	xorl	%eax,%ecx
22 (0.0%)  	vpor	%ymm8,%ymm4,%ymm4
22 (0.0%)  	addl	40(%r13),%ebp
22 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
22 (0.0%)  	rorxl	$27,%ebx,%r12d
22 (0.0%)  	rorxl	$2,%ebx,%ecx
22 (0.0%)  	vpaddd	%ymm11,%ymm4,%ymm9
22 (0.0%)  	xorl	%edx,%ebx
22 (0.0%)  	addl	%r12d,%ebp
22 (0.0%)  	xorl	%esi,%ebx
22 (0.0%)  	addl	44(%r13),%eax
22 (0.0%)  	vmovdqu	%ymm9,384(%rsp)
22 (0.0%)  	leal	(%rax,%rbx,1),%eax
22 (0.0%)  	rorxl	$27,%ebp,%r12d
22 (0.0%)  	rorxl	$2,%ebp,%ebx
22 (0.0%)  	xorl	%ecx,%ebp
22 (0.0%)  	addl	%r12d,%eax
22 (0.0%)  	xorl	%edx,%ebp
22 (0.0%)  	addl	64(%r13),%esi
22 (0.0%)  	leal	(%rsi,%rbp,1),%esi
22 (0.0%)  	rorxl	$27,%eax,%r12d
22 (0.0%)  	rorxl	$2,%eax,%ebp
22 (0.0%)  	xorl	%ebx,%eax
22 (0.0%)  	addl	%r12d,%esi
22 (0.0%)  	xorl	%ecx,%eax
22 (0.0%)  	vpalignr	$8,%ymm3,%ymm4,%ymm8
22 (0.0%)  	vpxor	%ymm1,%ymm5,%ymm5
22 (0.0%)  	addl	68(%r13),%edx
22 (0.0%)  	leal	(%rdx,%rax,1),%edx
22 (0.0%)  	vpxor	%ymm6,%ymm5,%ymm5
22 (0.0%)  	rorxl	$27,%esi,%r12d
22 (0.0%)  	rorxl	$2,%esi,%eax
22 (0.0%)  	xorl	%ebp,%esi
22 (0.0%)  	vpxor	%ymm8,%ymm5,%ymm5
22 (0.0%)  	addl	%r12d,%edx
22 (0.0%)  	xorl	%ebx,%esi
22 (0.0%)  	addl	72(%r13),%ecx
22 (0.0%)  	vpsrld	$30,%ymm5,%ymm8
22 (0.0%)  	vpslld	$2,%ymm5,%ymm5
22 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
22 (0.0%)  	rorxl	$27,%edx,%r12d
22 (0.0%)  	rorxl	$2,%edx,%esi
22 (0.0%)  	xorl	%eax,%edx
22 (0.0%)  	addl	%r12d,%ecx
22 (0.0%)  	xorl	%ebp,%edx
22 (0.0%)  	vpor	%ymm8,%ymm5,%ymm5
22 (0.0%)  	addl	76(%r13),%ebx
22 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
22 (0.0%)  	rorxl	$27,%ecx,%r12d
22 (0.0%)  	rorxl	$2,%ecx,%edx
22 (0.0%)  	vpaddd	%ymm11,%ymm5,%ymm9
22 (0.0%)  	xorl	%esi,%ecx
22 (0.0%)  	addl	%r12d,%ebx
22 (0.0%)  	xorl	%eax,%ecx
22 (0.0%)  	addl	96(%r13),%ebp
22 (0.0%)  	vmovdqu	%ymm9,416(%rsp)
22 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
22 (0.0%)  	rorxl	$27,%ebx,%r12d
22 (0.0%)  	rorxl	$2,%ebx,%ecx
22 (0.0%)  	xorl	%edx,%ebx
22 (0.0%)  	addl	%r12d,%ebp
22 (0.0%)  	xorl	%esi,%ebx
22 (0.0%)  	addl	100(%r13),%eax
22 (0.0%)  	leal	(%rax,%rbx,1),%eax
22 (0.0%)  	rorxl	$27,%ebp,%r12d
22 (0.0%)  	rorxl	$2,%ebp,%ebx
22 (0.0%)  	xorl	%ecx,%ebp
22 (0.0%)  	addl	%r12d,%eax
22 (0.0%)  	xorl	%edx,%ebp
22 (0.0%)  	vpalignr	$8,%ymm4,%ymm5,%ymm8
22 (0.0%)  	vpxor	%ymm2,%ymm6,%ymm6
22 (0.0%)  	addl	104(%r13),%esi
22 (0.0%)  	leal	(%rsi,%rbp,1),%esi
22 (0.0%)  	vpxor	%ymm7,%ymm6,%ymm6
22 (0.0%)  	rorxl	$27,%eax,%r12d
22 (0.0%)  	rorxl	$2,%eax,%ebp
22 (0.0%)  	xorl	%ebx,%eax
22 (0.0%)  	vpxor	%ymm8,%ymm6,%ymm6
22 (0.0%)  	addl	%r12d,%esi
22 (0.0%)  	xorl	%ecx,%eax
22 (0.0%)  	addl	108(%r13),%edx
22 (0.0%)  	leaq	256(%r13),%r13
22 (0.0%)  	vpsrld	$30,%ymm6,%ymm8
22 (0.0%)  	vpslld	$2,%ymm6,%ymm6
22 (0.0%)  	leal	(%rdx,%rax,1),%edx
22 (0.0%)  	rorxl	$27,%esi,%r12d
22 (0.0%)  	rorxl	$2,%esi,%eax
22 (0.0%)  	xorl	%ebp,%esi
22 (0.0%)  	addl	%r12d,%edx
22 (0.0%)  	xorl	%ebx,%esi
22 (0.0%)  	vpor	%ymm8,%ymm6,%ymm6
22 (0.0%)  	addl	-128(%r13),%ecx
22 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
22 (0.0%)  	rorxl	$27,%edx,%r12d
22 (0.0%)  	rorxl	$2,%edx,%esi
22 (0.0%)  	vpaddd	%ymm11,%ymm6,%ymm9
22 (0.0%)  	xorl	%eax,%edx
22 (0.0%)  	addl	%r12d,%ecx
22 (0.0%)  	xorl	%ebp,%edx
22 (0.0%)  	addl	-124(%r13),%ebx
22 (0.0%)  	vmovdqu	%ymm9,448(%rsp)
22 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
22 (0.0%)  	rorxl	$27,%ecx,%r12d
22 (0.0%)  	rorxl	$2,%ecx,%edx
22 (0.0%)  	xorl	%esi,%ecx
22 (0.0%)  	addl	%r12d,%ebx
22 (0.0%)  	xorl	%eax,%ecx
22 (0.0%)  	addl	-120(%r13),%ebp
22 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
22 (0.0%)  	rorxl	$27,%ebx,%r12d
22 (0.0%)  	rorxl	$2,%ebx,%ecx
22 (0.0%)  	xorl	%edx,%ebx
22 (0.0%)  	addl	%r12d,%ebp
22 (0.0%)  	xorl	%esi,%ebx
22 (0.0%)  	vpalignr	$8,%ymm5,%ymm6,%ymm8
22 (0.0%)  	vpxor	%ymm3,%ymm7,%ymm7
22 (0.0%)  	addl	-116(%r13),%eax
22 (0.0%)  	leal	(%rax,%rbx,1),%eax
22 (0.0%)  	vpxor	%ymm0,%ymm7,%ymm7
22 (0.0%)  	vmovdqu	32(%r14),%ymm11
22 (0.0%)  	rorxl	$27,%ebp,%r12d
22 (0.0%)  	rorxl	$2,%ebp,%ebx
22 (0.0%)  	xorl	%ecx,%ebp
22 (0.0%)  	vpxor	%ymm8,%ymm7,%ymm7
22 (0.0%)  	addl	%r12d,%eax
22 (0.0%)  	xorl	%edx,%ebp
22 (0.0%)  	addl	-96(%r13),%esi
22 (0.0%)  	vpsrld	$30,%ymm7,%ymm8
22 (0.0%)  	vpslld	$2,%ymm7,%ymm7
22 (0.0%)  	leal	(%rsi,%rbp,1),%esi
22 (0.0%)  	rorxl	$27,%eax,%r12d
22 (0.0%)  	rorxl	$2,%eax,%ebp
22 (0.0%)  	xorl	%ebx,%eax
22 (0.0%)  	addl	%r12d,%esi
22 (0.0%)  	xorl	%ecx,%eax
22 (0.0%)  	vpor	%ymm8,%ymm7,%ymm7
22 (0.0%)  	addl	-92(%r13),%edx
22 (0.0%)  	leal	(%rdx,%rax,1),%edx
22 (0.0%)  	rorxl	$27,%esi,%r12d
22 (0.0%)  	rorxl	$2,%esi,%eax
22 (0.0%)  	vpaddd	%ymm11,%ymm7,%ymm9
22 (0.0%)  	xorl	%ebp,%esi
22 (0.0%)  	addl	%r12d,%edx
22 (0.0%)  	xorl	%ebx,%esi
22 (0.0%)  	addl	-88(%r13),%ecx
22 (0.0%)  	vmovdqu	%ymm9,480(%rsp)
22 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
22 (0.0%)  	rorxl	$27,%edx,%r12d
22 (0.0%)  	rorxl	$2,%edx,%esi
22 (0.0%)  	xorl	%eax,%edx
22 (0.0%)  	addl	%r12d,%ecx
22 (0.0%)  	xorl	%ebp,%edx
22 (0.0%)  	addl	-84(%r13),%ebx
22 (0.0%)  	movl	%esi,%edi
22 (0.0%)  	xorl	%eax,%edi
22 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
22 (0.0%)  	rorxl	$27,%ecx,%r12d
22 (0.0%)  	rorxl	$2,%ecx,%edx
22 (0.0%)  	xorl	%esi,%ecx
22 (0.0%)  	addl	%r12d,%ebx
22 (0.0%)  	andl	%edi,%ecx
22 (0.0%)  	jmp	.Lalign32_2
 .         .align	32
 .         .Lalign32_2:
22 (0.0%)  	vpalignr	$8,%ymm6,%ymm7,%ymm8
22 (0.0%)  	vpxor	%ymm4,%ymm0,%ymm0
22 (0.0%)  	addl	-64(%r13),%ebp
22 (0.0%)  	xorl	%esi,%ecx
22 (0.0%)  	vpxor	%ymm1,%ymm0,%ymm0
22 (0.0%)  	movl	%edx,%edi
22 (0.0%)  	xorl	%esi,%edi
22 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
22 (0.0%)  	vpxor	%ymm8,%ymm0,%ymm0
22 (0.0%)  	rorxl	$27,%ebx,%r12d
22 (0.0%)  	rorxl	$2,%ebx,%ecx
22 (0.0%)  	xorl	%edx,%ebx
22 (0.0%)  	vpsrld	$30,%ymm0,%ymm8
22 (0.0%)  	vpslld	$2,%ymm0,%ymm0
22 (0.0%)  	addl	%r12d,%ebp
22 (0.0%)  	andl	%edi,%ebx
22 (0.0%)  	addl	-60(%r13),%eax
22 (0.0%)  	xorl	%edx,%ebx
22 (0.0%)  	movl	%ecx,%edi
22 (0.0%)  	xorl	%edx,%edi
22 (0.0%)  	vpor	%ymm8,%ymm0,%ymm0
22 (0.0%)  	leal	(%rax,%rbx,1),%eax
22 (0.0%)  	rorxl	$27,%ebp,%r12d
22 (0.0%)  	rorxl	$2,%ebp,%ebx
22 (0.0%)  	xorl	%ecx,%ebp
22 (0.0%)  	vpaddd	%ymm11,%ymm0,%ymm9
22 (0.0%)  	addl	%r12d,%eax
22 (0.0%)  	andl	%edi,%ebp
22 (0.0%)  	addl	-56(%r13),%esi
22 (0.0%)  	xorl	%ecx,%ebp
22 (0.0%)  	vmovdqu	%ymm9,512(%rsp)
22 (0.0%)  	movl	%ebx,%edi
22 (0.0%)  	xorl	%ecx,%edi
22 (0.0%)  	leal	(%rsi,%rbp,1),%esi
22 (0.0%)  	rorxl	$27,%eax,%r12d
22 (0.0%)  	rorxl	$2,%eax,%ebp
22 (0.0%)  	xorl	%ebx,%eax
22 (0.0%)  	addl	%r12d,%esi
22 (0.0%)  	andl	%edi,%eax
22 (0.0%)  	addl	-52(%r13),%edx
22 (0.0%)  	xorl	%ebx,%eax
22 (0.0%)  	movl	%ebp,%edi
22 (0.0%)  	xorl	%ebx,%edi
22 (0.0%)  	leal	(%rdx,%rax,1),%edx
22 (0.0%)  	rorxl	$27,%esi,%r12d
22 (0.0%)  	rorxl	$2,%esi,%eax
22 (0.0%)  	xorl	%ebp,%esi
22 (0.0%)  	addl	%r12d,%edx
22 (0.0%)  	andl	%edi,%esi
22 (0.0%)  	addl	-32(%r13),%ecx
22 (0.0%)  	xorl	%ebp,%esi
22 (0.0%)  	movl	%eax,%edi
22 (0.0%)  	xorl	%ebp,%edi
22 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
22 (0.0%)  	rorxl	$27,%edx,%r12d
22 (0.0%)  	rorxl	$2,%edx,%esi
22 (0.0%)  	xorl	%eax,%edx
22 (0.0%)  	addl	%r12d,%ecx
22 (0.0%)  	andl	%edi,%edx
22 (0.0%)  	vpalignr	$8,%ymm7,%ymm0,%ymm8
22 (0.0%)  	vpxor	%ymm5,%ymm1,%ymm1
22 (0.0%)  	addl	-28(%r13),%ebx
22 (0.0%)  	xorl	%eax,%edx
22 (0.0%)  	vpxor	%ymm2,%ymm1,%ymm1
22 (0.0%)  	movl	%esi,%edi
22 (0.0%)  	xorl	%eax,%edi
22 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
22 (0.0%)  	vpxor	%ymm8,%ymm1,%ymm1
22 (0.0%)  	rorxl	$27,%ecx,%r12d
22 (0.0%)  	rorxl	$2,%ecx,%edx
22 (0.0%)  	xorl	%esi,%ecx
22 (0.0%)  	vpsrld	$30,%ymm1,%ymm8
22 (0.0%)  	vpslld	$2,%ymm1,%ymm1
22 (0.0%)  	addl	%r12d,%ebx
22 (0.0%)  	andl	%edi,%ecx
22 (0.0%)  	addl	-24(%r13),%ebp
22 (0.0%)  	xorl	%esi,%ecx
22 (0.0%)  	movl	%edx,%edi
22 (0.0%)  	xorl	%esi,%edi
22 (0.0%)  	vpor	%ymm8,%ymm1,%ymm1
22 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
22 (0.0%)  	rorxl	$27,%ebx,%r12d
22 (0.0%)  	rorxl	$2,%ebx,%ecx
22 (0.0%)  	xorl	%edx,%ebx
22 (0.0%)  	vpaddd	%ymm11,%ymm1,%ymm9
22 (0.0%)  	addl	%r12d,%ebp
22 (0.0%)  	andl	%edi,%ebx
22 (0.0%)  	addl	-20(%r13),%eax
22 (0.0%)  	xorl	%edx,%ebx
22 (0.0%)  	vmovdqu	%ymm9,544(%rsp)
22 (0.0%)  	movl	%ecx,%edi
22 (0.0%)  	xorl	%edx,%edi
22 (0.0%)  	leal	(%rax,%rbx,1),%eax
22 (0.0%)  	rorxl	$27,%ebp,%r12d
22 (0.0%)  	rorxl	$2,%ebp,%ebx
22 (0.0%)  	xorl	%ecx,%ebp
22 (0.0%)  	addl	%r12d,%eax
22 (0.0%)  	andl	%edi,%ebp
22 (0.0%)  	addl	0(%r13),%esi
22 (0.0%)  	xorl	%ecx,%ebp
22 (0.0%)  	movl	%ebx,%edi
22 (0.0%)  	xorl	%ecx,%edi
22 (0.0%)  	leal	(%rsi,%rbp,1),%esi
22 (0.0%)  	rorxl	$27,%eax,%r12d
22 (0.0%)  	rorxl	$2,%eax,%ebp
22 (0.0%)  	xorl	%ebx,%eax
22 (0.0%)  	addl	%r12d,%esi
22 (0.0%)  	andl	%edi,%eax
22 (0.0%)  	addl	4(%r13),%edx
22 (0.0%)  	xorl	%ebx,%eax
22 (0.0%)  	movl	%ebp,%edi
22 (0.0%)  	xorl	%ebx,%edi
22 (0.0%)  	leal	(%rdx,%rax,1),%edx
22 (0.0%)  	rorxl	$27,%esi,%r12d
22 (0.0%)  	rorxl	$2,%esi,%eax
22 (0.0%)  	xorl	%ebp,%esi
22 (0.0%)  	addl	%r12d,%edx
22 (0.0%)  	andl	%edi,%esi
22 (0.0%)  	vpalignr	$8,%ymm0,%ymm1,%ymm8
22 (0.0%)  	vpxor	%ymm6,%ymm2,%ymm2
22 (0.0%)  	addl	8(%r13),%ecx
22 (0.0%)  	xorl	%ebp,%esi
22 (0.0%)  	vpxor	%ymm3,%ymm2,%ymm2
22 (0.0%)  	movl	%eax,%edi
22 (0.0%)  	xorl	%ebp,%edi
22 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
22 (0.0%)  	vpxor	%ymm8,%ymm2,%ymm2
22 (0.0%)  	rorxl	$27,%edx,%r12d
22 (0.0%)  	rorxl	$2,%edx,%esi
22 (0.0%)  	xorl	%eax,%edx
22 (0.0%)  	vpsrld	$30,%ymm2,%ymm8
22 (0.0%)  	vpslld	$2,%ymm2,%ymm2
22 (0.0%)  	addl	%r12d,%ecx
22 (0.0%)  	andl	%edi,%edx
22 (0.0%)  	addl	12(%r13),%ebx
22 (0.0%)  	xorl	%eax,%edx
22 (0.0%)  	movl	%esi,%edi
22 (0.0%)  	xorl	%eax,%edi
22 (0.0%)  	vpor	%ymm8,%ymm2,%ymm2
22 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
22 (0.0%)  	rorxl	$27,%ecx,%r12d
22 (0.0%)  	rorxl	$2,%ecx,%edx
22 (0.0%)  	xorl	%esi,%ecx
22 (0.0%)  	vpaddd	%ymm11,%ymm2,%ymm9
22 (0.0%)  	addl	%r12d,%ebx
22 (0.0%)  	andl	%edi,%ecx
22 (0.0%)  	addl	32(%r13),%ebp
22 (0.0%)  	xorl	%esi,%ecx
22 (0.0%)  	vmovdqu	%ymm9,576(%rsp)
22 (0.0%)  	movl	%edx,%edi
22 (0.0%)  	xorl	%esi,%edi
22 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
22 (0.0%)  	rorxl	$27,%ebx,%r12d
22 (0.0%)  	rorxl	$2,%ebx,%ecx
22 (0.0%)  	xorl	%edx,%ebx
22 (0.0%)  	addl	%r12d,%ebp
22 (0.0%)  	andl	%edi,%ebx
22 (0.0%)  	addl	36(%r13),%eax
22 (0.0%)  	xorl	%edx,%ebx
22 (0.0%)  	movl	%ecx,%edi
22 (0.0%)  	xorl	%edx,%edi
22 (0.0%)  	leal	(%rax,%rbx,1),%eax
22 (0.0%)  	rorxl	$27,%ebp,%r12d
22 (0.0%)  	rorxl	$2,%ebp,%ebx
22 (0.0%)  	xorl	%ecx,%ebp
22 (0.0%)  	addl	%r12d,%eax
22 (0.0%)  	andl	%edi,%ebp
22 (0.0%)  	addl	40(%r13),%esi
22 (0.0%)  	xorl	%ecx,%ebp
22 (0.0%)  	movl	%ebx,%edi
22 (0.0%)  	xorl	%ecx,%edi
22 (0.0%)  	leal	(%rsi,%rbp,1),%esi
22 (0.0%)  	rorxl	$27,%eax,%r12d
22 (0.0%)  	rorxl	$2,%eax,%ebp
22 (0.0%)  	xorl	%ebx,%eax
22 (0.0%)  	addl	%r12d,%esi
22 (0.0%)  	andl	%edi,%eax
22 (0.0%)  	vpalignr	$8,%ymm1,%ymm2,%ymm8
22 (0.0%)  	vpxor	%ymm7,%ymm3,%ymm3
22 (0.0%)  	addl	44(%r13),%edx
22 (0.0%)  	xorl	%ebx,%eax
22 (0.0%)  	vpxor	%ymm4,%ymm3,%ymm3
22 (0.0%)  	movl	%ebp,%edi
22 (0.0%)  	xorl	%ebx,%edi
22 (0.0%)  	leal	(%rdx,%rax,1),%edx
22 (0.0%)  	vpxor	%ymm8,%ymm3,%ymm3
22 (0.0%)  	rorxl	$27,%esi,%r12d
22 (0.0%)  	rorxl	$2,%esi,%eax
22 (0.0%)  	xorl	%ebp,%esi
22 (0.0%)  	vpsrld	$30,%ymm3,%ymm8
22 (0.0%)  	vpslld	$2,%ymm3,%ymm3
22 (0.0%)  	addl	%r12d,%edx
22 (0.0%)  	andl	%edi,%esi
22 (0.0%)  	addl	64(%r13),%ecx
22 (0.0%)  	xorl	%ebp,%esi
22 (0.0%)  	movl	%eax,%edi
22 (0.0%)  	xorl	%ebp,%edi
22 (0.0%)  	vpor	%ymm8,%ymm3,%ymm3
22 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
22 (0.0%)  	rorxl	$27,%edx,%r12d
22 (0.0%)  	rorxl	$2,%edx,%esi
22 (0.0%)  	xorl	%eax,%edx
22 (0.0%)  	vpaddd	%ymm11,%ymm3,%ymm9
22 (0.0%)  	addl	%r12d,%ecx
22 (0.0%)  	andl	%edi,%edx
22 (0.0%)  	addl	68(%r13),%ebx
22 (0.0%)  	xorl	%eax,%edx
22 (0.0%)  	vmovdqu	%ymm9,608(%rsp)
22 (0.0%)  	movl	%esi,%edi
22 (0.0%)  	xorl	%eax,%edi
22 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
22 (0.0%)  	rorxl	$27,%ecx,%r12d
22 (0.0%)  	rorxl	$2,%ecx,%edx
22 (0.0%)  	xorl	%esi,%ecx
22 (0.0%)  	addl	%r12d,%ebx
22 (0.0%)  	andl	%edi,%ecx
22 (0.0%)  	addl	72(%r13),%ebp
22 (0.0%)  	xorl	%esi,%ecx
22 (0.0%)  	movl	%edx,%edi
22 (0.0%)  	xorl	%esi,%edi
22 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
22 (0.0%)  	rorxl	$27,%ebx,%r12d
22 (0.0%)  	rorxl	$2,%ebx,%ecx
22 (0.0%)  	xorl	%edx,%ebx
22 (0.0%)  	addl	%r12d,%ebp
22 (0.0%)  	andl	%edi,%ebx
22 (0.0%)  	addl	76(%r13),%eax
22 (0.0%)  	xorl	%edx,%ebx
22 (0.0%)  	leal	(%rax,%rbx,1),%eax
22 (0.0%)  	rorxl	$27,%ebp,%r12d
22 (0.0%)  	rorxl	$2,%ebp,%ebx
22 (0.0%)  	xorl	%ecx,%ebp
22 (0.0%)  	addl	%r12d,%eax
22 (0.0%)  	xorl	%edx,%ebp
22 (0.0%)  	addl	96(%r13),%esi
22 (0.0%)  	leal	(%rsi,%rbp,1),%esi
22 (0.0%)  	rorxl	$27,%eax,%r12d
22 (0.0%)  	rorxl	$2,%eax,%ebp
22 (0.0%)  	xorl	%ebx,%eax
22 (0.0%)  	addl	%r12d,%esi
22 (0.0%)  	xorl	%ecx,%eax
22 (0.0%)  	addl	100(%r13),%edx
22 (0.0%)  	leal	(%rdx,%rax,1),%edx
22 (0.0%)  	rorxl	$27,%esi,%r12d
22 (0.0%)  	rorxl	$2,%esi,%eax
22 (0.0%)  	xorl	%ebp,%esi
22 (0.0%)  	addl	%r12d,%edx
22 (0.0%)  	xorl	%ebx,%esi
22 (0.0%)  	addl	104(%r13),%ecx
22 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
22 (0.0%)  	rorxl	$27,%edx,%r12d
22 (0.0%)  	rorxl	$2,%edx,%esi
22 (0.0%)  	xorl	%eax,%edx
22 (0.0%)  	addl	%r12d,%ecx
22 (0.0%)  	xorl	%ebp,%edx
22 (0.0%)  	addl	108(%r13),%ebx
22 (0.0%)  	leaq	256(%r13),%r13
22 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
22 (0.0%)  	rorxl	$27,%ecx,%r12d
22 (0.0%)  	rorxl	$2,%ecx,%edx
22 (0.0%)  	xorl	%esi,%ecx
22 (0.0%)  	addl	%r12d,%ebx
22 (0.0%)  	xorl	%eax,%ecx
22 (0.0%)  	addl	-128(%r13),%ebp
22 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
22 (0.0%)  	rorxl	$27,%ebx,%r12d
22 (0.0%)  	rorxl	$2,%ebx,%ecx
22 (0.0%)  	xorl	%edx,%ebx
22 (0.0%)  	addl	%r12d,%ebp
22 (0.0%)  	xorl	%esi,%ebx
22 (0.0%)  	addl	-124(%r13),%eax
22 (0.0%)  	leal	(%rax,%rbx,1),%eax
22 (0.0%)  	rorxl	$27,%ebp,%r12d
22 (0.0%)  	rorxl	$2,%ebp,%ebx
22 (0.0%)  	xorl	%ecx,%ebp
22 (0.0%)  	addl	%r12d,%eax
22 (0.0%)  	xorl	%edx,%ebp
22 (0.0%)  	addl	-120(%r13),%esi
22 (0.0%)  	leal	(%rsi,%rbp,1),%esi
22 (0.0%)  	rorxl	$27,%eax,%r12d
22 (0.0%)  	rorxl	$2,%eax,%ebp
22 (0.0%)  	xorl	%ebx,%eax
22 (0.0%)  	addl	%r12d,%esi
22 (0.0%)  	xorl	%ecx,%eax
22 (0.0%)  	addl	-116(%r13),%edx
22 (0.0%)  	leal	(%rdx,%rax,1),%edx
22 (0.0%)  	rorxl	$27,%esi,%r12d
22 (0.0%)  	rorxl	$2,%esi,%eax
22 (0.0%)  	xorl	%ebp,%esi
22 (0.0%)  	addl	%r12d,%edx
22 (0.0%)  	xorl	%ebx,%esi
22 (0.0%)  	addl	-96(%r13),%ecx
22 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
22 (0.0%)  	rorxl	$27,%edx,%r12d
22 (0.0%)  	rorxl	$2,%edx,%esi
22 (0.0%)  	xorl	%eax,%edx
22 (0.0%)  	addl	%r12d,%ecx
22 (0.0%)  	xorl	%ebp,%edx
22 (0.0%)  	addl	-92(%r13),%ebx
22 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
22 (0.0%)  	rorxl	$27,%ecx,%r12d
22 (0.0%)  	rorxl	$2,%ecx,%edx
22 (0.0%)  	xorl	%esi,%ecx
22 (0.0%)  	addl	%r12d,%ebx
22 (0.0%)  	xorl	%eax,%ecx
22 (0.0%)  	addl	-88(%r13),%ebp
22 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
22 (0.0%)  	rorxl	$27,%ebx,%r12d
22 (0.0%)  	rorxl	$2,%ebx,%ecx
22 (0.0%)  	xorl	%edx,%ebx
22 (0.0%)  	addl	%r12d,%ebp
22 (0.0%)  	xorl	%esi,%ebx
22 (0.0%)  	addl	-84(%r13),%eax
22 (0.0%)  	leal	(%rax,%rbx,1),%eax
22 (0.0%)  	rorxl	$27,%ebp,%r12d
22 (0.0%)  	rorxl	$2,%ebp,%ebx
22 (0.0%)  	xorl	%ecx,%ebp
22 (0.0%)  	addl	%r12d,%eax
22 (0.0%)  	xorl	%edx,%ebp
22 (0.0%)  	addl	-64(%r13),%esi
22 (0.0%)  	leal	(%rsi,%rbp,1),%esi
22 (0.0%)  	rorxl	$27,%eax,%r12d
22 (0.0%)  	rorxl	$2,%eax,%ebp
22 (0.0%)  	xorl	%ebx,%eax
22 (0.0%)  	addl	%r12d,%esi
22 (0.0%)  	xorl	%ecx,%eax
22 (0.0%)  	addl	-60(%r13),%edx
22 (0.0%)  	leal	(%rdx,%rax,1),%edx
22 (0.0%)  	rorxl	$27,%esi,%r12d
22 (0.0%)  	rorxl	$2,%esi,%eax
22 (0.0%)  	xorl	%ebp,%esi
22 (0.0%)  	addl	%r12d,%edx
22 (0.0%)  	xorl	%ebx,%esi
22 (0.0%)  	addl	-56(%r13),%ecx
22 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
22 (0.0%)  	rorxl	$27,%edx,%r12d
22 (0.0%)  	rorxl	$2,%edx,%esi
22 (0.0%)  	xorl	%eax,%edx
22 (0.0%)  	addl	%r12d,%ecx
22 (0.0%)  	xorl	%ebp,%edx
22 (0.0%)  	addl	-52(%r13),%ebx
22 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
22 (0.0%)  	rorxl	$27,%ecx,%r12d
22 (0.0%)  	rorxl	$2,%ecx,%edx
22 (0.0%)  	xorl	%esi,%ecx
22 (0.0%)  	addl	%r12d,%ebx
22 (0.0%)  	xorl	%eax,%ecx
22 (0.0%)  	addl	-32(%r13),%ebp
22 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
22 (0.0%)  	rorxl	$27,%ebx,%r12d
22 (0.0%)  	rorxl	$2,%ebx,%ecx
22 (0.0%)  	xorl	%edx,%ebx
22 (0.0%)  	addl	%r12d,%ebp
22 (0.0%)  	xorl	%esi,%ebx
22 (0.0%)  	addl	-28(%r13),%eax
22 (0.0%)  	leal	(%rax,%rbx,1),%eax
22 (0.0%)  	rorxl	$27,%ebp,%r12d
22 (0.0%)  	rorxl	$2,%ebp,%ebx
22 (0.0%)  	xorl	%ecx,%ebp
22 (0.0%)  	addl	%r12d,%eax
22 (0.0%)  	xorl	%edx,%ebp
22 (0.0%)  	addl	-24(%r13),%esi
22 (0.0%)  	leal	(%rsi,%rbp,1),%esi
22 (0.0%)  	rorxl	$27,%eax,%r12d
22 (0.0%)  	rorxl	$2,%eax,%ebp
22 (0.0%)  	xorl	%ebx,%eax
22 (0.0%)  	addl	%r12d,%esi
22 (0.0%)  	xorl	%ecx,%eax
22 (0.0%)  	addl	-20(%r13),%edx
22 (0.0%)  	leal	(%rdx,%rax,1),%edx
22 (0.0%)  	rorxl	$27,%esi,%r12d
22 (0.0%)  	addl	%r12d,%edx
22 (0.0%)  	leaq	128(%r9),%r13
22 (0.0%)  	leaq	128(%r9),%rdi
22 (0.0%)  	cmpq	%r10,%r13
22 (0.0%)  	cmovaeq	%r9,%r13
 .         
 .         
22 (0.0%)  	addl	0(%r8),%edx
22 (0.0%)  	addl	4(%r8),%esi
22 (0.0%)  	addl	8(%r8),%ebp
22 (0.0%)  	movl	%edx,0(%r8)
22 (0.0%)  	addl	12(%r8),%ebx
22 (0.0%)  	movl	%esi,4(%r8)
22 (0.0%)  	movl	%edx,%eax
22 (0.0%)  	addl	16(%r8),%ecx
22 (0.0%)  	movl	%ebp,%r12d
22 (0.0%)  	movl	%ebp,8(%r8)
22 (0.0%)  	movl	%ebx,%edx
 .         
22 (0.0%)  	movl	%ebx,12(%r8)
22 (0.0%)  	movl	%esi,%ebp
22 (0.0%)  	movl	%ecx,16(%r8)
 .         
22 (0.0%)  	movl	%ecx,%esi
22 (0.0%)  	movl	%r12d,%ecx
 .         
 .         
22 (0.0%)  	cmpq	%r10,%r9
22 (0.0%)  	je	.Ldone_avx2
12 (0.0%)  	vmovdqu	64(%r14),%ymm6
12 (0.0%)  	cmpq	%r10,%rdi
12 (0.0%)  	ja	.Last_avx2
 .         
 8 (0.0%)  	vmovdqu	-64(%rdi),%xmm0
 8 (0.0%)  	vmovdqu	-48(%rdi),%xmm1
 8 (0.0%)  	vmovdqu	-32(%rdi),%xmm2
 8 (0.0%)  	vmovdqu	-16(%rdi),%xmm3
 8 (0.0%)  	vinserti128	$1,0(%r13),%ymm0,%ymm0
 8 (0.0%)  	vinserti128	$1,16(%r13),%ymm1,%ymm1
 8 (0.0%)  	vinserti128	$1,32(%r13),%ymm2,%ymm2
 8 (0.0%)  	vinserti128	$1,48(%r13),%ymm3,%ymm3
 8 (0.0%)  	jmp	.Last_avx2
 .         
 .         .align	32
 .         .Last_avx2:
12 (0.0%)  	leaq	128+16(%rsp),%r13
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	andnl	%edx,%ebp,%edi
12 (0.0%)  	andl	%ecx,%ebp
12 (0.0%)  	xorl	%edi,%ebp
12 (0.0%)  	subq	$-128,%r9
12 (0.0%)  	addl	-128(%r13),%esi
12 (0.0%)  	andnl	%ecx,%eax,%edi
12 (0.0%)  	addl	%ebp,%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	andl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%edi,%eax
12 (0.0%)  	addl	-124(%r13),%edx
12 (0.0%)  	andnl	%ebx,%esi,%edi
12 (0.0%)  	addl	%eax,%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	andl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%edi,%esi
12 (0.0%)  	addl	-120(%r13),%ecx
12 (0.0%)  	andnl	%ebp,%edx,%edi
12 (0.0%)  	addl	%esi,%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	andl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%edi,%edx
12 (0.0%)  	addl	-116(%r13),%ebx
12 (0.0%)  	andnl	%eax,%ecx,%edi
12 (0.0%)  	addl	%edx,%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	andl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%edi,%ecx
12 (0.0%)  	addl	-96(%r13),%ebp
12 (0.0%)  	andnl	%esi,%ebx,%edi
12 (0.0%)  	addl	%ecx,%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	andl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%edi,%ebx
12 (0.0%)  	addl	-92(%r13),%eax
12 (0.0%)  	andnl	%edx,%ebp,%edi
12 (0.0%)  	addl	%ebx,%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	andl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edi,%ebp
12 (0.0%)  	addl	-88(%r13),%esi
12 (0.0%)  	andnl	%ecx,%eax,%edi
12 (0.0%)  	addl	%ebp,%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	andl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%edi,%eax
12 (0.0%)  	addl	-84(%r13),%edx
12 (0.0%)  	andnl	%ebx,%esi,%edi
12 (0.0%)  	addl	%eax,%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	andl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%edi,%esi
12 (0.0%)  	addl	-64(%r13),%ecx
12 (0.0%)  	andnl	%ebp,%edx,%edi
12 (0.0%)  	addl	%esi,%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	andl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%edi,%edx
12 (0.0%)  	addl	-60(%r13),%ebx
12 (0.0%)  	andnl	%eax,%ecx,%edi
12 (0.0%)  	addl	%edx,%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	andl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%edi,%ecx
12 (0.0%)  	addl	-56(%r13),%ebp
12 (0.0%)  	andnl	%esi,%ebx,%edi
12 (0.0%)  	addl	%ecx,%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	andl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%edi,%ebx
12 (0.0%)  	addl	-52(%r13),%eax
12 (0.0%)  	andnl	%edx,%ebp,%edi
12 (0.0%)  	addl	%ebx,%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	andl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edi,%ebp
12 (0.0%)  	addl	-32(%r13),%esi
12 (0.0%)  	andnl	%ecx,%eax,%edi
12 (0.0%)  	addl	%ebp,%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	andl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%edi,%eax
12 (0.0%)  	addl	-28(%r13),%edx
12 (0.0%)  	andnl	%ebx,%esi,%edi
12 (0.0%)  	addl	%eax,%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	andl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%edi,%esi
12 (0.0%)  	addl	-24(%r13),%ecx
12 (0.0%)  	andnl	%ebp,%edx,%edi
12 (0.0%)  	addl	%esi,%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	andl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%edi,%edx
12 (0.0%)  	addl	-20(%r13),%ebx
12 (0.0%)  	andnl	%eax,%ecx,%edi
12 (0.0%)  	addl	%edx,%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	andl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%edi,%ecx
12 (0.0%)  	addl	0(%r13),%ebp
12 (0.0%)  	andnl	%esi,%ebx,%edi
12 (0.0%)  	addl	%ecx,%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	andl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%edi,%ebx
12 (0.0%)  	addl	4(%r13),%eax
12 (0.0%)  	andnl	%edx,%ebp,%edi
12 (0.0%)  	addl	%ebx,%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	andl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edi,%ebp
12 (0.0%)  	addl	8(%r13),%esi
12 (0.0%)  	andnl	%ecx,%eax,%edi
12 (0.0%)  	addl	%ebp,%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	andl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%edi,%eax
12 (0.0%)  	addl	12(%r13),%edx
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%ebx,%esi
12 (0.0%)  	addl	32(%r13),%ecx
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%ebp,%edx
12 (0.0%)  	addl	36(%r13),%ebx
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%eax,%ecx
12 (0.0%)  	addl	40(%r13),%ebp
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%esi,%ebx
12 (0.0%)  	addl	44(%r13),%eax
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edx,%ebp
12 (0.0%)  	addl	64(%r13),%esi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%ecx,%eax
12 (0.0%)  	vmovdqu	-64(%r14),%ymm11
12 (0.0%)  	vpshufb	%ymm6,%ymm0,%ymm0
12 (0.0%)  	addl	68(%r13),%edx
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%ebx,%esi
12 (0.0%)  	addl	72(%r13),%ecx
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%ebp,%edx
12 (0.0%)  	addl	76(%r13),%ebx
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%eax,%ecx
12 (0.0%)  	addl	96(%r13),%ebp
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%esi,%ebx
12 (0.0%)  	addl	100(%r13),%eax
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edx,%ebp
12 (0.0%)  	vpshufb	%ymm6,%ymm1,%ymm1
12 (0.0%)  	vpaddd	%ymm11,%ymm0,%ymm8
12 (0.0%)  	addl	104(%r13),%esi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%ecx,%eax
12 (0.0%)  	addl	108(%r13),%edx
12 (0.0%)  	leaq	256(%r13),%r13
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%ebx,%esi
12 (0.0%)  	addl	-128(%r13),%ecx
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%ebp,%edx
12 (0.0%)  	addl	-124(%r13),%ebx
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%eax,%ecx
12 (0.0%)  	addl	-120(%r13),%ebp
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%esi,%ebx
12 (0.0%)  	vmovdqu	%ymm8,0(%rsp)
12 (0.0%)  	vpshufb	%ymm6,%ymm2,%ymm2
12 (0.0%)  	vpaddd	%ymm11,%ymm1,%ymm9
12 (0.0%)  	addl	-116(%r13),%eax
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edx,%ebp
12 (0.0%)  	addl	-96(%r13),%esi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%ecx,%eax
12 (0.0%)  	addl	-92(%r13),%edx
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%ebx,%esi
12 (0.0%)  	addl	-88(%r13),%ecx
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%ebp,%edx
12 (0.0%)  	addl	-84(%r13),%ebx
12 (0.0%)  	movl	%esi,%edi
12 (0.0%)  	xorl	%eax,%edi
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	andl	%edi,%ecx
12 (0.0%)  	vmovdqu	%ymm9,32(%rsp)
12 (0.0%)  	vpshufb	%ymm6,%ymm3,%ymm3
12 (0.0%)  	vpaddd	%ymm11,%ymm2,%ymm6
12 (0.0%)  	addl	-64(%r13),%ebp
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	movl	%edx,%edi
12 (0.0%)  	xorl	%esi,%edi
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	andl	%edi,%ebx
12 (0.0%)  	addl	-60(%r13),%eax
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	movl	%ecx,%edi
12 (0.0%)  	xorl	%edx,%edi
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	andl	%edi,%ebp
12 (0.0%)  	addl	-56(%r13),%esi
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	movl	%ebx,%edi
12 (0.0%)  	xorl	%ecx,%edi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	andl	%edi,%eax
12 (0.0%)  	addl	-52(%r13),%edx
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	movl	%ebp,%edi
12 (0.0%)  	xorl	%ebx,%edi
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	andl	%edi,%esi
12 (0.0%)  	addl	-32(%r13),%ecx
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	movl	%eax,%edi
12 (0.0%)  	xorl	%ebp,%edi
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	andl	%edi,%edx
12 (0.0%)  	jmp	.Lalign32_3
 .         .align	32
 .         .Lalign32_3:
12 (0.0%)  	vmovdqu	%ymm6,64(%rsp)
12 (0.0%)  	vpaddd	%ymm11,%ymm3,%ymm7
12 (0.0%)  	addl	-28(%r13),%ebx
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	movl	%esi,%edi
12 (0.0%)  	xorl	%eax,%edi
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	andl	%edi,%ecx
12 (0.0%)  	addl	-24(%r13),%ebp
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	movl	%edx,%edi
12 (0.0%)  	xorl	%esi,%edi
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	andl	%edi,%ebx
12 (0.0%)  	addl	-20(%r13),%eax
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	movl	%ecx,%edi
12 (0.0%)  	xorl	%edx,%edi
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	andl	%edi,%ebp
12 (0.0%)  	addl	0(%r13),%esi
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	movl	%ebx,%edi
12 (0.0%)  	xorl	%ecx,%edi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	andl	%edi,%eax
12 (0.0%)  	addl	4(%r13),%edx
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	movl	%ebp,%edi
12 (0.0%)  	xorl	%ebx,%edi
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	andl	%edi,%esi
12 (0.0%)  	vmovdqu	%ymm7,96(%rsp)
12 (0.0%)  	addl	8(%r13),%ecx
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	movl	%eax,%edi
12 (0.0%)  	xorl	%ebp,%edi
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	andl	%edi,%edx
12 (0.0%)  	addl	12(%r13),%ebx
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	movl	%esi,%edi
12 (0.0%)  	xorl	%eax,%edi
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	andl	%edi,%ecx
12 (0.0%)  	addl	32(%r13),%ebp
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	movl	%edx,%edi
12 (0.0%)  	xorl	%esi,%edi
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	andl	%edi,%ebx
12 (0.0%)  	addl	36(%r13),%eax
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	movl	%ecx,%edi
12 (0.0%)  	xorl	%edx,%edi
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	andl	%edi,%ebp
12 (0.0%)  	addl	40(%r13),%esi
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	movl	%ebx,%edi
12 (0.0%)  	xorl	%ecx,%edi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	andl	%edi,%eax
12 (0.0%)  	vpalignr	$8,%ymm0,%ymm1,%ymm4
12 (0.0%)  	addl	44(%r13),%edx
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	movl	%ebp,%edi
12 (0.0%)  	xorl	%ebx,%edi
12 (0.0%)  	vpsrldq	$4,%ymm3,%ymm8
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	vpxor	%ymm0,%ymm4,%ymm4
12 (0.0%)  	vpxor	%ymm2,%ymm8,%ymm8
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	vpxor	%ymm8,%ymm4,%ymm4
12 (0.0%)  	andl	%edi,%esi
12 (0.0%)  	addl	64(%r13),%ecx
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	movl	%eax,%edi
12 (0.0%)  	vpsrld	$31,%ymm4,%ymm8
12 (0.0%)  	xorl	%ebp,%edi
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	vpslldq	$12,%ymm4,%ymm10
12 (0.0%)  	vpaddd	%ymm4,%ymm4,%ymm4
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
12 (0.0%)  	vpor	%ymm8,%ymm4,%ymm4
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	andl	%edi,%edx
12 (0.0%)  	vpslld	$2,%ymm10,%ymm10
12 (0.0%)  	vpxor	%ymm9,%ymm4,%ymm4
12 (0.0%)  	addl	68(%r13),%ebx
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	vpxor	%ymm10,%ymm4,%ymm4
12 (0.0%)  	movl	%esi,%edi
12 (0.0%)  	xorl	%eax,%edi
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	vpaddd	%ymm11,%ymm4,%ymm9
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	vmovdqu	%ymm9,128(%rsp)
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	andl	%edi,%ecx
12 (0.0%)  	addl	72(%r13),%ebp
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	movl	%edx,%edi
12 (0.0%)  	xorl	%esi,%edi
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	andl	%edi,%ebx
12 (0.0%)  	addl	76(%r13),%eax
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edx,%ebp
12 (0.0%)  	vpalignr	$8,%ymm1,%ymm2,%ymm5
12 (0.0%)  	addl	96(%r13),%esi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	vpsrldq	$4,%ymm4,%ymm8
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%ecx,%eax
12 (0.0%)  	vpxor	%ymm1,%ymm5,%ymm5
12 (0.0%)  	vpxor	%ymm3,%ymm8,%ymm8
12 (0.0%)  	addl	100(%r13),%edx
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	vpxor	%ymm8,%ymm5,%ymm5
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	vpsrld	$31,%ymm5,%ymm8
12 (0.0%)  	vmovdqu	-32(%r14),%ymm11
12 (0.0%)  	xorl	%ebx,%esi
12 (0.0%)  	addl	104(%r13),%ecx
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	vpslldq	$12,%ymm5,%ymm10
12 (0.0%)  	vpaddd	%ymm5,%ymm5,%ymm5
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
12 (0.0%)  	vpor	%ymm8,%ymm5,%ymm5
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	vpslld	$2,%ymm10,%ymm10
12 (0.0%)  	vpxor	%ymm9,%ymm5,%ymm5
12 (0.0%)  	xorl	%ebp,%edx
12 (0.0%)  	addl	108(%r13),%ebx
12 (0.0%)  	leaq	256(%r13),%r13
12 (0.0%)  	vpxor	%ymm10,%ymm5,%ymm5
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	vpaddd	%ymm11,%ymm5,%ymm9
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%eax,%ecx
12 (0.0%)  	vmovdqu	%ymm9,160(%rsp)
12 (0.0%)  	addl	-128(%r13),%ebp
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%esi,%ebx
12 (0.0%)  	vpalignr	$8,%ymm2,%ymm3,%ymm6
12 (0.0%)  	addl	-124(%r13),%eax
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	vpsrldq	$4,%ymm5,%ymm8
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edx,%ebp
12 (0.0%)  	vpxor	%ymm2,%ymm6,%ymm6
12 (0.0%)  	vpxor	%ymm4,%ymm8,%ymm8
12 (0.0%)  	addl	-120(%r13),%esi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	vpxor	%ymm8,%ymm6,%ymm6
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	vpsrld	$31,%ymm6,%ymm8
12 (0.0%)  	xorl	%ecx,%eax
12 (0.0%)  	addl	-116(%r13),%edx
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	vpslldq	$12,%ymm6,%ymm10
12 (0.0%)  	vpaddd	%ymm6,%ymm6,%ymm6
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
12 (0.0%)  	vpor	%ymm8,%ymm6,%ymm6
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	vpslld	$2,%ymm10,%ymm10
12 (0.0%)  	vpxor	%ymm9,%ymm6,%ymm6
12 (0.0%)  	xorl	%ebx,%esi
12 (0.0%)  	addl	-96(%r13),%ecx
12 (0.0%)  	vpxor	%ymm10,%ymm6,%ymm6
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	vpaddd	%ymm11,%ymm6,%ymm9
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%ebp,%edx
12 (0.0%)  	vmovdqu	%ymm9,192(%rsp)
12 (0.0%)  	addl	-92(%r13),%ebx
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%eax,%ecx
12 (0.0%)  	vpalignr	$8,%ymm3,%ymm4,%ymm7
12 (0.0%)  	addl	-88(%r13),%ebp
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	vpsrldq	$4,%ymm6,%ymm8
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%esi,%ebx
12 (0.0%)  	vpxor	%ymm3,%ymm7,%ymm7
12 (0.0%)  	vpxor	%ymm5,%ymm8,%ymm8
12 (0.0%)  	addl	-84(%r13),%eax
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	vpxor	%ymm8,%ymm7,%ymm7
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	vpsrld	$31,%ymm7,%ymm8
12 (0.0%)  	xorl	%edx,%ebp
12 (0.0%)  	addl	-64(%r13),%esi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	vpslldq	$12,%ymm7,%ymm10
12 (0.0%)  	vpaddd	%ymm7,%ymm7,%ymm7
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	vpsrld	$30,%ymm10,%ymm9
12 (0.0%)  	vpor	%ymm8,%ymm7,%ymm7
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	vpslld	$2,%ymm10,%ymm10
12 (0.0%)  	vpxor	%ymm9,%ymm7,%ymm7
12 (0.0%)  	xorl	%ecx,%eax
12 (0.0%)  	addl	-60(%r13),%edx
12 (0.0%)  	vpxor	%ymm10,%ymm7,%ymm7
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	rorxl	$2,%esi,%eax
12 (0.0%)  	vpaddd	%ymm11,%ymm7,%ymm9
12 (0.0%)  	xorl	%ebp,%esi
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	xorl	%ebx,%esi
12 (0.0%)  	vmovdqu	%ymm9,224(%rsp)
12 (0.0%)  	addl	-56(%r13),%ecx
12 (0.0%)  	leal	(%rcx,%rsi,1),%ecx
12 (0.0%)  	rorxl	$27,%edx,%r12d
12 (0.0%)  	rorxl	$2,%edx,%esi
12 (0.0%)  	xorl	%eax,%edx
12 (0.0%)  	addl	%r12d,%ecx
12 (0.0%)  	xorl	%ebp,%edx
12 (0.0%)  	addl	-52(%r13),%ebx
12 (0.0%)  	leal	(%rbx,%rdx,1),%ebx
12 (0.0%)  	rorxl	$27,%ecx,%r12d
12 (0.0%)  	rorxl	$2,%ecx,%edx
12 (0.0%)  	xorl	%esi,%ecx
12 (0.0%)  	addl	%r12d,%ebx
12 (0.0%)  	xorl	%eax,%ecx
12 (0.0%)  	addl	-32(%r13),%ebp
12 (0.0%)  	leal	(%rcx,%rbp,1),%ebp
12 (0.0%)  	rorxl	$27,%ebx,%r12d
12 (0.0%)  	rorxl	$2,%ebx,%ecx
12 (0.0%)  	xorl	%edx,%ebx
12 (0.0%)  	addl	%r12d,%ebp
12 (0.0%)  	xorl	%esi,%ebx
12 (0.0%)  	addl	-28(%r13),%eax
12 (0.0%)  	leal	(%rax,%rbx,1),%eax
12 (0.0%)  	rorxl	$27,%ebp,%r12d
12 (0.0%)  	rorxl	$2,%ebp,%ebx
12 (0.0%)  	xorl	%ecx,%ebp
12 (0.0%)  	addl	%r12d,%eax
12 (0.0%)  	xorl	%edx,%ebp
12 (0.0%)  	addl	-24(%r13),%esi
12 (0.0%)  	leal	(%rsi,%rbp,1),%esi
12 (0.0%)  	rorxl	$27,%eax,%r12d
12 (0.0%)  	rorxl	$2,%eax,%ebp
12 (0.0%)  	xorl	%ebx,%eax
12 (0.0%)  	addl	%r12d,%esi
12 (0.0%)  	xorl	%ecx,%eax
12 (0.0%)  	addl	-20(%r13),%edx
12 (0.0%)  	leal	(%rdx,%rax,1),%edx
12 (0.0%)  	rorxl	$27,%esi,%r12d
12 (0.0%)  	addl	%r12d,%edx
12 (0.0%)  	leaq	128(%rsp),%r13
 .         
 .         
12 (0.0%)  	addl	0(%r8),%edx
12 (0.0%)  	addl	4(%r8),%esi
12 (0.0%)  	addl	8(%r8),%ebp
12 (0.0%)  	movl	%edx,0(%r8)
12 (0.0%)  	addl	12(%r8),%ebx
12 (0.0%)  	movl	%esi,4(%r8)
12 (0.0%)  	movl	%edx,%eax
12 (0.0%)  	addl	16(%r8),%ecx
12 (0.0%)  	movl	%ebp,%r12d
12 (0.0%)  	movl	%ebp,8(%r8)
12 (0.0%)  	movl	%ebx,%edx
 .         
12 (0.0%)  	movl	%ebx,12(%r8)
12 (0.0%)  	movl	%esi,%ebp
12 (0.0%)  	movl	%ecx,16(%r8)
 .         
12 (0.0%)  	movl	%ecx,%esi
12 (0.0%)  	movl	%r12d,%ecx
 .         
 .         
12 (0.0%)  	cmpq	%r10,%r9
12 (0.0%)  	jbe	.Loop_avx2
 .         
 .         .Ldone_avx2:
14 (0.0%)  	vzeroupper
14 (0.0%)  	movq	-40(%r11),%r14
 .         .cfi_restore	%r14
14 (0.0%)  	movq	-32(%r11),%r13
 .         .cfi_restore	%r13
14 (0.0%)  	movq	-24(%r11),%r12
 .         .cfi_restore	%r12
14 (0.0%)  	movq	-16(%r11),%rbp
 .         .cfi_restore	%rbp
14 (0.0%)  	movq	-8(%r11),%rbx
 .         .cfi_restore	%rbx
28 (0.0%)  	leaq	(%r11),%rsp
 .         .cfi_def_cfa_register	%rsp
 .         .Lepilogue_avx2:
 .         	.byte	0xf3,0xc3
 .         .cfi_endproc	
 .         .size	sha1_block_data_order_avx2,.-sha1_block_data_order_avx2
 .         .section	.rodata
 .         .align	64
 .         K_XX_XX:
-- line 5448 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha256-x86_64.S
--------------------------------------------------------------------------------
Ir________ 

-- line 9 ----------------------------------------
  .         .extern	OPENSSL_ia32cap_P
  .         .hidden OPENSSL_ia32cap_P
  .         .globl	sha256_block_data_order
  .         .hidden sha256_block_data_order
  .         .type	sha256_block_data_order,@function
  .         .align	16
  .         sha256_block_data_order:
  .         .cfi_startproc	
225 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r11
225 (0.0%)  	movl	0(%r11),%r9d
225 (0.0%)  	movl	4(%r11),%r10d
225 (0.0%)  	movl	8(%r11),%r11d
225 (0.0%)  	testl	$536870912,%r11d
225 (0.0%)  	jnz	.Lshaext_shortcut
225 (0.0%)  	andl	$1073741824,%r9d
225 (0.0%)  	andl	$268435968,%r10d
225 (0.0%)  	orl	%r9d,%r10d
225 (0.0%)  	cmpl	$1342177792,%r10d
225 (0.0%)  	je	.Lavx_shortcut
  .         	testl	$512,%r10d
  .         	jnz	.Lssse3_shortcut
  .         	movq	%rsp,%rax
  .         .cfi_def_cfa_register	%rax
  .         	pushq	%rbx
  .         .cfi_offset	%rbx,-16
  .         	pushq	%rbp
  .         .cfi_offset	%rbp,-24
-- line 35 ----------------------------------------
-- line 3105 ----------------------------------------
  .         	.byte	0xf3,0xc3
  .         .cfi_endproc	
  .         .size	sha256_block_data_order_ssse3,.-sha256_block_data_order_ssse3
  .         .type	sha256_block_data_order_avx,@function
  .         .align	64
  .         sha256_block_data_order_avx:
  .         .cfi_startproc	
  .         .Lavx_shortcut:
225 (0.0%)  	movq	%rsp,%rax
  .         .cfi_def_cfa_register	%rax
225 (0.0%)  	pushq	%rbx
  .         .cfi_offset	%rbx,-16
225 (0.0%)  	pushq	%rbp
  .         .cfi_offset	%rbp,-24
225 (0.0%)  	pushq	%r12
  .         .cfi_offset	%r12,-32
225 (0.0%)  	pushq	%r13
  .         .cfi_offset	%r13,-40
225 (0.0%)  	pushq	%r14
  .         .cfi_offset	%r14,-48
225 (0.0%)  	pushq	%r15
  .         .cfi_offset	%r15,-56
225 (0.0%)  	shlq	$4,%rdx
225 (0.0%)  	subq	$96,%rsp
225 (0.0%)  	leaq	(%rsi,%rdx,4),%rdx
225 (0.0%)  	andq	$-64,%rsp
225 (0.0%)  	movq	%rdi,64+0(%rsp)
225 (0.0%)  	movq	%rsi,64+8(%rsp)
225 (0.0%)  	movq	%rdx,64+16(%rsp)
225 (0.0%)  	movq	%rax,88(%rsp)
  .         .cfi_escape	0x0f,0x06,0x77,0xd8,0x00,0x06,0x23,0x08
  .         .Lprologue_avx:
  .         
225 (0.0%)  	vzeroupper
225 (0.0%)  	movl	0(%rdi),%eax
225 (0.0%)  	movl	4(%rdi),%ebx
225 (0.0%)  	movl	8(%rdi),%ecx
225 (0.0%)  	movl	12(%rdi),%edx
225 (0.0%)  	movl	16(%rdi),%r8d
225 (0.0%)  	movl	20(%rdi),%r9d
225 (0.0%)  	movl	24(%rdi),%r10d
225 (0.0%)  	movl	28(%rdi),%r11d
225 (0.0%)  	vmovdqa	K256+512+32(%rip),%xmm8
225 (0.0%)  	vmovdqa	K256+512+64(%rip),%xmm9
225 (0.0%)  	jmp	.Lloop_avx
  .         .align	16
  .         .Lloop_avx:
271 (0.0%)  	vmovdqa	K256+512(%rip),%xmm7
271 (0.0%)  	vmovdqu	0(%rsi),%xmm0
271 (0.0%)  	vmovdqu	16(%rsi),%xmm1
271 (0.0%)  	vmovdqu	32(%rsi),%xmm2
271 (0.0%)  	vmovdqu	48(%rsi),%xmm3
271 (0.0%)  	vpshufb	%xmm7,%xmm0,%xmm0
271 (0.0%)  	leaq	K256(%rip),%rbp
271 (0.0%)  	vpshufb	%xmm7,%xmm1,%xmm1
271 (0.0%)  	vpshufb	%xmm7,%xmm2,%xmm2
271 (0.0%)  	vpaddd	0(%rbp),%xmm0,%xmm4
271 (0.0%)  	vpshufb	%xmm7,%xmm3,%xmm3
271 (0.0%)  	vpaddd	32(%rbp),%xmm1,%xmm5
271 (0.0%)  	vpaddd	64(%rbp),%xmm2,%xmm6
271 (0.0%)  	vpaddd	96(%rbp),%xmm3,%xmm7
271 (0.0%)  	vmovdqa	%xmm4,0(%rsp)
271 (0.0%)  	movl	%eax,%r14d
271 (0.0%)  	vmovdqa	%xmm5,16(%rsp)
271 (0.0%)  	movl	%ebx,%edi
271 (0.0%)  	vmovdqa	%xmm6,32(%rsp)
271 (0.0%)  	xorl	%ecx,%edi
271 (0.0%)  	vmovdqa	%xmm7,48(%rsp)
271 (0.0%)  	movl	%r8d,%r13d
271 (0.0%)  	jmp	.Lavx_00_47
  .         
  .         .align	16
  .         .Lavx_00_47:
813 (0.0%)  	subq	$-128,%rbp
813 (0.0%)  	vpalignr	$4,%xmm0,%xmm1,%xmm4
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	movl	%r14d,%eax
813 (0.0%)  	movl	%r9d,%r12d
813 (0.0%)  	vpalignr	$4,%xmm2,%xmm3,%xmm7
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	xorl	%r8d,%r13d
813 (0.0%)  	xorl	%r10d,%r12d
813 (0.0%)  	vpsrld	$7,%xmm4,%xmm6
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	xorl	%eax,%r14d
813 (0.0%)  	andl	%r8d,%r12d
813 (0.0%)  	vpaddd	%xmm7,%xmm0,%xmm0
813 (0.0%)  	xorl	%r8d,%r13d
813 (0.0%)  	addl	0(%rsp),%r11d
813 (0.0%)  	movl	%eax,%r15d
813 (0.0%)  	vpsrld	$3,%xmm4,%xmm7
813 (0.0%)  	xorl	%r10d,%r12d
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	xorl	%ebx,%r15d
813 (0.0%)  	vpslld	$14,%xmm4,%xmm5
813 (0.0%)  	addl	%r12d,%r11d
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	andl	%r15d,%edi
813 (0.0%)  	vpxor	%xmm6,%xmm7,%xmm4
813 (0.0%)  	xorl	%eax,%r14d
813 (0.0%)  	addl	%r13d,%r11d
813 (0.0%)  	xorl	%ebx,%edi
813 (0.0%)  	vpshufd	$250,%xmm3,%xmm7
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	addl	%r11d,%edx
813 (0.0%)  	addl	%edi,%r11d
813 (0.0%)  	vpsrld	$11,%xmm6,%xmm6
813 (0.0%)  	movl	%edx,%r13d
813 (0.0%)  	addl	%r11d,%r14d
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
813 (0.0%)  	movl	%r14d,%r11d
813 (0.0%)  	movl	%r8d,%r12d
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	vpslld	$11,%xmm5,%xmm5
813 (0.0%)  	xorl	%edx,%r13d
813 (0.0%)  	xorl	%r9d,%r12d
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	vpxor	%xmm6,%xmm4,%xmm4
813 (0.0%)  	xorl	%r11d,%r14d
813 (0.0%)  	andl	%edx,%r12d
813 (0.0%)  	xorl	%edx,%r13d
813 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
813 (0.0%)  	addl	4(%rsp),%r10d
813 (0.0%)  	movl	%r11d,%edi
813 (0.0%)  	xorl	%r9d,%r12d
813 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	xorl	%eax,%edi
813 (0.0%)  	addl	%r12d,%r10d
813 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	andl	%edi,%r15d
813 (0.0%)  	xorl	%r11d,%r14d
813 (0.0%)  	vpaddd	%xmm4,%xmm0,%xmm0
813 (0.0%)  	addl	%r13d,%r10d
813 (0.0%)  	xorl	%eax,%r15d
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	addl	%r10d,%ecx
813 (0.0%)  	addl	%r15d,%r10d
813 (0.0%)  	movl	%ecx,%r13d
813 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
813 (0.0%)  	addl	%r10d,%r14d
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	movl	%r14d,%r10d
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	movl	%edx,%r12d
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	xorl	%ecx,%r13d
813 (0.0%)  	vpshufb	%xmm8,%xmm6,%xmm6
813 (0.0%)  	xorl	%r8d,%r12d
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	xorl	%r10d,%r14d
813 (0.0%)  	vpaddd	%xmm6,%xmm0,%xmm0
813 (0.0%)  	andl	%ecx,%r12d
813 (0.0%)  	xorl	%ecx,%r13d
813 (0.0%)  	addl	8(%rsp),%r9d
813 (0.0%)  	vpshufd	$80,%xmm0,%xmm7
813 (0.0%)  	movl	%r10d,%r15d
813 (0.0%)  	xorl	%r8d,%r12d
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
813 (0.0%)  	xorl	%r11d,%r15d
813 (0.0%)  	addl	%r12d,%r9d
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
813 (0.0%)  	andl	%r15d,%edi
813 (0.0%)  	xorl	%r10d,%r14d
813 (0.0%)  	addl	%r13d,%r9d
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	xorl	%r11d,%edi
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	addl	%r9d,%ebx
813 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
813 (0.0%)  	addl	%edi,%r9d
813 (0.0%)  	movl	%ebx,%r13d
813 (0.0%)  	addl	%r9d,%r14d
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	movl	%r14d,%r9d
813 (0.0%)  	movl	%ecx,%r12d
813 (0.0%)  	vpshufb	%xmm9,%xmm6,%xmm6
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	xorl	%ebx,%r13d
813 (0.0%)  	xorl	%edx,%r12d
813 (0.0%)  	vpaddd	%xmm6,%xmm0,%xmm0
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	xorl	%r9d,%r14d
813 (0.0%)  	andl	%ebx,%r12d
813 (0.0%)  	vpaddd	0(%rbp),%xmm0,%xmm6
813 (0.0%)  	xorl	%ebx,%r13d
813 (0.0%)  	addl	12(%rsp),%r8d
813 (0.0%)  	movl	%r9d,%edi
813 (0.0%)  	xorl	%edx,%r12d
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	xorl	%r10d,%edi
813 (0.0%)  	addl	%r12d,%r8d
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	andl	%edi,%r15d
813 (0.0%)  	xorl	%r9d,%r14d
813 (0.0%)  	addl	%r13d,%r8d
813 (0.0%)  	xorl	%r10d,%r15d
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	addl	%r8d,%eax
813 (0.0%)  	addl	%r15d,%r8d
813 (0.0%)  	movl	%eax,%r13d
813 (0.0%)  	addl	%r8d,%r14d
813 (0.0%)  	vmovdqa	%xmm6,0(%rsp)
813 (0.0%)  	vpalignr	$4,%xmm1,%xmm2,%xmm4
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	movl	%r14d,%r8d
813 (0.0%)  	movl	%ebx,%r12d
813 (0.0%)  	vpalignr	$4,%xmm3,%xmm0,%xmm7
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	xorl	%eax,%r13d
813 (0.0%)  	xorl	%ecx,%r12d
813 (0.0%)  	vpsrld	$7,%xmm4,%xmm6
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	xorl	%r8d,%r14d
813 (0.0%)  	andl	%eax,%r12d
813 (0.0%)  	vpaddd	%xmm7,%xmm1,%xmm1
813 (0.0%)  	xorl	%eax,%r13d
813 (0.0%)  	addl	16(%rsp),%edx
813 (0.0%)  	movl	%r8d,%r15d
813 (0.0%)  	vpsrld	$3,%xmm4,%xmm7
813 (0.0%)  	xorl	%ecx,%r12d
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	xorl	%r9d,%r15d
813 (0.0%)  	vpslld	$14,%xmm4,%xmm5
813 (0.0%)  	addl	%r12d,%edx
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	andl	%r15d,%edi
813 (0.0%)  	vpxor	%xmm6,%xmm7,%xmm4
813 (0.0%)  	xorl	%r8d,%r14d
813 (0.0%)  	addl	%r13d,%edx
813 (0.0%)  	xorl	%r9d,%edi
813 (0.0%)  	vpshufd	$250,%xmm0,%xmm7
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	addl	%edx,%r11d
813 (0.0%)  	addl	%edi,%edx
813 (0.0%)  	vpsrld	$11,%xmm6,%xmm6
813 (0.0%)  	movl	%r11d,%r13d
813 (0.0%)  	addl	%edx,%r14d
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
813 (0.0%)  	movl	%r14d,%edx
813 (0.0%)  	movl	%eax,%r12d
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	vpslld	$11,%xmm5,%xmm5
813 (0.0%)  	xorl	%r11d,%r13d
813 (0.0%)  	xorl	%ebx,%r12d
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	vpxor	%xmm6,%xmm4,%xmm4
813 (0.0%)  	xorl	%edx,%r14d
813 (0.0%)  	andl	%r11d,%r12d
813 (0.0%)  	xorl	%r11d,%r13d
813 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
813 (0.0%)  	addl	20(%rsp),%ecx
813 (0.0%)  	movl	%edx,%edi
813 (0.0%)  	xorl	%ebx,%r12d
813 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	xorl	%r8d,%edi
813 (0.0%)  	addl	%r12d,%ecx
813 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	andl	%edi,%r15d
813 (0.0%)  	xorl	%edx,%r14d
813 (0.0%)  	vpaddd	%xmm4,%xmm1,%xmm1
813 (0.0%)  	addl	%r13d,%ecx
813 (0.0%)  	xorl	%r8d,%r15d
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	addl	%ecx,%r10d
813 (0.0%)  	addl	%r15d,%ecx
813 (0.0%)  	movl	%r10d,%r13d
813 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
813 (0.0%)  	addl	%ecx,%r14d
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	movl	%r14d,%ecx
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	movl	%r11d,%r12d
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	xorl	%r10d,%r13d
813 (0.0%)  	vpshufb	%xmm8,%xmm6,%xmm6
813 (0.0%)  	xorl	%eax,%r12d
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	xorl	%ecx,%r14d
813 (0.0%)  	vpaddd	%xmm6,%xmm1,%xmm1
813 (0.0%)  	andl	%r10d,%r12d
813 (0.0%)  	xorl	%r10d,%r13d
813 (0.0%)  	addl	24(%rsp),%ebx
813 (0.0%)  	vpshufd	$80,%xmm1,%xmm7
813 (0.0%)  	movl	%ecx,%r15d
813 (0.0%)  	xorl	%eax,%r12d
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
813 (0.0%)  	xorl	%edx,%r15d
813 (0.0%)  	addl	%r12d,%ebx
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
813 (0.0%)  	andl	%r15d,%edi
813 (0.0%)  	xorl	%ecx,%r14d
813 (0.0%)  	addl	%r13d,%ebx
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	xorl	%edx,%edi
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	addl	%ebx,%r9d
813 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
813 (0.0%)  	addl	%edi,%ebx
813 (0.0%)  	movl	%r9d,%r13d
813 (0.0%)  	addl	%ebx,%r14d
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	movl	%r14d,%ebx
813 (0.0%)  	movl	%r10d,%r12d
813 (0.0%)  	vpshufb	%xmm9,%xmm6,%xmm6
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	xorl	%r9d,%r13d
813 (0.0%)  	xorl	%r11d,%r12d
813 (0.0%)  	vpaddd	%xmm6,%xmm1,%xmm1
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	xorl	%ebx,%r14d
813 (0.0%)  	andl	%r9d,%r12d
813 (0.0%)  	vpaddd	32(%rbp),%xmm1,%xmm6
813 (0.0%)  	xorl	%r9d,%r13d
813 (0.0%)  	addl	28(%rsp),%eax
813 (0.0%)  	movl	%ebx,%edi
813 (0.0%)  	xorl	%r11d,%r12d
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	xorl	%ecx,%edi
813 (0.0%)  	addl	%r12d,%eax
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	andl	%edi,%r15d
813 (0.0%)  	xorl	%ebx,%r14d
813 (0.0%)  	addl	%r13d,%eax
813 (0.0%)  	xorl	%ecx,%r15d
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	addl	%eax,%r8d
813 (0.0%)  	addl	%r15d,%eax
813 (0.0%)  	movl	%r8d,%r13d
813 (0.0%)  	addl	%eax,%r14d
813 (0.0%)  	vmovdqa	%xmm6,16(%rsp)
813 (0.0%)  	vpalignr	$4,%xmm2,%xmm3,%xmm4
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	movl	%r14d,%eax
813 (0.0%)  	movl	%r9d,%r12d
813 (0.0%)  	vpalignr	$4,%xmm0,%xmm1,%xmm7
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	xorl	%r8d,%r13d
813 (0.0%)  	xorl	%r10d,%r12d
813 (0.0%)  	vpsrld	$7,%xmm4,%xmm6
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	xorl	%eax,%r14d
813 (0.0%)  	andl	%r8d,%r12d
813 (0.0%)  	vpaddd	%xmm7,%xmm2,%xmm2
813 (0.0%)  	xorl	%r8d,%r13d
813 (0.0%)  	addl	32(%rsp),%r11d
813 (0.0%)  	movl	%eax,%r15d
813 (0.0%)  	vpsrld	$3,%xmm4,%xmm7
813 (0.0%)  	xorl	%r10d,%r12d
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	xorl	%ebx,%r15d
813 (0.0%)  	vpslld	$14,%xmm4,%xmm5
813 (0.0%)  	addl	%r12d,%r11d
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	andl	%r15d,%edi
813 (0.0%)  	vpxor	%xmm6,%xmm7,%xmm4
813 (0.0%)  	xorl	%eax,%r14d
813 (0.0%)  	addl	%r13d,%r11d
813 (0.0%)  	xorl	%ebx,%edi
813 (0.0%)  	vpshufd	$250,%xmm1,%xmm7
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	addl	%r11d,%edx
813 (0.0%)  	addl	%edi,%r11d
813 (0.0%)  	vpsrld	$11,%xmm6,%xmm6
813 (0.0%)  	movl	%edx,%r13d
813 (0.0%)  	addl	%r11d,%r14d
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
813 (0.0%)  	movl	%r14d,%r11d
813 (0.0%)  	movl	%r8d,%r12d
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	vpslld	$11,%xmm5,%xmm5
813 (0.0%)  	xorl	%edx,%r13d
813 (0.0%)  	xorl	%r9d,%r12d
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	vpxor	%xmm6,%xmm4,%xmm4
813 (0.0%)  	xorl	%r11d,%r14d
813 (0.0%)  	andl	%edx,%r12d
813 (0.0%)  	xorl	%edx,%r13d
813 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
813 (0.0%)  	addl	36(%rsp),%r10d
813 (0.0%)  	movl	%r11d,%edi
813 (0.0%)  	xorl	%r9d,%r12d
813 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	xorl	%eax,%edi
813 (0.0%)  	addl	%r12d,%r10d
813 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	andl	%edi,%r15d
813 (0.0%)  	xorl	%r11d,%r14d
813 (0.0%)  	vpaddd	%xmm4,%xmm2,%xmm2
813 (0.0%)  	addl	%r13d,%r10d
813 (0.0%)  	xorl	%eax,%r15d
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	addl	%r10d,%ecx
813 (0.0%)  	addl	%r15d,%r10d
813 (0.0%)  	movl	%ecx,%r13d
813 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
813 (0.0%)  	addl	%r10d,%r14d
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	movl	%r14d,%r10d
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	movl	%edx,%r12d
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	xorl	%ecx,%r13d
813 (0.0%)  	vpshufb	%xmm8,%xmm6,%xmm6
813 (0.0%)  	xorl	%r8d,%r12d
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	xorl	%r10d,%r14d
813 (0.0%)  	vpaddd	%xmm6,%xmm2,%xmm2
813 (0.0%)  	andl	%ecx,%r12d
813 (0.0%)  	xorl	%ecx,%r13d
813 (0.0%)  	addl	40(%rsp),%r9d
813 (0.0%)  	vpshufd	$80,%xmm2,%xmm7
813 (0.0%)  	movl	%r10d,%r15d
813 (0.0%)  	xorl	%r8d,%r12d
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
813 (0.0%)  	xorl	%r11d,%r15d
813 (0.0%)  	addl	%r12d,%r9d
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
813 (0.0%)  	andl	%r15d,%edi
813 (0.0%)  	xorl	%r10d,%r14d
813 (0.0%)  	addl	%r13d,%r9d
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	xorl	%r11d,%edi
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	addl	%r9d,%ebx
813 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
813 (0.0%)  	addl	%edi,%r9d
813 (0.0%)  	movl	%ebx,%r13d
813 (0.0%)  	addl	%r9d,%r14d
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	movl	%r14d,%r9d
813 (0.0%)  	movl	%ecx,%r12d
813 (0.0%)  	vpshufb	%xmm9,%xmm6,%xmm6
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	xorl	%ebx,%r13d
813 (0.0%)  	xorl	%edx,%r12d
813 (0.0%)  	vpaddd	%xmm6,%xmm2,%xmm2
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	xorl	%r9d,%r14d
813 (0.0%)  	andl	%ebx,%r12d
813 (0.0%)  	vpaddd	64(%rbp),%xmm2,%xmm6
813 (0.0%)  	xorl	%ebx,%r13d
813 (0.0%)  	addl	44(%rsp),%r8d
813 (0.0%)  	movl	%r9d,%edi
813 (0.0%)  	xorl	%edx,%r12d
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	xorl	%r10d,%edi
813 (0.0%)  	addl	%r12d,%r8d
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	andl	%edi,%r15d
813 (0.0%)  	xorl	%r9d,%r14d
813 (0.0%)  	addl	%r13d,%r8d
813 (0.0%)  	xorl	%r10d,%r15d
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	addl	%r8d,%eax
813 (0.0%)  	addl	%r15d,%r8d
813 (0.0%)  	movl	%eax,%r13d
813 (0.0%)  	addl	%r8d,%r14d
813 (0.0%)  	vmovdqa	%xmm6,32(%rsp)
813 (0.0%)  	vpalignr	$4,%xmm3,%xmm0,%xmm4
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	movl	%r14d,%r8d
813 (0.0%)  	movl	%ebx,%r12d
813 (0.0%)  	vpalignr	$4,%xmm1,%xmm2,%xmm7
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	xorl	%eax,%r13d
813 (0.0%)  	xorl	%ecx,%r12d
813 (0.0%)  	vpsrld	$7,%xmm4,%xmm6
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	xorl	%r8d,%r14d
813 (0.0%)  	andl	%eax,%r12d
813 (0.0%)  	vpaddd	%xmm7,%xmm3,%xmm3
813 (0.0%)  	xorl	%eax,%r13d
813 (0.0%)  	addl	48(%rsp),%edx
813 (0.0%)  	movl	%r8d,%r15d
813 (0.0%)  	vpsrld	$3,%xmm4,%xmm7
813 (0.0%)  	xorl	%ecx,%r12d
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	xorl	%r9d,%r15d
813 (0.0%)  	vpslld	$14,%xmm4,%xmm5
813 (0.0%)  	addl	%r12d,%edx
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	andl	%r15d,%edi
813 (0.0%)  	vpxor	%xmm6,%xmm7,%xmm4
813 (0.0%)  	xorl	%r8d,%r14d
813 (0.0%)  	addl	%r13d,%edx
813 (0.0%)  	xorl	%r9d,%edi
813 (0.0%)  	vpshufd	$250,%xmm2,%xmm7
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	addl	%edx,%r11d
813 (0.0%)  	addl	%edi,%edx
813 (0.0%)  	vpsrld	$11,%xmm6,%xmm6
813 (0.0%)  	movl	%r11d,%r13d
813 (0.0%)  	addl	%edx,%r14d
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
813 (0.0%)  	movl	%r14d,%edx
813 (0.0%)  	movl	%eax,%r12d
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	vpslld	$11,%xmm5,%xmm5
813 (0.0%)  	xorl	%r11d,%r13d
813 (0.0%)  	xorl	%ebx,%r12d
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	vpxor	%xmm6,%xmm4,%xmm4
813 (0.0%)  	xorl	%edx,%r14d
813 (0.0%)  	andl	%r11d,%r12d
813 (0.0%)  	xorl	%r11d,%r13d
813 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
813 (0.0%)  	addl	52(%rsp),%ecx
813 (0.0%)  	movl	%edx,%edi
813 (0.0%)  	xorl	%ebx,%r12d
813 (0.0%)  	vpxor	%xmm5,%xmm4,%xmm4
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	xorl	%r8d,%edi
813 (0.0%)  	addl	%r12d,%ecx
813 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	andl	%edi,%r15d
813 (0.0%)  	xorl	%edx,%r14d
813 (0.0%)  	vpaddd	%xmm4,%xmm3,%xmm3
813 (0.0%)  	addl	%r13d,%ecx
813 (0.0%)  	xorl	%r8d,%r15d
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	addl	%ecx,%r10d
813 (0.0%)  	addl	%r15d,%ecx
813 (0.0%)  	movl	%r10d,%r13d
813 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
813 (0.0%)  	addl	%ecx,%r14d
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	movl	%r14d,%ecx
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	movl	%r11d,%r12d
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	xorl	%r10d,%r13d
813 (0.0%)  	vpshufb	%xmm8,%xmm6,%xmm6
813 (0.0%)  	xorl	%eax,%r12d
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	xorl	%ecx,%r14d
813 (0.0%)  	vpaddd	%xmm6,%xmm3,%xmm3
813 (0.0%)  	andl	%r10d,%r12d
813 (0.0%)  	xorl	%r10d,%r13d
813 (0.0%)  	addl	56(%rsp),%ebx
813 (0.0%)  	vpshufd	$80,%xmm3,%xmm7
813 (0.0%)  	movl	%ecx,%r15d
813 (0.0%)  	xorl	%eax,%r12d
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	vpsrld	$10,%xmm7,%xmm6
813 (0.0%)  	xorl	%edx,%r15d
813 (0.0%)  	addl	%r12d,%ebx
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	vpsrlq	$17,%xmm7,%xmm7
813 (0.0%)  	andl	%r15d,%edi
813 (0.0%)  	xorl	%ecx,%r14d
813 (0.0%)  	addl	%r13d,%ebx
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	xorl	%edx,%edi
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	addl	%ebx,%r9d
813 (0.0%)  	vpsrlq	$2,%xmm7,%xmm7
813 (0.0%)  	addl	%edi,%ebx
813 (0.0%)  	movl	%r9d,%r13d
813 (0.0%)  	addl	%ebx,%r14d
813 (0.0%)  	vpxor	%xmm7,%xmm6,%xmm6
813 (0.0%)  	shrdl	$14,%r13d,%r13d
813 (0.0%)  	movl	%r14d,%ebx
813 (0.0%)  	movl	%r10d,%r12d
813 (0.0%)  	vpshufb	%xmm9,%xmm6,%xmm6
813 (0.0%)  	shrdl	$9,%r14d,%r14d
813 (0.0%)  	xorl	%r9d,%r13d
813 (0.0%)  	xorl	%r11d,%r12d
813 (0.0%)  	vpaddd	%xmm6,%xmm3,%xmm3
813 (0.0%)  	shrdl	$5,%r13d,%r13d
813 (0.0%)  	xorl	%ebx,%r14d
813 (0.0%)  	andl	%r9d,%r12d
813 (0.0%)  	vpaddd	96(%rbp),%xmm3,%xmm6
813 (0.0%)  	xorl	%r9d,%r13d
813 (0.0%)  	addl	60(%rsp),%eax
813 (0.0%)  	movl	%ebx,%edi
813 (0.0%)  	xorl	%r11d,%r12d
813 (0.0%)  	shrdl	$11,%r14d,%r14d
813 (0.0%)  	xorl	%ecx,%edi
813 (0.0%)  	addl	%r12d,%eax
813 (0.0%)  	shrdl	$6,%r13d,%r13d
813 (0.0%)  	andl	%edi,%r15d
813 (0.0%)  	xorl	%ebx,%r14d
813 (0.0%)  	addl	%r13d,%eax
813 (0.0%)  	xorl	%ecx,%r15d
813 (0.0%)  	shrdl	$2,%r14d,%r14d
813 (0.0%)  	addl	%eax,%r8d
813 (0.0%)  	addl	%r15d,%eax
813 (0.0%)  	movl	%r8d,%r13d
813 (0.0%)  	addl	%eax,%r14d
813 (0.0%)  	vmovdqa	%xmm6,48(%rsp)
813 (0.0%)  	cmpb	$0,131(%rbp)
813 (0.0%)  	jne	.Lavx_00_47
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%eax
271 (0.0%)  	movl	%r9d,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%r8d,%r13d
271 (0.0%)  	xorl	%r10d,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%eax,%r14d
271 (0.0%)  	andl	%r8d,%r12d
271 (0.0%)  	xorl	%r8d,%r13d
271 (0.0%)  	addl	0(%rsp),%r11d
271 (0.0%)  	movl	%eax,%r15d
271 (0.0%)  	xorl	%r10d,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%ebx,%r15d
271 (0.0%)  	addl	%r12d,%r11d
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%r15d,%edi
271 (0.0%)  	xorl	%eax,%r14d
271 (0.0%)  	addl	%r13d,%r11d
271 (0.0%)  	xorl	%ebx,%edi
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%r11d,%edx
271 (0.0%)  	addl	%edi,%r11d
271 (0.0%)  	movl	%edx,%r13d
271 (0.0%)  	addl	%r11d,%r14d
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%r11d
271 (0.0%)  	movl	%r8d,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%edx,%r13d
271 (0.0%)  	xorl	%r9d,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%r11d,%r14d
271 (0.0%)  	andl	%edx,%r12d
271 (0.0%)  	xorl	%edx,%r13d
271 (0.0%)  	addl	4(%rsp),%r10d
271 (0.0%)  	movl	%r11d,%edi
271 (0.0%)  	xorl	%r9d,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%eax,%edi
271 (0.0%)  	addl	%r12d,%r10d
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%edi,%r15d
271 (0.0%)  	xorl	%r11d,%r14d
271 (0.0%)  	addl	%r13d,%r10d
271 (0.0%)  	xorl	%eax,%r15d
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%r10d,%ecx
271 (0.0%)  	addl	%r15d,%r10d
271 (0.0%)  	movl	%ecx,%r13d
271 (0.0%)  	addl	%r10d,%r14d
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%r10d
271 (0.0%)  	movl	%edx,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%ecx,%r13d
271 (0.0%)  	xorl	%r8d,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%r10d,%r14d
271 (0.0%)  	andl	%ecx,%r12d
271 (0.0%)  	xorl	%ecx,%r13d
271 (0.0%)  	addl	8(%rsp),%r9d
271 (0.0%)  	movl	%r10d,%r15d
271 (0.0%)  	xorl	%r8d,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%r11d,%r15d
271 (0.0%)  	addl	%r12d,%r9d
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%r15d,%edi
271 (0.0%)  	xorl	%r10d,%r14d
271 (0.0%)  	addl	%r13d,%r9d
271 (0.0%)  	xorl	%r11d,%edi
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%r9d,%ebx
271 (0.0%)  	addl	%edi,%r9d
271 (0.0%)  	movl	%ebx,%r13d
271 (0.0%)  	addl	%r9d,%r14d
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%r9d
271 (0.0%)  	movl	%ecx,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%ebx,%r13d
271 (0.0%)  	xorl	%edx,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%r9d,%r14d
271 (0.0%)  	andl	%ebx,%r12d
271 (0.0%)  	xorl	%ebx,%r13d
271 (0.0%)  	addl	12(%rsp),%r8d
271 (0.0%)  	movl	%r9d,%edi
271 (0.0%)  	xorl	%edx,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%r10d,%edi
271 (0.0%)  	addl	%r12d,%r8d
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%edi,%r15d
271 (0.0%)  	xorl	%r9d,%r14d
271 (0.0%)  	addl	%r13d,%r8d
271 (0.0%)  	xorl	%r10d,%r15d
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%r8d,%eax
271 (0.0%)  	addl	%r15d,%r8d
271 (0.0%)  	movl	%eax,%r13d
271 (0.0%)  	addl	%r8d,%r14d
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%r8d
271 (0.0%)  	movl	%ebx,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%eax,%r13d
271 (0.0%)  	xorl	%ecx,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%r8d,%r14d
271 (0.0%)  	andl	%eax,%r12d
271 (0.0%)  	xorl	%eax,%r13d
271 (0.0%)  	addl	16(%rsp),%edx
271 (0.0%)  	movl	%r8d,%r15d
271 (0.0%)  	xorl	%ecx,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%r9d,%r15d
271 (0.0%)  	addl	%r12d,%edx
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%r15d,%edi
271 (0.0%)  	xorl	%r8d,%r14d
271 (0.0%)  	addl	%r13d,%edx
271 (0.0%)  	xorl	%r9d,%edi
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%edx,%r11d
271 (0.0%)  	addl	%edi,%edx
271 (0.0%)  	movl	%r11d,%r13d
271 (0.0%)  	addl	%edx,%r14d
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%edx
271 (0.0%)  	movl	%eax,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%r11d,%r13d
271 (0.0%)  	xorl	%ebx,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%edx,%r14d
271 (0.0%)  	andl	%r11d,%r12d
271 (0.0%)  	xorl	%r11d,%r13d
271 (0.0%)  	addl	20(%rsp),%ecx
271 (0.0%)  	movl	%edx,%edi
271 (0.0%)  	xorl	%ebx,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%r8d,%edi
271 (0.0%)  	addl	%r12d,%ecx
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%edi,%r15d
271 (0.0%)  	xorl	%edx,%r14d
271 (0.0%)  	addl	%r13d,%ecx
271 (0.0%)  	xorl	%r8d,%r15d
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%ecx,%r10d
271 (0.0%)  	addl	%r15d,%ecx
271 (0.0%)  	movl	%r10d,%r13d
271 (0.0%)  	addl	%ecx,%r14d
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%ecx
271 (0.0%)  	movl	%r11d,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%r10d,%r13d
271 (0.0%)  	xorl	%eax,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%ecx,%r14d
271 (0.0%)  	andl	%r10d,%r12d
271 (0.0%)  	xorl	%r10d,%r13d
271 (0.0%)  	addl	24(%rsp),%ebx
271 (0.0%)  	movl	%ecx,%r15d
271 (0.0%)  	xorl	%eax,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%edx,%r15d
271 (0.0%)  	addl	%r12d,%ebx
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%r15d,%edi
271 (0.0%)  	xorl	%ecx,%r14d
271 (0.0%)  	addl	%r13d,%ebx
271 (0.0%)  	xorl	%edx,%edi
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%ebx,%r9d
271 (0.0%)  	addl	%edi,%ebx
271 (0.0%)  	movl	%r9d,%r13d
271 (0.0%)  	addl	%ebx,%r14d
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%ebx
271 (0.0%)  	movl	%r10d,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%r9d,%r13d
271 (0.0%)  	xorl	%r11d,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%ebx,%r14d
271 (0.0%)  	andl	%r9d,%r12d
271 (0.0%)  	xorl	%r9d,%r13d
271 (0.0%)  	addl	28(%rsp),%eax
271 (0.0%)  	movl	%ebx,%edi
271 (0.0%)  	xorl	%r11d,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%ecx,%edi
271 (0.0%)  	addl	%r12d,%eax
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%edi,%r15d
271 (0.0%)  	xorl	%ebx,%r14d
271 (0.0%)  	addl	%r13d,%eax
271 (0.0%)  	xorl	%ecx,%r15d
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%eax,%r8d
271 (0.0%)  	addl	%r15d,%eax
271 (0.0%)  	movl	%r8d,%r13d
271 (0.0%)  	addl	%eax,%r14d
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%eax
271 (0.0%)  	movl	%r9d,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%r8d,%r13d
271 (0.0%)  	xorl	%r10d,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%eax,%r14d
271 (0.0%)  	andl	%r8d,%r12d
271 (0.0%)  	xorl	%r8d,%r13d
271 (0.0%)  	addl	32(%rsp),%r11d
271 (0.0%)  	movl	%eax,%r15d
271 (0.0%)  	xorl	%r10d,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%ebx,%r15d
271 (0.0%)  	addl	%r12d,%r11d
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%r15d,%edi
271 (0.0%)  	xorl	%eax,%r14d
271 (0.0%)  	addl	%r13d,%r11d
271 (0.0%)  	xorl	%ebx,%edi
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%r11d,%edx
271 (0.0%)  	addl	%edi,%r11d
271 (0.0%)  	movl	%edx,%r13d
271 (0.0%)  	addl	%r11d,%r14d
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%r11d
271 (0.0%)  	movl	%r8d,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%edx,%r13d
271 (0.0%)  	xorl	%r9d,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%r11d,%r14d
271 (0.0%)  	andl	%edx,%r12d
271 (0.0%)  	xorl	%edx,%r13d
271 (0.0%)  	addl	36(%rsp),%r10d
271 (0.0%)  	movl	%r11d,%edi
271 (0.0%)  	xorl	%r9d,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%eax,%edi
271 (0.0%)  	addl	%r12d,%r10d
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%edi,%r15d
271 (0.0%)  	xorl	%r11d,%r14d
271 (0.0%)  	addl	%r13d,%r10d
271 (0.0%)  	xorl	%eax,%r15d
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%r10d,%ecx
271 (0.0%)  	addl	%r15d,%r10d
271 (0.0%)  	movl	%ecx,%r13d
271 (0.0%)  	addl	%r10d,%r14d
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%r10d
271 (0.0%)  	movl	%edx,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%ecx,%r13d
271 (0.0%)  	xorl	%r8d,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%r10d,%r14d
271 (0.0%)  	andl	%ecx,%r12d
271 (0.0%)  	xorl	%ecx,%r13d
271 (0.0%)  	addl	40(%rsp),%r9d
271 (0.0%)  	movl	%r10d,%r15d
271 (0.0%)  	xorl	%r8d,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%r11d,%r15d
271 (0.0%)  	addl	%r12d,%r9d
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%r15d,%edi
271 (0.0%)  	xorl	%r10d,%r14d
271 (0.0%)  	addl	%r13d,%r9d
271 (0.0%)  	xorl	%r11d,%edi
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%r9d,%ebx
271 (0.0%)  	addl	%edi,%r9d
271 (0.0%)  	movl	%ebx,%r13d
271 (0.0%)  	addl	%r9d,%r14d
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%r9d
271 (0.0%)  	movl	%ecx,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%ebx,%r13d
271 (0.0%)  	xorl	%edx,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%r9d,%r14d
271 (0.0%)  	andl	%ebx,%r12d
271 (0.0%)  	xorl	%ebx,%r13d
271 (0.0%)  	addl	44(%rsp),%r8d
271 (0.0%)  	movl	%r9d,%edi
271 (0.0%)  	xorl	%edx,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%r10d,%edi
271 (0.0%)  	addl	%r12d,%r8d
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%edi,%r15d
271 (0.0%)  	xorl	%r9d,%r14d
271 (0.0%)  	addl	%r13d,%r8d
271 (0.0%)  	xorl	%r10d,%r15d
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%r8d,%eax
271 (0.0%)  	addl	%r15d,%r8d
271 (0.0%)  	movl	%eax,%r13d
271 (0.0%)  	addl	%r8d,%r14d
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%r8d
271 (0.0%)  	movl	%ebx,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%eax,%r13d
271 (0.0%)  	xorl	%ecx,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%r8d,%r14d
271 (0.0%)  	andl	%eax,%r12d
271 (0.0%)  	xorl	%eax,%r13d
271 (0.0%)  	addl	48(%rsp),%edx
271 (0.0%)  	movl	%r8d,%r15d
271 (0.0%)  	xorl	%ecx,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%r9d,%r15d
271 (0.0%)  	addl	%r12d,%edx
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%r15d,%edi
271 (0.0%)  	xorl	%r8d,%r14d
271 (0.0%)  	addl	%r13d,%edx
271 (0.0%)  	xorl	%r9d,%edi
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%edx,%r11d
271 (0.0%)  	addl	%edi,%edx
271 (0.0%)  	movl	%r11d,%r13d
271 (0.0%)  	addl	%edx,%r14d
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%edx
271 (0.0%)  	movl	%eax,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%r11d,%r13d
271 (0.0%)  	xorl	%ebx,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%edx,%r14d
271 (0.0%)  	andl	%r11d,%r12d
271 (0.0%)  	xorl	%r11d,%r13d
271 (0.0%)  	addl	52(%rsp),%ecx
271 (0.0%)  	movl	%edx,%edi
271 (0.0%)  	xorl	%ebx,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%r8d,%edi
271 (0.0%)  	addl	%r12d,%ecx
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%edi,%r15d
271 (0.0%)  	xorl	%edx,%r14d
271 (0.0%)  	addl	%r13d,%ecx
271 (0.0%)  	xorl	%r8d,%r15d
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%ecx,%r10d
271 (0.0%)  	addl	%r15d,%ecx
271 (0.0%)  	movl	%r10d,%r13d
271 (0.0%)  	addl	%ecx,%r14d
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%ecx
271 (0.0%)  	movl	%r11d,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%r10d,%r13d
271 (0.0%)  	xorl	%eax,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%ecx,%r14d
271 (0.0%)  	andl	%r10d,%r12d
271 (0.0%)  	xorl	%r10d,%r13d
271 (0.0%)  	addl	56(%rsp),%ebx
271 (0.0%)  	movl	%ecx,%r15d
271 (0.0%)  	xorl	%eax,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%edx,%r15d
271 (0.0%)  	addl	%r12d,%ebx
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%r15d,%edi
271 (0.0%)  	xorl	%ecx,%r14d
271 (0.0%)  	addl	%r13d,%ebx
271 (0.0%)  	xorl	%edx,%edi
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%ebx,%r9d
271 (0.0%)  	addl	%edi,%ebx
271 (0.0%)  	movl	%r9d,%r13d
271 (0.0%)  	addl	%ebx,%r14d
271 (0.0%)  	shrdl	$14,%r13d,%r13d
271 (0.0%)  	movl	%r14d,%ebx
271 (0.0%)  	movl	%r10d,%r12d
271 (0.0%)  	shrdl	$9,%r14d,%r14d
271 (0.0%)  	xorl	%r9d,%r13d
271 (0.0%)  	xorl	%r11d,%r12d
271 (0.0%)  	shrdl	$5,%r13d,%r13d
271 (0.0%)  	xorl	%ebx,%r14d
271 (0.0%)  	andl	%r9d,%r12d
271 (0.0%)  	xorl	%r9d,%r13d
271 (0.0%)  	addl	60(%rsp),%eax
271 (0.0%)  	movl	%ebx,%edi
271 (0.0%)  	xorl	%r11d,%r12d
271 (0.0%)  	shrdl	$11,%r14d,%r14d
271 (0.0%)  	xorl	%ecx,%edi
271 (0.0%)  	addl	%r12d,%eax
271 (0.0%)  	shrdl	$6,%r13d,%r13d
271 (0.0%)  	andl	%edi,%r15d
271 (0.0%)  	xorl	%ebx,%r14d
271 (0.0%)  	addl	%r13d,%eax
271 (0.0%)  	xorl	%ecx,%r15d
271 (0.0%)  	shrdl	$2,%r14d,%r14d
271 (0.0%)  	addl	%eax,%r8d
271 (0.0%)  	addl	%r15d,%eax
271 (0.0%)  	movl	%r8d,%r13d
271 (0.0%)  	addl	%eax,%r14d
271 (0.0%)  	movq	64+0(%rsp),%rdi
271 (0.0%)  	movl	%r14d,%eax
  .         
271 (0.0%)  	addl	0(%rdi),%eax
271 (0.0%)  	leaq	64(%rsi),%rsi
271 (0.0%)  	addl	4(%rdi),%ebx
271 (0.0%)  	addl	8(%rdi),%ecx
271 (0.0%)  	addl	12(%rdi),%edx
271 (0.0%)  	addl	16(%rdi),%r8d
271 (0.0%)  	addl	20(%rdi),%r9d
271 (0.0%)  	addl	24(%rdi),%r10d
271 (0.0%)  	addl	28(%rdi),%r11d
  .         
271 (0.0%)  	cmpq	64+16(%rsp),%rsi
  .         
271 (0.0%)  	movl	%eax,0(%rdi)
271 (0.0%)  	movl	%ebx,4(%rdi)
271 (0.0%)  	movl	%ecx,8(%rdi)
271 (0.0%)  	movl	%edx,12(%rdi)
271 (0.0%)  	movl	%r8d,16(%rdi)
271 (0.0%)  	movl	%r9d,20(%rdi)
271 (0.0%)  	movl	%r10d,24(%rdi)
271 (0.0%)  	movl	%r11d,28(%rdi)
271 (0.0%)  	jb	.Lloop_avx
  .         
225 (0.0%)  	movq	88(%rsp),%rsi
  .         .cfi_def_cfa	%rsi,8
225 (0.0%)  	vzeroupper
225 (0.0%)  	movq	-48(%rsi),%r15
  .         .cfi_restore	%r15
225 (0.0%)  	movq	-40(%rsi),%r14
  .         .cfi_restore	%r14
225 (0.0%)  	movq	-32(%rsi),%r13
  .         .cfi_restore	%r13
225 (0.0%)  	movq	-24(%rsi),%r12
  .         .cfi_restore	%r12
225 (0.0%)  	movq	-16(%rsi),%rbp
  .         .cfi_restore	%rbp
225 (0.0%)  	movq	-8(%rsi),%rbx
  .         .cfi_restore	%rbx
450 (0.0%)  	leaq	(%rsi),%rsp
  .         .cfi_def_cfa_register	%rsp
  .         .Lepilogue_avx:
  .         	.byte	0xf3,0xc3
  .         .cfi_endproc	
  .         .size	sha256_block_data_order_avx,.-sha256_block_data_order_avx
  .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/sha512-x86_64.S
--------------------------------------------------------------------------------
Ir_______ 

-- line 9 ----------------------------------------
 .         .extern	OPENSSL_ia32cap_P
 .         .hidden OPENSSL_ia32cap_P
 .         .globl	sha512_block_data_order
 .         .hidden sha512_block_data_order
 .         .type	sha512_block_data_order,@function
 .         .align	16
 .         sha512_block_data_order:
 .         .cfi_startproc	
13 (0.0%)  	leaq	OPENSSL_ia32cap_P(%rip),%r11
13 (0.0%)  	movl	0(%r11),%r9d
13 (0.0%)  	movl	4(%r11),%r10d
13 (0.0%)  	movl	8(%r11),%r11d
13 (0.0%)  	andl	$1073741824,%r9d
13 (0.0%)  	andl	$268435968,%r10d
13 (0.0%)  	orl	%r9d,%r10d
13 (0.0%)  	cmpl	$1342177792,%r10d
13 (0.0%)  	je	.Lavx_shortcut
 .         	movq	%rsp,%rax
 .         .cfi_def_cfa_register	%rax
 .         	pushq	%rbx
 .         .cfi_offset	%rbx,-16
 .         	pushq	%rbp
 .         .cfi_offset	%rbp,-24
 .         	pushq	%r12
 .         .cfi_offset	%r12,-32
-- line 33 ----------------------------------------
-- line 1818 ----------------------------------------
 .         .quad	0x0001020304050607,0x08090a0b0c0d0e0f
 .         .byte	83,72,65,53,49,50,32,98,108,111,99,107,32,116,114,97,110,115,102,111,114,109,32,102,111,114,32,120,56,54,95,54,52,44,32,67,82,89,80,84,79,71,65,77,83,32,98,121,32,60,97,112,112,114,111,64,111,112,101,110,115,115,108,46,111,114,103,62,0
 .         .text	
 .         .type	sha512_block_data_order_avx,@function
 .         .align	64
 .         sha512_block_data_order_avx:
 .         .cfi_startproc	
 .         .Lavx_shortcut:
13 (0.0%)  	movq	%rsp,%rax
 .         .cfi_def_cfa_register	%rax
13 (0.0%)  	pushq	%rbx
 .         .cfi_offset	%rbx,-16
13 (0.0%)  	pushq	%rbp
 .         .cfi_offset	%rbp,-24
13 (0.0%)  	pushq	%r12
 .         .cfi_offset	%r12,-32
13 (0.0%)  	pushq	%r13
 .         .cfi_offset	%r13,-40
13 (0.0%)  	pushq	%r14
 .         .cfi_offset	%r14,-48
13 (0.0%)  	pushq	%r15
 .         .cfi_offset	%r15,-56
13 (0.0%)  	shlq	$4,%rdx
13 (0.0%)  	subq	$160,%rsp
13 (0.0%)  	leaq	(%rsi,%rdx,8),%rdx
13 (0.0%)  	andq	$-64,%rsp
13 (0.0%)  	movq	%rdi,128+0(%rsp)
13 (0.0%)  	movq	%rsi,128+8(%rsp)
13 (0.0%)  	movq	%rdx,128+16(%rsp)
13 (0.0%)  	movq	%rax,152(%rsp)
 .         .cfi_escape	0x0f,0x06,0x77,0x98,0x01,0x06,0x23,0x08
 .         .Lprologue_avx:
 .         
13 (0.0%)  	vzeroupper
13 (0.0%)  	movq	0(%rdi),%rax
13 (0.0%)  	movq	8(%rdi),%rbx
13 (0.0%)  	movq	16(%rdi),%rcx
13 (0.0%)  	movq	24(%rdi),%rdx
13 (0.0%)  	movq	32(%rdi),%r8
13 (0.0%)  	movq	40(%rdi),%r9
13 (0.0%)  	movq	48(%rdi),%r10
13 (0.0%)  	movq	56(%rdi),%r11
13 (0.0%)  	jmp	.Lloop_avx
 .         .align	16
 .         .Lloop_avx:
17 (0.0%)  	vmovdqa	K512+1280(%rip),%xmm11
17 (0.0%)  	vmovdqu	0(%rsi),%xmm0
17 (0.0%)  	leaq	K512+128(%rip),%rbp
17 (0.0%)  	vmovdqu	16(%rsi),%xmm1
17 (0.0%)  	vmovdqu	32(%rsi),%xmm2
17 (0.0%)  	vpshufb	%xmm11,%xmm0,%xmm0
17 (0.0%)  	vmovdqu	48(%rsi),%xmm3
17 (0.0%)  	vpshufb	%xmm11,%xmm1,%xmm1
17 (0.0%)  	vmovdqu	64(%rsi),%xmm4
17 (0.0%)  	vpshufb	%xmm11,%xmm2,%xmm2
17 (0.0%)  	vmovdqu	80(%rsi),%xmm5
17 (0.0%)  	vpshufb	%xmm11,%xmm3,%xmm3
17 (0.0%)  	vmovdqu	96(%rsi),%xmm6
17 (0.0%)  	vpshufb	%xmm11,%xmm4,%xmm4
17 (0.0%)  	vmovdqu	112(%rsi),%xmm7
17 (0.0%)  	vpshufb	%xmm11,%xmm5,%xmm5
17 (0.0%)  	vpaddq	-128(%rbp),%xmm0,%xmm8
17 (0.0%)  	vpshufb	%xmm11,%xmm6,%xmm6
17 (0.0%)  	vpaddq	-96(%rbp),%xmm1,%xmm9
17 (0.0%)  	vpshufb	%xmm11,%xmm7,%xmm7
17 (0.0%)  	vpaddq	-64(%rbp),%xmm2,%xmm10
17 (0.0%)  	vpaddq	-32(%rbp),%xmm3,%xmm11
17 (0.0%)  	vmovdqa	%xmm8,0(%rsp)
17 (0.0%)  	vpaddq	0(%rbp),%xmm4,%xmm8
17 (0.0%)  	vmovdqa	%xmm9,16(%rsp)
17 (0.0%)  	vpaddq	32(%rbp),%xmm5,%xmm9
17 (0.0%)  	vmovdqa	%xmm10,32(%rsp)
17 (0.0%)  	vpaddq	64(%rbp),%xmm6,%xmm10
17 (0.0%)  	vmovdqa	%xmm11,48(%rsp)
17 (0.0%)  	vpaddq	96(%rbp),%xmm7,%xmm11
17 (0.0%)  	vmovdqa	%xmm8,64(%rsp)
17 (0.0%)  	movq	%rax,%r14
17 (0.0%)  	vmovdqa	%xmm9,80(%rsp)
17 (0.0%)  	movq	%rbx,%rdi
17 (0.0%)  	vmovdqa	%xmm10,96(%rsp)
17 (0.0%)  	xorq	%rcx,%rdi
17 (0.0%)  	vmovdqa	%xmm11,112(%rsp)
17 (0.0%)  	movq	%r8,%r13
17 (0.0%)  	jmp	.Lavx_00_47
 .         
 .         .align	16
 .         .Lavx_00_47:
68 (0.0%)  	addq	$256,%rbp
68 (0.0%)  	vpalignr	$8,%xmm0,%xmm1,%xmm8
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%rax
68 (0.0%)  	vpalignr	$8,%xmm4,%xmm5,%xmm11
68 (0.0%)  	movq	%r9,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
68 (0.0%)  	xorq	%r8,%r13
68 (0.0%)  	xorq	%r10,%r12
68 (0.0%)  	vpaddq	%xmm11,%xmm0,%xmm0
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%rax,%r14
68 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
68 (0.0%)  	andq	%r8,%r12
68 (0.0%)  	xorq	%r8,%r13
68 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
68 (0.0%)  	addq	0(%rsp),%r11
68 (0.0%)  	movq	%rax,%r15
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
68 (0.0%)  	xorq	%r10,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
68 (0.0%)  	xorq	%rbx,%r15
68 (0.0%)  	addq	%r12,%r11
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%r15,%rdi
68 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
68 (0.0%)  	xorq	%rax,%r14
68 (0.0%)  	addq	%r13,%r11
68 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
68 (0.0%)  	xorq	%rbx,%rdi
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	vpsrlq	$6,%xmm7,%xmm11
68 (0.0%)  	addq	%r11,%rdx
68 (0.0%)  	addq	%rdi,%r11
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	movq	%rdx,%r13
68 (0.0%)  	addq	%r11,%r14
68 (0.0%)  	vpsllq	$3,%xmm7,%xmm10
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%r11
68 (0.0%)  	vpaddq	%xmm8,%xmm0,%xmm0
68 (0.0%)  	movq	%r8,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$19,%xmm7,%xmm9
68 (0.0%)  	xorq	%rdx,%r13
68 (0.0%)  	xorq	%r9,%r12
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%r11,%r14
68 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
68 (0.0%)  	andq	%rdx,%r12
68 (0.0%)  	xorq	%rdx,%r13
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	addq	8(%rsp),%r10
68 (0.0%)  	movq	%r11,%rdi
68 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
68 (0.0%)  	xorq	%r9,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	xorq	%rax,%rdi
68 (0.0%)  	addq	%r12,%r10
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%rdi,%r15
68 (0.0%)  	vpaddq	%xmm11,%xmm0,%xmm0
68 (0.0%)  	xorq	%r11,%r14
68 (0.0%)  	addq	%r13,%r10
68 (0.0%)  	vpaddq	-128(%rbp),%xmm0,%xmm10
68 (0.0%)  	xorq	%rax,%r15
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	addq	%r10,%rcx
68 (0.0%)  	addq	%r15,%r10
68 (0.0%)  	movq	%rcx,%r13
68 (0.0%)  	addq	%r10,%r14
68 (0.0%)  	vmovdqa	%xmm10,0(%rsp)
68 (0.0%)  	vpalignr	$8,%xmm1,%xmm2,%xmm8
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%r10
68 (0.0%)  	vpalignr	$8,%xmm5,%xmm6,%xmm11
68 (0.0%)  	movq	%rdx,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
68 (0.0%)  	xorq	%rcx,%r13
68 (0.0%)  	xorq	%r8,%r12
68 (0.0%)  	vpaddq	%xmm11,%xmm1,%xmm1
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%r10,%r14
68 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
68 (0.0%)  	andq	%rcx,%r12
68 (0.0%)  	xorq	%rcx,%r13
68 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
68 (0.0%)  	addq	16(%rsp),%r9
68 (0.0%)  	movq	%r10,%r15
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
68 (0.0%)  	xorq	%r8,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
68 (0.0%)  	xorq	%r11,%r15
68 (0.0%)  	addq	%r12,%r9
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%r15,%rdi
68 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
68 (0.0%)  	xorq	%r10,%r14
68 (0.0%)  	addq	%r13,%r9
68 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
68 (0.0%)  	xorq	%r11,%rdi
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	vpsrlq	$6,%xmm0,%xmm11
68 (0.0%)  	addq	%r9,%rbx
68 (0.0%)  	addq	%rdi,%r9
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	movq	%rbx,%r13
68 (0.0%)  	addq	%r9,%r14
68 (0.0%)  	vpsllq	$3,%xmm0,%xmm10
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%r9
68 (0.0%)  	vpaddq	%xmm8,%xmm1,%xmm1
68 (0.0%)  	movq	%rcx,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$19,%xmm0,%xmm9
68 (0.0%)  	xorq	%rbx,%r13
68 (0.0%)  	xorq	%rdx,%r12
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%r9,%r14
68 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
68 (0.0%)  	andq	%rbx,%r12
68 (0.0%)  	xorq	%rbx,%r13
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	addq	24(%rsp),%r8
68 (0.0%)  	movq	%r9,%rdi
68 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
68 (0.0%)  	xorq	%rdx,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	xorq	%r10,%rdi
68 (0.0%)  	addq	%r12,%r8
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%rdi,%r15
68 (0.0%)  	vpaddq	%xmm11,%xmm1,%xmm1
68 (0.0%)  	xorq	%r9,%r14
68 (0.0%)  	addq	%r13,%r8
68 (0.0%)  	vpaddq	-96(%rbp),%xmm1,%xmm10
68 (0.0%)  	xorq	%r10,%r15
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	addq	%r8,%rax
68 (0.0%)  	addq	%r15,%r8
68 (0.0%)  	movq	%rax,%r13
68 (0.0%)  	addq	%r8,%r14
68 (0.0%)  	vmovdqa	%xmm10,16(%rsp)
68 (0.0%)  	vpalignr	$8,%xmm2,%xmm3,%xmm8
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%r8
68 (0.0%)  	vpalignr	$8,%xmm6,%xmm7,%xmm11
68 (0.0%)  	movq	%rbx,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
68 (0.0%)  	xorq	%rax,%r13
68 (0.0%)  	xorq	%rcx,%r12
68 (0.0%)  	vpaddq	%xmm11,%xmm2,%xmm2
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%r8,%r14
68 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
68 (0.0%)  	andq	%rax,%r12
68 (0.0%)  	xorq	%rax,%r13
68 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
68 (0.0%)  	addq	32(%rsp),%rdx
68 (0.0%)  	movq	%r8,%r15
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
68 (0.0%)  	xorq	%rcx,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
68 (0.0%)  	xorq	%r9,%r15
68 (0.0%)  	addq	%r12,%rdx
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%r15,%rdi
68 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
68 (0.0%)  	xorq	%r8,%r14
68 (0.0%)  	addq	%r13,%rdx
68 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
68 (0.0%)  	xorq	%r9,%rdi
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	vpsrlq	$6,%xmm1,%xmm11
68 (0.0%)  	addq	%rdx,%r11
68 (0.0%)  	addq	%rdi,%rdx
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	movq	%r11,%r13
68 (0.0%)  	addq	%rdx,%r14
68 (0.0%)  	vpsllq	$3,%xmm1,%xmm10
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%rdx
68 (0.0%)  	vpaddq	%xmm8,%xmm2,%xmm2
68 (0.0%)  	movq	%rax,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$19,%xmm1,%xmm9
68 (0.0%)  	xorq	%r11,%r13
68 (0.0%)  	xorq	%rbx,%r12
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%rdx,%r14
68 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
68 (0.0%)  	andq	%r11,%r12
68 (0.0%)  	xorq	%r11,%r13
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	addq	40(%rsp),%rcx
68 (0.0%)  	movq	%rdx,%rdi
68 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
68 (0.0%)  	xorq	%rbx,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	xorq	%r8,%rdi
68 (0.0%)  	addq	%r12,%rcx
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%rdi,%r15
68 (0.0%)  	vpaddq	%xmm11,%xmm2,%xmm2
68 (0.0%)  	xorq	%rdx,%r14
68 (0.0%)  	addq	%r13,%rcx
68 (0.0%)  	vpaddq	-64(%rbp),%xmm2,%xmm10
68 (0.0%)  	xorq	%r8,%r15
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	addq	%rcx,%r10
68 (0.0%)  	addq	%r15,%rcx
68 (0.0%)  	movq	%r10,%r13
68 (0.0%)  	addq	%rcx,%r14
68 (0.0%)  	vmovdqa	%xmm10,32(%rsp)
68 (0.0%)  	vpalignr	$8,%xmm3,%xmm4,%xmm8
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%rcx
68 (0.0%)  	vpalignr	$8,%xmm7,%xmm0,%xmm11
68 (0.0%)  	movq	%r11,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
68 (0.0%)  	xorq	%r10,%r13
68 (0.0%)  	xorq	%rax,%r12
68 (0.0%)  	vpaddq	%xmm11,%xmm3,%xmm3
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%rcx,%r14
68 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
68 (0.0%)  	andq	%r10,%r12
68 (0.0%)  	xorq	%r10,%r13
68 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
68 (0.0%)  	addq	48(%rsp),%rbx
68 (0.0%)  	movq	%rcx,%r15
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
68 (0.0%)  	xorq	%rax,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
68 (0.0%)  	xorq	%rdx,%r15
68 (0.0%)  	addq	%r12,%rbx
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%r15,%rdi
68 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
68 (0.0%)  	xorq	%rcx,%r14
68 (0.0%)  	addq	%r13,%rbx
68 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
68 (0.0%)  	xorq	%rdx,%rdi
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	vpsrlq	$6,%xmm2,%xmm11
68 (0.0%)  	addq	%rbx,%r9
68 (0.0%)  	addq	%rdi,%rbx
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	movq	%r9,%r13
68 (0.0%)  	addq	%rbx,%r14
68 (0.0%)  	vpsllq	$3,%xmm2,%xmm10
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%rbx
68 (0.0%)  	vpaddq	%xmm8,%xmm3,%xmm3
68 (0.0%)  	movq	%r10,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$19,%xmm2,%xmm9
68 (0.0%)  	xorq	%r9,%r13
68 (0.0%)  	xorq	%r11,%r12
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%rbx,%r14
68 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
68 (0.0%)  	andq	%r9,%r12
68 (0.0%)  	xorq	%r9,%r13
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	addq	56(%rsp),%rax
68 (0.0%)  	movq	%rbx,%rdi
68 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
68 (0.0%)  	xorq	%r11,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	xorq	%rcx,%rdi
68 (0.0%)  	addq	%r12,%rax
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%rdi,%r15
68 (0.0%)  	vpaddq	%xmm11,%xmm3,%xmm3
68 (0.0%)  	xorq	%rbx,%r14
68 (0.0%)  	addq	%r13,%rax
68 (0.0%)  	vpaddq	-32(%rbp),%xmm3,%xmm10
68 (0.0%)  	xorq	%rcx,%r15
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	addq	%rax,%r8
68 (0.0%)  	addq	%r15,%rax
68 (0.0%)  	movq	%r8,%r13
68 (0.0%)  	addq	%rax,%r14
68 (0.0%)  	vmovdqa	%xmm10,48(%rsp)
68 (0.0%)  	vpalignr	$8,%xmm4,%xmm5,%xmm8
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%rax
68 (0.0%)  	vpalignr	$8,%xmm0,%xmm1,%xmm11
68 (0.0%)  	movq	%r9,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
68 (0.0%)  	xorq	%r8,%r13
68 (0.0%)  	xorq	%r10,%r12
68 (0.0%)  	vpaddq	%xmm11,%xmm4,%xmm4
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%rax,%r14
68 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
68 (0.0%)  	andq	%r8,%r12
68 (0.0%)  	xorq	%r8,%r13
68 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
68 (0.0%)  	addq	64(%rsp),%r11
68 (0.0%)  	movq	%rax,%r15
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
68 (0.0%)  	xorq	%r10,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
68 (0.0%)  	xorq	%rbx,%r15
68 (0.0%)  	addq	%r12,%r11
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%r15,%rdi
68 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
68 (0.0%)  	xorq	%rax,%r14
68 (0.0%)  	addq	%r13,%r11
68 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
68 (0.0%)  	xorq	%rbx,%rdi
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	vpsrlq	$6,%xmm3,%xmm11
68 (0.0%)  	addq	%r11,%rdx
68 (0.0%)  	addq	%rdi,%r11
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	movq	%rdx,%r13
68 (0.0%)  	addq	%r11,%r14
68 (0.0%)  	vpsllq	$3,%xmm3,%xmm10
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%r11
68 (0.0%)  	vpaddq	%xmm8,%xmm4,%xmm4
68 (0.0%)  	movq	%r8,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$19,%xmm3,%xmm9
68 (0.0%)  	xorq	%rdx,%r13
68 (0.0%)  	xorq	%r9,%r12
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%r11,%r14
68 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
68 (0.0%)  	andq	%rdx,%r12
68 (0.0%)  	xorq	%rdx,%r13
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	addq	72(%rsp),%r10
68 (0.0%)  	movq	%r11,%rdi
68 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
68 (0.0%)  	xorq	%r9,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	xorq	%rax,%rdi
68 (0.0%)  	addq	%r12,%r10
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%rdi,%r15
68 (0.0%)  	vpaddq	%xmm11,%xmm4,%xmm4
68 (0.0%)  	xorq	%r11,%r14
68 (0.0%)  	addq	%r13,%r10
68 (0.0%)  	vpaddq	0(%rbp),%xmm4,%xmm10
68 (0.0%)  	xorq	%rax,%r15
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	addq	%r10,%rcx
68 (0.0%)  	addq	%r15,%r10
68 (0.0%)  	movq	%rcx,%r13
68 (0.0%)  	addq	%r10,%r14
68 (0.0%)  	vmovdqa	%xmm10,64(%rsp)
68 (0.0%)  	vpalignr	$8,%xmm5,%xmm6,%xmm8
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%r10
68 (0.0%)  	vpalignr	$8,%xmm1,%xmm2,%xmm11
68 (0.0%)  	movq	%rdx,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
68 (0.0%)  	xorq	%rcx,%r13
68 (0.0%)  	xorq	%r8,%r12
68 (0.0%)  	vpaddq	%xmm11,%xmm5,%xmm5
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%r10,%r14
68 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
68 (0.0%)  	andq	%rcx,%r12
68 (0.0%)  	xorq	%rcx,%r13
68 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
68 (0.0%)  	addq	80(%rsp),%r9
68 (0.0%)  	movq	%r10,%r15
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
68 (0.0%)  	xorq	%r8,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
68 (0.0%)  	xorq	%r11,%r15
68 (0.0%)  	addq	%r12,%r9
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%r15,%rdi
68 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
68 (0.0%)  	xorq	%r10,%r14
68 (0.0%)  	addq	%r13,%r9
68 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
68 (0.0%)  	xorq	%r11,%rdi
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	vpsrlq	$6,%xmm4,%xmm11
68 (0.0%)  	addq	%r9,%rbx
68 (0.0%)  	addq	%rdi,%r9
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	movq	%rbx,%r13
68 (0.0%)  	addq	%r9,%r14
68 (0.0%)  	vpsllq	$3,%xmm4,%xmm10
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%r9
68 (0.0%)  	vpaddq	%xmm8,%xmm5,%xmm5
68 (0.0%)  	movq	%rcx,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$19,%xmm4,%xmm9
68 (0.0%)  	xorq	%rbx,%r13
68 (0.0%)  	xorq	%rdx,%r12
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%r9,%r14
68 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
68 (0.0%)  	andq	%rbx,%r12
68 (0.0%)  	xorq	%rbx,%r13
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	addq	88(%rsp),%r8
68 (0.0%)  	movq	%r9,%rdi
68 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
68 (0.0%)  	xorq	%rdx,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	xorq	%r10,%rdi
68 (0.0%)  	addq	%r12,%r8
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%rdi,%r15
68 (0.0%)  	vpaddq	%xmm11,%xmm5,%xmm5
68 (0.0%)  	xorq	%r9,%r14
68 (0.0%)  	addq	%r13,%r8
68 (0.0%)  	vpaddq	32(%rbp),%xmm5,%xmm10
68 (0.0%)  	xorq	%r10,%r15
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	addq	%r8,%rax
68 (0.0%)  	addq	%r15,%r8
68 (0.0%)  	movq	%rax,%r13
68 (0.0%)  	addq	%r8,%r14
68 (0.0%)  	vmovdqa	%xmm10,80(%rsp)
68 (0.0%)  	vpalignr	$8,%xmm6,%xmm7,%xmm8
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%r8
68 (0.0%)  	vpalignr	$8,%xmm2,%xmm3,%xmm11
68 (0.0%)  	movq	%rbx,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
68 (0.0%)  	xorq	%rax,%r13
68 (0.0%)  	xorq	%rcx,%r12
68 (0.0%)  	vpaddq	%xmm11,%xmm6,%xmm6
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%r8,%r14
68 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
68 (0.0%)  	andq	%rax,%r12
68 (0.0%)  	xorq	%rax,%r13
68 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
68 (0.0%)  	addq	96(%rsp),%rdx
68 (0.0%)  	movq	%r8,%r15
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
68 (0.0%)  	xorq	%rcx,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
68 (0.0%)  	xorq	%r9,%r15
68 (0.0%)  	addq	%r12,%rdx
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%r15,%rdi
68 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
68 (0.0%)  	xorq	%r8,%r14
68 (0.0%)  	addq	%r13,%rdx
68 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
68 (0.0%)  	xorq	%r9,%rdi
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	vpsrlq	$6,%xmm5,%xmm11
68 (0.0%)  	addq	%rdx,%r11
68 (0.0%)  	addq	%rdi,%rdx
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	movq	%r11,%r13
68 (0.0%)  	addq	%rdx,%r14
68 (0.0%)  	vpsllq	$3,%xmm5,%xmm10
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%rdx
68 (0.0%)  	vpaddq	%xmm8,%xmm6,%xmm6
68 (0.0%)  	movq	%rax,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$19,%xmm5,%xmm9
68 (0.0%)  	xorq	%r11,%r13
68 (0.0%)  	xorq	%rbx,%r12
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%rdx,%r14
68 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
68 (0.0%)  	andq	%r11,%r12
68 (0.0%)  	xorq	%r11,%r13
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	addq	104(%rsp),%rcx
68 (0.0%)  	movq	%rdx,%rdi
68 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
68 (0.0%)  	xorq	%rbx,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	xorq	%r8,%rdi
68 (0.0%)  	addq	%r12,%rcx
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%rdi,%r15
68 (0.0%)  	vpaddq	%xmm11,%xmm6,%xmm6
68 (0.0%)  	xorq	%rdx,%r14
68 (0.0%)  	addq	%r13,%rcx
68 (0.0%)  	vpaddq	64(%rbp),%xmm6,%xmm10
68 (0.0%)  	xorq	%r8,%r15
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	addq	%rcx,%r10
68 (0.0%)  	addq	%r15,%rcx
68 (0.0%)  	movq	%r10,%r13
68 (0.0%)  	addq	%rcx,%r14
68 (0.0%)  	vmovdqa	%xmm10,96(%rsp)
68 (0.0%)  	vpalignr	$8,%xmm7,%xmm0,%xmm8
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%rcx
68 (0.0%)  	vpalignr	$8,%xmm3,%xmm4,%xmm11
68 (0.0%)  	movq	%r11,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$1,%xmm8,%xmm10
68 (0.0%)  	xorq	%r10,%r13
68 (0.0%)  	xorq	%rax,%r12
68 (0.0%)  	vpaddq	%xmm11,%xmm7,%xmm7
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%rcx,%r14
68 (0.0%)  	vpsrlq	$7,%xmm8,%xmm11
68 (0.0%)  	andq	%r10,%r12
68 (0.0%)  	xorq	%r10,%r13
68 (0.0%)  	vpsllq	$56,%xmm8,%xmm9
68 (0.0%)  	addq	112(%rsp),%rbx
68 (0.0%)  	movq	%rcx,%r15
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm8
68 (0.0%)  	xorq	%rax,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpsrlq	$7,%xmm10,%xmm10
68 (0.0%)  	xorq	%rdx,%r15
68 (0.0%)  	addq	%r12,%rbx
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%r15,%rdi
68 (0.0%)  	vpsllq	$7,%xmm9,%xmm9
68 (0.0%)  	xorq	%rcx,%r14
68 (0.0%)  	addq	%r13,%rbx
68 (0.0%)  	vpxor	%xmm10,%xmm8,%xmm8
68 (0.0%)  	xorq	%rdx,%rdi
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	vpsrlq	$6,%xmm6,%xmm11
68 (0.0%)  	addq	%rbx,%r9
68 (0.0%)  	addq	%rdi,%rbx
68 (0.0%)  	vpxor	%xmm9,%xmm8,%xmm8
68 (0.0%)  	movq	%r9,%r13
68 (0.0%)  	addq	%rbx,%r14
68 (0.0%)  	vpsllq	$3,%xmm6,%xmm10
68 (0.0%)  	shrdq	$23,%r13,%r13
68 (0.0%)  	movq	%r14,%rbx
68 (0.0%)  	vpaddq	%xmm8,%xmm7,%xmm7
68 (0.0%)  	movq	%r10,%r12
68 (0.0%)  	shrdq	$5,%r14,%r14
68 (0.0%)  	vpsrlq	$19,%xmm6,%xmm9
68 (0.0%)  	xorq	%r9,%r13
68 (0.0%)  	xorq	%r11,%r12
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	shrdq	$4,%r13,%r13
68 (0.0%)  	xorq	%rbx,%r14
68 (0.0%)  	vpsllq	$42,%xmm10,%xmm10
68 (0.0%)  	andq	%r9,%r12
68 (0.0%)  	xorq	%r9,%r13
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	addq	120(%rsp),%rax
68 (0.0%)  	movq	%rbx,%rdi
68 (0.0%)  	vpsrlq	$42,%xmm9,%xmm9
68 (0.0%)  	xorq	%r11,%r12
68 (0.0%)  	shrdq	$6,%r14,%r14
68 (0.0%)  	vpxor	%xmm10,%xmm11,%xmm11
68 (0.0%)  	xorq	%rcx,%rdi
68 (0.0%)  	addq	%r12,%rax
68 (0.0%)  	vpxor	%xmm9,%xmm11,%xmm11
68 (0.0%)  	shrdq	$14,%r13,%r13
68 (0.0%)  	andq	%rdi,%r15
68 (0.0%)  	vpaddq	%xmm11,%xmm7,%xmm7
68 (0.0%)  	xorq	%rbx,%r14
68 (0.0%)  	addq	%r13,%rax
68 (0.0%)  	vpaddq	96(%rbp),%xmm7,%xmm10
68 (0.0%)  	xorq	%rcx,%r15
68 (0.0%)  	shrdq	$28,%r14,%r14
68 (0.0%)  	addq	%rax,%r8
68 (0.0%)  	addq	%r15,%rax
68 (0.0%)  	movq	%r8,%r13
68 (0.0%)  	addq	%rax,%r14
68 (0.0%)  	vmovdqa	%xmm10,112(%rsp)
68 (0.0%)  	cmpb	$0,135(%rbp)
68 (0.0%)  	jne	.Lavx_00_47
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%rax
17 (0.0%)  	movq	%r9,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%r8,%r13
17 (0.0%)  	xorq	%r10,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%rax,%r14
17 (0.0%)  	andq	%r8,%r12
17 (0.0%)  	xorq	%r8,%r13
17 (0.0%)  	addq	0(%rsp),%r11
17 (0.0%)  	movq	%rax,%r15
17 (0.0%)  	xorq	%r10,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%rbx,%r15
17 (0.0%)  	addq	%r12,%r11
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%r15,%rdi
17 (0.0%)  	xorq	%rax,%r14
17 (0.0%)  	addq	%r13,%r11
17 (0.0%)  	xorq	%rbx,%rdi
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%r11,%rdx
17 (0.0%)  	addq	%rdi,%r11
17 (0.0%)  	movq	%rdx,%r13
17 (0.0%)  	addq	%r11,%r14
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%r11
17 (0.0%)  	movq	%r8,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%rdx,%r13
17 (0.0%)  	xorq	%r9,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%r11,%r14
17 (0.0%)  	andq	%rdx,%r12
17 (0.0%)  	xorq	%rdx,%r13
17 (0.0%)  	addq	8(%rsp),%r10
17 (0.0%)  	movq	%r11,%rdi
17 (0.0%)  	xorq	%r9,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%rax,%rdi
17 (0.0%)  	addq	%r12,%r10
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%rdi,%r15
17 (0.0%)  	xorq	%r11,%r14
17 (0.0%)  	addq	%r13,%r10
17 (0.0%)  	xorq	%rax,%r15
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%r10,%rcx
17 (0.0%)  	addq	%r15,%r10
17 (0.0%)  	movq	%rcx,%r13
17 (0.0%)  	addq	%r10,%r14
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%r10
17 (0.0%)  	movq	%rdx,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%rcx,%r13
17 (0.0%)  	xorq	%r8,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%r10,%r14
17 (0.0%)  	andq	%rcx,%r12
17 (0.0%)  	xorq	%rcx,%r13
17 (0.0%)  	addq	16(%rsp),%r9
17 (0.0%)  	movq	%r10,%r15
17 (0.0%)  	xorq	%r8,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%r11,%r15
17 (0.0%)  	addq	%r12,%r9
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%r15,%rdi
17 (0.0%)  	xorq	%r10,%r14
17 (0.0%)  	addq	%r13,%r9
17 (0.0%)  	xorq	%r11,%rdi
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%r9,%rbx
17 (0.0%)  	addq	%rdi,%r9
17 (0.0%)  	movq	%rbx,%r13
17 (0.0%)  	addq	%r9,%r14
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%r9
17 (0.0%)  	movq	%rcx,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%rbx,%r13
17 (0.0%)  	xorq	%rdx,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%r9,%r14
17 (0.0%)  	andq	%rbx,%r12
17 (0.0%)  	xorq	%rbx,%r13
17 (0.0%)  	addq	24(%rsp),%r8
17 (0.0%)  	movq	%r9,%rdi
17 (0.0%)  	xorq	%rdx,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%r10,%rdi
17 (0.0%)  	addq	%r12,%r8
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%rdi,%r15
17 (0.0%)  	xorq	%r9,%r14
17 (0.0%)  	addq	%r13,%r8
17 (0.0%)  	xorq	%r10,%r15
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%r8,%rax
17 (0.0%)  	addq	%r15,%r8
17 (0.0%)  	movq	%rax,%r13
17 (0.0%)  	addq	%r8,%r14
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%r8
17 (0.0%)  	movq	%rbx,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%rax,%r13
17 (0.0%)  	xorq	%rcx,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%r8,%r14
17 (0.0%)  	andq	%rax,%r12
17 (0.0%)  	xorq	%rax,%r13
17 (0.0%)  	addq	32(%rsp),%rdx
17 (0.0%)  	movq	%r8,%r15
17 (0.0%)  	xorq	%rcx,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%r9,%r15
17 (0.0%)  	addq	%r12,%rdx
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%r15,%rdi
17 (0.0%)  	xorq	%r8,%r14
17 (0.0%)  	addq	%r13,%rdx
17 (0.0%)  	xorq	%r9,%rdi
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%rdx,%r11
17 (0.0%)  	addq	%rdi,%rdx
17 (0.0%)  	movq	%r11,%r13
17 (0.0%)  	addq	%rdx,%r14
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%rdx
17 (0.0%)  	movq	%rax,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%r11,%r13
17 (0.0%)  	xorq	%rbx,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%rdx,%r14
17 (0.0%)  	andq	%r11,%r12
17 (0.0%)  	xorq	%r11,%r13
17 (0.0%)  	addq	40(%rsp),%rcx
17 (0.0%)  	movq	%rdx,%rdi
17 (0.0%)  	xorq	%rbx,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%r8,%rdi
17 (0.0%)  	addq	%r12,%rcx
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%rdi,%r15
17 (0.0%)  	xorq	%rdx,%r14
17 (0.0%)  	addq	%r13,%rcx
17 (0.0%)  	xorq	%r8,%r15
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%rcx,%r10
17 (0.0%)  	addq	%r15,%rcx
17 (0.0%)  	movq	%r10,%r13
17 (0.0%)  	addq	%rcx,%r14
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%rcx
17 (0.0%)  	movq	%r11,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%r10,%r13
17 (0.0%)  	xorq	%rax,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%rcx,%r14
17 (0.0%)  	andq	%r10,%r12
17 (0.0%)  	xorq	%r10,%r13
17 (0.0%)  	addq	48(%rsp),%rbx
17 (0.0%)  	movq	%rcx,%r15
17 (0.0%)  	xorq	%rax,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%rdx,%r15
17 (0.0%)  	addq	%r12,%rbx
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%r15,%rdi
17 (0.0%)  	xorq	%rcx,%r14
17 (0.0%)  	addq	%r13,%rbx
17 (0.0%)  	xorq	%rdx,%rdi
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%rbx,%r9
17 (0.0%)  	addq	%rdi,%rbx
17 (0.0%)  	movq	%r9,%r13
17 (0.0%)  	addq	%rbx,%r14
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%rbx
17 (0.0%)  	movq	%r10,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%r9,%r13
17 (0.0%)  	xorq	%r11,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%rbx,%r14
17 (0.0%)  	andq	%r9,%r12
17 (0.0%)  	xorq	%r9,%r13
17 (0.0%)  	addq	56(%rsp),%rax
17 (0.0%)  	movq	%rbx,%rdi
17 (0.0%)  	xorq	%r11,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%rcx,%rdi
17 (0.0%)  	addq	%r12,%rax
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%rdi,%r15
17 (0.0%)  	xorq	%rbx,%r14
17 (0.0%)  	addq	%r13,%rax
17 (0.0%)  	xorq	%rcx,%r15
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%rax,%r8
17 (0.0%)  	addq	%r15,%rax
17 (0.0%)  	movq	%r8,%r13
17 (0.0%)  	addq	%rax,%r14
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%rax
17 (0.0%)  	movq	%r9,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%r8,%r13
17 (0.0%)  	xorq	%r10,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%rax,%r14
17 (0.0%)  	andq	%r8,%r12
17 (0.0%)  	xorq	%r8,%r13
17 (0.0%)  	addq	64(%rsp),%r11
17 (0.0%)  	movq	%rax,%r15
17 (0.0%)  	xorq	%r10,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%rbx,%r15
17 (0.0%)  	addq	%r12,%r11
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%r15,%rdi
17 (0.0%)  	xorq	%rax,%r14
17 (0.0%)  	addq	%r13,%r11
17 (0.0%)  	xorq	%rbx,%rdi
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%r11,%rdx
17 (0.0%)  	addq	%rdi,%r11
17 (0.0%)  	movq	%rdx,%r13
17 (0.0%)  	addq	%r11,%r14
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%r11
17 (0.0%)  	movq	%r8,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%rdx,%r13
17 (0.0%)  	xorq	%r9,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%r11,%r14
17 (0.0%)  	andq	%rdx,%r12
17 (0.0%)  	xorq	%rdx,%r13
17 (0.0%)  	addq	72(%rsp),%r10
17 (0.0%)  	movq	%r11,%rdi
17 (0.0%)  	xorq	%r9,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%rax,%rdi
17 (0.0%)  	addq	%r12,%r10
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%rdi,%r15
17 (0.0%)  	xorq	%r11,%r14
17 (0.0%)  	addq	%r13,%r10
17 (0.0%)  	xorq	%rax,%r15
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%r10,%rcx
17 (0.0%)  	addq	%r15,%r10
17 (0.0%)  	movq	%rcx,%r13
17 (0.0%)  	addq	%r10,%r14
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%r10
17 (0.0%)  	movq	%rdx,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%rcx,%r13
17 (0.0%)  	xorq	%r8,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%r10,%r14
17 (0.0%)  	andq	%rcx,%r12
17 (0.0%)  	xorq	%rcx,%r13
17 (0.0%)  	addq	80(%rsp),%r9
17 (0.0%)  	movq	%r10,%r15
17 (0.0%)  	xorq	%r8,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%r11,%r15
17 (0.0%)  	addq	%r12,%r9
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%r15,%rdi
17 (0.0%)  	xorq	%r10,%r14
17 (0.0%)  	addq	%r13,%r9
17 (0.0%)  	xorq	%r11,%rdi
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%r9,%rbx
17 (0.0%)  	addq	%rdi,%r9
17 (0.0%)  	movq	%rbx,%r13
17 (0.0%)  	addq	%r9,%r14
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%r9
17 (0.0%)  	movq	%rcx,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%rbx,%r13
17 (0.0%)  	xorq	%rdx,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%r9,%r14
17 (0.0%)  	andq	%rbx,%r12
17 (0.0%)  	xorq	%rbx,%r13
17 (0.0%)  	addq	88(%rsp),%r8
17 (0.0%)  	movq	%r9,%rdi
17 (0.0%)  	xorq	%rdx,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%r10,%rdi
17 (0.0%)  	addq	%r12,%r8
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%rdi,%r15
17 (0.0%)  	xorq	%r9,%r14
17 (0.0%)  	addq	%r13,%r8
17 (0.0%)  	xorq	%r10,%r15
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%r8,%rax
17 (0.0%)  	addq	%r15,%r8
17 (0.0%)  	movq	%rax,%r13
17 (0.0%)  	addq	%r8,%r14
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%r8
17 (0.0%)  	movq	%rbx,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%rax,%r13
17 (0.0%)  	xorq	%rcx,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%r8,%r14
17 (0.0%)  	andq	%rax,%r12
17 (0.0%)  	xorq	%rax,%r13
17 (0.0%)  	addq	96(%rsp),%rdx
17 (0.0%)  	movq	%r8,%r15
17 (0.0%)  	xorq	%rcx,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%r9,%r15
17 (0.0%)  	addq	%r12,%rdx
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%r15,%rdi
17 (0.0%)  	xorq	%r8,%r14
17 (0.0%)  	addq	%r13,%rdx
17 (0.0%)  	xorq	%r9,%rdi
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%rdx,%r11
17 (0.0%)  	addq	%rdi,%rdx
17 (0.0%)  	movq	%r11,%r13
17 (0.0%)  	addq	%rdx,%r14
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%rdx
17 (0.0%)  	movq	%rax,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%r11,%r13
17 (0.0%)  	xorq	%rbx,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%rdx,%r14
17 (0.0%)  	andq	%r11,%r12
17 (0.0%)  	xorq	%r11,%r13
17 (0.0%)  	addq	104(%rsp),%rcx
17 (0.0%)  	movq	%rdx,%rdi
17 (0.0%)  	xorq	%rbx,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%r8,%rdi
17 (0.0%)  	addq	%r12,%rcx
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%rdi,%r15
17 (0.0%)  	xorq	%rdx,%r14
17 (0.0%)  	addq	%r13,%rcx
17 (0.0%)  	xorq	%r8,%r15
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%rcx,%r10
17 (0.0%)  	addq	%r15,%rcx
17 (0.0%)  	movq	%r10,%r13
17 (0.0%)  	addq	%rcx,%r14
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%rcx
17 (0.0%)  	movq	%r11,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%r10,%r13
17 (0.0%)  	xorq	%rax,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%rcx,%r14
17 (0.0%)  	andq	%r10,%r12
17 (0.0%)  	xorq	%r10,%r13
17 (0.0%)  	addq	112(%rsp),%rbx
17 (0.0%)  	movq	%rcx,%r15
17 (0.0%)  	xorq	%rax,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%rdx,%r15
17 (0.0%)  	addq	%r12,%rbx
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%r15,%rdi
17 (0.0%)  	xorq	%rcx,%r14
17 (0.0%)  	addq	%r13,%rbx
17 (0.0%)  	xorq	%rdx,%rdi
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%rbx,%r9
17 (0.0%)  	addq	%rdi,%rbx
17 (0.0%)  	movq	%r9,%r13
17 (0.0%)  	addq	%rbx,%r14
17 (0.0%)  	shrdq	$23,%r13,%r13
17 (0.0%)  	movq	%r14,%rbx
17 (0.0%)  	movq	%r10,%r12
17 (0.0%)  	shrdq	$5,%r14,%r14
17 (0.0%)  	xorq	%r9,%r13
17 (0.0%)  	xorq	%r11,%r12
17 (0.0%)  	shrdq	$4,%r13,%r13
17 (0.0%)  	xorq	%rbx,%r14
17 (0.0%)  	andq	%r9,%r12
17 (0.0%)  	xorq	%r9,%r13
17 (0.0%)  	addq	120(%rsp),%rax
17 (0.0%)  	movq	%rbx,%rdi
17 (0.0%)  	xorq	%r11,%r12
17 (0.0%)  	shrdq	$6,%r14,%r14
17 (0.0%)  	xorq	%rcx,%rdi
17 (0.0%)  	addq	%r12,%rax
17 (0.0%)  	shrdq	$14,%r13,%r13
17 (0.0%)  	andq	%rdi,%r15
17 (0.0%)  	xorq	%rbx,%r14
17 (0.0%)  	addq	%r13,%rax
17 (0.0%)  	xorq	%rcx,%r15
17 (0.0%)  	shrdq	$28,%r14,%r14
17 (0.0%)  	addq	%rax,%r8
17 (0.0%)  	addq	%r15,%rax
17 (0.0%)  	movq	%r8,%r13
17 (0.0%)  	addq	%rax,%r14
17 (0.0%)  	movq	128+0(%rsp),%rdi
17 (0.0%)  	movq	%r14,%rax
 .         
17 (0.0%)  	addq	0(%rdi),%rax
17 (0.0%)  	leaq	128(%rsi),%rsi
17 (0.0%)  	addq	8(%rdi),%rbx
17 (0.0%)  	addq	16(%rdi),%rcx
17 (0.0%)  	addq	24(%rdi),%rdx
17 (0.0%)  	addq	32(%rdi),%r8
17 (0.0%)  	addq	40(%rdi),%r9
17 (0.0%)  	addq	48(%rdi),%r10
17 (0.0%)  	addq	56(%rdi),%r11
 .         
17 (0.0%)  	cmpq	128+16(%rsp),%rsi
 .         
17 (0.0%)  	movq	%rax,0(%rdi)
17 (0.0%)  	movq	%rbx,8(%rdi)
17 (0.0%)  	movq	%rcx,16(%rdi)
17 (0.0%)  	movq	%rdx,24(%rdi)
17 (0.0%)  	movq	%r8,32(%rdi)
17 (0.0%)  	movq	%r9,40(%rdi)
17 (0.0%)  	movq	%r10,48(%rdi)
17 (0.0%)  	movq	%r11,56(%rdi)
17 (0.0%)  	jb	.Lloop_avx
 .         
13 (0.0%)  	movq	152(%rsp),%rsi
 .         .cfi_def_cfa	%rsi,8
13 (0.0%)  	vzeroupper
13 (0.0%)  	movq	-48(%rsi),%r15
 .         .cfi_restore	%r15
13 (0.0%)  	movq	-40(%rsi),%r14
 .         .cfi_restore	%r14
13 (0.0%)  	movq	-32(%rsi),%r13
 .         .cfi_restore	%r13
13 (0.0%)  	movq	-24(%rsi),%r12
 .         .cfi_restore	%r12
13 (0.0%)  	movq	-16(%rsi),%rbp
 .         .cfi_restore	%rbp
13 (0.0%)  	movq	-8(%rsi),%rbx
 .         .cfi_restore	%rbx
26 (0.0%)  	leaq	(%rsi),%rsp
 .         .cfi_def_cfa_register	%rsp
 .         .Lepilogue_avx:
 .         	.byte	0xf3,0xc3
 .         .cfi_endproc	
 .         .size	sha512_block_data_order_avx,.-sha512_block_data_order_avx
 .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/generated-src/linux-x86_64/crypto/fipsmodule/x86_64-mont.S
--------------------------------------------------------------------------------
Ir________ 

-- line 10 ----------------------------------------
  .         .hidden OPENSSL_ia32cap_P
  .         
  .         .globl	bn_mul_mont
  .         .hidden bn_mul_mont
  .         .type	bn_mul_mont,@function
  .         .align	16
  .         bn_mul_mont:
  .         .cfi_startproc	
 84 (0.0%)  	movl	%r9d,%r9d
 84 (0.0%)  	movq	%rsp,%rax
  .         .cfi_def_cfa_register	%rax
 84 (0.0%)  	testl	$3,%r9d
 84 (0.0%)  	jnz	.Lmul_enter
 84 (0.0%)  	cmpl	$8,%r9d
 84 (0.0%)  	jb	.Lmul_enter
  .         	leaq	OPENSSL_ia32cap_P(%rip),%r11
  .         	movl	8(%r11),%r11d
  .         	cmpq	%rsi,%rdx
  .         	jne	.Lmul4x_enter
  .         	testl	$7,%r9d
  .         	jz	.Lsqr8x_enter
  .         	jmp	.Lmul4x_enter
  .         
  .         .align	16
  .         .Lmul_enter:
 84 (0.0%)  	pushq	%rbx
  .         .cfi_offset	%rbx,-16
 84 (0.0%)  	pushq	%rbp
  .         .cfi_offset	%rbp,-24
 84 (0.0%)  	pushq	%r12
  .         .cfi_offset	%r12,-32
 84 (0.0%)  	pushq	%r13
  .         .cfi_offset	%r13,-40
 84 (0.0%)  	pushq	%r14
  .         .cfi_offset	%r14,-48
 84 (0.0%)  	pushq	%r15
  .         .cfi_offset	%r15,-56
  .         
 84 (0.0%)  	negq	%r9
 84 (0.0%)  	movq	%rsp,%r11
 84 (0.0%)  	leaq	-16(%rsp,%r9,8),%r10
 84 (0.0%)  	negq	%r9
 84 (0.0%)  	andq	$-1024,%r10
  .         
  .         
  .         
  .         
  .         
  .         
  .         
  .         
  .         
 84 (0.0%)  	subq	%r10,%r11
 84 (0.0%)  	andq	$-4096,%r11
 84 (0.0%)  	leaq	(%r10,%r11,1),%rsp
 84 (0.0%)  	movq	(%rsp),%r11
 84 (0.0%)  	cmpq	%r10,%rsp
 84 (0.0%)  	ja	.Lmul_page_walk
 84 (0.0%)  	jmp	.Lmul_page_walk_done
  .         
  .         .align	16
  .         .Lmul_page_walk:
  .         	leaq	-4096(%rsp),%rsp
  .         	movq	(%rsp),%r11
  .         	cmpq	%r10,%rsp
  .         	ja	.Lmul_page_walk
  .         .Lmul_page_walk_done:
  .         
 84 (0.0%)  	movq	%rax,8(%rsp,%r9,8)
  .         .cfi_escape	0x0f,0x0a,0x77,0x08,0x79,0x00,0x38,0x1e,0x22,0x06,0x23,0x08
  .         .Lmul_body:
 84 (0.0%)  	movq	%rdx,%r12
 84 (0.0%)  	movq	(%r8),%r8
 84 (0.0%)  	movq	(%r12),%rbx
 84 (0.0%)  	movq	(%rsi),%rax
  .         
 84 (0.0%)  	xorq	%r14,%r14
 84 (0.0%)  	xorq	%r15,%r15
  .         
 84 (0.0%)  	movq	%r8,%rbp
 84 (0.0%)  	mulq	%rbx
 84 (0.0%)  	movq	%rax,%r10
 84 (0.0%)  	movq	(%rcx),%rax
  .         
 84 (0.0%)  	imulq	%r10,%rbp
 84 (0.0%)  	movq	%rdx,%r11
  .         
 84 (0.0%)  	mulq	%rbp
 84 (0.0%)  	addq	%rax,%r10
 84 (0.0%)  	movq	8(%rsi),%rax
 84 (0.0%)  	adcq	$0,%rdx
 84 (0.0%)  	movq	%rdx,%r13
  .         
 84 (0.0%)  	leaq	1(%r15),%r15
 84 (0.0%)  	jmp	.L1st_enter
  .         
  .         .align	16
  .         .L1st:
168 (0.0%)  	addq	%rax,%r13
168 (0.0%)  	movq	(%rsi,%r15,8),%rax
168 (0.0%)  	adcq	$0,%rdx
168 (0.0%)  	addq	%r11,%r13
168 (0.0%)  	movq	%r10,%r11
168 (0.0%)  	adcq	$0,%rdx
168 (0.0%)  	movq	%r13,-16(%rsp,%r15,8)
168 (0.0%)  	movq	%rdx,%r13
  .         
  .         .L1st_enter:
252 (0.0%)  	mulq	%rbx
252 (0.0%)  	addq	%rax,%r11
252 (0.0%)  	movq	(%rcx,%r15,8),%rax
252 (0.0%)  	adcq	$0,%rdx
252 (0.0%)  	leaq	1(%r15),%r15
252 (0.0%)  	movq	%rdx,%r10
  .         
252 (0.0%)  	mulq	%rbp
252 (0.0%)  	cmpq	%r9,%r15
252 (0.0%)  	jne	.L1st
  .         
 84 (0.0%)  	addq	%rax,%r13
 84 (0.0%)  	movq	(%rsi),%rax
 84 (0.0%)  	adcq	$0,%rdx
 84 (0.0%)  	addq	%r11,%r13
 84 (0.0%)  	adcq	$0,%rdx
 84 (0.0%)  	movq	%r13,-16(%rsp,%r15,8)
 84 (0.0%)  	movq	%rdx,%r13
 84 (0.0%)  	movq	%r10,%r11
  .         
 84 (0.0%)  	xorq	%rdx,%rdx
 84 (0.0%)  	addq	%r11,%r13
 84 (0.0%)  	adcq	$0,%rdx
 84 (0.0%)  	movq	%r13,-8(%rsp,%r9,8)
 84 (0.0%)  	movq	%rdx,(%rsp,%r9,8)
  .         
 84 (0.0%)  	leaq	1(%r14),%r14
 84 (0.0%)  	jmp	.Louter
  .         .align	16
  .         .Louter:
252 (0.0%)  	movq	(%r12,%r14,8),%rbx
252 (0.0%)  	xorq	%r15,%r15
252 (0.0%)  	movq	%r8,%rbp
252 (0.0%)  	movq	(%rsp),%r10
252 (0.0%)  	mulq	%rbx
252 (0.0%)  	addq	%rax,%r10
252 (0.0%)  	movq	(%rcx),%rax
252 (0.0%)  	adcq	$0,%rdx
  .         
252 (0.0%)  	imulq	%r10,%rbp
252 (0.0%)  	movq	%rdx,%r11
  .         
252 (0.0%)  	mulq	%rbp
252 (0.0%)  	addq	%rax,%r10
252 (0.0%)  	movq	8(%rsi),%rax
252 (0.0%)  	adcq	$0,%rdx
252 (0.0%)  	movq	8(%rsp),%r10
252 (0.0%)  	movq	%rdx,%r13
  .         
252 (0.0%)  	leaq	1(%r15),%r15
252 (0.0%)  	jmp	.Linner_enter
  .         
  .         .align	16
  .         .Linner:
504 (0.0%)  	addq	%rax,%r13
504 (0.0%)  	movq	(%rsi,%r15,8),%rax
504 (0.0%)  	adcq	$0,%rdx
504 (0.0%)  	addq	%r10,%r13
504 (0.0%)  	movq	(%rsp,%r15,8),%r10
504 (0.0%)  	adcq	$0,%rdx
504 (0.0%)  	movq	%r13,-16(%rsp,%r15,8)
504 (0.0%)  	movq	%rdx,%r13
  .         
  .         .Linner_enter:
756 (0.0%)  	mulq	%rbx
756 (0.0%)  	addq	%rax,%r11
756 (0.0%)  	movq	(%rcx,%r15,8),%rax
756 (0.0%)  	adcq	$0,%rdx
756 (0.0%)  	addq	%r11,%r10
756 (0.0%)  	movq	%rdx,%r11
756 (0.0%)  	adcq	$0,%r11
756 (0.0%)  	leaq	1(%r15),%r15
  .         
756 (0.0%)  	mulq	%rbp
756 (0.0%)  	cmpq	%r9,%r15
756 (0.0%)  	jne	.Linner
  .         
252 (0.0%)  	addq	%rax,%r13
252 (0.0%)  	movq	(%rsi),%rax
252 (0.0%)  	adcq	$0,%rdx
252 (0.0%)  	addq	%r10,%r13
252 (0.0%)  	movq	(%rsp,%r15,8),%r10
252 (0.0%)  	adcq	$0,%rdx
252 (0.0%)  	movq	%r13,-16(%rsp,%r15,8)
252 (0.0%)  	movq	%rdx,%r13
  .         
252 (0.0%)  	xorq	%rdx,%rdx
252 (0.0%)  	addq	%r11,%r13
252 (0.0%)  	adcq	$0,%rdx
252 (0.0%)  	addq	%r10,%r13
252 (0.0%)  	adcq	$0,%rdx
252 (0.0%)  	movq	%r13,-8(%rsp,%r9,8)
252 (0.0%)  	movq	%rdx,(%rsp,%r9,8)
  .         
252 (0.0%)  	leaq	1(%r14),%r14
252 (0.0%)  	cmpq	%r9,%r14
252 (0.0%)  	jb	.Louter
  .         
 84 (0.0%)  	xorq	%r14,%r14
 84 (0.0%)  	movq	(%rsp),%rax
 84 (0.0%)  	movq	%r9,%r15
  .         
  .         .align	16
336 (0.0%)  .Lsub:	sbbq	(%rcx,%r14,8),%rax
336 (0.0%)  	movq	%rax,(%rdi,%r14,8)
336 (0.0%)  	movq	8(%rsp,%r14,8),%rax
336 (0.0%)  	leaq	1(%r14),%r14
336 (0.0%)  	decq	%r15
336 (0.0%)  	jnz	.Lsub
  .         
 84 (0.0%)  	sbbq	$0,%rax
 84 (0.0%)  	movq	$-1,%rbx
 84 (0.0%)  	xorq	%rax,%rbx
 84 (0.0%)  	xorq	%r14,%r14
 84 (0.0%)  	movq	%r9,%r15
  .         
  .         .Lcopy:
336 (0.0%)  	movq	(%rdi,%r14,8),%rcx
336 (0.0%)  	movq	(%rsp,%r14,8),%rdx
336 (0.0%)  	andq	%rbx,%rcx
336 (0.0%)  	andq	%rax,%rdx
336 (0.0%)  	movq	%r9,(%rsp,%r14,8)
336 (0.0%)  	orq	%rcx,%rdx
336 (0.0%)  	movq	%rdx,(%rdi,%r14,8)
336 (0.0%)  	leaq	1(%r14),%r14
336 (0.0%)  	subq	$1,%r15
336 (0.0%)  	jnz	.Lcopy
  .         
 84 (0.0%)  	movq	8(%rsp,%r9,8),%rsi
  .         .cfi_def_cfa	%rsi,8
 84 (0.0%)  	movq	$1,%rax
 84 (0.0%)  	movq	-48(%rsi),%r15
  .         .cfi_restore	%r15
 84 (0.0%)  	movq	-40(%rsi),%r14
  .         .cfi_restore	%r14
 84 (0.0%)  	movq	-32(%rsi),%r13
  .         .cfi_restore	%r13
 84 (0.0%)  	movq	-24(%rsi),%r12
  .         .cfi_restore	%r12
 84 (0.0%)  	movq	-16(%rsi),%rbp
  .         .cfi_restore	%rbp
 84 (0.0%)  	movq	-8(%rsi),%rbx
  .         .cfi_restore	%rbx
168 (0.0%)  	leaq	(%rsi),%rsp
  .         .cfi_def_cfa_register	%rsp
  .         .Lmul_epilogue:
  .         	.byte	0xf3,0xc3
  .         .cfi_endproc	
  .         .size	bn_mul_mont,.-bn_mul_mont
  .         .type	bn_mul4x_mont,@function
  .         .align	16
  .         bn_mul4x_mont:
-- line 269 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hash.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 26 ----------------------------------------
     .         #if defined(S2N_LIBCRYPTO_SUPPORTS_EVP_MD5_SHA1_HASH)
     .             return false;
     .         #else
     .             return true;
     .         #endif
     .         }
     .         
     .         static bool s2n_use_evp_impl()
 1,926 (0.0%)  {
   642 (0.0%)      return s2n_is_in_fips_mode();
 1,284 (0.0%)  }
     .         
     .         bool s2n_hash_evp_fully_supported()
     6 (0.0%)  {
    12 (0.0%)      return s2n_use_evp_impl() && !s2n_use_custom_md5_sha1();
     4 (0.0%)  }
     .         
     .         const EVP_MD *s2n_hash_alg_to_evp_md(s2n_hash_algorithm alg)
     .         {
     .             switch (alg) {
     .                 case S2N_HASH_MD5:
     .                     return EVP_md5();
     .                 case S2N_HASH_SHA1:
     .                     return EVP_sha1();
-- line 49 ----------------------------------------
-- line 60 ----------------------------------------
     .                     return EVP_md5_sha1();
     .         #endif
     .                 default:
     .                     return NULL;
     .             }
     .         }
     .         
     .         int s2n_hash_digest_size(s2n_hash_algorithm alg, uint8_t *out)
 1,547 (0.0%)  {
   442 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(out, sizeof(*out)), S2N_ERR_PRECONDITION_VIOLATION);
     .             /* clang-format off */
 2,210 (0.0%)      switch (alg) {
    69 (0.0%)          case S2N_HASH_NONE:     *out = 0;                    break;
     .                 case S2N_HASH_MD5:      *out = MD5_DIGEST_LENGTH;    break;
     .                 case S2N_HASH_SHA1:     *out = SHA_DIGEST_LENGTH;    break;
     .                 case S2N_HASH_SHA224:   *out = SHA224_DIGEST_LENGTH; break;
   594 (0.0%)          case S2N_HASH_SHA256:   *out = SHA256_DIGEST_LENGTH; break;
     .                 case S2N_HASH_SHA384:   *out = SHA384_DIGEST_LENGTH; break;
     .                 case S2N_HASH_SHA512:   *out = SHA512_DIGEST_LENGTH; break;
     .                 case S2N_HASH_MD5_SHA1: *out = MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH; break;
     .                 default:
     .                     POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
     .             }
     .             /* clang-format on */
   221 (0.0%)      return S2N_SUCCESS;
   663 (0.0%)  }
     .         
     .         /* NOTE: s2n_hash_const_time_get_currently_in_hash_block takes advantage of the fact that
     .          * hash_block_size is a power of 2. This is true for all hashes we currently support
     .          * If this ever becomes untrue, this would require fixing*/
     .         int s2n_hash_block_size(s2n_hash_algorithm alg, uint64_t *block_size)
     .         {
     .             POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(block_size, sizeof(*block_size)), S2N_ERR_PRECONDITION_VIOLATION);
     .             /* clang-format off */
-- line 93 ----------------------------------------
-- line 104 ----------------------------------------
     .                         POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
     .             }
     .             /* clang-format on */
     .             return S2N_SUCCESS;
     .         }
     .         
     .         /* Return true if hash algorithm is available, false otherwise. */
     .         bool s2n_hash_is_available(s2n_hash_algorithm alg)
 1,210 (0.0%)  {
 2,420 (0.0%)      switch (alg) {
     .                 case S2N_HASH_MD5:
     .                 case S2N_HASH_MD5_SHA1:
     .                     /* return false if in FIPS mode, as MD5 algs are not available in FIPS mode. */
    32 (0.0%)              return !s2n_is_in_fips_mode();
     .                 case S2N_HASH_NONE:
     .                 case S2N_HASH_SHA1:
     .                 case S2N_HASH_SHA224:
     .                 case S2N_HASH_SHA256:
     .                 case S2N_HASH_SHA384:
     .                 case S2N_HASH_SHA512:
   476 (0.0%)              return true;
     .                 case S2N_HASH_SENTINEL:
     .                     return false;
     .             }
     .             return false;
   484 (0.0%)  }
     .         
     .         int s2n_hash_is_ready_for_input(struct s2n_hash_state *state)
     .         {
     .             POSIX_PRECONDITION(s2n_hash_state_validate(state));
     .             return state->is_ready_for_input;
     .         }
     .         
     .         static int s2n_low_level_hash_new(struct s2n_hash_state *state)
 1,744 (0.0%)  {
     .             /* s2n_hash_new will always call the corresponding implementation of the s2n_hash
     .              * being used. For the s2n_low_level_hash implementation, new is a no-op.
     .              */
     .         
 8,066 (0.1%)      *state = (struct s2n_hash_state){ 0 };
   218 (0.0%)      return S2N_SUCCESS;
 1,090 (0.0%)  }
     .         
     .         static int s2n_low_level_hash_init(struct s2n_hash_state *state, s2n_hash_algorithm alg)
 1,820 (0.0%)  {
 2,600 (0.0%)      switch (alg) {
     .                 case S2N_HASH_NONE:
    88 (0.0%)              break;
     .                 case S2N_HASH_MD5:
    24 (0.0%)              POSIX_GUARD_OSSL(MD5_Init(&state->digest.low_level.md5), S2N_ERR_HASH_INIT_FAILED);
     8 (0.0%)              break;
     .                 case S2N_HASH_SHA1:
    24 (0.0%)              POSIX_GUARD_OSSL(SHA1_Init(&state->digest.low_level.sha1), S2N_ERR_HASH_INIT_FAILED);
     8 (0.0%)              break;
     .                 case S2N_HASH_SHA224:
    24 (0.0%)              POSIX_GUARD_OSSL(SHA224_Init(&state->digest.low_level.sha224), S2N_ERR_HASH_INIT_FAILED);
     8 (0.0%)              break;
     .                 case S2N_HASH_SHA256:
 1,152 (0.0%)              POSIX_GUARD_OSSL(SHA256_Init(&state->digest.low_level.sha256), S2N_ERR_HASH_INIT_FAILED);
   384 (0.0%)              break;
     .                 case S2N_HASH_SHA384:
    24 (0.0%)              POSIX_GUARD_OSSL(SHA384_Init(&state->digest.low_level.sha384), S2N_ERR_HASH_INIT_FAILED);
     8 (0.0%)              break;
     .                 case S2N_HASH_SHA512:
    24 (0.0%)              POSIX_GUARD_OSSL(SHA512_Init(&state->digest.low_level.sha512), S2N_ERR_HASH_INIT_FAILED);
     8 (0.0%)              break;
     .                 case S2N_HASH_MD5_SHA1:
    24 (0.0%)              POSIX_GUARD_OSSL(SHA1_Init(&state->digest.low_level.md5_sha1.sha1), S2N_ERR_HASH_INIT_FAILED);
    24 (0.0%)              POSIX_GUARD_OSSL(MD5_Init(&state->digest.low_level.md5_sha1.md5), S2N_ERR_HASH_INIT_FAILED);
     4 (0.0%)              break;
     .         
     .                 default:
     .                     POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
     .             }
     .         
   780 (0.0%)      state->alg = alg;
   520 (0.0%)      state->is_ready_for_input = 1;
   520 (0.0%)      state->currently_in_hash = 0;
     .         
   260 (0.0%)      return 0;
   780 (0.0%)  }
     .         
     .         static int s2n_low_level_hash_update(struct s2n_hash_state *state, const void *data, uint32_t size)
 2,512 (0.0%)  {
 1,256 (0.0%)      POSIX_ENSURE(state->is_ready_for_input, S2N_ERR_HASH_NOT_READY);
     .         
 3,768 (0.1%)      switch (state->alg) {
     .                 case S2N_HASH_NONE:
    72 (0.0%)              break;
     .                 case S2N_HASH_MD5:
    63 (0.0%)              POSIX_GUARD_OSSL(MD5_Update(&state->digest.low_level.md5, data, size), S2N_ERR_HASH_UPDATE_FAILED);
    14 (0.0%)              break;
     .                 case S2N_HASH_SHA1:
    63 (0.0%)              POSIX_GUARD_OSSL(SHA1_Update(&state->digest.low_level.sha1, data, size), S2N_ERR_HASH_UPDATE_FAILED);
    14 (0.0%)              break;
     .                 case S2N_HASH_SHA224:
    63 (0.0%)              POSIX_GUARD_OSSL(SHA224_Update(&state->digest.low_level.sha224, data, size), S2N_ERR_HASH_UPDATE_FAILED);
    14 (0.0%)              break;
     .                 case S2N_HASH_SHA256:
 2,124 (0.0%)              POSIX_GUARD_OSSL(SHA256_Update(&state->digest.low_level.sha256, data, size), S2N_ERR_HASH_UPDATE_FAILED);
   472 (0.0%)              break;
     .                 case S2N_HASH_SHA384:
    63 (0.0%)              POSIX_GUARD_OSSL(SHA384_Update(&state->digest.low_level.sha384, data, size), S2N_ERR_HASH_UPDATE_FAILED);
    14 (0.0%)              break;
     .                 case S2N_HASH_SHA512:
    63 (0.0%)              POSIX_GUARD_OSSL(SHA512_Update(&state->digest.low_level.sha512, data, size), S2N_ERR_HASH_UPDATE_FAILED);
    14 (0.0%)              break;
     .                 case S2N_HASH_MD5_SHA1:
    63 (0.0%)              POSIX_GUARD_OSSL(SHA1_Update(&state->digest.low_level.md5_sha1.sha1, data, size), S2N_ERR_HASH_UPDATE_FAILED);
    63 (0.0%)              POSIX_GUARD_OSSL(MD5_Update(&state->digest.low_level.md5_sha1.md5, data, size), S2N_ERR_HASH_UPDATE_FAILED);
     7 (0.0%)              break;
     .                 default:
     .                     POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
     .             }
     .         
 1,884 (0.0%)      POSIX_ENSURE(size <= (UINT64_MAX - state->currently_in_hash), S2N_ERR_INTEGER_OVERFLOW);
 1,884 (0.0%)      state->currently_in_hash += size;
     .         
   314 (0.0%)      return S2N_SUCCESS;
   942 (0.0%)  }
     .         
     .         static int s2n_low_level_hash_digest(struct s2n_hash_state *state, void *out, uint32_t size)
   912 (0.0%)  {
   456 (0.0%)      POSIX_ENSURE(state->is_ready_for_input, S2N_ERR_HASH_NOT_READY);
     .         
 1,368 (0.0%)      switch (state->alg) {
     .                 case S2N_HASH_NONE:
    16 (0.0%)              break;
     .                 case S2N_HASH_MD5:
     .                     POSIX_ENSURE_EQ(size, MD5_DIGEST_LENGTH);
     .                     POSIX_GUARD_OSSL(MD5_Final(out, &state->digest.low_level.md5), S2N_ERR_HASH_DIGEST_FAILED);
     .                     break;
     .                 case S2N_HASH_SHA1:
     .                     POSIX_ENSURE_EQ(size, SHA_DIGEST_LENGTH);
     .                     POSIX_GUARD_OSSL(SHA1_Final(out, &state->digest.low_level.sha1), S2N_ERR_HASH_DIGEST_FAILED);
     .                     break;
     .                 case S2N_HASH_SHA224:
     .                     POSIX_ENSURE_EQ(size, SHA224_DIGEST_LENGTH);
     .                     POSIX_GUARD_OSSL(SHA224_Final(out, &state->digest.low_level.sha224), S2N_ERR_HASH_DIGEST_FAILED);
     .                     break;
     .                 case S2N_HASH_SHA256:
   212 (0.0%)              POSIX_ENSURE_EQ(size, SHA256_DIGEST_LENGTH);
   848 (0.0%)              POSIX_GUARD_OSSL(SHA256_Final(out, &state->digest.low_level.sha256), S2N_ERR_HASH_DIGEST_FAILED);
   212 (0.0%)              break;
     .                 case S2N_HASH_SHA384:
     .                     POSIX_ENSURE_EQ(size, SHA384_DIGEST_LENGTH);
     .                     POSIX_GUARD_OSSL(SHA384_Final(out, &state->digest.low_level.sha384), S2N_ERR_HASH_DIGEST_FAILED);
     .                     break;
     .                 case S2N_HASH_SHA512:
     .                     POSIX_ENSURE_EQ(size, SHA512_DIGEST_LENGTH);
     .                     POSIX_GUARD_OSSL(SHA512_Final(out, &state->digest.low_level.sha512), S2N_ERR_HASH_DIGEST_FAILED);
     .                     break;
-- line 255 ----------------------------------------
-- line 257 ----------------------------------------
     .                     POSIX_ENSURE_EQ(size, MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH);
     .                     POSIX_GUARD_OSSL(SHA1_Final(((uint8_t *) out) + MD5_DIGEST_LENGTH, &state->digest.low_level.md5_sha1.sha1), S2N_ERR_HASH_DIGEST_FAILED);
     .                     POSIX_GUARD_OSSL(MD5_Final(out, &state->digest.low_level.md5_sha1.md5), S2N_ERR_HASH_DIGEST_FAILED);
     .                     break;
     .                 default:
     .                     POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
     .             }
     .         
   228 (0.0%)      state->currently_in_hash = 0;
   228 (0.0%)      state->is_ready_for_input = 0;
   114 (0.0%)      return 0;
   342 (0.0%)  }
     .         
     .         static int s2n_low_level_hash_copy(struct s2n_hash_state *to, struct s2n_hash_state *from)
 1,190 (0.0%)  {
 2,550 (0.0%)      POSIX_CHECKED_MEMCPY(to, from, sizeof(struct s2n_hash_state));
   170 (0.0%)      return 0;
   510 (0.0%)  }
     .         
     .         static int s2n_low_level_hash_reset(struct s2n_hash_state *state)
    90 (0.0%)  {
     .             /* hash_init resets the ready_for_input and currently_in_hash fields. */
   108 (0.0%)      return s2n_low_level_hash_init(state, state->alg);
    36 (0.0%)  }
     .         
     .         static int s2n_low_level_hash_free(struct s2n_hash_state *state)
   648 (0.0%)  {
     .             /* s2n_hash_free will always call the corresponding implementation of the s2n_hash
     .              * being used. For the s2n_low_level_hash implementation, free is a no-op.
     .              */
   324 (0.0%)      state->is_ready_for_input = 0;
   162 (0.0%)      return S2N_SUCCESS;
   324 (0.0%)  }
     .         
     .         static int s2n_evp_hash_new(struct s2n_hash_state *state)
     .         {
     .             POSIX_ENSURE_REF(state->digest.high_level.evp.ctx = S2N_EVP_MD_CTX_NEW());
     .             if (s2n_use_custom_md5_sha1()) {
     .                 POSIX_ENSURE_REF(state->digest.high_level.evp_md5_secondary.ctx = S2N_EVP_MD_CTX_NEW());
     .             }
     .         
-- line 297 ----------------------------------------
-- line 481 ----------------------------------------
     .             .update = &s2n_evp_hash_update,
     .             .digest = &s2n_evp_hash_digest,
     .             .copy = &s2n_evp_hash_copy,
     .             .reset = &s2n_evp_hash_reset,
     .             .free = &s2n_evp_hash_free,
     .         };
     .         
     .         static int s2n_hash_set_impl(struct s2n_hash_state *state)
 3,200 (0.1%)  {
 1,920 (0.0%)      state->hash_impl = &s2n_low_level_hash;
 2,560 (0.0%)      if (s2n_use_evp_impl()) {
     .                 state->hash_impl = &s2n_evp_hash;
     .             }
   640 (0.0%)      return S2N_SUCCESS;
 1,280 (0.0%)  }
     .         
     .         int s2n_hash_new(struct s2n_hash_state *state)
 1,308 (0.0%)  {
   436 (0.0%)      POSIX_ENSURE_REF(state);
     .             /* Set hash_impl on initial hash creation.
     .              * When in FIPS mode, the EVP API's must be used for hashes.
     .              */
 1,090 (0.0%)      POSIX_GUARD(s2n_hash_set_impl(state));
     .         
 1,090 (0.0%)      POSIX_ENSURE_REF(state->hash_impl->alloc);
     .         
 1,744 (0.0%)      POSIX_GUARD(state->hash_impl->alloc(state));
   218 (0.0%)      return S2N_SUCCESS;
   654 (0.0%)  }
     .         
     .         S2N_RESULT s2n_hash_state_validate(struct s2n_hash_state *state)
12,504 (0.2%)  {
 4,168 (0.1%)      RESULT_ENSURE_REF(state);
 2,084 (0.0%)      return S2N_RESULT_OK;
 6,252 (0.1%)  }
     .         
     .         int s2n_hash_allow_md5_for_fips(struct s2n_hash_state *state)
     .         {
     .             POSIX_ENSURE_REF(state);
     .             /* Ensure that hash_impl is set, as it may have been reset for s2n_hash_state on s2n_connection_wipe.
     .              * When in FIPS mode, the EVP API's must be used for hashes.
     .              */
     .             POSIX_GUARD(s2n_hash_set_impl(state));
     .         
     .             POSIX_ENSURE_REF(state->hash_impl->allow_md5_for_fips);
     .         
     .             return state->hash_impl->allow_md5_for_fips(state);
     .         }
     .         
     .         int s2n_hash_init(struct s2n_hash_state *state, s2n_hash_algorithm alg)
 2,420 (0.0%)  {
   484 (0.0%)      POSIX_ENSURE_REF(state);
     .             /* Ensure that hash_impl is set, as it may have been reset for s2n_hash_state on s2n_connection_wipe.
     .              * When in FIPS mode, the EVP API's must be used for hashes.
     .              */
 1,210 (0.0%)      POSIX_GUARD(s2n_hash_set_impl(state));
     .         
   242 (0.0%)      bool is_md5_allowed_for_fips = false;
 2,662 (0.0%)      POSIX_GUARD_RESULT(s2n_digest_is_md5_allowed_for_fips(&state->digest.high_level.evp, &is_md5_allowed_for_fips));
     .         
 1,210 (0.0%)      if (s2n_hash_is_available(alg) || ((alg == S2N_HASH_MD5 || alg == S2N_HASH_MD5_SHA1) && is_md5_allowed_for_fips)) {
     .                 /* s2n will continue to initialize an "unavailable" hash when s2n is in FIPS mode and
     .                  * FIPS is forcing the hash to be made available.
     .                  */
 1,210 (0.0%)          POSIX_ENSURE_REF(state->hash_impl->init);
     .         
 2,178 (0.0%)          return state->hash_impl->init(state, alg);
     .             } else {
     .                 POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
     .             }
 1,452 (0.0%)  }
     .         
     .         int s2n_hash_update(struct s2n_hash_state *state, const void *data, uint32_t size)
 2,512 (0.0%)  {
 4,710 (0.1%)      POSIX_PRECONDITION(s2n_hash_state_validate(state));
 1,248 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_PRECONDITION_VIOLATION);
 1,570 (0.0%)      POSIX_ENSURE_REF(state->hash_impl->update);
     .         
 2,826 (0.0%)      return state->hash_impl->update(state, data, size);
   942 (0.0%)  }
     .         
     .         int s2n_hash_digest(struct s2n_hash_state *state, void *out, uint32_t size)
   912 (0.0%)  {
 1,710 (0.0%)      POSIX_PRECONDITION(s2n_hash_state_validate(state));
   440 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(out, size), S2N_ERR_PRECONDITION_VIOLATION);
   570 (0.0%)      POSIX_ENSURE_REF(state->hash_impl->digest);
     .         
 1,026 (0.0%)      return state->hash_impl->digest(state, out, size);
   342 (0.0%)  }
     .         
     .         int s2n_hash_copy(struct s2n_hash_state *to, struct s2n_hash_state *from)
 1,190 (0.0%)  {
 2,550 (0.0%)      POSIX_PRECONDITION(s2n_hash_state_validate(to));
 2,550 (0.0%)      POSIX_PRECONDITION(s2n_hash_state_validate(from));
   850 (0.0%)      POSIX_ENSURE_REF(from->hash_impl->copy);
     .         
 1,360 (0.0%)      return from->hash_impl->copy(to, from);
   510 (0.0%)  }
     .         
     .         int s2n_hash_reset(struct s2n_hash_state *state)
   108 (0.0%)  {
    36 (0.0%)      POSIX_ENSURE_REF(state);
     .             /* Ensure that hash_impl is set, as it may have been reset for s2n_hash_state on s2n_connection_wipe.
     .              * When in FIPS mode, the EVP API's must be used for hashes.
     .              */
    90 (0.0%)      POSIX_GUARD(s2n_hash_set_impl(state));
     .         
    90 (0.0%)      POSIX_ENSURE_REF(state->hash_impl->reset);
     .         
   108 (0.0%)      return state->hash_impl->reset(state);
    54 (0.0%)  }
     .         
     .         int s2n_hash_free(struct s2n_hash_state *state)
   972 (0.0%)  {
   324 (0.0%)      if (state == NULL) {
     .                 return S2N_SUCCESS;
     .             }
     .             /* Ensure that hash_impl is set, as it may have been reset for s2n_hash_state on s2n_connection_wipe.
     .              * When in FIPS mode, the EVP API's must be used for hashes.
     .              */
   810 (0.0%)      POSIX_GUARD(s2n_hash_set_impl(state));
     .         
   810 (0.0%)      POSIX_ENSURE_REF(state->hash_impl->free);
     .         
   972 (0.0%)      return state->hash_impl->free(state);
   486 (0.0%)  }
     .         
     .         int s2n_hash_get_currently_in_hash_total(struct s2n_hash_state *state, uint64_t *out)
   756 (0.0%)  {
 1,620 (0.0%)      POSIX_PRECONDITION(s2n_hash_state_validate(state));
   216 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(out, sizeof(*out)), S2N_ERR_PRECONDITION_VIOLATION);
   432 (0.0%)      POSIX_ENSURE(state->is_ready_for_input, S2N_ERR_HASH_NOT_READY);
     .         
   432 (0.0%)      *out = state->currently_in_hash;
   108 (0.0%)      return S2N_SUCCESS;
   324 (0.0%)  }
     .         
     .         /* Calculate, in constant time, the number of bytes currently in the hash_block */
     .         int s2n_hash_const_time_get_currently_in_hash_block(struct s2n_hash_state *state, uint64_t *out)
     .         {
     .             POSIX_PRECONDITION(s2n_hash_state_validate(state));
     .             POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(out, sizeof(*out)), S2N_ERR_PRECONDITION_VIOLATION);
     .             POSIX_ENSURE(state->is_ready_for_input, S2N_ERR_HASH_NOT_READY);
     .             uint64_t hash_block_size = 0;
-- line 624 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/crypto/s2n_hmac.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 44 ----------------------------------------
     .             case S2N_HASH_MD5_SHA1:   /* Fall through ... */
     .             default:
     .                 POSIX_BAIL(S2N_ERR_HASH_INVALID_ALGORITHM);
     .             }
     .             return S2N_SUCCESS;
     .         }
     .         
     .         int s2n_hmac_hash_alg(s2n_hmac_algorithm hmac_alg, s2n_hash_algorithm *out)
 1,932 (0.0%)  {
   552 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(out, sizeof(*out)), S2N_ERR_PRECONDITION_VIOLATION);
 2,760 (0.0%)      switch(hmac_alg) {
    99 (0.0%)      case S2N_HMAC_NONE:       *out = S2N_HASH_NONE;   break;
     .             case S2N_HMAC_MD5:        *out = S2N_HASH_MD5;    break;
     .             case S2N_HMAC_SHA1:       *out = S2N_HASH_SHA1;   break;
     .             case S2N_HMAC_SHA224:     *out = S2N_HASH_SHA224; break;
   729 (0.0%)      case S2N_HMAC_SHA256:     *out = S2N_HASH_SHA256; break;
     .             case S2N_HMAC_SHA384:     *out = S2N_HASH_SHA384; break;
     .             case S2N_HMAC_SHA512:     *out = S2N_HASH_SHA512; break;
     .             case S2N_HMAC_SSLv3_MD5:  *out = S2N_HASH_MD5;    break;
     .             case S2N_HMAC_SSLv3_SHA1: *out = S2N_HASH_SHA1;   break;
     .             default:
     .                 POSIX_BAIL(S2N_ERR_HMAC_INVALID_ALGORITHM);
     .             }
   276 (0.0%)      return S2N_SUCCESS;
   828 (0.0%)  }
     .         
     .         int s2n_hmac_digest_size(s2n_hmac_algorithm hmac_alg, uint8_t *out)
 1,863 (0.0%)  {
     .             s2n_hash_algorithm hash_alg;
 1,449 (0.0%)      POSIX_GUARD(s2n_hmac_hash_alg(hmac_alg, &hash_alg));
 1,449 (0.0%)      POSIX_GUARD(s2n_hash_digest_size(hash_alg, out));
   207 (0.0%)      return S2N_SUCCESS;
 1,035 (0.0%)  }
     .         
     .         /* Return 1 if hmac algorithm is available, 0 otherwise. */
     .         bool s2n_hmac_is_available(s2n_hmac_algorithm hmac_alg)
   280 (0.0%)  {
   468 (0.0%)      switch(hmac_alg) {
     .             case S2N_HMAC_MD5:
     .             case S2N_HMAC_SSLv3_MD5:
     .             case S2N_HMAC_SSLv3_SHA1:
     .                 /* Some libcryptos, such as OpenSSL, disable MD5 by default when in FIPS mode, which is
     .                  * required in order to negotiate SSLv3. However, this is supported in AWS-LC.
     .                  */
     .                 return !s2n_is_in_fips_mode() || s2n_libcrypto_is_awslc();
     .             case S2N_HMAC_NONE:
     .             case S2N_HMAC_SHA1:
     .             case S2N_HMAC_SHA224:
     .             case S2N_HMAC_SHA256:
     .             case S2N_HMAC_SHA384:
     .             case S2N_HMAC_SHA512:
   112 (0.0%)          return true;
     .             }
     .             return false;
   112 (0.0%)  }
     .         
     .         static int s2n_sslv3_mac_init(struct s2n_hmac_state *state, s2n_hmac_algorithm alg, const void *key, uint32_t klen)
     .         {
     .             for (int i = 0; i < state->xor_pad_size; i++) {
     .                 state->xor_pad[i] = 0x36;
     .             }
     .         
     .             POSIX_GUARD(s2n_hash_update(&state->inner_just_key, key, klen));
-- line 106 ----------------------------------------
-- line 112 ----------------------------------------
     .         
     .             POSIX_GUARD(s2n_hash_update(&state->outer_just_key, key, klen));
     .             POSIX_GUARD(s2n_hash_update(&state->outer_just_key, state->xor_pad, state->xor_pad_size));
     .         
     .             return S2N_SUCCESS;
     .         }
     .         
     .         static int s2n_tls_hmac_init(struct s2n_hmac_state *state, s2n_hmac_algorithm alg, const void *key, uint32_t klen)
   504 (0.0%)  {
   336 (0.0%)      memset(&state->xor_pad, 0, sizeof(state->xor_pad));
     .         
   280 (0.0%)      if (klen > state->xor_pad_size) {
     .                 POSIX_GUARD(s2n_hash_update(&state->outer, key, klen));
     .                 POSIX_GUARD(s2n_hash_digest(&state->outer, state->digest_pad, state->digest_size));
     .                 POSIX_CHECKED_MEMCPY(state->xor_pad, state->digest_pad, state->digest_size);
     .             } else {
   852 (0.0%)          POSIX_CHECKED_MEMCPY(state->xor_pad, key, klen);
     .             }
     .         
21,896 (0.3%)      for (int i = 0; i < state->xor_pad_size; i++) {
35,840 (0.6%)          state->xor_pad[i] ^= 0x36;
     .             }
     .         
   672 (0.0%)      POSIX_GUARD(s2n_hash_update(&state->inner_just_key, state->xor_pad, state->xor_pad_size));
     .         
     .             /* 0x36 xor 0x5c == 0x6a */
21,896 (0.3%)      for (int i = 0; i < state->xor_pad_size; i++) {
35,840 (0.6%)          state->xor_pad[i] ^= 0x6a;
     .             }
     .         
   672 (0.0%)      POSIX_GUARD(s2n_hash_update(&state->outer_just_key, state->xor_pad, state->xor_pad_size));
    56 (0.0%)      return S2N_SUCCESS;
   168 (0.0%)  }
     .         
     .         int s2n_hmac_xor_pad_size(s2n_hmac_algorithm hmac_alg, uint16_t *xor_pad_size)
   392 (0.0%)  {
   112 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(xor_pad_size, sizeof(*xor_pad_size)), S2N_ERR_PRECONDITION_VIOLATION);
   560 (0.0%)      switch(hmac_alg) {
    30 (0.0%)      case S2N_HMAC_NONE:       *xor_pad_size = 64;   break;
     .             case S2N_HMAC_MD5:        *xor_pad_size = 64;   break;
     .             case S2N_HMAC_SHA1:       *xor_pad_size = 64;   break;
     .             case S2N_HMAC_SHA224:     *xor_pad_size = 64;   break;
   138 (0.0%)      case S2N_HMAC_SHA256:     *xor_pad_size = 64;   break;
     .             case S2N_HMAC_SHA384:     *xor_pad_size = 128;  break;
     .             case S2N_HMAC_SHA512:     *xor_pad_size = 128;  break;
     .             case S2N_HMAC_SSLv3_MD5:  *xor_pad_size = 48;   break;
     .             case S2N_HMAC_SSLv3_SHA1: *xor_pad_size = 40;   break;
     .             default:
     .                 POSIX_BAIL(S2N_ERR_HMAC_INVALID_ALGORITHM);
     .             }
    56 (0.0%)      return S2N_SUCCESS;
   168 (0.0%)  }
     .         
     .         int s2n_hmac_hash_block_size(s2n_hmac_algorithm hmac_alg, uint16_t *block_size)
   392 (0.0%)  {
   112 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_WRITABLE_CHECK(block_size, sizeof(*block_size)), S2N_ERR_PRECONDITION_VIOLATION);
   560 (0.0%)      switch(hmac_alg) {
    30 (0.0%)      case S2N_HMAC_NONE:       *block_size = 64;   break;
     .             case S2N_HMAC_MD5:        *block_size = 64;   break;
     .             case S2N_HMAC_SHA1:       *block_size = 64;   break;
     .             case S2N_HMAC_SHA224:     *block_size = 64;   break;
   138 (0.0%)      case S2N_HMAC_SHA256:     *block_size = 64;   break;
     .             case S2N_HMAC_SHA384:     *block_size = 128;  break;
     .             case S2N_HMAC_SHA512:     *block_size = 128;  break;
     .             case S2N_HMAC_SSLv3_MD5:  *block_size = 64;   break;
     .             case S2N_HMAC_SSLv3_SHA1: *block_size = 64;   break;
     .             default:
     .                 POSIX_BAIL(S2N_ERR_HMAC_INVALID_ALGORITHM);
     .             }
    56 (0.0%)      return S2N_SUCCESS;
   168 (0.0%)  }
     .         
     .         int s2n_hmac_new(struct s2n_hmac_state *state)
   300 (0.0%)  {
   100 (0.0%)      POSIX_ENSURE_REF(state);
   300 (0.0%)      POSIX_GUARD(s2n_hash_new(&state->inner));
   300 (0.0%)      POSIX_GUARD(s2n_hash_new(&state->inner_just_key));
   300 (0.0%)      POSIX_GUARD(s2n_hash_new(&state->outer));
   300 (0.0%)      POSIX_GUARD(s2n_hash_new(&state->outer_just_key));
   750 (0.0%)      POSIX_POSTCONDITION(s2n_hmac_state_validate(state));
    50 (0.0%)      return S2N_SUCCESS;
   150 (0.0%)  }
     .         
     .         S2N_RESULT s2n_hmac_state_validate(struct s2n_hmac_state *state)
 1,812 (0.0%)  {
   604 (0.0%)      RESULT_ENSURE_REF(state);
 2,718 (0.0%)      RESULT_GUARD(s2n_hash_state_validate(&state->inner));
 2,718 (0.0%)      RESULT_GUARD(s2n_hash_state_validate(&state->inner_just_key));
 2,718 (0.0%)      RESULT_GUARD(s2n_hash_state_validate(&state->outer));
 2,718 (0.0%)      RESULT_GUARD(s2n_hash_state_validate(&state->outer_just_key));
   302 (0.0%)      return S2N_RESULT_OK;
   906 (0.0%)  }
     .         
     .         int s2n_hmac_init(struct s2n_hmac_state *state, s2n_hmac_algorithm alg, const void *key, uint32_t klen)
   672 (0.0%)  {
   112 (0.0%)      POSIX_ENSURE_REF(state);
   336 (0.0%)      if (!s2n_hmac_is_available(alg)) {
     .                 /* Prevent hmacs from being used if they are not available. */
     .                 POSIX_BAIL(S2N_ERR_HMAC_INVALID_ALGORITHM);
     .             }
     .         
   168 (0.0%)      state->alg = alg;
   448 (0.0%)      POSIX_GUARD(s2n_hmac_hash_block_size(alg, &state->hash_block_size));
   112 (0.0%)      state->currently_in_hash_block = 0;
   448 (0.0%)      POSIX_GUARD(s2n_hmac_xor_pad_size(alg, &state->xor_pad_size));
   448 (0.0%)      POSIX_GUARD(s2n_hmac_digest_size(alg, &state->digest_size));
     .         
   224 (0.0%)      POSIX_ENSURE_GTE(sizeof(state->xor_pad), state->xor_pad_size);
   224 (0.0%)      POSIX_ENSURE_GTE(sizeof(state->digest_pad), state->digest_size);
     .             /* key needs to be as large as the biggest block size */
   224 (0.0%)      POSIX_ENSURE_GTE(sizeof(state->xor_pad), state->hash_block_size);
     .         
     .             s2n_hash_algorithm hash_alg;
   392 (0.0%)      POSIX_GUARD(s2n_hmac_hash_alg(alg, &hash_alg));
     .         
   448 (0.0%)      POSIX_GUARD(s2n_hash_init(&state->inner, hash_alg));
   448 (0.0%)      POSIX_GUARD(s2n_hash_init(&state->inner_just_key, hash_alg));
   448 (0.0%)      POSIX_GUARD(s2n_hash_init(&state->outer, hash_alg));
   448 (0.0%)      POSIX_GUARD(s2n_hash_init(&state->outer_just_key, hash_alg));
     .         
   224 (0.0%)      if (alg == S2N_HMAC_SSLv3_SHA1 || alg == S2N_HMAC_SSLv3_MD5) {
     .                 POSIX_GUARD(s2n_sslv3_mac_init(state, alg, key, klen));
     .             } else {
   448 (0.0%)          POSIX_GUARD(s2n_tls_hmac_init(state, alg, key, klen));
     .             }
     .         
     .             /* Once we have produced inner_just_key and outer_just_key, don't need the key material in xor_pad, so wipe it.
     .              * Since xor_pad is used as a source of bytes in s2n_hmac_digest_two_compression_rounds,
     .              * this also prevents uninitilized bytes being used.
     .              */
   336 (0.0%)      memset(&state->xor_pad, 0, sizeof(state->xor_pad));
   280 (0.0%)      POSIX_GUARD(s2n_hmac_reset(state));
     .         
    56 (0.0%)      return S2N_SUCCESS;
   336 (0.0%)  }
     .         
     .         int s2n_hmac_update(struct s2n_hmac_state *state, const void *in, uint32_t size)
   752 (0.0%)  {
 1,410 (0.0%)      POSIX_PRECONDITION(s2n_hmac_state_validate(state));
   376 (0.0%)      POSIX_ENSURE(state->hash_block_size != 0, S2N_ERR_PRECONDITION_VIOLATION);
     .             /* Keep track of how much of the current hash block is full
     .              *
     .              * Why the 4294949760 constant in this code? 4294949760 is the highest 32-bit
     .              * value that is congruent to 0 modulo all of our HMAC block sizes, that is also
     .              * at least 16k smaller than 2^32. It therefore has no effect on the mathematical
     .              * result, and no valid record size can cause it to overflow.
     .              *
     .              * The value was found with the following python code;
-- line 259 ----------------------------------------
-- line 265 ----------------------------------------
     .              *   x -= 1
     .              * print x
     .              *
     .              * What it does do however is ensure that the mod operation takes a
     .              * constant number of instruction cycles, regardless of the size of the
     .              * input. On some platforms, including Intel, the operation can take a
     .              * smaller number of cycles if the input is "small".
     .              */
    94 (0.0%)      const uint32_t HIGHEST_32_BIT = 4294949760;
   376 (0.0%)      POSIX_ENSURE(size <= (UINT32_MAX - HIGHEST_32_BIT), S2N_ERR_INTEGER_OVERFLOW);
   940 (0.0%)      uint32_t value = (HIGHEST_32_BIT + size) % state->hash_block_size;
   940 (0.0%)      POSIX_GUARD(s2n_add_overflow(state->currently_in_hash_block, value, &state->currently_in_hash_block));
 1,034 (0.0%)      state->currently_in_hash_block %= state->hash_block_size;
     .         
   658 (0.0%)      return s2n_hash_update(&state->inner, in, size);
   282 (0.0%)  }
     .         
     .         int s2n_hmac_digest(struct s2n_hmac_state *state, void *out, uint32_t size)
   350 (0.0%)  {
   750 (0.0%)      POSIX_PRECONDITION(s2n_hmac_state_validate(state));
   600 (0.0%)      POSIX_GUARD(s2n_hash_digest(&state->inner, state->digest_pad, state->digest_size));
   450 (0.0%)      POSIX_GUARD(s2n_hash_copy(&state->outer, &state->outer_just_key));
   600 (0.0%)      POSIX_GUARD(s2n_hash_update(&state->outer, state->digest_pad, state->digest_size));
     .         
   350 (0.0%)      return s2n_hash_digest(&state->outer, out, size);
   100 (0.0%)  }
     .         
     .         int s2n_hmac_digest_two_compression_rounds(struct s2n_hmac_state *state, void *out, uint32_t size)
     .         {
     .             /* Do the "real" work of this function. */
     .             POSIX_GUARD(s2n_hmac_digest(state, out, size));
     .         
     .             /* If there were 9 or more bytes of space left in the current hash block
     .              * then the serialized length, plus an 0x80 byte, will have fit in that block.
-- line 298 ----------------------------------------
-- line 310 ----------------------------------------
     .             /* Can't reuse a hash after it has been finalized, so reset and push another block in */
     .             POSIX_GUARD(s2n_hash_reset(&state->inner));
     .         
     .             /* No-op s2n_hash_update to normalize timing and guard against Lucky13. This does not affect the value of *out. */
     .             return s2n_hash_update(&state->inner, state->xor_pad, state->hash_block_size);
     .         }
     .         
     .         int s2n_hmac_free(struct s2n_hmac_state *state)
   200 (0.0%)  {
    80 (0.0%)      if (state) {
   240 (0.0%)          POSIX_GUARD(s2n_hash_free(&state->inner));
   240 (0.0%)          POSIX_GUARD(s2n_hash_free(&state->inner_just_key));
   240 (0.0%)          POSIX_GUARD(s2n_hash_free(&state->outer));
   240 (0.0%)          POSIX_GUARD(s2n_hash_free(&state->outer_just_key));
     .             }
     .         
    40 (0.0%)      return S2N_SUCCESS;
    80 (0.0%)  }
     .         
     .         int s2n_hmac_reset(struct s2n_hmac_state *state)
   972 (0.0%)  {
 1,620 (0.0%)      POSIX_PRECONDITION(s2n_hmac_state_validate(state));
   432 (0.0%)      POSIX_ENSURE(state->hash_block_size != 0, S2N_ERR_PRECONDITION_VIOLATION);
   972 (0.0%)      POSIX_GUARD(s2n_hash_copy(&state->inner, &state->inner_just_key));
     .         
   108 (0.0%)      uint64_t bytes_in_hash = 0;
   864 (0.0%)      POSIX_GUARD(s2n_hash_get_currently_in_hash_total(&state->inner, &bytes_in_hash));
   972 (0.0%)      bytes_in_hash %= state->hash_block_size;
   432 (0.0%)      POSIX_ENSURE(bytes_in_hash <= UINT32_MAX, S2N_ERR_INTEGER_OVERFLOW);
     .             /* The length of the key is not private, so don't need to do tricky math here */
   432 (0.0%)      state->currently_in_hash_block = bytes_in_hash;
   108 (0.0%)      return S2N_SUCCESS;
   648 (0.0%)  }
     .         
     .         int s2n_hmac_digest_verify(const void *a, const void *b, uint32_t len)
    28 (0.0%)  {
    36 (0.0%)      return S2N_SUCCESS - !s2n_constant_time_equals(a, b, len);
     8 (0.0%)  }
     .         
     .         int s2n_hmac_copy(struct s2n_hmac_state *to, struct s2n_hmac_state *from)
     .         {
     .             POSIX_PRECONDITION(s2n_hmac_state_validate(to));
     .             POSIX_PRECONDITION(s2n_hmac_state_validate(from));
     .             /* memcpy cannot be used on s2n_hmac_state as the underlying s2n_hash implementation's
     .              * copy must be used. This is enforced when the s2n_hash implementation is s2n_evp_hash.
     .              */
-- line 355 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 18 ----------------------------------------
     .         #include <sys/param.h>
     .         
     .         #include "error/s2n_errno.h"
     .         #include "utils/s2n_blob.h"
     .         #include "utils/s2n_mem.h"
     .         #include "utils/s2n_safety.h"
     .         
     .         S2N_RESULT s2n_stuffer_validate(const struct s2n_stuffer *stuffer)
24,390 (0.4%)  {
     .             /**
     .              * Note that we do not assert any properties on the tainted field,
     .              * as any boolean value in that field is valid.
     .              */
 8,130 (0.1%)      RESULT_ENSURE_REF(stuffer);
32,520 (0.5%)      RESULT_GUARD(s2n_blob_validate(&stuffer->blob));
44,168 (0.7%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(stuffer->growable, stuffer->alloced), S2N_ERR_SAFETY);
     .         
     .             /* <= is valid because we can have a fully written/read stuffer */
36,585 (0.6%)      RESULT_DEBUG_ENSURE(stuffer->high_water_mark <= stuffer->blob.size, S2N_ERR_SAFETY);
36,585 (0.6%)      RESULT_DEBUG_ENSURE(stuffer->write_cursor <= stuffer->high_water_mark, S2N_ERR_SAFETY);
36,585 (0.6%)      RESULT_DEBUG_ENSURE(stuffer->read_cursor <= stuffer->write_cursor, S2N_ERR_SAFETY);
 4,065 (0.1%)      return S2N_RESULT_OK;
12,195 (0.2%)  }
     .         
     .         S2N_RESULT s2n_stuffer_reservation_validate(const struct s2n_stuffer_reservation *reservation)
   306 (0.0%)  {
     .             /**
     .              * Note that we need two dereferences here to decrease proof complexity
     .              * for CBMC (see https://github.com/awslabs/s2n/issues/2290). We can roll back
     .              * this change once CBMC can handle common subexpression elimination.
     .              */
   102 (0.0%)      RESULT_ENSURE_REF(reservation);
   255 (0.0%)      const struct s2n_stuffer_reservation reserve_obj = *reservation;
   408 (0.0%)      RESULT_GUARD(s2n_stuffer_validate(reserve_obj.stuffer));
   561 (0.0%)      const struct s2n_stuffer stuffer_obj = *(reserve_obj.stuffer);
     .         
     .             /* Verify that write_cursor + length can be represented as a uint32_t without overflow */
   306 (0.0%)      RESULT_ENSURE_LTE(reserve_obj.write_cursor, UINT32_MAX - reserve_obj.length);
     .             /* The entire reservation must fit between the stuffer read and write cursors */
   357 (0.0%)      RESULT_ENSURE_LTE(reserve_obj.write_cursor + reserve_obj.length, stuffer_obj.write_cursor);
   204 (0.0%)      RESULT_ENSURE_GTE(reserve_obj.write_cursor, stuffer_obj.read_cursor);
     .         
    51 (0.0%)      return S2N_RESULT_OK;
   153 (0.0%)  }
     .         
     .         int s2n_stuffer_init(struct s2n_stuffer *stuffer, struct s2n_blob *in)
   658 (0.0%)  {
   188 (0.0%)      POSIX_ENSURE_MUT(stuffer);
 1,410 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(in));
   752 (0.0%)      stuffer->blob = *in;
   188 (0.0%)      stuffer->read_cursor = 0;
   188 (0.0%)      stuffer->write_cursor = 0;
   188 (0.0%)      stuffer->high_water_mark = 0;
   376 (0.0%)      stuffer->alloced = 0;
   376 (0.0%)      stuffer->growable = 0;
   376 (0.0%)      stuffer->tainted = 0;
 1,410 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    94 (0.0%)      return S2N_SUCCESS;
   282 (0.0%)  }
     .         
     .         int s2n_stuffer_init_written(struct s2n_stuffer *stuffer, struct s2n_blob *in)
     7 (0.0%)  {
     2 (0.0%)      POSIX_ENSURE_REF(in);
     7 (0.0%)      POSIX_GUARD(s2n_stuffer_init(stuffer, in));
     8 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(stuffer, in->size));
     1 (0.0%)      return S2N_SUCCESS;
     3 (0.0%)  }
     .         
     .         int s2n_stuffer_alloc(struct s2n_stuffer *stuffer, const uint32_t size)
    84 (0.0%)  {
    24 (0.0%)      POSIX_ENSURE_REF(stuffer);
    60 (0.0%)      *stuffer = (struct s2n_stuffer){ 0 };
    84 (0.0%)      POSIX_GUARD(s2n_alloc(&stuffer->blob, size));
    84 (0.0%)      POSIX_GUARD(s2n_stuffer_init(stuffer, &stuffer->blob));
     .         
    48 (0.0%)      stuffer->alloced = 1;
     .         
   180 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    12 (0.0%)      return S2N_SUCCESS;
    36 (0.0%)  }
     .         
     .         int s2n_stuffer_growable_alloc(struct s2n_stuffer *stuffer, const uint32_t size)
    60 (0.0%)  {
    70 (0.0%)      POSIX_GUARD(s2n_stuffer_alloc(stuffer, size));
     .         
    40 (0.0%)      stuffer->growable = 1;
     .         
   150 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    10 (0.0%)      return S2N_SUCCESS;
    20 (0.0%)  }
     .         
     .         int s2n_stuffer_free(struct s2n_stuffer *stuffer)
   130 (0.0%)  {
   390 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
   130 (0.0%)      if (stuffer->alloced) {
    20 (0.0%)          POSIX_GUARD(s2n_free(&stuffer->blob));
     .             }
   130 (0.0%)      *stuffer = (struct s2n_stuffer){ 0 };
    26 (0.0%)      return S2N_SUCCESS;
    52 (0.0%)  }
     .         
     .         int s2n_stuffer_free_without_wipe(struct s2n_stuffer *stuffer)
     .         {
     .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
     .             if (stuffer->alloced) {
     .                 POSIX_GUARD(s2n_free_without_wipe(&stuffer->blob));
     .             }
     .             *stuffer = (struct s2n_stuffer){ 0 };
     .             return S2N_SUCCESS;
     .         }
     .         
     .         int s2n_stuffer_resize(struct s2n_stuffer *stuffer, const uint32_t size)
    70 (0.0%)  {
   150 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    50 (0.0%)      POSIX_ENSURE(!stuffer->tainted, S2N_ERR_RESIZE_TAINTED_STUFFER);
    50 (0.0%)      POSIX_ENSURE(stuffer->growable, S2N_ERR_RESIZE_STATIC_STUFFER);
     .         
    40 (0.0%)      if (size == stuffer->blob.size) {
    12 (0.0%)          return S2N_SUCCESS;
     .             }
     .         
     8 (0.0%)      if (size == 0) {
     6 (0.0%)          s2n_stuffer_wipe(stuffer);
     8 (0.0%)          return s2n_free(&stuffer->blob);
     .             }
     .         
     8 (0.0%)      if (size < stuffer->blob.size) {
     .                 POSIX_CHECKED_MEMSET(stuffer->blob.data + size, S2N_WIPE_PATTERN, (stuffer->blob.size - size));
     .                 if (stuffer->read_cursor > size) {
     .                     stuffer->read_cursor = size;
     .                 }
     .                 if (stuffer->write_cursor > size) {
     .                     stuffer->write_cursor = size;
     .                 }
     .                 if (stuffer->high_water_mark > size) {
     .                     stuffer->high_water_mark = size;
     .                 }
     .                 stuffer->blob.size = size;
     .                 POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     .                 return S2N_SUCCESS;
     .             }
     .         
    14 (0.0%)      POSIX_GUARD(s2n_realloc(&stuffer->blob, size));
    30 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     2 (0.0%)      return S2N_SUCCESS;
    30 (0.0%)  }
     .         
     .         int s2n_stuffer_resize_if_empty(struct s2n_stuffer *stuffer, const uint32_t size)
   140 (0.0%)  {
   300 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    80 (0.0%)      if (stuffer->blob.data == NULL) {
    10 (0.0%)          POSIX_ENSURE(!stuffer->tainted, S2N_ERR_RESIZE_TAINTED_STUFFER);
    10 (0.0%)          POSIX_ENSURE(stuffer->growable, S2N_ERR_RESIZE_STATIC_STUFFER);
    14 (0.0%)          POSIX_GUARD(s2n_realloc(&stuffer->blob, size));
     .             }
   300 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    20 (0.0%)      return S2N_SUCCESS;
    60 (0.0%)  }
     .         
     .         int s2n_stuffer_rewrite(struct s2n_stuffer *stuffer)
   270 (0.0%)  {
   810 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
   108 (0.0%)      stuffer->write_cursor = 0;
   108 (0.0%)      stuffer->read_cursor = 0;
   810 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    54 (0.0%)      return S2N_SUCCESS;
   108 (0.0%)  }
     .         
     .         int s2n_stuffer_rewind_read(struct s2n_stuffer *stuffer, const uint32_t size)
   161 (0.0%)  {
   345 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    92 (0.0%)      POSIX_ENSURE(stuffer->read_cursor >= size, S2N_ERR_STUFFER_OUT_OF_DATA);
   138 (0.0%)      stuffer->read_cursor -= size;
   345 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    23 (0.0%)      return S2N_SUCCESS;
    69 (0.0%)  }
     .         
     .         int s2n_stuffer_reread(struct s2n_stuffer *stuffer)
   330 (0.0%)  {
   990 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
   132 (0.0%)      stuffer->read_cursor = 0;
    66 (0.0%)      return S2N_SUCCESS;
   132 (0.0%)  }
     .         
     .         int s2n_stuffer_wipe_n(struct s2n_stuffer *stuffer, const uint32_t size)
    98 (0.0%)  {
   210 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    84 (0.0%)      uint32_t wipe_size = MIN(size, stuffer->write_cursor);
     .         
    84 (0.0%)      stuffer->write_cursor -= wipe_size;
   112 (0.0%)      stuffer->read_cursor = MIN(stuffer->read_cursor, stuffer->write_cursor);
   238 (0.0%)      POSIX_CHECKED_MEMSET(stuffer->blob.data + stuffer->write_cursor, S2N_WIPE_PATTERN, wipe_size);
     .         
   210 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    14 (0.0%)      return S2N_SUCCESS;
    42 (0.0%)  }
     .         
     .         bool s2n_stuffer_is_consumed(struct s2n_stuffer *stuffer)
    36 (0.0%)  {
   144 (0.0%)      return stuffer && (stuffer->read_cursor == stuffer->write_cursor) && !stuffer->tainted;
    18 (0.0%)  }
     .         
     .         int s2n_stuffer_wipe(struct s2n_stuffer *stuffer)
   378 (0.0%)  {
   945 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
   252 (0.0%)      if (!s2n_stuffer_is_wiped(stuffer)) {
   810 (0.0%)          POSIX_CHECKED_MEMSET(stuffer->blob.data, S2N_WIPE_PATTERN, stuffer->high_water_mark);
     .             }
     .         
   252 (0.0%)      stuffer->tainted = 0;
   126 (0.0%)      stuffer->write_cursor = 0;
   126 (0.0%)      stuffer->read_cursor = 0;
   126 (0.0%)      stuffer->high_water_mark = 0;
   945 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
    63 (0.0%)      return S2N_SUCCESS;
   189 (0.0%)  }
     .         
     .         int s2n_stuffer_skip_read(struct s2n_stuffer *stuffer, uint32_t n)
 1,862 (0.0%)  {
 3,990 (0.1%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 1,862 (0.0%)      POSIX_ENSURE(s2n_stuffer_data_available(stuffer) >= n, S2N_ERR_STUFFER_OUT_OF_DATA);
     .         
 1,596 (0.0%)      stuffer->read_cursor += n;
   266 (0.0%)      return S2N_SUCCESS;
   798 (0.0%)  }
     .         
     .         void *s2n_stuffer_raw_read(struct s2n_stuffer *stuffer, uint32_t data_len)
   420 (0.0%)  {
   490 (0.0%)      PTR_GUARD_POSIX(s2n_stuffer_skip_read(stuffer, data_len));
     .         
   280 (0.0%)      stuffer->tainted = 1;
     .         
   910 (0.0%)      return (stuffer->blob.data) ? (stuffer->blob.data + stuffer->read_cursor - data_len) : NULL;
   140 (0.0%)  }
     .         
     .         int s2n_stuffer_read(struct s2n_stuffer *stuffer, struct s2n_blob *out)
     7 (0.0%)  {
     2 (0.0%)      POSIX_ENSURE_REF(out);
     .         
     8 (0.0%)      return s2n_stuffer_read_bytes(stuffer, out->data, out->size);
     3 (0.0%)  }
     .         
     .         int s2n_stuffer_erase_and_read(struct s2n_stuffer *stuffer, struct s2n_blob *out)
     .         {
     .             POSIX_GUARD(s2n_stuffer_skip_read(stuffer, out->size));
     .         
     .             void *ptr = (stuffer->blob.data) ? (stuffer->blob.data + stuffer->read_cursor - out->size) : NULL;
     .             POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, out->size), S2N_ERR_NULL);
     .         
     .             POSIX_CHECKED_MEMCPY(out->data, ptr, out->size);
     .             POSIX_CHECKED_MEMSET(ptr, 0, out->size);
     .         
     .             return S2N_SUCCESS;
     .         }
     .         
     .         int s2n_stuffer_read_bytes(struct s2n_stuffer *stuffer, uint8_t *data, uint32_t size)
 1,120 (0.0%)  {
   280 (0.0%)      POSIX_ENSURE_REF(data);
 2,100 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
   980 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_read(stuffer, size));
   560 (0.0%)      POSIX_ENSURE_REF(stuffer->blob.data);
 1,260 (0.0%)      void *ptr = stuffer->blob.data + stuffer->read_cursor - size;
     .         
 2,240 (0.0%)      POSIX_CHECKED_MEMCPY(data, ptr, size);
     .         
   140 (0.0%)      return S2N_SUCCESS;
   420 (0.0%)  }
     .         
     .         int s2n_stuffer_erase_and_read_bytes(struct s2n_stuffer *stuffer, uint8_t *data, uint32_t size)
     8 (0.0%)  {
     7 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_read(stuffer, size));
     4 (0.0%)      POSIX_ENSURE_REF(stuffer->blob.data);
     9 (0.0%)      void *ptr = stuffer->blob.data + stuffer->read_cursor - size;
     .         
    16 (0.0%)      POSIX_CHECKED_MEMCPY(data, ptr, size);
    16 (0.0%)      POSIX_CHECKED_MEMSET(ptr, 0, size);
     .         
     1 (0.0%)      return S2N_SUCCESS;
     3 (0.0%)  }
     .         
     .         int s2n_stuffer_skip_write(struct s2n_stuffer *stuffer, const uint32_t n)
 3,258 (0.1%)  {
 8,145 (0.1%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 3,801 (0.1%)      POSIX_GUARD(s2n_stuffer_reserve_space(stuffer, n));
 3,258 (0.1%)      stuffer->write_cursor += n;
 4,344 (0.1%)      stuffer->high_water_mark = MAX(stuffer->write_cursor, stuffer->high_water_mark);
 8,145 (0.1%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
   543 (0.0%)      return S2N_SUCCESS;
 1,086 (0.0%)  }
     .         
     .         void *s2n_stuffer_raw_write(struct s2n_stuffer *stuffer, const uint32_t data_len)
   126 (0.0%)  {
   147 (0.0%)      PTR_GUARD_POSIX(s2n_stuffer_skip_write(stuffer, data_len));
     .         
    84 (0.0%)      stuffer->tainted = 1;
     .         
   273 (0.0%)      return (stuffer->blob.data) ? (stuffer->blob.data + stuffer->write_cursor - data_len) : NULL;
    42 (0.0%)  }
     .         
     .         int s2n_stuffer_write(struct s2n_stuffer *stuffer, const struct s2n_blob *in)
   462 (0.0%)  {
 1,155 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 1,155 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(in));
   616 (0.0%)      return s2n_stuffer_write_bytes(stuffer, in->data, in->size);
   154 (0.0%)  }
     .         
     .         int s2n_stuffer_write_bytes(struct s2n_stuffer *stuffer, const uint8_t *data, const uint32_t size)
 2,336 (0.0%)  {
 1,128 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_SAFETY);
 4,380 (0.1%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 2,044 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(stuffer, size));
     .         
 2,628 (0.0%)      void *ptr = stuffer->blob.data + stuffer->write_cursor - size;
 1,128 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, size), S2N_ERR_NULL);
     .         
   876 (0.0%)      if (ptr == data) {
    30 (0.0%)          POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
     4 (0.0%)          return S2N_SUCCESS;
     .             }
     .         
 4,460 (0.1%)      POSIX_CHECKED_MEMCPY(ptr, data, size);
     .         
 4,350 (0.1%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
   290 (0.0%)      return S2N_SUCCESS;
   876 (0.0%)  }
     .         
     .         int s2n_stuffer_writev_bytes(struct s2n_stuffer *stuffer, const struct iovec *iov, size_t iov_count, uint32_t offs,
     .                 uint32_t size)
    90 (0.0%)  {
   135 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
    18 (0.0%)      POSIX_ENSURE_REF(iov);
    54 (0.0%)      void *ptr = s2n_stuffer_raw_write(stuffer, size);
    36 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(ptr, size), S2N_ERR_NULL);
     .         
    36 (0.0%)      size_t size_left = size, to_skip = offs;
    45 (0.0%)      for (size_t i = 0; i < iov_count; i++) {
    72 (0.0%)          if (to_skip >= iov[i].iov_len) {
     .                     to_skip -= iov[i].iov_len;
     .                     continue;
     .                 }
    72 (0.0%)          size_t iov_len_op = iov[i].iov_len - to_skip;
    27 (0.0%)          POSIX_ENSURE_LTE(iov_len_op, UINT32_MAX);
    18 (0.0%)          uint32_t iov_len = (uint32_t) iov_len_op;
    45 (0.0%)          uint32_t iov_size_to_take = MIN(size_left, iov_len);
    72 (0.0%)          POSIX_ENSURE_REF(iov[i].iov_base);
    72 (0.0%)          POSIX_ENSURE_LT(to_skip, iov[i].iov_len);
   207 (0.0%)          POSIX_CHECKED_MEMCPY(ptr, ((uint8_t *) (iov[i].iov_base)) + to_skip, iov_size_to_take);
    18 (0.0%)          size_left -= iov_size_to_take;
    18 (0.0%)          if (size_left == 0) {
     9 (0.0%)              break;
     .                 }
     .                 ptr = (void *) ((uint8_t *) ptr + iov_size_to_take);
     .                 to_skip = 0;
     .             }
     .         
     9 (0.0%)      return S2N_SUCCESS;
    27 (0.0%)  }
     .         
     .         static int s2n_stuffer_copy_impl(struct s2n_stuffer *from, struct s2n_stuffer *to, const uint32_t len)
   216 (0.0%)  {
   189 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_read(from, len));
   189 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(to, len));
     .         
   378 (0.0%)      uint8_t *from_ptr = (from->blob.data) ? (from->blob.data + from->read_cursor - len) : NULL;
   378 (0.0%)      uint8_t *to_ptr = (to->blob.data) ? (to->blob.data + to->write_cursor - len) : NULL;
     .         
   414 (0.0%)      POSIX_CHECKED_MEMCPY(to_ptr, from_ptr, len);
     .         
    27 (0.0%)      return S2N_SUCCESS;
    81 (0.0%)  }
     .         
     .         int s2n_stuffer_reserve_space(struct s2n_stuffer *stuffer, uint32_t n)
 5,630 (0.1%)  {
 8,445 (0.1%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
 3,941 (0.1%)      if (s2n_stuffer_space_remaining(stuffer) < n) {
     .                 POSIX_ENSURE(stuffer->growable, S2N_ERR_STUFFER_IS_FULL);
     .                 /* Always grow a stuffer by at least 1k */
     .                 const uint32_t growth = MAX(n - s2n_stuffer_space_remaining(stuffer), S2N_MIN_STUFFER_GROWTH_IN_BYTES);
     .                 uint32_t new_size = 0;
     .                 POSIX_GUARD(s2n_add_overflow(stuffer->blob.size, growth, &new_size));
     .                 POSIX_GUARD(s2n_stuffer_resize(stuffer, new_size));
     .             }
 8,445 (0.1%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
   563 (0.0%)      return S2N_SUCCESS;
 3,378 (0.1%)  }
     .         
     .         /* Copies "len" bytes from "from" to "to".
     .          * If the copy cannot succeed (i.e. there are either not enough bytes available, or there is not enough space to write them
     .          * restore the old value of the stuffer */
     .         int s2n_stuffer_copy(struct s2n_stuffer *from, struct s2n_stuffer *to, const uint32_t len)
   189 (0.0%)  {
    81 (0.0%)      const uint32_t orig_read_cursor = from->read_cursor;
    81 (0.0%)      const uint32_t orig_write_cursor = to->write_cursor;
     .         
   216 (0.0%)      if (s2n_stuffer_copy_impl(from, to, len) < 0) {
     .                 from->read_cursor = orig_read_cursor;
     .                 to->write_cursor = orig_write_cursor;
     .                 S2N_ERROR_PRESERVE_ERRNO();
     .             }
     .         
    27 (0.0%)      return S2N_SUCCESS;
    54 (0.0%)  }
     .         
     .         int s2n_stuffer_extract_blob(struct s2n_stuffer *stuffer, struct s2n_blob *out)
     .         {
     .             POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
     .             POSIX_ENSURE_REF(out);
     .             POSIX_GUARD(s2n_realloc(out, s2n_stuffer_data_available(stuffer)));
     .         
     .             if (s2n_stuffer_data_available(stuffer) > 0) {
-- line 427 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/stuffer/s2n_stuffer_network_order.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 15 ----------------------------------------
    .         
    .         #include "error/s2n_errno.h"
    .         #include "stuffer/s2n_stuffer.h"
    .         #include "utils/s2n_annotations.h"
    .         #include "utils/s2n_safety.h"
    .         
    .         /* Writes length bytes of input to stuffer, in network order, starting from the smallest byte of input. */
    .         int s2n_stuffer_write_network_order(struct s2n_stuffer *stuffer, const uint64_t input, const uint8_t length)
  963 (0.0%)  {
  214 (0.0%)      if (length == 0) {
    .                 return S2N_SUCCESS;
    .             }
  214 (0.0%)      POSIX_ENSURE_REF(stuffer);
  214 (0.0%)      POSIX_ENSURE(length <= sizeof(input), S2N_ERR_SAFETY);
  749 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(stuffer, length));
  428 (0.0%)      POSIX_ENSURE_REF(stuffer->blob.data);
  963 (0.0%)      uint8_t *data = stuffer->blob.data + stuffer->write_cursor - length;
1,455 (0.0%)      for (int i = 0; i < length; i++) {
    .                 S2N_INVARIANT(i <= length);
1,150 (0.0%)          uint8_t shift = (length - i - 1) * CHAR_BIT;
2,530 (0.0%)          data[i] = (input >> (shift)) & UINT8_MAX;
    .             }
1,605 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(stuffer));
  107 (0.0%)      return S2N_SUCCESS;
  321 (0.0%)  }
    .         
    .         int s2n_stuffer_reserve(struct s2n_stuffer *stuffer, struct s2n_stuffer_reservation *reservation, const uint8_t length)
  153 (0.0%)  {
  255 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(stuffer));
   34 (0.0%)      POSIX_ENSURE_REF(reservation);
    .         
  136 (0.0%)      *reservation = (struct s2n_stuffer_reservation){ .stuffer = stuffer,
   34 (0.0%)          .write_cursor = stuffer->write_cursor,
    .                 .length = length };
    .         
  153 (0.0%)      POSIX_GUARD(s2n_stuffer_skip_write(stuffer, reservation->length));
  374 (0.0%)      POSIX_CHECKED_MEMSET(stuffer->blob.data + reservation->write_cursor, S2N_WIPE_PATTERN, reservation->length);
  255 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_reservation_validate(reservation));
   17 (0.0%)      return S2N_SUCCESS;
   51 (0.0%)  }
    .         
    .         int s2n_stuffer_read_uint8(struct s2n_stuffer *stuffer, uint8_t *u)
  228 (0.0%)  {
  304 (0.0%)      POSIX_GUARD(s2n_stuffer_read_bytes(stuffer, u, sizeof(uint8_t)));
    .         
   38 (0.0%)      return S2N_SUCCESS;
   76 (0.0%)  }
    .         
    .         int s2n_stuffer_write_uint8(struct s2n_stuffer *stuffer, const uint8_t u)
  770 (0.0%)  {
  880 (0.0%)      POSIX_GUARD(s2n_stuffer_write_bytes(stuffer, &u, sizeof(u)));
    .         
  110 (0.0%)      return S2N_SUCCESS;
  220 (0.0%)  }
    .         
    .         int s2n_stuffer_reserve_uint8(struct s2n_stuffer *stuffer, struct s2n_stuffer_reservation *reservation)
    .         {
    .             return s2n_stuffer_reserve(stuffer, reservation, sizeof(uint8_t));
    .         }
    .         
    .         int s2n_stuffer_read_uint16(struct s2n_stuffer *stuffer, uint16_t *u)
  650 (0.0%)  {
  130 (0.0%)      POSIX_ENSURE_REF(u);
    .             uint8_t data[sizeof(uint16_t)];
    .         
  520 (0.0%)      POSIX_GUARD(s2n_stuffer_read_bytes(stuffer, data, sizeof(data)));
    .         
  390 (0.0%)      *u = data[0] << 8;
  455 (0.0%)      *u |= data[1];
    .         
   65 (0.0%)      return S2N_SUCCESS;
  390 (0.0%)  }
    .         
    .         int s2n_stuffer_write_uint16(struct s2n_stuffer *stuffer, const uint16_t u)
  525 (0.0%)  {
  450 (0.0%)      return s2n_stuffer_write_network_order(stuffer, u, sizeof(u));
  150 (0.0%)  }
    .         
    .         int s2n_stuffer_reserve_uint16(struct s2n_stuffer *stuffer, struct s2n_stuffer_reservation *reservation)
   96 (0.0%)  {
   96 (0.0%)      return s2n_stuffer_reserve(stuffer, reservation, sizeof(uint16_t));
   32 (0.0%)  }
    .         
    .         int s2n_stuffer_read_uint24(struct s2n_stuffer *stuffer, uint32_t *u)
  100 (0.0%)  {
   20 (0.0%)      POSIX_ENSURE_REF(u);
    .             uint8_t data[SIZEOF_UINT24];
    .         
   80 (0.0%)      POSIX_GUARD(s2n_stuffer_read_bytes(stuffer, data, sizeof(data)));
    .         
   60 (0.0%)      *u = data[0] << 16;
   80 (0.0%)      *u |= data[1] << 8;
   70 (0.0%)      *u |= data[2];
    .         
   10 (0.0%)      return S2N_SUCCESS;
   60 (0.0%)  }
    .         
    .         int s2n_stuffer_write_uint24(struct s2n_stuffer *stuffer, const uint32_t u)
   90 (0.0%)  {
   90 (0.0%)      return s2n_stuffer_write_network_order(stuffer, u, SIZEOF_UINT24);
   30 (0.0%)  }
    .         
    .         int s2n_stuffer_reserve_uint24(struct s2n_stuffer *stuffer, struct s2n_stuffer_reservation *reservation)
    6 (0.0%)  {
    6 (0.0%)      return s2n_stuffer_reserve(stuffer, reservation, SIZEOF_UINT24);
    2 (0.0%)  }
    .         
    .         int s2n_stuffer_read_uint32(struct s2n_stuffer *stuffer, uint32_t *u)
    .         {
    .             POSIX_ENSURE_REF(u);
    .             uint8_t data[sizeof(uint32_t)];
    .         
    .             POSIX_GUARD(s2n_stuffer_read_bytes(stuffer, data, sizeof(data)));
    .         
-- line 128 ----------------------------------------
-- line 159 ----------------------------------------
    .         }
    .         
    .         int s2n_stuffer_write_uint64(struct s2n_stuffer *stuffer, const uint64_t u)
    .         {
    .             return s2n_stuffer_write_network_order(stuffer, u, sizeof(u));
    .         }
    .         
    .         static int length_matches_value_check(uint32_t value, uint8_t length)
  136 (0.0%)  {
    .             /* Value is represented as a uint32_t, so shouldn't be assumed larger */
   34 (0.0%)      POSIX_ENSURE(length <= sizeof(uint32_t), S2N_ERR_SIZE_MISMATCH);
    .         
   34 (0.0%)      if (length < sizeof(uint32_t)) {
    .                 /* Value should be less than the maximum for its length */
  119 (0.0%)          const uint32_t size_max = 1 << (length * 8);
   51 (0.0%)          POSIX_ENSURE(value < size_max, S2N_ERR_SIZE_MISMATCH);
    .             }
    .         
   17 (0.0%)      return S2N_SUCCESS;
   51 (0.0%)  }
    .         
    .         static int s2n_stuffer_write_reservation_impl(struct s2n_stuffer_reservation *reservation, const uint32_t u)
  102 (0.0%)  {
   85 (0.0%)      reservation->stuffer->write_cursor = reservation->write_cursor;
  272 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_validate(reservation->stuffer));
    .         
  153 (0.0%)      POSIX_GUARD(length_matches_value_check(u, reservation->length));
  187 (0.0%)      POSIX_GUARD(s2n_stuffer_write_network_order(reservation->stuffer, u, reservation->length));
  272 (0.0%)      POSIX_POSTCONDITION(s2n_stuffer_validate(reservation->stuffer));
   17 (0.0%)      return S2N_SUCCESS;
   34 (0.0%)  }
    .         
    .         int s2n_stuffer_write_reservation(struct s2n_stuffer_reservation *reservation, const uint32_t u)
  102 (0.0%)  {
  255 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_reservation_validate(reservation));
   68 (0.0%)      uint32_t old_write_cursor = reservation->stuffer->write_cursor;
  102 (0.0%)      int result = s2n_stuffer_write_reservation_impl(reservation, u);
   68 (0.0%)      reservation->stuffer->write_cursor = old_write_cursor;
   17 (0.0%)      return result;
   34 (0.0%)  }
    .         
    .         int s2n_stuffer_get_vector_size(const struct s2n_stuffer_reservation *reservation, uint32_t *size)
  119 (0.0%)  {
  255 (0.0%)      POSIX_PRECONDITION(s2n_stuffer_reservation_validate(reservation));
   34 (0.0%)      POSIX_ENSURE_REF(size);
  204 (0.0%)      *size = reservation->stuffer->write_cursor - (reservation->write_cursor + reservation->length);
   17 (0.0%)      return S2N_SUCCESS;
   51 (0.0%)  }
    .         
    .         int s2n_stuffer_write_vector_size(struct s2n_stuffer_reservation *reservation)
  128 (0.0%)  {
   16 (0.0%)      uint32_t size = 0;
  112 (0.0%)      POSIX_GUARD(s2n_stuffer_get_vector_size(reservation, &size));
  112 (0.0%)      POSIX_GUARD(s2n_stuffer_write_reservation(reservation, size));
   16 (0.0%)      return S2N_SUCCESS;
   80 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_blob.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 19 ----------------------------------------
     .         #include <string.h>
     .         #include <sys/param.h>
     .         
     .         #include "api/s2n.h"
     .         #include "error/s2n_errno.h"
     .         #include "utils/s2n_safety.h"
     .         
     .         S2N_RESULT s2n_blob_validate(const struct s2n_blob *b)
28,830 (0.5%)  {
 9,610 (0.2%)      RESULT_ENSURE_REF(b);
35,889 (0.6%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->data == NULL, b->size == 0), S2N_ERR_SAFETY);
35,889 (0.6%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->data == NULL, b->allocated == 0), S2N_ERR_SAFETY);
61,344 (1.0%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->growable == 0, b->allocated == 0), S2N_ERR_SAFETY);
52,237 (0.8%)      RESULT_DEBUG_ENSURE(S2N_IMPLIES(b->growable != 0, b->size <= b->allocated), S2N_ERR_SAFETY);
44,366 (0.7%)      RESULT_DEBUG_ENSURE(S2N_MEM_IS_READABLE(b->data, b->allocated), S2N_ERR_SAFETY);
64,820 (1.0%)      RESULT_DEBUG_ENSURE(S2N_MEM_IS_READABLE(b->data, b->size), S2N_ERR_SAFETY);
 4,805 (0.1%)      return S2N_RESULT_OK;
14,415 (0.2%)  }
     .         
     .         int s2n_blob_init(struct s2n_blob *b, uint8_t *data, uint32_t size)
 1,952 (0.0%)  {
   488 (0.0%)      POSIX_ENSURE_REF(b);
   968 (0.0%)      POSIX_ENSURE(S2N_MEM_IS_READABLE(data, size), S2N_ERR_SAFETY);
 2,928 (0.0%)      *b = (struct s2n_blob){ .data = data, .size = size, .allocated = 0, .growable = 0 };
 3,660 (0.1%)      POSIX_POSTCONDITION(s2n_blob_validate(b));
   244 (0.0%)      return S2N_SUCCESS;
   732 (0.0%)  }
     .         
     .         int s2n_blob_zero(struct s2n_blob *b)
   684 (0.0%)  {
 1,710 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(b));
 1,708 (0.0%)      POSIX_CHECKED_MEMSET(b->data, 0, MAX(b->allocated, b->size));
 1,710 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(b));
   114 (0.0%)      return S2N_SUCCESS;
   342 (0.0%)  }
     .         
     .         int s2n_blob_slice(const struct s2n_blob *b, struct s2n_blob *slice, uint32_t offset, uint32_t size)
   144 (0.0%)  {
   180 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(b));
   180 (0.0%)      POSIX_PRECONDITION(s2n_blob_validate(slice));
     .         
    12 (0.0%)      uint32_t slice_size = 0;
    96 (0.0%)      POSIX_GUARD(s2n_add_overflow(offset, size, &slice_size));
    60 (0.0%)      POSIX_ENSURE(b->size >= slice_size, S2N_ERR_SIZE_MISMATCH);
   132 (0.0%)      slice->data = (b->data) ? (b->data + offset) : NULL;
    36 (0.0%)      slice->size = size;
    48 (0.0%)      slice->growable = 0;
    24 (0.0%)      slice->allocated = 0;
     .         
   180 (0.0%)      POSIX_POSTCONDITION(s2n_blob_validate(slice));
    12 (0.0%)      return S2N_SUCCESS;
    72 (0.0%)  }
     .         
     .         int s2n_blob_char_to_lower(struct s2n_blob *b)
     .         {
     .             POSIX_PRECONDITION(s2n_blob_validate(b));
     .             for (size_t i = 0; i < b->size; i++) {
     .                 b->data[i] = tolower(b->data[i]);
     .             }
     .             POSIX_POSTCONDITION(s2n_blob_validate(b));
-- line 78 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_ensure.c
--------------------------------------------------------------------------------
Ir__________ 

-- line 11 ----------------------------------------
    .          * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
    .          * express or implied. See the License for the specific language governing
    .          * permissions and limitations under the License.
    .          */
    .         
    .         #include "utils/s2n_safety.h"
    .         
    .         void *s2n_ensure_memmove_trace(void *to, const void *from, size_t size)
5,920 (0.1%)  {
1,480 (0.0%)      PTR_ENSURE_REF(to);
1,480 (0.0%)      PTR_ENSURE_REF(from);
    .         
    .             /* use memmove instead of memcpy since it'll handle overlapping regions and not result in UB */
5,180 (0.1%)      void *result = memmove(to, from, size);
1,480 (0.0%)      PTR_ENSURE_REF(result);
  740 (0.0%)      return result;
2,220 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/proj/s2n/bindings/rust/s2n-tls-sys/lib/utils/s2n_result.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 79 ----------------------------------------
     .         #include "utils/s2n_result.h"
     .         
     .         #include <stdbool.h>
     .         
     .         #include "api/s2n.h"
     .         
     .         /* returns true when the result is S2N_RESULT_OK */
     .         inline bool s2n_result_is_ok(s2n_result result)
72,820 (1.2%)  {
54,615 (0.9%)      return result.__error_signal == S2N_SUCCESS;
36,410 (0.6%)  }
     .         
     .         /* returns true when the result is S2N_RESULT_ERROR */
     .         inline bool s2n_result_is_error(s2n_result result)
    64 (0.0%)  {
    48 (0.0%)      return result.__error_signal == S2N_FAILURE;
    32 (0.0%)  }
     .         
     .         /* ignores the returned result of a function */
     .         inline void s2n_result_ignore(s2n_result result)
    40 (0.0%)  {
     .             /* noop */
    30 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir_______________ 

5,112,256 (81.6%)    annotated: files known & above threshold & readable, line numbers known
        0            annotated: files known & above threshold & readable, line numbers unknown
        0          unannotated: files known & above threshold & two or more non-identical
  673,646 (10.7%)  unannotated: files known & above threshold & unreadable 
  475,204  (7.6%)  unannotated: files known & below threshold
    7,151  (0.1%)  unannotated: files unknown

