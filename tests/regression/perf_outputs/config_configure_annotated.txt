--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate cachegrind.out.config_configure
Command:          target/debug/config_configure
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir__________________ 

138,388,060 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir_______________________  file:function

< 56,600,061 (40.9%, 40.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c:
  19,148,880 (13.8%)           base64_ascii_to_bin
  13,737,240  (9.9%)           constant_time_in_range_8
  10,615,140  (7.7%)           constant_time_lt_args_8
   7,474,924  (5.4%)           aws_lc_0_19_0_EVP_DecodeUpdate
   5,619,205  (4.1%)           base64_decode_quad

< 31,847,756 (23.0%, 63.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h:
   8,741,880  (6.3%)           constant_time_msb_w
   8,741,880  (6.3%)           constant_time_is_zero_w
   7,493,040  (5.4%)           constant_time_eq_8
   6,868,620  (5.0%)           constant_time_eq_w

<  8,938,084  (6.5%, 70.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c:
   2,733,054  (2.0%)           cbs_get
   1,852,434  (1.3%)           aws_lc_0_19_0_CBS_get_u8
   1,099,967  (0.8%)           cbs_get_any_asn1_element
     658,296  (0.5%)           aws_lc_0_19_0_CBS_len
     531,132  (0.4%)           parse_asn1_tag
     432,345  (0.3%)           aws_lc_0_19_0_CBS_init
     382,734  (0.3%)           aws_lc_0_19_0_CBS_get_any_ber_asn1_element
     379,380  (0.3%)           aws_lc_0_19_0_CBS_get_bytes
     253,380  (0.2%)           aws_lc_0_19_0_CBS_skip
     199,995  (0.1%)           aws_lc_0_19_0_CBS_is_valid_asn1_oid

<  5,248,937  (3.8%, 74.2%)  ./malloc/./malloc/malloc.c:
   2,492,441  (1.8%)           _int_malloc
   1,299,497  (0.9%)           malloc
     851,538  (0.6%)           _int_free
     401,480  (0.3%)           free

<  4,292,258  (3.1%, 77.3%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c:
   1,506,140  (1.1%)           asn1_item_ex_i2d_opt
     982,172  (0.7%)           asn1_template_ex_i2d
     908,878  (0.7%)           asn1_ex_i2c
     695,848  (0.5%)           asn1_i2d_ex_primitive

<  4,118,943  (3.0%, 80.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c:
   1,439,128  (1.0%)           asn1_item_ex_d2i
     713,181  (0.5%)           asn1_check_tlen
     656,578  (0.5%)           asn1_template_noexp_d2i
     565,172  (0.4%)           asn1_d2i_ex_primitive
     382,051  (0.3%)           asn1_template_ex_d2i
     314,139  (0.2%)           asn1_ex_c2i

<  3,297,055  (2.4%, 82.6%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c:
     924,288  (0.7%)           aws_lc_0_19_0_OPENSSL_malloc
     577,672  (0.4%)           aws_lc_0_19_0_OPENSSL_free
     387,876  (0.3%)           aws_lc_0_19_0_OPENSSL_isspace
     367,821  (0.3%)           aws_lc_0_19_0_OPENSSL_zalloc
     239,136  (0.2%)           __asan_poison_memory_region
     209,310  (0.2%)           aws_lc_0_19_0_OPENSSL_cleanse
     171,846  (0.1%)           aws_lc_0_19_0_OPENSSL_tolower

<  2,445,972  (1.8%, 84.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c:
     516,000  (0.4%)           cbb_add_u
     420,000  (0.3%)           cbb_buffer_reserve
     312,000  (0.2%)           aws_lc_0_19_0_CBB_add_space
     306,720  (0.2%)           aws_lc_0_19_0_CBB_flush
     297,360  (0.2%)           cbb_get_base
     288,000  (0.2%)           cbb_buffer_add
     180,000  (0.1%)           aws_lc_0_19_0_CBB_add_u8

<  1,997,323  (1.4%, 85.8%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c:
     984,662  (0.7%)           aws_lc_0_19_0_ASN1_get_object
     404,590  (0.3%)           aws_lc_0_19_0_ASN1_object_size
     257,492  (0.2%)           aws_lc_0_19_0_ASN1_put_object

<  1,800,666  (1.3%, 87.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c:
   1,218,076  (0.9%)           aws_lc_0_19_0_X509_NAME_cmp
     582,590  (0.4%)           aws_lc_0_19_0_X509_subject_name_cmp

<  1,528,078  (1.1%, 88.2%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c:
     542,678  (0.4%)           aws_lc_0_19_0_asn1_get_field_ptr
     312,304  (0.2%)           aws_lc_0_19_0_asn1_do_adb
     284,208  (0.2%)           asn1_get_enc_ptr

<  1,491,818  (1.1%, 89.3%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c:
     959,560  (0.7%)           x509_object_cmp
     514,050  (0.4%)           x509_object_cmp_sk

<  1,464,650  (1.1%, 90.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c:
     708,637  (0.5%)           asn1_item_ex_combine_new
     313,241  (0.2%)           ASN1_template_new
     252,382  (0.2%)           ASN1_primitive_new

<  1,350,228  (1.0%, 91.4%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c:
     583,440  (0.4%)           aws_lc_0_19_0_cbs_get_latin1
     246,840  (0.2%)           aws_lc_0_19_0_cbb_add_utf8
     191,012  (0.1%)           is_valid_code_point
     166,232  (0.1%)           aws_lc_0_19_0_cbb_get_utf8_len
     162,704  (0.1%)           aws_lc_0_19_0_cbs_get_utf8

<  1,088,472  (0.8%, 92.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_mbstr.c:
   1,064,460  (0.8%)           aws_lc_0_19_0_ASN1_mbstring_ncopy

<  1,057,115  (0.8%, 92.9%)  ./stdlib/./stdlib/qsort.c:
   1,047,051  (0.8%)           msort_with_tmp.part.0

<  1,046,657  (0.8%, 93.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/stack/stack.c:
     280,486  (0.2%)           aws_lc_0_19_0_OPENSSL_sk_insert
     161,481  (0.1%)           aws_lc_0_19_0_OPENSSL_sk_value
     151,850  (0.1%)           aws_lc_0_19_0_OPENSSL_sk_num

<    850,774  (0.6%, 94.3%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x_name.c:
     465,666  (0.3%)           asn1_string_canon

<    748,223  (0.5%, 94.8%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms

<    619,920  (0.4%, 95.3%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h:
     187,904  (0.1%)           CRYPTO_bswap4

<    611,870  (0.4%, 95.7%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:
     611,328  (0.4%)           __memcpy_avx_unaligned_erms

<    589,120  (0.4%, 96.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h:
     533,008  (0.4%)           OPENSSL_memset

<    465,111  (0.3%, 96.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c:
     268,261  (0.2%)           aws_lc_0_19_0_asn1_item_combine_free

<    337,863  (0.2%, 96.7%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/pem/pem_lib.c:
     329,103  (0.2%)           aws_lc_0_19_0_PEM_read_bio

<    259,669  (0.2%, 96.9%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/buf/buf.c:
     145,038  (0.1%)           aws_lc_0_19_0_BUF_MEM_grow

<    248,349  (0.2%, 97.1%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c:
     230,175  (0.2%)           aws_lc_0_19_0_OBJ_dup

<    229,261  (0.2%, 97.2%)  ./libio/./libio/iogetline.c:
     218,428  (0.2%)           _IO_getline_info

<    202,211  (0.1%, 97.4%)  ./libio/./libio/iofgets.c:fgets

<    166,227  (0.1%, 97.5%)  /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bio/bio.c:
     166,099  (0.1%)           aws_lc_0_19_0_BIO_gets

<    163,935  (0.1%, 97.6%)  ???:
     163,550  (0.1%)           ???

<    153,336  (0.1%, 97.7%)  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir_______________________  function:file

> 19,148,880 (13.8%, 13.8%)  base64_ascii_to_bin:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

> 13,737,240  (9.9%, 23.8%)  constant_time_in_range_8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

> 10,615,140  (7.7%, 31.4%)  constant_time_lt_args_8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

>  8,748,376  (6.3%, 37.8%)  constant_time_msb_w:
   8,741,880  (6.3%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h

>  8,748,376  (6.3%, 44.1%)  constant_time_is_zero_w:
   8,741,880  (6.3%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h

>  7,493,040  (5.4%, 49.5%)  constant_time_eq_8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h

>  7,474,924  (5.4%, 54.9%)  aws_lc_0_19_0_EVP_DecodeUpdate:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

>  6,873,724  (5.0%, 59.9%)  constant_time_eq_w:
   6,868,620  (5.0%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h

>  5,619,205  (4.1%, 63.9%)  base64_decode_quad:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c

>  2,733,054  (2.0%, 65.9%)  cbs_get:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>  2,492,441  (1.8%, 67.7%)  _int_malloc:./malloc/./malloc/malloc.c

>  1,852,434  (1.3%, 69.0%)  aws_lc_0_19_0_CBS_get_u8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>  1,506,140  (1.1%, 70.1%)  asn1_item_ex_i2d_opt:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>  1,439,128  (1.0%, 71.2%)  asn1_item_ex_d2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>  1,332,858  (1.0%, 72.1%)  malloc:
   1,299,497  (0.9%)           ./malloc/./malloc/malloc.c

>  1,218,076  (0.9%, 73.0%)  aws_lc_0_19_0_X509_NAME_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c

>  1,099,967  (0.8%, 73.8%)  cbs_get_any_asn1_element:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>  1,089,222  (0.8%, 74.6%)  msort_with_tmp.part.0:
   1,047,051  (0.8%)           ./stdlib/./stdlib/qsort.c

>  1,064,460  (0.8%, 75.4%)  aws_lc_0_19_0_ASN1_mbstring_ncopy:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_mbstr.c

>    984,662  (0.7%, 76.1%)  aws_lc_0_19_0_ASN1_get_object:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c

>    982,172  (0.7%, 76.8%)  asn1_template_ex_i2d:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>    959,560  (0.7%, 77.5%)  x509_object_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c

>    924,288  (0.7%, 78.1%)  aws_lc_0_19_0_OPENSSL_malloc:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    908,878  (0.7%, 78.8%)  asn1_ex_i2c:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>    851,538  (0.6%, 79.4%)  _int_free:./malloc/./malloc/malloc.c

>    748,223  (0.5%, 80.0%)  __memset_avx2_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

>    713,181  (0.5%, 80.5%)  asn1_check_tlen:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>    708,637  (0.5%, 81.0%)  asn1_item_ex_combine_new:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c

>    695,848  (0.5%, 81.5%)  asn1_i2d_ex_primitive:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c

>    675,920  (0.5%, 82.0%)  OPENSSL_memset:
     533,008  (0.4%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h

>    658,296  (0.5%, 82.4%)  aws_lc_0_19_0_CBS_len:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    656,578  (0.5%, 82.9%)  asn1_template_noexp_d2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>    611,328  (0.4%, 83.4%)  __memcpy_avx_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

>    583,440  (0.4%, 83.8%)  aws_lc_0_19_0_cbs_get_latin1:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c

>    582,590  (0.4%, 84.2%)  aws_lc_0_19_0_X509_subject_name_cmp:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c

>    577,672  (0.4%, 84.6%)  aws_lc_0_19_0_OPENSSL_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    565,172  (0.4%, 85.0%)  asn1_d2i_ex_primitive:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>    542,678  (0.4%, 85.4%)  aws_lc_0_19_0_asn1_get_field_ptr:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c

>    531,132  (0.4%, 85.8%)  parse_asn1_tag:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    516,000  (0.4%, 86.2%)  cbb_add_u:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    514,050  (0.4%, 86.6%)  x509_object_cmp_sk:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c

>    465,666  (0.3%, 86.9%)  asn1_string_canon:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x_name.c

>    443,417  (0.3%, 87.2%)  free:
     401,480  (0.3%)           ./malloc/./malloc/malloc.c

>    432,345  (0.3%, 87.5%)  aws_lc_0_19_0_CBS_init:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    420,000  (0.3%, 87.8%)  cbb_buffer_reserve:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    404,590  (0.3%, 88.1%)  aws_lc_0_19_0_ASN1_object_size:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c

>    387,876  (0.3%, 88.4%)  aws_lc_0_19_0_OPENSSL_isspace:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    382,734  (0.3%, 88.7%)  aws_lc_0_19_0_CBS_get_any_ber_asn1_element:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    382,051  (0.3%, 89.0%)  asn1_template_ex_d2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>    379,380  (0.3%, 89.2%)  aws_lc_0_19_0_CBS_get_bytes:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    367,821  (0.3%, 89.5%)  aws_lc_0_19_0_OPENSSL_zalloc:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    329,103  (0.2%, 89.7%)  aws_lc_0_19_0_PEM_read_bio:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/pem/pem_lib.c

>    314,139  (0.2%, 90.0%)  asn1_ex_c2i:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c

>    313,241  (0.2%, 90.2%)  ASN1_template_new:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c

>    312,304  (0.2%, 90.4%)  aws_lc_0_19_0_asn1_do_adb:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c

>    312,000  (0.2%, 90.6%)  aws_lc_0_19_0_CBB_add_space:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    306,720  (0.2%, 90.9%)  aws_lc_0_19_0_CBB_flush:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    297,360  (0.2%, 91.1%)  cbb_get_base:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    288,000  (0.2%, 91.3%)  cbb_buffer_add:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    284,208  (0.2%, 91.5%)  asn1_get_enc_ptr:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c

>    280,486  (0.2%, 91.7%)  aws_lc_0_19_0_OPENSSL_sk_insert:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/stack/stack.c

>    268,261  (0.2%, 91.9%)  aws_lc_0_19_0_asn1_item_combine_free:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c

>    257,492  (0.2%, 92.1%)  aws_lc_0_19_0_ASN1_put_object:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c

>    253,380  (0.2%, 92.2%)  aws_lc_0_19_0_CBS_skip:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    252,382  (0.2%, 92.4%)  ASN1_primitive_new:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c

>    246,840  (0.2%, 92.6%)  aws_lc_0_19_0_cbb_add_utf8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c

>    241,931  (0.2%, 92.8%)  fgets:
     202,211  (0.1%)           ./libio/./libio/iofgets.c

>    239,136  (0.2%, 93.0%)  __asan_poison_memory_region:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    236,671  (0.2%, 93.1%)  _IO_getline_info:
     218,428  (0.2%)           ./libio/./libio/iogetline.c

>    230,175  (0.2%, 93.3%)  aws_lc_0_19_0_OBJ_dup:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c

>    209,310  (0.2%, 93.4%)  aws_lc_0_19_0_OPENSSL_cleanse:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    199,995  (0.1%, 93.6%)  aws_lc_0_19_0_CBS_is_valid_asn1_oid:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c

>    192,576  (0.1%, 93.7%)  CRYPTO_bswap4:
     187,904  (0.1%)           /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h

>    191,012  (0.1%, 93.9%)  is_valid_code_point:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c

>    188,102  (0.1%, 94.0%)  ???:
     163,550  (0.1%)           ???

>    180,000  (0.1%, 94.1%)  aws_lc_0_19_0_CBB_add_u8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c

>    171,846  (0.1%, 94.3%)  aws_lc_0_19_0_OPENSSL_tolower:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c

>    166,232  (0.1%, 94.4%)  aws_lc_0_19_0_cbb_get_utf8_len:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c

>    166,099  (0.1%, 94.5%)  aws_lc_0_19_0_BIO_gets:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bio/bio.c

>    162,704  (0.1%, 94.6%)  aws_lc_0_19_0_cbs_get_utf8:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c

>    161,481  (0.1%, 94.7%)  aws_lc_0_19_0_OPENSSL_sk_value:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/stack/stack.c

>    153,336  (0.1%, 94.8%)  __memcmp_avx2_movbe:./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S

>    151,850  (0.1%, 95.0%)  aws_lc_0_19_0_OPENSSL_sk_num:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/stack/stack.c

>    145,038  (0.1%, 95.1%)  aws_lc_0_19_0_BUF_MEM_grow:/home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/buf/buf.c

--------------------------------------------------------------------------------
-- Annotated source file: ./libio/./libio/iofgets.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./libio/./libio/iofgets.c

--------------------------------------------------------------------------------
-- Annotated source file: ./libio/./libio/iogetline.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./libio/./libio/iogetline.c

--------------------------------------------------------------------------------
-- Annotated source file: ./malloc/./malloc/malloc.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./malloc/./malloc/malloc.c

--------------------------------------------------------------------------------
-- Annotated source file: ./stdlib/./stdlib/qsort.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./stdlib/./stdlib/qsort.c

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/a_mbstr.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 69 ----------------------------------------
      .         // These functions take a string in UTF8, ASCII or multibyte form and a mask
      .         // of permissible ASN1 string types. It then works out the minimal type
      .         // (using the order Printable < IA5 < T61 < BMP < Universal < UTF8) and
      .         // creates a string of the correct type with the supplied data. Yes this is
      .         // horrible: it has to be :-( The 'ncopy' form checks minimum and maximum
      .         // size limits too.
      .         
      .         int ASN1_mbstring_copy(ASN1_STRING **out, const unsigned char *in,
  9,396 (0.0%)                         ossl_ssize_t len, int inform, unsigned long mask) {
 12,528 (0.0%)    return ASN1_mbstring_ncopy(out, in, len, inform, mask, /*minsize=*/0,
      .                                      /*maxsize=*/0);
  2,088 (0.0%)  }
      .         
      .         OPENSSL_DECLARE_ERROR_REASON(ASN1, INVALID_BMPSTRING)
      .         OPENSSL_DECLARE_ERROR_REASON(ASN1, INVALID_UNIVERSALSTRING)
      .         OPENSSL_DECLARE_ERROR_REASON(ASN1, INVALID_UTF8STRING)
      .         
      .         int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in,
      .                                 ossl_ssize_t len, int inform, unsigned long mask,
 13,572 (0.0%)                          ossl_ssize_t minsize, ossl_ssize_t maxsize) {
  2,088 (0.0%)    if (len == -1) {
      .             len = strlen((const char *)in);
      .           }
  2,088 (0.0%)    if (!mask) {
      .             mask = DIRSTRING_TYPE;
      .           }
      .         
      .           int (*decode_func)(CBS *, uint32_t *);
      .           int error;
 12,000 (0.0%)    switch (inform) {
      .             case MBSTRING_BMP:
      .               decode_func = cbs_get_ucs2_be;
      .               error = ASN1_R_INVALID_BMPSTRING;
      .               break;
      .         
      .             case MBSTRING_UNIV:
      .               decode_func = cbs_get_utf32_be;
      .               error = ASN1_R_INVALID_UNIVERSALSTRING;
      .               break;
      .         
      .             case MBSTRING_UTF8:
    528 (0.0%)        decode_func = cbs_get_utf8;
    264 (0.0%)        error = ASN1_R_INVALID_UTF8STRING;
    264 (0.0%)        break;
      .         
      .             case MBSTRING_ASC:
  1,560 (0.0%)        decode_func = cbs_get_latin1;
    780 (0.0%)        error = ERR_R_INTERNAL_ERROR;  // Latin-1 inputs are never invalid.
    780 (0.0%)        break;
      .         
      .             default:
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNKNOWN_FORMAT);
      .               return -1;
      .           }
      .         
      .           // Check |minsize| and |maxsize| and work out the minimal type, if any.
      .           CBS cbs;
  6,264 (0.0%)    CBS_init(&cbs, in, len);
  2,088 (0.0%)    size_t utf8_len = 0, nchar = 0;
 89,364 (0.1%)    while (CBS_len(&cbs) != 0) {
      .             uint32_t c;
132,960 (0.1%)      if (!decode_func(&cbs, &c)) {
      .               OPENSSL_PUT_ERROR(ASN1, error);
      .               return -1;
      .             }
 37,416 (0.0%)      if (nchar == 0 && (inform == MBSTRING_BMP || inform == MBSTRING_UNIV) &&
      .                 c == 0xfeff) {
      .               // Reject byte-order mark. We could drop it but that would mean
      .               // adding ambiguity around whether a BOM was included or not when
      .               // matching strings.
      .               //
      .               // For a little-endian UCS-2 string, the BOM will appear as 0xfffe
      .               // and will be rejected as noncharacter, below.
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_CHARACTERS);
      .               return -1;
      .             }
      .         
      .             // Update which output formats are still possible.
 66,480 (0.0%)      if ((mask & B_ASN1_PRINTABLESTRING) && !asn1_is_printable(c)) {
      .               mask &= ~B_ASN1_PRINTABLESTRING;
      .             }
 66,480 (0.0%)      if ((mask & B_ASN1_IA5STRING) && (c > 127)) {
      .               mask &= ~B_ASN1_IA5STRING;
      .             }
 66,480 (0.0%)      if ((mask & B_ASN1_T61STRING) && (c > 0xff)) {
      .               mask &= ~B_ASN1_T61STRING;
      .             }
 66,480 (0.0%)      if ((mask & B_ASN1_BMPSTRING) && (c > 0xffff)) {
      .               mask &= ~B_ASN1_BMPSTRING;
      .             }
 33,240 (0.0%)      if (!mask) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_CHARACTERS);
      .               return -1;
      .             }
      .         
 16,620 (0.0%)      nchar++;
 66,480 (0.0%)      utf8_len += cbb_get_utf8_len(c);
 33,240 (0.0%)      if (maxsize > 0 && nchar > (size_t)maxsize) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_STRING_TOO_LONG);
      .         #if defined(OPENSSL_WINDOWS)
      .               ERR_add_error_dataf("maxsize=%lu", (unsigned long)maxsize);
      .         #else
      .               ERR_add_error_dataf("maxsize=%zu", (size_t)maxsize);
      .         #endif
      .               return -1;
      .             }
      .           }
      .         
  2,088 (0.0%)    if (minsize > 0 && nchar < (size_t)minsize) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_STRING_TOO_SHORT);
      .         #if defined(OPENSSL_WINDOWS)
      .             ERR_add_error_dataf("minsize=%lu", (unsigned long)minsize);
      .         #else
      .             ERR_add_error_dataf("minsize=%zu", (size_t)minsize);
      .         #endif
      .             return -1;
      .           }
      .         
      .           // Now work out output format and string type
      .           int str_type;
  2,088 (0.0%)    int (*encode_func)(CBB *, uint32_t) = cbb_add_latin1;
  2,088 (0.0%)    size_t size_estimate = nchar;
  1,044 (0.0%)    int outform = MBSTRING_ASC;
  4,176 (0.0%)    if (mask & B_ASN1_PRINTABLESTRING) {
      .             str_type = V_ASN1_PRINTABLESTRING;
  4,176 (0.0%)    } else if (mask & B_ASN1_IA5STRING) {
      .             str_type = V_ASN1_IA5STRING;
  4,176 (0.0%)    } else if (mask & B_ASN1_T61STRING) {
      .             str_type = V_ASN1_T61STRING;
  4,176 (0.0%)    } else if (mask & B_ASN1_BMPSTRING) {
      .             str_type = V_ASN1_BMPSTRING;
      .             outform = MBSTRING_BMP;
      .             encode_func = cbb_add_ucs2_be;
      .             size_estimate = 2 * nchar;
  4,176 (0.0%)    } else if (mask & B_ASN1_UNIVERSALSTRING) {
      .             str_type = V_ASN1_UNIVERSALSTRING;
      .             encode_func = cbb_add_utf32_be;
      .             size_estimate = 4 * nchar;
      .             outform = MBSTRING_UNIV;
  4,176 (0.0%)    } else if (mask & B_ASN1_UTF8STRING) {
  1,044 (0.0%)      str_type = V_ASN1_UTF8STRING;
  1,044 (0.0%)      outform = MBSTRING_UTF8;
  2,088 (0.0%)      encode_func = cbb_add_utf8;
  3,132 (0.0%)      size_estimate = utf8_len;
      .           } else {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_CHARACTERS);
      .             return -1;
      .           }
      .         
  2,088 (0.0%)    if (!out) {
      .             return str_type;
      .           }
      .         
  1,044 (0.0%)    int free_dest = 0;
      .           ASN1_STRING *dest;
  4,176 (0.0%)    if (*out) {
  4,176 (0.0%)      dest = *out;
      .           } else {
      .             free_dest = 1;
      .             dest = ASN1_STRING_type_new(str_type);
      .             if (!dest) {
      .               return -1;
      .             }
      .           }
      .         
      .           CBB cbb;
  3,132 (0.0%)    CBB_zero(&cbb);
      .           // If both the same type just copy across
  3,132 (0.0%)    if (inform == outform) {
  2,112 (0.0%)      if (!ASN1_STRING_set(dest, in, len)) {
      .               goto err;
      .             }
    792 (0.0%)      dest->type = str_type;
    792 (0.0%)      *out = dest;
    528 (0.0%)      return str_type;
      .           }
  6,240 (0.0%)    if (!CBB_init(&cbb, size_estimate + 1)) {
      .             goto err;
      .           }
  4,680 (0.0%)    CBS_init(&cbs, in, len);
 60,780 (0.0%)    while (CBS_len(&cbs) != 0) {
      .             uint32_t c;
179,520 (0.1%)      if (!decode_func(&cbs, &c) || !encode_func(&cbb, c)) {
      .               OPENSSL_PUT_ERROR(ASN1, ERR_R_INTERNAL_ERROR);
      .               goto err;
      .             }
      .           }
    780 (0.0%)    uint8_t *data = NULL;
      .           size_t data_len;
  1,560 (0.0%)    if (// OpenSSL historically NUL-terminated this value with a single byte,
      .               // even for |MBSTRING_BMP| and |MBSTRING_UNIV|.
 10,920 (0.0%)        !CBB_add_u8(&cbb, 0) || !CBB_finish(&cbb, &data, &data_len) ||
  3,900 (0.0%)        data_len < 1 || data_len > INT_MAX) {
      .             OPENSSL_PUT_ERROR(ASN1, ERR_R_INTERNAL_ERROR);
      .             OPENSSL_free(data);
      .             goto err;
      .           }
  2,340 (0.0%)    dest->type = str_type;
  5,460 (0.0%)    ASN1_STRING_set0(dest, data, (int)data_len - 1);
  2,340 (0.0%)    *out = dest;
  1,560 (0.0%)    return str_type;
      .         
      .         err:
      .           if (free_dest) {
      .             ASN1_STRING_free(dest);
      .           }
      .           CBB_cleanup(&cbb);
      .           return -1;
  5,220 (0.0%)  }
      .         
      .         int asn1_is_printable(uint32_t value) {
      .           if (value > 0x7f) {
      .             return 0;
      .           }
      .           return OPENSSL_isalnum(value) || //
      .                  value == ' ' || value == '\'' || value == '(' || value == ')' ||
      .                  value == '+' || value == ',' || value == '-' || value == '.' ||
-- line 285 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/asn1_lib.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 109 ----------------------------------------
      .         //
      .         // In particular, this limit is small enough that the bit count of a BIT STRING
      .         // comfortably fits in an |int|, with room for arithmetic.
      .         #define ASN1_STRING_MAX (64 * 1024 * 1024)
      .         
      .         static void asn1_put_length(unsigned char **pp, int length);
      .         
      .         int ASN1_get_object(const unsigned char **inp, long *out_len, int *out_tag,
139,176 (0.1%)                      int *out_class, long in_len) {
 23,196 (0.0%)    if (in_len < 0) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_HEADER_TOO_LONG);
      .             return 0x80;
      .           }
      .         
      .           // TODO(https://crbug.com/boringssl/354): This should use |CBS_get_asn1| to
      .           // reject non-minimal lengths, which are only allowed in BER. However,
      .           // Android sometimes needs allow a non-minimal length in certificate
      .           // signature fields (see b/18228011). Make this only apply to that field,
      .           // while requiring DER elsewhere. Better yet, it should be limited to an
      .           // preprocessing step in that part of Android.
      .           CBS_ASN1_TAG tag;
      .           size_t header_len;
      .           int indefinite;
      .           CBS cbs, body;
 81,186 (0.1%)    CBS_init(&cbs, *inp, (size_t)in_len);
127,578 (0.1%)    if (!CBS_get_any_ber_asn1_element(&cbs, &body, &tag, &header_len,
 34,794 (0.0%)                                      /*out_ber_found=*/NULL, &indefinite) ||
104,382 (0.1%)        indefinite || !CBS_skip(&body, header_len) ||
      .               // Bound the length to comfortably fit in an int. Lengths in this
      .               // module often switch between int and long without overflow checks.
 34,794 (0.0%)        CBS_len(&body) > INT_MAX / 2) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_HEADER_TOO_LONG);
      .             return 0x80;
      .           }
      .         
      .           // Convert between tag representations.
 46,392 (0.0%)    int tag_class = (tag & CBS_ASN1_CLASS_MASK) >> CBS_ASN1_TAG_SHIFT;
 46,392 (0.0%)    int constructed = (tag & CBS_ASN1_CONSTRUCTED) >> CBS_ASN1_TAG_SHIFT;
 34,794 (0.0%)    int tag_number = tag & CBS_ASN1_TAG_NUMBER_MASK;
      .         
      .           // To avoid ambiguity with V_ASN1_NEG, impose a limit on universal tags.
 45,224 (0.0%)    if (tag_class == V_ASN1_UNIVERSAL && tag_number > V_ASN1_MAX_UNIVERSAL) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_HEADER_TOO_LONG);
      .             return 0x80;
      .           }
      .         
 57,990 (0.0%)    *inp = CBS_data(&body);
 69,588 (0.1%)    *out_len = CBS_len(&body);
 34,794 (0.0%)    *out_tag = tag_number;
 34,794 (0.0%)    *out_class = tag_class;
 11,598 (0.0%)    return constructed;
 57,990 (0.0%)  }
      .         
      .         // class 0 is constructed constructed == 2 for indefinite length constructed
      .         void ASN1_put_object(unsigned char **pp, int constructed, int length, int tag,
 58,872 (0.0%)                       int xclass) {
 14,718 (0.0%)    unsigned char *p = *pp;
      .           int i, ttag;
      .         
 22,004 (0.0%)    i = (constructed) ? V_ASN1_CONSTRUCTED : 0;
 14,718 (0.0%)    i |= (xclass & V_ASN1_PRIVATE);
  9,812 (0.0%)    if (tag < 31) {
 58,872 (0.0%)      *(p++) = i | (tag & V_ASN1_PRIMITIVE_TAG);
      .           } else {
      .             *(p++) = i | V_ASN1_PRIMITIVE_TAG;
      .             for (i = 0, ttag = tag; ttag > 0; i++) {
      .               ttag >>= 7;
      .             }
      .             ttag = i;
      .             while (i-- > 0) {
      .               p[i] = tag & 0x7f;
      .               if (i != (ttag - 1)) {
      .                 p[i] |= 0x80;
      .               }
      .               tag >>= 7;
      .             }
      .             p += ttag;
      .           }
  9,812 (0.0%)    if (constructed == 2) {
      .             *(p++) = 0x80;
      .           } else {
 24,530 (0.0%)      asn1_put_length(&p, length);
      .           }
 14,718 (0.0%)    *pp = p;
 29,436 (0.0%)  }
      .         
      .         int ASN1_put_eoc(unsigned char **pp) {
      .           // This function is no longer used in the library, but some external code
      .           // uses it.
      .           unsigned char *p = *pp;
      .           *p++ = 0;
      .           *p++ = 0;
      .           *pp = p;
      .           return 2;
      .         }
      .         
 24,530 (0.0%)  static void asn1_put_length(unsigned char **pp, int length) {
 14,718 (0.0%)    unsigned char *p = *pp;
      .           int i, l;
  9,812 (0.0%)    if (length <= 127) {
 28,164 (0.0%)      *(p++) = (unsigned char)length;
      .           } else {
    424 (0.0%)      l = length;
  2,120 (0.0%)      for (i = 0; l > 0; i++) {
    424 (0.0%)        l >>= 8;
      .             }
  1,696 (0.0%)      *(p++) = i | 0x80;
    424 (0.0%)      l = i;
  3,392 (0.0%)      while (i-- > 0) {
  2,544 (0.0%)        p[i] = length & 0xff;
    424 (0.0%)        length >>= 8;
      .             }
    636 (0.0%)      p += l;
      .           }
 14,718 (0.0%)    *pp = p;
 14,718 (0.0%)  }
      .         
 95,448 (0.1%)  int ASN1_object_size(int constructed, int length, int tag) {
 15,908 (0.0%)    int ret = 1;
 31,816 (0.0%)    if (length < 0) {
      .             return -1;
      .           }
 31,816 (0.0%)    if (tag >= 31) {
      .             while (tag > 0) {
      .               tag >>= 7;
      .               ret++;
      .             }
      .           }
 31,816 (0.0%)    if (constructed == 2) {
      .             ret += 3;
      .           } else {
 15,908 (0.0%)      ret++;
 31,816 (0.0%)      if (length > 127) {
  1,060 (0.0%)        int tmplen = length;
  3,710 (0.0%)        while (tmplen > 0) {
  1,060 (0.0%)          tmplen >>= 8;
  1,060 (0.0%)          ret++;
      .               }
      .             }
      .           }
 63,632 (0.0%)    if (ret >= INT_MAX - length) {
      .             return -1;
      .           }
 47,724 (0.0%)    return ret + length;
 31,816 (0.0%)  }
      .         
      .         int ASN1_STRING_copy(ASN1_STRING *dst, const ASN1_STRING *str) {
      .           if (str == NULL) {
      .             return 0;
      .           }
      .           if (!ASN1_STRING_set(dst, str->data, str->length)) {
      .             return 0;
      .           }
-- line 261 ----------------------------------------
-- line 275 ----------------------------------------
      .           }
      .           if (!ASN1_STRING_copy(ret, str)) {
      .             ASN1_STRING_free(ret);
      .             return NULL;
      .           }
      .           return ret;
      .         }
      .         
 16,765 (0.0%)  int ASN1_STRING_set(ASN1_STRING *str, const void *_data, ossl_ssize_t len_s) {
  4,790 (0.0%)    const char *data = _data;
      .           size_t len;
  4,790 (0.0%)    if (len_s < 0) {
      .             if (data == NULL) {
      .               return 0;
      .             }
      .             len = strlen(data);
      .           } else {
  4,790 (0.0%)      len = (size_t)len_s;
      .           }
      .         
      .           OPENSSL_STATIC_ASSERT(ASN1_STRING_MAX < INT_MAX, len_will_not_overflow_int);
  4,790 (0.0%)    if (len > ASN1_STRING_MAX) {
      .             OPENSSL_PUT_ERROR(ASN1, ERR_R_OVERFLOW);
      .             return 0;
      .           }
      .         
 11,975 (0.0%)    if (str->length <= (int)len || str->data == NULL) {
  7,185 (0.0%)      unsigned char *c = str->data;
  4,790 (0.0%)      if (c == NULL) {
 16,765 (0.0%)        str->data = OPENSSL_malloc(len + 1);
      .             } else {
      .               str->data = OPENSSL_realloc(c, len + 1);
      .             }
      .         
  9,580 (0.0%)      if (str->data == NULL) {
      .               str->data = c;
      .               return 0;
      .             }
      .           }
  9,580 (0.0%)    str->length = (int)len;
  4,790 (0.0%)    if (data != NULL) {
 16,765 (0.0%)      OPENSSL_memcpy(str->data, data, len);
      .             // Historically, OpenSSL would NUL-terminate most (but not all)
      .             // |ASN1_STRING|s, in case anyone accidentally passed |str->data| into a
      .             // function expecting a C string. We retain this behavior for compatibility,
      .             // but code must not rely on this. See CVE-2021-3712.
 11,975 (0.0%)      str->data[len] = '\0';
      .           }
  2,395 (0.0%)    return 1;
  4,790 (0.0%)  }
      .         
  5,460 (0.0%)  void ASN1_STRING_set0(ASN1_STRING *str, void *data, int len) {
  3,120 (0.0%)    OPENSSL_free(str->data);
  2,340 (0.0%)    str->data = data;
  2,340 (0.0%)    str->length = len;
  2,340 (0.0%)  }
      .         
      .         ASN1_STRING *ASN1_STRING_new(void) {
      .           return (ASN1_STRING_type_new(V_ASN1_OCTET_STRING));
      .         }
      .         
 17,335 (0.0%)  ASN1_STRING *ASN1_STRING_type_new(int type) {
      .           ASN1_STRING *ret;
      .         
 10,401 (0.0%)    ret = (ASN1_STRING *)OPENSSL_zalloc(sizeof(ASN1_STRING));
  6,934 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
 10,401 (0.0%)    ret->type = type;
  3,467 (0.0%)    return ret;
  6,934 (0.0%)  }
      .         
  8,470 (0.0%)  void ASN1_STRING_free(ASN1_STRING *str) {
  3,388 (0.0%)    if (str == NULL) {
    650 (0.0%)      return;
      .           }
  4,176 (0.0%)    OPENSSL_free(str->data);
  4,176 (0.0%)    OPENSSL_free(str);
  3,388 (0.0%)  }
      .         
      .         void ASN1_STRING_clear_free(ASN1_STRING *str) {
      .           ASN1_STRING_free(str);
      .         }
      .         
      .         int ASN1_STRING_cmp(const ASN1_STRING *a, const ASN1_STRING *b) {
      .           // Capture padding bits and implicit truncation in BIT STRINGs.
      .           int a_length = a->length, b_length = b->length;
-- line 361 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_dec.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 121 ----------------------------------------
      .             B_ASN1_GRAPHICSTRING,
      .             B_ASN1_ISO64STRING,
      .             B_ASN1_GENERALSTRING,
      .             B_ASN1_UNIVERSALSTRING,
      .             B_ASN1_UNKNOWN,  // CHARACTER STRING
      .             B_ASN1_BMPSTRING,
      .         };
      .         
  9,520 (0.0%)  unsigned long ASN1_tag2bit(int tag) {
  9,520 (0.0%)    if (tag < 0 || tag > 30) {
      .             return 0;
      .           }
 11,900 (0.0%)    return tag2bit[tag];
  4,760 (0.0%)  }
      .         
      .         // Macro to initialize and invalidate the cache
      .         
      .         // Decode an ASN1 item, this currently behaves just like a standard 'd2i'
      .         // function. 'in' points to a buffer to read the data from, in future we
      .         // will have more advanced versions that can input data a piece at a time and
      .         // this will simply be a special case.
      .         
      .         ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
  1,606 (0.0%)                            const ASN1_ITEM *it) {
    146 (0.0%)    ASN1_VALUE *ptmpval = NULL;
    292 (0.0%)    if (!pval) {
    292 (0.0%)      pval = &ptmpval;
      .           }
      .         
  1,898 (0.0%)    if (asn1_item_ex_d2i(pval, in, len, it, -1, 0, 0, 0) > 0) {
    438 (0.0%)      return *pval;
      .           }
      .           return NULL;
    730 (0.0%)  }
      .         
      .         // Decode an item, taking care of IMPLICIT tagging, if any. If 'opt' set and
      .         // tag mismatch return -1 to handle OPTIONAL
      .         
      .         static int asn1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in,
      .                                     long len, const ASN1_ITEM *it, int tag, int aclass,
146,370 (0.1%)                              char opt, int depth) {
  9,758 (0.0%)    const ASN1_TEMPLATE *tt, *errtt = NULL;
      .           const ASN1_EXTERN_FUNCS *ef;
  9,758 (0.0%)    const unsigned char *p = NULL, *q;
      .           unsigned char oclass;
      .           char cst, isopt;
      .           int i;
      .           int otag;
  9,758 (0.0%)    int ret = 0;
      .           ASN1_VALUE **pchptr;
 29,274 (0.0%)    int combine = aclass & ASN1_TFLG_COMBINE;
  9,758 (0.0%)    aclass &= ~ASN1_TFLG_COMBINE;
 39,032 (0.0%)    if (pval == NULL || it == NULL) {
      .             return 0;
      .           }
      .         
      .           // Bound |len| to comfortably fit in an int. Lengths in this module often
      .           // switch between int and long without overflow checks.
 29,274 (0.0%)    if (len > INT_MAX / 2) {
      .             len = INT_MAX / 2;
      .           }
      .         
 29,274 (0.0%)    if (++depth > ASN1_MAX_CONSTRUCTED_NEST) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_TOO_DEEP);
      .             goto err;
      .           }
      .         
126,854 (0.1%)    switch (it->itype) {
      .             case ASN1_ITYPE_PRIMITIVE:
 22,244 (0.0%)        if (it->templates) {
      .                 // tagging or OPTIONAL is currently illegal on an item template
      .                 // because the flags can't get passed down. In practice this
      .                 // isn't a problem: we include the relevant flags from the item
      .                 // template in the template itself.
  5,344 (0.0%)          if ((tag != -1) || opt) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
      .                   goto err;
      .                 }
 16,032 (0.0%)          return asn1_template_ex_d2i(pval, in, len, it->templates, opt, depth);
      .               }
 54,925 (0.0%)        return asn1_d2i_ex_primitive(pval, in, len, it, tag, aclass, opt);
      .               break;
      .         
      .             case ASN1_ITYPE_MSTRING:
      .               // It never makes sense for multi-strings to have implicit tagging, so
      .               // if tag != -1, then this looks like an error in the template.
  2,672 (0.0%)        if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 goto err;
      .               }
      .         
  4,008 (0.0%)        p = *in;
      .               // Just read in tag and class
 21,376 (0.0%)        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, &p, len, -1, 0, 1);
  2,672 (0.0%)        if (!ret) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
      .         
      .               // Must be UNIVERSAL class
  4,008 (0.0%)        if (oclass != V_ASN1_UNIVERSAL) {
      .                 // If OPTIONAL, assume this is OK
      .                 if (opt) {
      .                   return -1;
      .                 }
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_MSTRING_NOT_UNIVERSAL);
      .                 goto err;
      .               }
      .               // Check tag matches bit map
 13,360 (0.0%)        if (!(ASN1_tag2bit(otag) & it->utype)) {
      .                 // If OPTIONAL, assume this is OK
      .                 if (opt) {
      .                   return -1;
      .                 }
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_MSTRING_WRONG_TAG);
      .                 goto err;
      .               }
 17,368 (0.0%)        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0);
      .         
      .             case ASN1_ITYPE_EXTERN:
      .               // Use new style d2i
    876 (0.0%)        ef = it->funcs;
  4,380 (0.0%)        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, NULL);
      .         
      .             case ASN1_ITYPE_CHOICE: {
      .               // It never makes sense for CHOICE types to have implicit tagging, so if
      .               // tag != -1, then this looks like an error in the template.
      .               if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 goto err;
      .               }
-- line 251 ----------------------------------------
-- line 305 ----------------------------------------
      .               if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL)) {
      .                 goto auxerr;
      .               }
      .               *in = p;
      .               return 1;
      .             }
      .         
      .             case ASN1_ITYPE_SEQUENCE: {
  7,707 (0.0%)        p = *in;
      .         
      .               // If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL
  5,138 (0.0%)        if (tag == -1) {
  2,569 (0.0%)          tag = V_ASN1_SEQUENCE;
  2,569 (0.0%)          aclass = V_ASN1_UNIVERSAL;
      .               }
      .               // Get SEQUENCE length and update len, p
 51,380 (0.0%)        ret = asn1_check_tlen(&len, NULL, NULL, &cst, &p, len, tag, aclass, opt);
  5,138 (0.0%)        if (!ret) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
  5,138 (0.0%)        } else if (ret == -1) {
      .                 return -1;
      .               }
  7,707 (0.0%)        if (!cst) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
      .                 goto err;
      .               }
      .         
 22,127 (0.0%)        if (!*pval && !ASN1_item_ex_new(pval, it)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
      .         
  7,707 (0.0%)        const ASN1_AUX *aux = it->funcs;
 11,152 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
  7,766 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL)) {
      .                 goto auxerr;
      .               }
      .         
      .               // Free up and zero any ADB found
 83,899 (0.1%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
 34,775 (0.0%)          if (tt->flags & ASN1_TFLG_ADB_MASK) {
      .                   const ASN1_TEMPLATE *seqtt;
      .                   ASN1_VALUE **pseqval;
      .                   seqtt = asn1_do_adb(pval, tt, 0);
      .                   if (seqtt == NULL) {
      .                     continue;
      .                   }
      .                   pseqval = asn1_get_field_ptr(pval, seqtt);
      .                   ASN1_template_free(pseqval, seqtt);
      .                 }
      .               }
      .         
      .               // Get each field entry
 85,748 (0.1%)        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
      .                 const ASN1_TEMPLATE *seqtt;
      .                 ASN1_VALUE **pseqval;
 48,685 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
 13,910 (0.0%)          if (seqtt == NULL) {
      .                   goto err;
      .                 }
 41,730 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
      .                 // Have we ran out of data?
 20,865 (0.0%)          if (!len) {
     80 (0.0%)            break;
      .                 }
 13,750 (0.0%)          q = p;
      .                 // This determines the OPTIONAL flag value. The field cannot be
      .                 // omitted if it is the last of a SEQUENCE and there is still
      .                 // data to be read. This isn't strictly necessary but it
      .                 // increases efficiency in some cases.
 48,125 (0.0%)          if (i == (it->tcount - 1)) {
  4,978 (0.0%)            isopt = 0;
      .                 } else {
 26,316 (0.0%)            isopt = (seqtt->flags & ASN1_TFLG_OPTIONAL) != 0;
      .                 }
      .                 // attempt to read in field, allowing each to be OPTIONAL
      .         
 75,625 (0.1%)          ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, depth);
 13,750 (0.0%)          if (!ret) {
      .                   errtt = seqtt;
      .                   goto err;
 13,750 (0.0%)          } else if (ret == -1) {
      .                   // OPTIONAL component absent. Free and zero the field.
  2,585 (0.0%)            ASN1_template_free(pseqval, seqtt);
    517 (0.0%)            continue;
      .                 }
      .                 // Update length
 31,790 (0.0%)          len -= p - q;
      .               }
      .         
      .               // Check all data read
  7,707 (0.0%)        if (len) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
      .                 goto err;
      .               }
      .         
      .               // If we get here we've got no more data in the SEQUENCE, however we
      .               // may not have read all fields so check all remaining are OPTIONAL
      .               // and clear any that are.
 16,054 (0.0%)        for (; i < it->tcount; tt++, i++) {
      .                 const ASN1_TEMPLATE *seqtt;
    560 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
    160 (0.0%)          if (seqtt == NULL) {
      .                   goto err;
      .                 }
    400 (0.0%)          if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
      .                   ASN1_VALUE **pseqval;
    480 (0.0%)            pseqval = asn1_get_field_ptr(pval, seqtt);
    480 (0.0%)            ASN1_template_free(pseqval, seqtt);
      .                 } else {
      .                   errtt = seqtt;
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_FIELD_MISSING);
      .                   goto err;
      .                 }
      .               }
      .               // Save encoding
 38,535 (0.0%)        if (!asn1_enc_save(pval, *in, p - *in, it)) {
      .                 goto auxerr;
      .               }
  7,766 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL)) {
      .                 goto auxerr;
      .               }
  7,707 (0.0%)        *in = p;
  5,138 (0.0%)        return 1;
      .             }
      .         
      .             default:
      .               return 0;
      .           }
      .         auxerr:
      .           OPENSSL_PUT_ERROR(ASN1, ASN1_R_AUX_ERROR);
      .         err:
-- line 437 ----------------------------------------
-- line 439 ----------------------------------------
      .             ASN1_item_ex_free(pval, it);
      .           }
      .           if (errtt) {
      .             ERR_add_error_data(4, "Field=", errtt->field_name, ", Type=", it->sname);
      .           } else {
      .             ERR_add_error_data(2, "Type=", it->sname);
      .           }
      .           return 0;
 48,790 (0.0%)  }
      .         
      .         int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
      .                              const ASN1_ITEM *it, int tag, int aclass, char opt,
  3,504 (0.0%)                       ASN1_TLC *ctx) {
  3,504 (0.0%)    return asn1_item_ex_d2i(pval, in, len, it, tag, aclass, opt, 0);
    584 (0.0%)  }
      .         
      .         // Templates are handled with two separate functions. One handles any
      .         // EXPLICIT tag and the other handles the rest.
      .         
      .         static int asn1_template_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                         long inlen, const ASN1_TEMPLATE *tt, char opt,
114,954 (0.1%)                                  int depth) {
      .           int aclass;
      .           int ret;
      .           long len;
      .           const unsigned char *p, *q;
 16,422 (0.0%)    if (!val) {
      .             return 0;
      .           }
 24,633 (0.0%)    uint32_t flags = tt->flags;
 24,633 (0.0%)    aclass = flags & ASN1_TFLG_TAG_CLASS;
      .         
 24,633 (0.0%)    p = *in;
      .         
      .           // Check if EXPLICIT tag expected
 32,844 (0.0%)    if (flags & ASN1_TFLG_EXPTAG) {
      .             char cst;
      .             // Need to work out amount of data available to the inner content and
      .             // where it starts: so read in EXPLICIT header to get the info.
  6,132 (0.0%)      ret = asn1_check_tlen(&len, NULL, NULL, &cst, &p, inlen, tt->tag, aclass,
      .                                   opt);
    584 (0.0%)      q = p;
    584 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
    584 (0.0%)      } else if (ret == -1) {
      .               return -1;
      .             }
    876 (0.0%)      if (!cst) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);
      .               return 0;
      .             }
      .             // We've found the field so it can't be OPTIONAL now
  2,920 (0.0%)      ret = asn1_template_noexp_d2i(val, &p, len, tt, 0, depth);
    584 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
      .             }
      .             // We read the field in OK so update length
  1,460 (0.0%)      len -= p - q;
      .             // Check for trailing data.
    876 (0.0%)      if (len) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_EXPLICIT_LENGTH_MISMATCH);
      .               goto err;
      .             }
      .           } else {
 87,109 (0.1%)      return asn1_template_noexp_d2i(val, in, inlen, tt, opt, depth);
      .           }
      .         
    876 (0.0%)    *in = p;
    292 (0.0%)    return 1;
      .         
      .         err:
      .           ASN1_template_free(val, tt);
      .           return 0;
 41,055 (0.0%)  }
      .         
      .         static int asn1_template_noexp_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                            long len, const ASN1_TEMPLATE *tt, char opt,
114,954 (0.1%)                                     int depth) {
      .           int aclass;
      .           int ret;
      .           const unsigned char *p;
 16,422 (0.0%)    if (!val) {
      .             return 0;
      .           }
 24,633 (0.0%)    uint32_t flags = tt->flags;
 24,633 (0.0%)    aclass = flags & ASN1_TFLG_TAG_CLASS;
      .         
 24,633 (0.0%)    p = *in;
      .         
 32,844 (0.0%)    if (flags & ASN1_TFLG_SK_MASK) {
      .             // SET OF, SEQUENCE OF
      .             int sktag, skaclass;
      .             // First work out expected inner tag value
  5,928 (0.0%)      if (flags & ASN1_TFLG_IMPTAG) {
      .               sktag = tt->tag;
      .               skaclass = aclass;
      .             } else {
  1,482 (0.0%)        skaclass = V_ASN1_UNIVERSAL;
  5,928 (0.0%)        if (flags & ASN1_TFLG_SET_OF) {
  2,088 (0.0%)          sktag = V_ASN1_SET;
      .               } else {
    438 (0.0%)          sktag = V_ASN1_SEQUENCE;
      .               }
      .             }
      .             // Get the tag
      .             ret =
 28,158 (0.0%)          asn1_check_tlen(&len, NULL, NULL, NULL, &p, len, sktag, skaclass, opt);
  2,964 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
  2,964 (0.0%)      } else if (ret == -1) {
      .               return -1;
      .             }
  5,928 (0.0%)      if (!*val) {
  5,928 (0.0%)        *val = (ASN1_VALUE *)sk_ASN1_VALUE_new_null();
      .             } else {
      .               // We've got a valid STACK: free up any items present
      .               STACK_OF(ASN1_VALUE) *sktmp = (STACK_OF(ASN1_VALUE) *)*val;
      .               ASN1_VALUE *vtmp;
      .               while (sk_ASN1_VALUE_num(sktmp) > 0) {
      .                 vtmp = sk_ASN1_VALUE_pop(sktmp);
      .                 ASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item));
      .               }
      .             }
      .         
  5,928 (0.0%)      if (!*val) {
      .               goto err;
      .             }
      .         
      .             // Read as many items as we can
 15,183 (0.0%)      while (len > 0) {
      .               ASN1_VALUE *skfield;
  5,182 (0.0%)        const unsigned char *q = p;
  2,591 (0.0%)        skfield = NULL;
 38,865 (0.0%)        if (!asn1_item_ex_d2i(&skfield, &p, len, ASN1_ITEM_ptr(tt->item), -1, 0,
      .                                     0, depth)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .                 goto err;
      .               }
 12,955 (0.0%)        len -= p - q;
 20,728 (0.0%)        if (!sk_ASN1_VALUE_push((STACK_OF(ASN1_VALUE) *)*val, skfield)) {
      .                 ASN1_item_ex_free(&skfield, ASN1_ITEM_ptr(tt->item));
      .                 goto err;
      .               }
      .             }
 26,916 (0.0%)    } else if (flags & ASN1_TFLG_IMPTAG) {
      .             // IMPLICIT tagging
  4,964 (0.0%)      ret = asn1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), tt->tag,
      .                                    aclass, opt, depth);
    584 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               goto err;
    584 (0.0%)      } else if (ret == -1) {
    584 (0.0%)        return -1;
      .             }
      .           } else {
      .             // Nothing special
102,992 (0.1%)      ret = asn1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), -1,
 12,874 (0.0%)                             tt->flags & ASN1_TFLG_COMBINE, opt, depth);
 12,874 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               goto err;
 12,874 (0.0%)      } else if (ret == -1) {
    450 (0.0%)        return -1;
      .             }
      .           }
      .         
 23,082 (0.0%)    *in = p;
 15,388 (0.0%)    return 1;
      .         
      .         err:
      .           ASN1_template_free(val, tt);
      .           return 0;
 41,055 (0.0%)  }
      .         
      .         static int asn1_d2i_ex_primitive(ASN1_VALUE **pval, const unsigned char **in,
      .                                          long inlen, const ASN1_ITEM *it, int tag,
 83,415 (0.1%)                                   int aclass, char opt) {
  5,561 (0.0%)    int ret = 0, utype;
      .           long plen;
      .           char cst;
      .           const unsigned char *p;
  5,561 (0.0%)    const unsigned char *cont = NULL;
      .           long len;
 11,122 (0.0%)    if (!pval) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_NULL);
      .             return 0;  // Should never happen
      .           }
      .         
 22,244 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
  2,672 (0.0%)      utype = tag;
  2,672 (0.0%)      tag = -1;
      .           } else {
 12,675 (0.0%)      utype = it->utype;
      .           }
      .         
 16,683 (0.0%)    if (utype == V_ASN1_ANY) {
      .             // If type is ANY need to figure out type from tag
      .             unsigned char oclass;
    716 (0.0%)      if (tag >= 0) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_TAGGED_ANY);
      .               return 0;
      .             }
    716 (0.0%)      if (opt) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OPTIONAL_ANY);
      .               return 0;
      .             }
  1,074 (0.0%)      p = *in;
  5,728 (0.0%)      ret = asn1_check_tlen(NULL, &utype, &oclass, NULL, &p, inlen, -1, 0, 0);
    716 (0.0%)      if (!ret) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .               return 0;
      .             }
  1,074 (0.0%)      if (oclass != V_ASN1_UNIVERSAL) {
      .               utype = V_ASN1_OTHER;
      .             }
      .           }
 11,122 (0.0%)    if (tag == -1) {
 10,538 (0.0%)      tag = utype;
  5,269 (0.0%)      aclass = V_ASN1_UNIVERSAL;
      .           }
 16,683 (0.0%)    p = *in;
      .           // Check header
111,220 (0.1%)    ret = asn1_check_tlen(&plen, NULL, NULL, &cst, &p, inlen, tag, aclass, opt);
 11,122 (0.0%)    if (!ret) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_NESTED_ASN1_ERROR);
      .             return 0;
 11,122 (0.0%)    } else if (ret == -1) {
  1,034 (0.0%)      return -1;
      .           }
  5,044 (0.0%)    ret = 0;
      .           // SEQUENCE, SET and "OTHER" are left in encoded form
 40,352 (0.0%)    if ((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||
  5,044 (0.0%)        (utype == V_ASN1_OTHER)) {
      .             // SEQUENCE and SET must be constructed
      .             if (utype != V_ASN1_OTHER && !cst) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_TYPE_NOT_CONSTRUCTED);
      .               return 0;
      .             }
      .         
      .             cont = *in;
      .             len = p - cont + plen;
      .             p += plen;
 15,132 (0.0%)    } else if (cst) {
      .             // This parser historically supported BER constructed strings. We no
      .             // longer do and will gradually tighten this parser into a DER
      .             // parser. BER types should use |CBS_asn1_ber_to_der|.
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_TYPE_NOT_PRIMITIVE);
      .             return 0;
      .           } else {
 10,088 (0.0%)      cont = p;
 10,088 (0.0%)      len = plen;
 20,176 (0.0%)      p += plen;
      .           }
      .         
      .           // We now have content length and type: translate into a structure
 50,440 (0.0%)    if (!asn1_ex_c2i(pval, cont, len, utype, it)) {
      .             goto err;
      .           }
      .         
 15,132 (0.0%)    *in = p;
 10,088 (0.0%)    ret = 1;
      .         err:
  5,044 (0.0%)    return ret;
 27,805 (0.0%)  }
      .         
      .         // Translate ASN1 content octets into a structure
      .         
      .         static int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, long len,
 60,528 (0.0%)                         int utype, const ASN1_ITEM *it) {
  5,044 (0.0%)    ASN1_VALUE **opval = NULL;
      .           ASN1_STRING *stmp;
  5,044 (0.0%)    ASN1_TYPE *typ = NULL;
  5,044 (0.0%)    int ret = 0;
      .           ASN1_INTEGER **tint;
      .         
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of callbacks.
 20,176 (0.0%)    assert(it->funcs == NULL);
      .         
      .           // If ANY type clear type and set pointer to internal value
 20,176 (0.0%)    if (it->utype == V_ASN1_ANY) {
  1,432 (0.0%)      if (!*pval) {
    716 (0.0%)        typ = ASN1_TYPE_new();
    716 (0.0%)        if (typ == NULL) {
      .                 goto err;
      .               }
  1,432 (0.0%)        *pval = (ASN1_VALUE *)typ;
      .             } else {
      .               typ = (ASN1_TYPE *)*pval;
      .             }
      .         
  1,432 (0.0%)      if (utype != typ->type) {
  2,148 (0.0%)        ASN1_TYPE_set(typ, utype, NULL);
      .             }
    716 (0.0%)      opval = pval;
  1,074 (0.0%)      pval = &typ->value.asn1_value;
      .           }
 39,752 (0.0%)    switch (utype) {
      .             case V_ASN1_OBJECT:
 16,200 (0.0%)        if (!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, &cont, len)) {
      .                 goto err;
      .               }
  4,050 (0.0%)        break;
      .         
      .             case V_ASN1_NULL:
    636 (0.0%)        if (len) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_NULL_IS_WRONG_LENGTH);
      .                 goto err;
      .               }
    636 (0.0%)        *pval = (ASN1_VALUE *)1;
    318 (0.0%)        break;
      .         
      .             case V_ASN1_BOOLEAN:
    556 (0.0%)        if (len != 1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BOOLEAN_IS_WRONG_LENGTH);
      .                 goto err;
      .               } else {
      .                 ASN1_BOOLEAN *tbool;
    556 (0.0%)          tbool = (ASN1_BOOLEAN *)pval;
  1,390 (0.0%)          *tbool = *cont;
      .               }
    278 (0.0%)        break;
      .         
      .             case V_ASN1_BIT_STRING:
  2,336 (0.0%)        if (!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, &cont, len)) {
      .                 goto err;
      .               }
    584 (0.0%)        break;
      .         
      .             case V_ASN1_INTEGER:
      .             case V_ASN1_ENUMERATED:
    584 (0.0%)        tint = (ASN1_INTEGER **)pval;
  2,336 (0.0%)        if (!c2i_ASN1_INTEGER(tint, &cont, len)) {
      .                 goto err;
      .               }
      .               // Fixup type to match the expected form
  2,628 (0.0%)        (*tint)->type = utype | ((*tint)->type & V_ASN1_NEG);
    292 (0.0%)        break;
      .         
      .             case V_ASN1_OCTET_STRING:
      .             case V_ASN1_NUMERICSTRING:
      .             case V_ASN1_PRINTABLESTRING:
      .             case V_ASN1_T61STRING:
      .             case V_ASN1_VIDEOTEXSTRING:
      .             case V_ASN1_IA5STRING:
      .             case V_ASN1_UTCTIME:
-- line 787 ----------------------------------------
-- line 791 ----------------------------------------
      .             case V_ASN1_GENERALSTRING:
      .             case V_ASN1_UNIVERSALSTRING:
      .             case V_ASN1_BMPSTRING:
      .             case V_ASN1_UTF8STRING:
      .             case V_ASN1_OTHER:
      .             case V_ASN1_SET:
      .             case V_ASN1_SEQUENCE:
      .             default:
  3,678 (0.0%)        if (utype == V_ASN1_BMPSTRING && (len & 1)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
      .                 goto err;
      .               }
  3,678 (0.0%)        if (utype == V_ASN1_UNIVERSALSTRING && (len & 3)) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
      .                 goto err;
      .               }
  3,678 (0.0%)        if (utype == V_ASN1_UTCTIME) {
      .                 CBS cbs;
  1,740 (0.0%)          CBS_init(&cbs, cont, (size_t)len);
  2,030 (0.0%)          if (!CBS_parse_utc_time(&cbs, NULL, /*allow_timezone_offset=*/1)) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_TIME_FORMAT);
      .                   goto err;
      .                 }
      .               }
  3,678 (0.0%)        if (utype == V_ASN1_GENERALIZEDTIME) {
      .                 CBS cbs;
     12 (0.0%)          CBS_init(&cbs, cont, (size_t)len);
     14 (0.0%)          if (!CBS_parse_generalized_time(&cbs, NULL,
      .                                                 /*allow_timezone_offset=*/0)) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_INVALID_TIME_FORMAT);
      .                   goto err;
      .                 }
      .               }
      .               // All based on ASN1_STRING and handled the same
  7,356 (0.0%)        if (!*pval) {
      .                 stmp = ASN1_STRING_type_new(utype);
      .                 if (!stmp) {
      .                   goto err;
      .                 }
      .                 *pval = (ASN1_VALUE *)stmp;
      .               } else {
  5,517 (0.0%)          stmp = (ASN1_STRING *)*pval;
  5,517 (0.0%)          stmp->type = utype;
      .               }
 14,712 (0.0%)        if (!ASN1_STRING_set(stmp, cont, len)) {
      .                 ASN1_STRING_free(stmp);
      .                 *pval = NULL;
      .                 goto err;
      .               }
  1,839 (0.0%)        break;
      .           }
      .           // If ASN1_ANY and NULL type fix up value
 10,804 (0.0%)    if (typ && (utype == V_ASN1_NULL)) {
    636 (0.0%)      typ->value.ptr = NULL;
      .           }
      .         
 10,088 (0.0%)    ret = 1;
      .         err:
 10,088 (0.0%)    if (!ret) {
      .             ASN1_TYPE_free(typ);
      .             if (opval) {
      .               *opval = NULL;
      .             }
      .           }
  5,044 (0.0%)    return ret;
 25,220 (0.0%)  }
      .         
      .         // Check an ASN1 tag and length: a bit like ASN1_get_object but it
      .         // checks the expected tag.
      .         
      .         static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,
      .                                    char *cst, const unsigned char **in, long len,
173,970 (0.1%)                             int exptag, int expclass, char opt) {
      .           int i;
      .           int ptag, pclass;
      .           long plen;
      .           const unsigned char *p;
 34,794 (0.0%)    p = *in;
      .         
104,382 (0.1%)    i = ASN1_get_object(&p, &plen, &ptag, &pclass, len);
 46,392 (0.0%)    if (i & 0x80) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_OBJECT_HEADER);
      .             return 0;
      .           }
 23,196 (0.0%)    if (exptag >= 0) {
 57,873 (0.0%)      if ((exptag != ptag) || (expclass != pclass)) {
      .               // If type is OPTIONAL, not an error: indicate missing type.
  1,034 (0.0%)        if (opt) {
  1,034 (0.0%)          return -1;
      .               }
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TAG);
      .               return 0;
      .             }
      .           }
      .         
 22,162 (0.0%)    if (cst) {
 39,525 (0.0%)      *cst = i & V_ASN1_CONSTRUCTED;
      .           }
      .         
 22,162 (0.0%)    if (olen) {
 28,161 (0.0%)      *olen = plen;
      .           }
      .         
 22,162 (0.0%)    if (oclass) {
  6,776 (0.0%)      *oclass = pclass;
      .           }
      .         
 22,162 (0.0%)    if (otag) {
  5,082 (0.0%)      *otag = ptag;
      .           }
      .         
 33,243 (0.0%)    *in = p;
 11,081 (0.0%)    return 1;
 57,990 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_enc.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 78 ----------------------------------------
      .         static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
      .                                     int skcontlen, const ASN1_ITEM *item, int do_sort);
      .         static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
      .                                         const ASN1_TEMPLATE *tt, int tag, int aclass,
      .                                         int optional);
      .         
      .         // Top level i2d equivalents
      .         
  1,460 (0.0%)  int ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it) {
    876 (0.0%)    if (out && !*out) {
      .             unsigned char *p, *buf;
  1,168 (0.0%)      int len = ASN1_item_ex_i2d(&val, NULL, it, /*tag=*/-1, /*aclass=*/0);
    292 (0.0%)      if (len <= 0) {
      .               return len;
      .             }
    730 (0.0%)      buf = OPENSSL_malloc(len);
    292 (0.0%)      if (!buf) {
      .               return -1;
      .             }
    292 (0.0%)      p = buf;
  1,168 (0.0%)      int len2 = ASN1_item_ex_i2d(&val, &p, it, /*tag=*/-1, /*aclass=*/0);
    292 (0.0%)      if (len2 <= 0) {
      .               OPENSSL_free(buf);
      .               return len2;
      .             }
    438 (0.0%)      assert(len == len2);
    438 (0.0%)      *out = buf;
    292 (0.0%)      return len;
      .           }
      .         
      .           return ASN1_item_ex_i2d(&val, out, it, /*tag=*/-1, /*aclass=*/0);
    730 (0.0%)  }
      .         
      .         // Encode an item, taking care of IMPLICIT tagging (if any). This function
      .         // performs the normal item handling: it can be used in external types.
      .         
      .         int ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
 49,608 (0.0%)                       const ASN1_ITEM *it, int tag, int aclass) {
 55,120 (0.0%)    int ret = asn1_item_ex_i2d_opt(pval, out, it, tag, aclass, /*optional=*/0);
 11,024 (0.0%)    assert(ret != 0);
  5,512 (0.0%)    return ret;
 11,024 (0.0%)  }
      .         
      .         // asn1_item_ex_i2d_opt behaves like |ASN1_item_ex_i2d| but, if |optional| is
      .         // non-zero and |*pval| is omitted, it returns zero and writes no bytes.
      .         int asn1_item_ex_i2d_opt(ASN1_VALUE **pval, unsigned char **out,
      .                                  const ASN1_ITEM *it, int tag, int aclass,
206,804 (0.1%)                           int optional) {
 15,908 (0.0%)    const ASN1_TEMPLATE *tt = NULL;
      .           int i, seqcontlen, seqlen;
      .         
      .           // Historically, |aclass| was repurposed to pass additional flags into the
      .           // encoding process.
 63,632 (0.0%)    assert((aclass & ASN1_TFLG_TAG_CLASS) == aclass);
      .           // If not overridding the tag, |aclass| is ignored and should be zero.
 63,632 (0.0%)    assert(tag != -1 || aclass == 0);
      .         
      .           // All fields are pointers, except for boolean |ASN1_ITYPE_PRIMITIVE|s.
      .           // Optional primitives are handled later.
 95,784 (0.1%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) {
      .             if (optional) {
      .               return 0;
      .             }
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
      .             return -1;
      .           }
      .         
206,804 (0.1%)    switch (it->itype) {
      .             case ASN1_ITYPE_PRIMITIVE:
 31,480 (0.0%)        if (it->templates) {
      .                 // This is an |ASN1_ITEM_TEMPLATE|.
 12,528 (0.0%)          if (it->templates->flags & ASN1_TFLG_OPTIONAL) {
      .                   OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                   return -1;
      .                 }
 25,056 (0.0%)          return asn1_template_ex_i2d(pval, out, it->templates, tag, aclass,
      .                                             optional);
      .               }
 63,602 (0.0%)        return asn1_i2d_ex_primitive(pval, out, it, tag, aclass, optional);
      .         
      .             case ASN1_ITYPE_MSTRING:
      .               // It never makes sense for multi-strings to have implicit tagging, so
      .               // if tag != -1, then this looks like an error in the template.
  8,352 (0.0%)        if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 return -1;
      .               }
 41,760 (0.0%)        return asn1_i2d_ex_primitive(pval, out, it, -1, 0, optional);
      .         
      .             case ASN1_ITYPE_CHOICE: {
      .               // It never makes sense for CHOICE types to have implicit tagging, so if
      .               // tag != -1, then this looks like an error in the template.
      .               if (tag != -1) {
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .                 return -1;
      .               }
-- line 173 ----------------------------------------
-- line 195 ----------------------------------------
      .                 // must be pointers.
      .                 OPENSSL_PUT_ERROR(ASN1, ERR_R_INTERNAL_ERROR);
      .                 return -1;
      .               }
      .               return ret;
      .             }
      .         
      .             case ASN1_ITYPE_SEQUENCE: {
 27,034 (0.0%)        i = asn1_enc_restore(&seqcontlen, out, pval, it);
      .               // An error occurred
  7,724 (0.0%)        if (i < 0) {
      .                 return -1;
      .               }
      .               // We have a valid cached encoding...
  7,724 (0.0%)        if (i > 0) {
      .                 return seqcontlen;
      .               }
      .               // Otherwise carry on
  3,862 (0.0%)        seqcontlen = 0;
      .               // If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL
  7,724 (0.0%)        if (tag == -1) {
  3,862 (0.0%)          tag = V_ASN1_SEQUENCE;
  3,862 (0.0%)          aclass = V_ASN1_UNIVERSAL;
      .               }
      .               // First work out sequence content length
104,274 (0.1%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
      .                 const ASN1_TEMPLATE *seqtt;
      .                 ASN1_VALUE **pseqval;
      .                 int tmplen;
 54,068 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
 15,448 (0.0%)          if (!seqtt) {
      .                   return -1;
      .                 }
 46,344 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
      .                 tmplen =
 69,516 (0.1%)              asn1_template_ex_i2d(pseqval, NULL, seqtt, -1, 0, /*optional=*/0);
 54,068 (0.0%)          if (tmplen == -1 || (tmplen > INT_MAX - seqcontlen)) {
      .                   return -1;
      .                 }
 30,896 (0.0%)          seqcontlen += tmplen;
      .               }
      .         
 23,172 (0.0%)        seqlen = ASN1_object_size(/*constructed=*/1, seqcontlen, tag);
 10,396 (0.0%)        if (!out || seqlen == -1) {
  5,052 (0.0%)          return seqlen;
      .               }
      .               // Output SEQUENCE header
 10,688 (0.0%)        ASN1_put_object(out, /*constructed=*/1, seqcontlen, tag, aclass);
 36,072 (0.0%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
      .                 const ASN1_TEMPLATE *seqtt;
      .                 ASN1_VALUE **pseqval;
 18,704 (0.0%)          seqtt = asn1_do_adb(pval, tt, 1);
  5,344 (0.0%)          if (!seqtt) {
      .                   return -1;
      .                 }
 16,032 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
 26,720 (0.0%)          if (asn1_template_ex_i2d(pseqval, out, seqtt, -1, 0, /*optional=*/0) <
      .                     0) {
      .                   return -1;
      .                 }
      .               }
  2,672 (0.0%)        return seqlen;
      .             }
      .         
      .             default:
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .               return -1;
      .           }
 79,540 (0.1%)  }
      .         
      .         // asn1_template_ex_i2d behaves like |asn1_item_ex_i2d_opt| but uses an
      .         // |ASN1_TEMPLATE| instead of an |ASN1_ITEM|. An |ASN1_TEMPLATE| wraps an
      .         // |ASN1_ITEM| with modifiers such as tagging, SEQUENCE or SET, etc.
      .         static int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,
      .                                         const ASN1_TEMPLATE *tt, int tag, int iclass,
162,292 (0.1%)                                  int optional) {
      .           int i, ret, ttag, tclass;
      .           size_t j;
 37,452 (0.0%)    uint32_t flags = tt->flags;
      .         
      .           // Historically, |iclass| was repurposed to pass additional flags into the
      .           // encoding process.
 49,936 (0.0%)    assert((iclass & ASN1_TFLG_TAG_CLASS) == iclass);
      .           // If not overridding the tag, |iclass| is ignored and should be zero.
 49,936 (0.0%)    assert(tag != -1 || iclass == 0);
      .         
      .           // Work out tag and class to use: tagging may come either from the
      .           // template or the arguments, not both because this would create
      .           // ambiguity.
 49,936 (0.0%)    if (flags & ASN1_TFLG_TAG_MASK) {
      .             // Error if argument and template tagging
      .             if (tag != -1) {
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_BAD_TEMPLATE);
      .               return -1;
      .             }
      .             // Get tagging from template
      .             ttag = tt->tag;
      .             tclass = flags & ASN1_TFLG_TAG_CLASS;
 24,968 (0.0%)    } else if (tag != -1) {
      .             // No template tagging, get from arguments
      .             ttag = tag;
      .             tclass = iclass & ASN1_TFLG_TAG_CLASS;
      .           } else {
 12,484 (0.0%)      ttag = -1;
 12,484 (0.0%)      tclass = 0;
      .           }
      .         
      .           // The template may itself by marked as optional, or this may be the template
      .           // of an |ASN1_ITEM_TEMPLATE| type which was contained inside an outer
      .           // optional template. (They cannot both be true because the
      .           // |ASN1_ITEM_TEMPLATE| codepath rejects optional templates.)
 24,968 (0.0%)    assert(!optional || (flags & ASN1_TFLG_OPTIONAL) == 0);
100,456 (0.1%)    optional = optional || (flags & ASN1_TFLG_OPTIONAL) != 0;
      .         
      .           // At this point 'ttag' contains the outer tag to use, and 'tclass' is the
      .           // class.
      .         
 49,936 (0.0%)    if (flags & ASN1_TFLG_SK_MASK) {
      .             // SET OF, SEQUENCE OF
  6,264 (0.0%)      STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;
      .             int isset, sktag, skaclass;
      .             int skcontlen, sklen;
      .             ASN1_VALUE *skitem;
      .         
  8,352 (0.0%)      if (!*pval) {
      .               if (optional) {
      .                 return 0;
      .               }
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
      .               return -1;
      .             }
      .         
  8,352 (0.0%)      if (flags & ASN1_TFLG_SET_OF) {
  2,088 (0.0%)        isset = 1;
      .               // Historically, types with both bits set were mutated when
      .               // serialized to apply the sort. We no longer support this.
  8,352 (0.0%)        assert((flags & ASN1_TFLG_SEQUENCE_OF) == 0);
      .             } else {
      .               isset = 0;
      .             }
      .         
      .             // Work out inner tag value: if EXPLICIT or no tagging use underlying
      .             // type.
  4,176 (0.0%)      if ((ttag != -1) && !(flags & ASN1_TFLG_EXPTAG)) {
      .               sktag = ttag;
      .               skaclass = tclass;
      .             } else {
  2,088 (0.0%)        skaclass = V_ASN1_UNIVERSAL;
  4,176 (0.0%)        if (isset) {
  4,176 (0.0%)          sktag = V_ASN1_SET;
      .               } else {
      .                 sktag = V_ASN1_SEQUENCE;
      .               }
      .             }
      .         
      .             // Determine total length of items
  2,088 (0.0%)      skcontlen = 0;
 27,144 (0.0%)      for (j = 0; j < sk_ASN1_VALUE_num(sk); j++) {
      .               int tmplen;
 12,528 (0.0%)        skitem = sk_ASN1_VALUE_value(sk, j);
 18,792 (0.0%)        tmplen = ASN1_item_ex_i2d(&skitem, NULL, ASN1_ITEM_ptr(tt->item), -1, 0);
 12,528 (0.0%)        if (tmplen == -1 || (skcontlen > INT_MAX - tmplen)) {
      .                 return -1;
      .               }
  4,176 (0.0%)        skcontlen += tmplen;
      .             }
 12,528 (0.0%)      sklen = ASN1_object_size(/*constructed=*/1, skcontlen, sktag);
  4,176 (0.0%)      if (sklen == -1) {
      .               return -1;
      .             }
      .             // If EXPLICIT need length of surrounding tag
  8,352 (0.0%)      if (flags & ASN1_TFLG_EXPTAG) {
      .               ret = ASN1_object_size(/*constructed=*/1, sklen, ttag);
      .             } else {
  4,176 (0.0%)        ret = sklen;
      .             }
      .         
  6,264 (0.0%)      if (!out || ret == -1) {
  2,088 (0.0%)        return ret;
      .             }
      .         
      .             // Now encode this lot...
      .             // EXPLICIT tag
  4,176 (0.0%)      if (flags & ASN1_TFLG_EXPTAG) {
      .               ASN1_put_object(out, /*constructed=*/1, sklen, ttag, tclass);
      .             }
      .             // SET or SEQUENCE and IMPLICIT tag
  8,352 (0.0%)      ASN1_put_object(out, /*constructed=*/1, skcontlen, sktag, skaclass);
      .             // And the stuff itself
 11,484 (0.0%)      if (!asn1_set_seq_out(sk, out, skcontlen, ASN1_ITEM_ptr(tt->item), isset)) {
      .               return -1;
      .             }
  2,088 (0.0%)      return ret;
      .           }
      .         
 41,584 (0.0%)    if (flags & ASN1_TFLG_EXPTAG) {
      .             // EXPLICIT tagging
      .             // Find length of tagged item
      .             i = asn1_item_ex_i2d_opt(pval, NULL, ASN1_ITEM_ptr(tt->item), -1, 0,
      .                                      optional);
      .             if (i <= 0) {
      .               return i;
      .             }
      .             // Find length of EXPLICIT tag
-- line 398 ----------------------------------------
-- line 403 ----------------------------------------
      .               if (ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item), -1, 0) < 0) {
      .                 return -1;
      .               }
      .             }
      .             return ret;
      .           }
      .         
      .           // Either normal or IMPLICIT tagging
114,356 (0.1%)    return asn1_item_ex_i2d_opt(pval, out, ASN1_ITEM_ptr(tt->item), ttag, tclass,
      .                                       optional);
 62,420 (0.0%)  }
      .         
      .         // Temporary structure used to hold DER encoding of items for SET OF
      .         
      .         typedef struct {
      .           unsigned char *data;
      .           int length;
      .         } DER_ENC;
      .         
-- line 421 ----------------------------------------
-- line 431 ----------------------------------------
      .         }
      .         
      .         // asn1_set_seq_out writes |sk| to |out| under the i2d output convention,
      .         // excluding the tag and length. It returns one on success and zero on error.
      .         // |skcontlen| must be the total encoded size. If |do_sort| is non-zero, the
      .         // elements are sorted for a SET OF type. Each element of |sk| has type
      .         // |item|.
      .         static int asn1_set_seq_out(STACK_OF(ASN1_VALUE) *sk, unsigned char **out,
 13,572 (0.0%)                              int skcontlen, const ASN1_ITEM *item, int do_sort) {
      .           // No need to sort if there are fewer than two items.
  7,308 (0.0%)    if (!do_sort || sk_ASN1_VALUE_num(sk) < 2) {
 13,572 (0.0%)      for (size_t i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
  6,264 (0.0%)        ASN1_VALUE *skitem = sk_ASN1_VALUE_value(sk, i);
  9,396 (0.0%)        if (ASN1_item_ex_i2d(&skitem, out, item, -1, 0) < 0) {
      .                 return 0;
      .               }
      .             }
  2,088 (0.0%)      return 1;
      .           }
      .         
      .           int ret = 0;
      .           unsigned char *const buf = OPENSSL_malloc(skcontlen);
      .           DER_ENC *encoded = OPENSSL_calloc(sk_ASN1_VALUE_num(sk), sizeof(*encoded));
      .           if (encoded == NULL || buf == NULL) {
      .             goto err;
      .           }
-- line 456 ----------------------------------------
-- line 478 ----------------------------------------
      .           *out = p;
      .         
      .           ret = 1;
      .         
      .         err:
      .           OPENSSL_free(encoded);
      .           OPENSSL_free(buf);
      .           return ret;
  6,264 (0.0%)  }
      .         
      .         // asn1_i2d_ex_primitive behaves like |ASN1_item_ex_i2d| but |item| must be a
      .         // a PRIMITIVE or MSTRING type that is not an |ASN1_ITEM_TEMPLATE|.
      .         static int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out,
      .                                          const ASN1_ITEM *it, int tag, int aclass,
129,454 (0.1%)                                   int optional) {
      .           // Get length of content octets and maybe find out the underlying type.
      .           int omit;
 29,874 (0.0%)    int utype = it->utype;
 89,622 (0.1%)    int len = asn1_ex_i2c(pval, NULL, &omit, &utype, it);
 19,916 (0.0%)    if (len < 0) {
      .             return -1;
      .           }
 29,874 (0.0%)    if (omit) {
      .             if (optional) {
      .               return 0;
      .             }
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_MISSING_VALUE);
      .             return -1;
      .           }
      .         
      .           // If SEQUENCE, SET or OTHER then header is included in pseudo content
      .           // octets so don't include tag+length. We need to check here because the
      .           // call to asn1_ex_i2c() could change utype.
  9,958 (0.0%)    int usetag =
109,538 (0.1%)        utype != V_ASN1_SEQUENCE && utype != V_ASN1_SET && utype != V_ASN1_OTHER;
      .         
      .           // If not implicitly tagged get tag from underlying type
 19,916 (0.0%)    if (tag == -1) {
 19,916 (0.0%)      tag = utype;
      .           }
      .         
      .           // Output tag+length followed by content octets
 19,916 (0.0%)    if (out) {
  5,052 (0.0%)      if (usetag) {
 20,208 (0.0%)        ASN1_put_object(out, /*constructed=*/0, len, tag, aclass);
      .             }
 25,260 (0.0%)      int len2 = asn1_ex_i2c(pval, *out, &omit, &utype, it);
  5,052 (0.0%)      if (len2 < 0) {
      .               return -1;
      .             }
  7,578 (0.0%)      assert(len == len2);
  7,578 (0.0%)      assert(!omit);
 17,682 (0.0%)      *out += len;
      .           }
      .         
 19,916 (0.0%)    if (usetag) {
 59,748 (0.0%)      return ASN1_object_size(/*constructed=*/0, len, tag);
      .           }
      .           return len;
 49,790 (0.0%)  }
      .         
      .         // asn1_ex_i2c writes the |*pval| to |cout| under the i2d output convention,
      .         // excluding the tag and length. It returns the number of bytes written,
      .         // possibly zero, on success or -1 on error. If |*pval| should be omitted, it
      .         // returns zero and sets |*out_omit| to true.
      .         //
      .         // If |it| is an MSTRING or ANY type, it gets the underlying type from |*pval|,
      .         // which must be an |ASN1_STRING| or |ASN1_TYPE|, respectively. It then updates
-- line 545 ----------------------------------------
-- line 548 ----------------------------------------
      .         // |V_ASN1_OTHER|, it additionally outputs the tag and length, so the caller
      .         // must not do so.
      .         //
      .         // Otherwise, |*putype| must contain |it->utype|.
      .         //
      .         // WARNING: Unlike most functions in this file, |asn1_ex_i2c| can return zero
      .         // without omitting the element. ASN.1 values may have empty contents.
      .         static int asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cout, int *out_omit,
149,808 (0.1%)                         int *putype, const ASN1_ITEM *it) {
 12,484 (0.0%)    ASN1_BOOLEAN *tbool = NULL;
      .           ASN1_STRING *strtmp;
      .           ASN1_OBJECT *otmp;
      .           int utype;
      .           const unsigned char *cont;
      .           unsigned char c;
      .           int len;
      .         
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of callbacks.
 49,936 (0.0%)    assert(it->funcs == NULL);
      .         
 24,968 (0.0%)    *out_omit = 0;
      .         
      .           // Should type be omitted?
 78,992 (0.1%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) || (it->utype != V_ASN1_BOOLEAN)) {
 49,936 (0.0%)      if (!*pval) {
      .               *out_omit = 1;
      .               return 0;
      .             }
      .           }
      .         
 49,936 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
      .             // If MSTRING type set the underlying type
 15,660 (0.0%)      strtmp = (ASN1_STRING *)*pval;
 15,660 (0.0%)      utype = strtmp->type;
 10,440 (0.0%)      if (utype < 0 && utype != V_ASN1_OTHER) {
      .               // MSTRINGs can have type -1 when default-constructed.
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TYPE);
      .               return -1;
      .             }
      .             // Negative INTEGER and ENUMERATED values use |ASN1_STRING| type values
      .             // that do not match their corresponding utype values. INTEGERs cannot
      .             // participate in MSTRING types, but ENUMERATEDs can.
      .             //
      .             // TODO(davidben): Is this a bug? Although arguably one of the MSTRING
      .             // types should contain more values, rather than less. See
      .             // https://crbug.com/boringssl/412. But it is not possible to fit all
      .             // possible ANY values into an |ASN1_STRING|, so matching the spec here
      .             // is somewhat hopeless.
 10,440 (0.0%)      if (utype == V_ASN1_NEG_INTEGER) {
      .               utype = V_ASN1_INTEGER;
 10,440 (0.0%)      } else if (utype == V_ASN1_NEG_ENUMERATED) {
      .               utype = V_ASN1_ENUMERATED;
      .             }
 20,880 (0.0%)      *putype = utype;
 29,056 (0.0%)    } else if (it->utype == V_ASN1_ANY) {
      .             // If ANY set type and pointer to value
      .             ASN1_TYPE *typ;
  2,190 (0.0%)      typ = (ASN1_TYPE *)*pval;
  2,190 (0.0%)      utype = typ->type;
  1,460 (0.0%)      if (utype < 0 && utype != V_ASN1_OTHER) {
      .               // |ASN1_TYPE|s can have type -1 when default-constructed.
      .               OPENSSL_PUT_ERROR(ASN1, ASN1_R_WRONG_TYPE);
      .               return -1;
      .             }
  2,190 (0.0%)      *putype = utype;
  2,920 (0.0%)      pval = &typ->value.asn1_value;
      .           } else {
 19,602 (0.0%)      utype = *putype;
      .           }
      .         
 83,080 (0.1%)    switch (utype) {
      .             case V_ASN1_OBJECT:
 18,450 (0.0%)        otmp = (ASN1_OBJECT *)*pval;
 18,450 (0.0%)        cont = otmp->data;
 18,450 (0.0%)        len = otmp->length;
 12,300 (0.0%)        if (len == 0) {
      .                 // Some |ASN1_OBJECT|s do not have OIDs and cannot be serialized.
      .                 OPENSSL_PUT_ERROR(ASN1, ASN1_R_ILLEGAL_OBJECT);
      .                 return -1;
      .               }
  6,150 (0.0%)        break;
      .         
      .             case V_ASN1_NULL:
    530 (0.0%)        cont = NULL;
    530 (0.0%)        len = 0;
    530 (0.0%)        break;
      .         
      .             case V_ASN1_BOOLEAN:
      .               tbool = (ASN1_BOOLEAN *)pval;
      .               if (*tbool == ASN1_BOOLEAN_NONE) {
      .                 *out_omit = 1;
      .                 return 0;
      .               }
      .               if (it->utype != V_ASN1_ANY) {
-- line 642 ----------------------------------------
-- line 648 ----------------------------------------
      .               }
      .               c = *tbool ? 0xff : 0x00;
      .               cont = &c;
      .               len = 1;
      .               break;
      .         
      .             case V_ASN1_BIT_STRING: {
      .               int ret =
  5,986 (0.0%)            i2c_ASN1_BIT_STRING((ASN1_BIT_STRING *)*pval, cout ? &cout : NULL);
      .               // |i2c_ASN1_BIT_STRING| returns zero on error instead of -1.
  2,336 (0.0%)        return ret <= 0 ? -1 : ret;
      .             }
      .         
      .             case V_ASN1_INTEGER:
      .             case V_ASN1_ENUMERATED: {
      .               // |i2c_ASN1_INTEGER| also handles ENUMERATED.
      .               int ret = i2c_ASN1_INTEGER((ASN1_INTEGER *)*pval, cout ? &cout : NULL);
      .               // |i2c_ASN1_INTEGER| returns zero on error instead of -1.
      .               return ret <= 0 ? -1 : ret;
-- line 666 ----------------------------------------
-- line 679 ----------------------------------------
      .             case V_ASN1_GENERALSTRING:
      .             case V_ASN1_UNIVERSALSTRING:
      .             case V_ASN1_BMPSTRING:
      .             case V_ASN1_UTF8STRING:
      .             case V_ASN1_SEQUENCE:
      .             case V_ASN1_SET:
      .             default:
      .               // All based on ASN1_STRING and handled the same
 15,660 (0.0%)        strtmp = (ASN1_STRING *)*pval;
 15,660 (0.0%)        cont = strtmp->data;
 15,660 (0.0%)        len = strtmp->length;
      .         
  5,220 (0.0%)        break;
      .           }
 40,460 (0.0%)    if (cout && len) {
 15,918 (0.0%)      OPENSSL_memcpy(cout, cont, len);
      .           }
 11,900 (0.0%)    return len;
 62,420 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_fre.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 60 ----------------------------------------
     .         
     .         #include <openssl/asn1t.h>
     .         #include <openssl/mem.h>
     .         
     .         #include "internal.h"
     .         
     .         // Free up an ASN1 structure
     .         
 8,016 (0.0%)  void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it) {
 8,016 (0.0%)    asn1_item_combine_free(&val, it, 0);
 4,008 (0.0%)  }
     .         
     .         void ASN1_item_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
     .           asn1_item_combine_free(pval, it, 0);
     .         }
     .         
     .         void asn1_item_combine_free(ASN1_VALUE **pval, const ASN1_ITEM *it,
28,147 (0.0%)                              int combine) {
 4,021 (0.0%)    const ASN1_TEMPLATE *tt = NULL, *seqtt;
     .           const ASN1_EXTERN_FUNCS *ef;
     .           int i;
16,084 (0.0%)    if (pval == NULL || it == NULL) {
     .             return;
     .           }
25,604 (0.0%)    if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval) {
   292 (0.0%)      return;
     .           }
     .         
50,375 (0.0%)    switch (it->itype) {
     .             case ASN1_ITYPE_PRIMITIVE:
 6,564 (0.0%)        if (it->templates) {
     .                 ASN1_template_free(pval, it->templates);
     .               } else {
 8,205 (0.0%)          ASN1_primitive_free(pval, it);
     .               }
 1,641 (0.0%)        break;
     .         
     .             case ASN1_ITYPE_MSTRING:
 5,220 (0.0%)        ASN1_primitive_free(pval, it);
 1,044 (0.0%)        break;
     .         
     .             case ASN1_ITYPE_CHOICE: {
     .               const ASN1_AUX *aux = it->funcs;
     .               ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
     .               if (asn1_cb) {
     .                 i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
     .                 if (i == 2) {
     .                   return;
-- line 107 ----------------------------------------
-- line 127 ----------------------------------------
     .             case ASN1_ITYPE_EXTERN:
     .               ef = it->funcs;
     .               if (ef && ef->asn1_ex_free) {
     .                 ef->asn1_ex_free(pval, it);
     .               }
     .               break;
     .         
     .             case ASN1_ITYPE_SEQUENCE: {
 8,330 (0.0%)        if (!asn1_refcount_dec_and_test_zero(pval, it)) {
   292 (0.0%)          return;
     .               }
 3,132 (0.0%)        const ASN1_AUX *aux = it->funcs;
 4,176 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
 2,088 (0.0%)        if (asn1_cb) {
     .                 i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
     .                 if (i == 2) {
     .                   return;
     .                 }
     .               }
 5,220 (0.0%)        asn1_enc_free(pval, it);
     .               // If we free up as normal we will invalidate any ANY DEFINED BY
     .               // field and we wont be able to determine the type of the field it
     .               // defines. So free up in reverse order.
 8,352 (0.0%)        tt = it->templates + it->tcount - 1;
25,056 (0.0%)        for (i = 0; i < it->tcount; tt--, i++) {
     .                 ASN1_VALUE **pseqval;
14,616 (0.0%)          seqtt = asn1_do_adb(pval, tt, 0);
 4,176 (0.0%)          if (!seqtt) {
     .                   continue;
     .                 }
12,528 (0.0%)          pseqval = asn1_get_field_ptr(pval, seqtt);
12,528 (0.0%)          ASN1_template_free(pseqval, seqtt);
     .               }
 2,088 (0.0%)        if (asn1_cb) {
     .                 asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);
     .               }
 2,088 (0.0%)        if (!combine) {
 4,176 (0.0%)          OPENSSL_free(*pval);
 2,088 (0.0%)          *pval = NULL;
     .               }
 2,088 (0.0%)        break;
     .             }
     .           }
 8,042 (0.0%)  }
     .         
24,165 (0.0%)  void ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
13,425 (0.0%)    if (tt->flags & ASN1_TFLG_SK_MASK) {
     .             STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;
     .             for (size_t i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
     .               ASN1_VALUE *vtmp = sk_ASN1_VALUE_value(sk, i);
     .               ASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item));
     .             }
     .             sk_ASN1_VALUE_free(sk);
     .             *pval = NULL;
     .           } else {
21,480 (0.0%)      asn1_item_combine_free(pval, ASN1_ITEM_ptr(tt->item),
 5,370 (0.0%)                             tt->flags & ASN1_TFLG_COMBINE);
     .           }
16,110 (0.0%)  }
     .         
16,110 (0.0%)  void ASN1_primitive_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
     .           // Historically, |it->funcs| for primitive types contained an
     .           // |ASN1_PRIMITIVE_FUNCS| table of calbacks.
10,740 (0.0%)    assert(it->funcs == NULL);
     .         
19,392 (0.0%)    int utype = it->itype == ASN1_ITYPE_MSTRING ? -1 : it->utype;
22,956 (0.0%)    switch (utype) {
     .             case V_ASN1_OBJECT:
 4,176 (0.0%)        ASN1_OBJECT_free((ASN1_OBJECT *)*pval);
 1,044 (0.0%)        break;
     .         
     .             case V_ASN1_BOOLEAN:
   450 (0.0%)        if (it) {
 1,125 (0.0%)          *(ASN1_BOOLEAN *)pval = (ASN1_BOOLEAN)it->size;
     .               } else {
     .                 *(ASN1_BOOLEAN *)pval = ASN1_BOOLEAN_NONE;
     .               }
   225 (0.0%)        return;
     .         
     .             case V_ASN1_NULL:
     .               break;
     .         
     .             case V_ASN1_ANY:
   320 (0.0%)        if (*pval != NULL) {
     .                 asn1_type_cleanup((ASN1_TYPE *)*pval);
     .                 OPENSSL_free(*pval);
     .               }
    80 (0.0%)        break;
     .         
     .             default:
 5,344 (0.0%)        ASN1_STRING_free((ASN1_STRING *)*pval);
 2,672 (0.0%)        *pval = NULL;
 1,336 (0.0%)        break;
     .           }
 4,920 (0.0%)    *pval = NULL;
 5,370 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_new.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 70 ----------------------------------------
      .         static int asn1_item_ex_combine_new(ASN1_VALUE **pval, const ASN1_ITEM *it,
      .                                             int combine);
      .         static void asn1_item_clear(ASN1_VALUE **pval, const ASN1_ITEM *it);
      .         static int ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);
      .         static void asn1_template_clear(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);
      .         static int ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it);
      .         static void asn1_primitive_clear(ASN1_VALUE **pval, const ASN1_ITEM *it);
      .         
 11,216 (0.0%)  ASN1_VALUE *ASN1_item_new(const ASN1_ITEM *it) {
  1,402 (0.0%)    ASN1_VALUE *ret = NULL;
  9,814 (0.0%)    if (ASN1_item_ex_new(&ret, it) > 0) {
  2,804 (0.0%)      return ret;
      .           }
      .           return NULL;
  7,010 (0.0%)  }
      .         
      .         // Allocate an ASN1 structure
      .         
 18,570 (0.0%)  int ASN1_item_ex_new(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 18,570 (0.0%)    return asn1_item_ex_combine_new(pval, it, 0);
  6,190 (0.0%)  }
      .         
      .         static int asn1_item_ex_combine_new(ASN1_VALUE **pval, const ASN1_ITEM *it,
 74,291 (0.1%)                                      int combine) {
 10,613 (0.0%)    const ASN1_TEMPLATE *tt = NULL;
      .           const ASN1_EXTERN_FUNCS *ef;
      .           ASN1_VALUE **pseqval;
      .           int i;
      .         
137,969 (0.1%)    switch (it->itype) {
      .             case ASN1_ITYPE_EXTERN:
    876 (0.0%)        ef = it->funcs;
  1,752 (0.0%)        if (ef && ef->asn1_ex_new) {
  2,628 (0.0%)          if (!ef->asn1_ex_new(pval, it)) {
      .                   goto memerr;
      .                 }
      .               }
    584 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_PRIMITIVE:
 17,312 (0.0%)        if (it->templates) {
      .                 if (!ASN1_template_new(pval, it->templates)) {
      .                   goto memerr;
      .                 }
 30,296 (0.0%)        } else if (!ASN1_primitive_new(pval, it)) {
      .                 goto memerr;
      .               }
  8,656 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_MSTRING:
 16,660 (0.0%)        if (!ASN1_primitive_new(pval, it)) {
      .                 goto memerr;
      .               }
  4,760 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_CHOICE: {
      .               const ASN1_AUX *aux = it->funcs;
      .               ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
      .               if (asn1_cb) {
      .                 i = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);
      .                 if (!i) {
      .                   goto auxerr;
-- line 131 ----------------------------------------
-- line 143 ----------------------------------------
      .               asn1_set_choice_selector(pval, -1, it);
      .               if (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL)) {
      .                 goto auxerr2;
      .               }
      .               break;
      .             }
      .         
      .             case ASN1_ITYPE_SEQUENCE: {
 10,839 (0.0%)        const ASN1_AUX *aux = it->funcs;
 15,328 (0.0%)        ASN1_aux_cb *asn1_cb = aux != NULL ? aux->asn1_cb : NULL;
  7,226 (0.0%)        if (asn1_cb) {
  2,336 (0.0%)          i = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);
    584 (0.0%)          if (!i) {
      .                   goto auxerr;
      .                 }
    584 (0.0%)          if (i == 2) {
      .                   return 1;
      .                 }
      .               }
  7,226 (0.0%)        if (!combine) {
 21,678 (0.0%)          *pval = OPENSSL_zalloc(it->size);
 14,452 (0.0%)          if (!*pval) {
      .                   goto memerr;
      .                 }
 18,065 (0.0%)          asn1_refcount_set_one(pval, it);
 18,065 (0.0%)          asn1_enc_init(pval, it);
      .               }
112,087 (0.1%)        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
 54,258 (0.0%)          pseqval = asn1_get_field_ptr(pval, tt);
 63,301 (0.0%)          if (!ASN1_template_new(pseqval, tt)) {
      .                   goto memerr2;
      .                 }
      .               }
  9,854 (0.0%)        if (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL)) {
      .                 goto auxerr2;
      .               }
  3,905 (0.0%)        break;
      .             }
      .           }
 21,226 (0.0%)    return 1;
      .         
      .         memerr2:
      .           asn1_item_combine_free(pval, it, combine);
      .         memerr:
      .           return 0;
      .         
      .         auxerr2:
      .           asn1_item_combine_free(pval, it, combine);
      .         auxerr:
      .           OPENSSL_PUT_ERROR(ASN1, ASN1_R_AUX_ERROR);
      .           return 0;
 21,226 (0.0%)  }
      .         
  8,274 (0.0%)  static void asn1_item_clear(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 17,927 (0.0%)    switch (it->itype) {
      .             case ASN1_ITYPE_EXTERN:
      .               *pval = NULL;
      .               break;
      .         
      .             case ASN1_ITYPE_PRIMITIVE:
  5,516 (0.0%)        if (it->templates) {
      .                 asn1_template_clear(pval, it->templates);
      .               } else {
  6,895 (0.0%)          asn1_primitive_clear(pval, it);
      .               }
  1,379 (0.0%)        break;
      .         
      .             case ASN1_ITYPE_MSTRING:
      .               asn1_primitive_clear(pval, it);
      .               break;
      .         
      .             case ASN1_ITYPE_CHOICE:
      .             case ASN1_ITYPE_SEQUENCE:
      .               *pval = NULL;
      .               break;
      .           }
  4,137 (0.0%)  }
      .         
 54,258 (0.0%)  static int ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
 27,129 (0.0%)    const ASN1_ITEM *it = ASN1_ITEM_ptr(tt->item);
      .           int ret;
 45,215 (0.0%)    if (tt->flags & ASN1_TFLG_OPTIONAL) {
  7,625 (0.0%)      asn1_template_clear(pval, tt);
  3,050 (0.0%)      return 1;
      .           }
      .           // If ANY DEFINED BY nothing to do
      .         
 37,590 (0.0%)    if (tt->flags & ASN1_TFLG_ADB_MASK) {
      .             *pval = NULL;
      .             return 1;
      .           }
      .           // If SET OF or SEQUENCE OF, its a STACK
 37,590 (0.0%)    if (tt->flags & ASN1_TFLG_SK_MASK) {
      .             STACK_OF(ASN1_VALUE) *skval;
      .             skval = sk_ASN1_VALUE_new_null();
      .             if (!skval) {
      .               ret = 0;
      .               goto done;
      .             }
      .             *pval = (ASN1_VALUE *)skval;
      .             ret = 1;
      .             goto done;
      .           }
      .           // Otherwise pass it back to the item routine
 75,180 (0.1%)    ret = asn1_item_ex_combine_new(pval, it, tt->flags & ASN1_TFLG_COMBINE);
      .         done:
  7,518 (0.0%)    return ret;
 18,086 (0.0%)  }
      .         
  9,150 (0.0%)  static void asn1_template_clear(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
      .           // If ADB or STACK just NULL the field
  7,625 (0.0%)    if (tt->flags & (ASN1_TFLG_ADB_MASK | ASN1_TFLG_SK_MASK)) {
    292 (0.0%)      *pval = NULL;
      .           } else {
  8,274 (0.0%)      asn1_item_clear(pval, ASN1_ITEM_ptr(tt->item));
      .           }
  4,721 (0.0%)  }
      .         
      .         // NB: could probably combine most of the real XXX_new() behaviour and junk
      .         // all the old functions.
      .         
 40,248 (0.0%)  static int ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 13,416 (0.0%)    if (!it) {
      .             return 0;
      .           }
      .         
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of calbacks.
 26,832 (0.0%)    assert(it->funcs == NULL);
      .         
      .           int utype;
 26,832 (0.0%)    if (it->itype == ASN1_ITYPE_MSTRING) {
  4,760 (0.0%)      utype = -1;
      .           } else {
 12,984 (0.0%)      utype = it->utype;
      .           }
 52,811 (0.0%)    switch (utype) {
      .             case V_ASN1_OBJECT:
  9,087 (0.0%)        *pval = (ASN1_VALUE *)OBJ_get_undef();
  6,058 (0.0%)        return 1;
      .         
      .             case V_ASN1_BOOLEAN:
      .               *(ASN1_BOOLEAN *)pval = (ASN1_BOOLEAN)it->size;
      .               return 1;
      .         
      .             case V_ASN1_NULL:
      .               *pval = (ASN1_VALUE *)1;
      .               return 1;
      .         
      .             case V_ASN1_ANY: {
  1,074 (0.0%)        ASN1_TYPE *typ = OPENSSL_zalloc(sizeof(ASN1_TYPE));
    716 (0.0%)        if (!typ) {
      .                 return 0;
      .               }
    716 (0.0%)        typ->type = -1;
  1,074 (0.0%)        *pval = (ASN1_VALUE *)typ;
    358 (0.0%)        break;
      .             }
      .         
      .             default:
 16,605 (0.0%)        *pval = (ASN1_VALUE *)ASN1_STRING_type_new(utype);
  3,321 (0.0%)        break;
      .           }
 14,716 (0.0%)    if (*pval) {
  7,358 (0.0%)      return 1;
      .           }
      .           return 0;
 13,416 (0.0%)  }
      .         
  8,274 (0.0%)  static void asn1_primitive_clear(ASN1_VALUE **pval, const ASN1_ITEM *it) {
      .           int utype;
      .           // Historically, |it->funcs| for primitive types contained an
      .           // |ASN1_PRIMITIVE_FUNCS| table of calbacks.
  8,274 (0.0%)    assert(it == NULL || it->funcs == NULL);
  8,274 (0.0%)    if (!it || (it->itype == ASN1_ITYPE_MSTRING)) {
      .             utype = -1;
      .           } else {
  4,137 (0.0%)      utype = it->utype;
      .           }
  2,758 (0.0%)    if (utype == V_ASN1_BOOLEAN) {
  2,515 (0.0%)      *(ASN1_BOOLEAN *)pval = (ASN1_BOOLEAN)it->size;
      .           } else {
  1,752 (0.0%)      *pval = NULL;
      .           }
  4,640 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/asn1/tasn_utl.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 86 ----------------------------------------
      .           int *sel, ret;
      .           sel = offset2ptr(*pval, it->utype);
      .           ret = *sel;
      .           *sel = value;
      .           return ret;
      .         }
      .         
      .         static CRYPTO_refcount_t *asn1_get_references(ASN1_VALUE **pval,
 24,015 (0.0%)                                                const ASN1_ITEM *it) {
 19,212 (0.0%)    if (it->itype != ASN1_ITYPE_SEQUENCE) {
      .             return NULL;
      .           }
 14,409 (0.0%)    const ASN1_AUX *aux = it->funcs;
 12,526 (0.0%)    if (!aux || !(aux->flags & ASN1_AFLG_REFCOUNT)) {
  9,022 (0.0%)      return NULL;
      .           }
  1,752 (0.0%)    return offset2ptr(*pval, aux->ref_offset);
  9,606 (0.0%)  }
      .         
 21,678 (0.0%)  void asn1_refcount_set_one(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 21,678 (0.0%)    CRYPTO_refcount_t *references = asn1_get_references(pval, it);
  7,226 (0.0%)    if (references != NULL) {
    292 (0.0%)      *references = 1;
      .           }
 10,839 (0.0%)  }
      .         
  7,140 (0.0%)  int asn1_refcount_dec_and_test_zero(ASN1_VALUE **pval, const ASN1_ITEM *it) {
  7,140 (0.0%)    CRYPTO_refcount_t *references = asn1_get_references(pval, it);
  2,380 (0.0%)    if (references != NULL) {
    584 (0.0%)      return CRYPTO_refcount_dec_and_test_zero(references);
      .           }
  1,044 (0.0%)    return 1;
  2,380 (0.0%)  }
      .         
 66,528 (0.0%)  static ASN1_ENCODING *asn1_get_enc_ptr(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 44,352 (0.0%)    assert(it->itype == ASN1_ITYPE_SEQUENCE);
      .           const ASN1_AUX *aux;
 66,528 (0.0%)    if (!pval || !*pval) {
      .             return NULL;
      .           }
 33,264 (0.0%)    aux = it->funcs;
 28,016 (0.0%)    if (!aux || !(aux->flags & ASN1_AFLG_ENCODING)) {
 21,592 (0.0%)      return NULL;
      .           }
  1,752 (0.0%)    return offset2ptr(*pval, aux->enc_offset);
 22,176 (0.0%)  }
      .         
 21,678 (0.0%)  void asn1_enc_init(ASN1_VALUE **pval, const ASN1_ITEM *it) {
 21,678 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
  7,226 (0.0%)    if (enc) {
    292 (0.0%)      enc->enc = NULL;
    292 (0.0%)      enc->len = 0;
    584 (0.0%)      enc->alias_only = 0;
    584 (0.0%)      enc->alias_only_on_next_parse = 0;
      .           }
 10,839 (0.0%)  }
      .         
  6,264 (0.0%)  void asn1_enc_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
  6,264 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
  2,088 (0.0%)    if (enc) {
      .             asn1_encoding_clear(enc);
      .           }
  3,132 (0.0%)  }
      .         
      .         int asn1_enc_save(ASN1_VALUE **pval, const unsigned char *in, int inlen,
 20,552 (0.0%)                    const ASN1_ITEM *it) {
      .           ASN1_ENCODING *enc;
 15,414 (0.0%)    enc = asn1_get_enc_ptr(pval, it);
  5,138 (0.0%)    if (!enc) {
  4,846 (0.0%)      return 1;
      .           }
      .         
    730 (0.0%)    if (!enc->alias_only) {
    584 (0.0%)      OPENSSL_free(enc->enc);
      .           }
      .         
  1,606 (0.0%)    enc->alias_only = enc->alias_only_on_next_parse;
    584 (0.0%)    enc->alias_only_on_next_parse = 0;
      .         
    730 (0.0%)    if (enc->alias_only) {
      .             enc->enc = (uint8_t *)in;
      .           } else {
  1,168 (0.0%)      enc->enc = OPENSSL_memdup(in, inlen);
    584 (0.0%)      if (!enc->enc) {
      .               return 0;
      .             }
      .           }
      .         
    584 (0.0%)    enc->len = inlen;
    146 (0.0%)    return 1;
  5,138 (0.0%)  }
      .         
      .         void asn1_encoding_clear(ASN1_ENCODING *enc) {
      .           if (!enc->alias_only) {
      .             OPENSSL_free(enc->enc);
      .           }
      .           enc->enc = NULL;
      .           enc->len = 0;
      .           enc->alias_only = 0;
      .           enc->alias_only_on_next_parse = 0;
      .         }
      .         
      .         int asn1_enc_restore(int *len, unsigned char **out, ASN1_VALUE **pval,
 30,896 (0.0%)                       const ASN1_ITEM *it) {
 23,172 (0.0%)    ASN1_ENCODING *enc = asn1_get_enc_ptr(pval, it);
  7,724 (0.0%)    if (!enc || enc->len == 0) {
  7,724 (0.0%)      return 0;
      .           }
      .           if (out) {
      .             OPENSSL_memcpy(*out, enc->enc, enc->len);
      .             *out += enc->len;
      .           }
      .           if (len) {
      .             *len = enc->len;
      .           }
      .           return 1;
  7,724 (0.0%)  }
      .         
      .         // Given an ASN1_TEMPLATE get a pointer to a field
142,810 (0.1%)  ASN1_VALUE **asn1_get_field_ptr(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt) {
      .           ASN1_VALUE **pvaltmp;
142,810 (0.1%)    if (tt->flags & ASN1_TFLG_COMBINE) {
      .             return pval;
      .           }
171,372 (0.1%)    pvaltmp = offset2ptr(*pval, tt->offset);
      .           // NOTE for BOOLEAN types the field is just a plain int so we can't return
      .           // int **, so settle for (int *).
 28,562 (0.0%)    return pvaltmp;
 57,124 (0.0%)  }
      .         
      .         // Handle ANY DEFINED BY template, find the selector, look up the relevant
      .         // ASN1_TEMPLATE in the table and return it.
      .         const ASN1_TEMPLATE *asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt,
136,633 (0.1%)                                   int nullerr) {
      .           const ASN1_ADB *adb;
      .           const ASN1_ADB_TABLE *atbl;
      .           ASN1_VALUE **sfld;
      .           int i;
 97,595 (0.1%)    if (!(tt->flags & ASN1_TFLG_ADB_MASK)) {
 39,038 (0.0%)      return tt;
      .           }
      .         
      .           // Else ANY DEFINED BY ... get the table
      .           adb = ASN1_ADB_ptr(tt->item);
      .         
      .           // Get the selector field
      .           sfld = offset2ptr(*pval, adb->offset);
      .         
-- line 233 ----------------------------------------
-- line 265 ----------------------------------------
      .           return adb->default_tt;
      .         
      .         err:
      .           // FIXME: should log the value or OID of unsupported type
      .           if (nullerr) {
      .             OPENSSL_PUT_ERROR(ASN1, ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);
      .           }
      .           return NULL;
 39,038 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/../internal.h
--------------------------------------------------------------------------------
Ir______________ 

-- line 318 ----------------------------------------
        .         #if defined(__GNUC__) || defined(__clang__)
        .           __asm__("" : "+r"(a) : /* no inputs */);
        .         #endif
        .           return a;
        .         }
        .         
        .         // constant_time_msb_w returns the given value with the MSB copied to all the
        .         // other bits.
3,746,520 (2.7%)  static inline crypto_word_t constant_time_msb_w(crypto_word_t a) {
2,497,680 (1.8%)    return 0u - (a >> (sizeof(a) * 8 - 1));
2,497,680 (1.8%)  }
        .         
        .         // constant_time_lt_w returns 0xff..f if a < b and 0 otherwise.
        .         static inline crypto_word_t constant_time_lt_w(crypto_word_t a,
        .                                                        crypto_word_t b) {
        .           // Consider the two cases of the problem:
        .           //   msb(a) == msb(b): a < b iff the MSB of a - b is set.
        .           //   msb(a) != msb(b): a < b iff the MSB of b is set.
        .           //
-- line 336 ----------------------------------------
-- line 377 ----------------------------------------
        .         
        .         // constant_time_ge_8 acts like |constant_time_ge_w| but returns an 8-bit
        .         // mask.
        .         static inline uint8_t constant_time_ge_8(crypto_word_t a, crypto_word_t b) {
        .           return (uint8_t)(constant_time_ge_w(a, b));
        .         }
        .         
        .         // constant_time_is_zero returns 0xff..f if a == 0 and 0 otherwise.
2,497,680 (1.8%)  static inline crypto_word_t constant_time_is_zero_w(crypto_word_t a) {
        .           // Here is an SMT-LIB verification of this formula:
        .           //
        .           // (define-fun is_zero ((a (_ BitVec 32))) (_ BitVec 32)
        .           //   (bvand (bvnot a) (bvsub a #x00000001))
        .           // )
        .           //
        .           // (declare-fun a () (_ BitVec 32))
        .           //
        .           // (assert (not (= (= #x00000001 (bvlshr (is_zero a) #x0000001f)) (= a #x00000000))))
        .           // (check-sat)
        .           // (get-model)
4,995,360 (3.6%)    return constant_time_msb_w(~a & (a - 1));
1,248,840 (0.9%)  }
        .         
        .         // constant_time_is_zero_8 acts like |constant_time_is_zero_w| but returns an
        .         // 8-bit mask.
        .         static inline uint8_t constant_time_is_zero_8(crypto_word_t a) {
        .           return (uint8_t)(constant_time_is_zero_w(a));
        .         }
        .         
        .         // constant_time_eq_w returns 0xff..f if a == b and 0 otherwise.
        .         static inline crypto_word_t constant_time_eq_w(crypto_word_t a,
3,122,100 (2.3%)                                                 crypto_word_t b) {
2,497,680 (1.8%)    return constant_time_is_zero_w(a ^ b);
1,248,840 (0.9%)  }
        .         
        .         // constant_time_eq_8 acts like |constant_time_eq_w| but returns an 8-bit
        .         // mask.
3,122,100 (2.3%)  static inline uint8_t constant_time_eq_8(crypto_word_t a, crypto_word_t b) {
3,122,100 (2.3%)    return (uint8_t)(constant_time_eq_w(a, b));
1,248,840 (0.9%)  }
        .         
        .         // constant_time_eq_int acts like |constant_time_eq_w| but works on int
        .         // values.
        .         static inline crypto_word_t constant_time_eq_int(int a, int b) {
        .           return constant_time_eq_w((crypto_word_t)(a), (crypto_word_t)(b));
        .         }
        .         
        .         // constant_time_eq_int_8 acts like |constant_time_eq_int| but returns an 8-bit
-- line 424 ----------------------------------------
-- line 882 ----------------------------------------
        .         static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
        .           if (n == 0) {
        .             return dst;
        .           }
        .         
        .           return memmove(dst, src, n);
        .         }
        .         
      876 (0.0%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
      292 (0.0%)    if (n == 0) {
        .             return dst;
        .           }
        .         
      876 (0.0%)    return memset(dst, c, n);
      292 (0.0%)  }
        .         
        .         
        .         // Loads and stores.
        .         //
        .         // The following functions load and store sized integers with the specified
        .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
        .         // requirements on the input and output pointers.
        .         
-- line 904 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/base64/base64.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 62 ----------------------------------------
        .         
        .         #include <openssl/type_check.h>
        .         
        .         #include "../internal.h"
        .         
        .         
        .         // constant_time_lt_args_8 behaves like |constant_time_lt_8| but takes |uint8_t|
        .         // arguments for a slightly simpler implementation.
4,370,940 (3.2%)  static inline uint8_t constant_time_lt_args_8(uint8_t a, uint8_t b) {
1,248,840 (0.9%)    crypto_word_t aw = a;
1,248,840 (0.9%)    crypto_word_t bw = b;
        .           // |crypto_word_t| is larger than |uint8_t|, so |aw| and |bw| have the same
        .           // MSB. |aw| < |bw| iff MSB(|aw| - |bw|) is 1.
2,497,680 (1.8%)    return constant_time_msb_w(aw - bw);
1,248,840 (0.9%)  }
        .         
        .         // constant_time_in_range_8 returns |CONSTTIME_TRUE_8| if |min| <= |a| <= |max|
        .         // and |CONSTTIME_FALSE_8| otherwise.
        .         static inline uint8_t constant_time_in_range_8(uint8_t a, uint8_t min,
6,244,200 (4.5%)                                                 uint8_t max) {
1,248,840 (0.9%)    a -= min;
4,995,360 (3.6%)    return constant_time_lt_args_8(a, max - min + 1);
1,248,840 (0.9%)  }
        .         
        .         // Encoding.
        .         
        .         static uint8_t conv_bin2ascii(uint8_t a) {
        .           // Since PEM is sometimes used to carry private keys, we encode base64 data
        .           // itself in constant-time.
        .           a &= 0x3f;
        .           uint8_t ret = constant_time_select_8(constant_time_eq_8(a, 62), '+', '/');
-- line 92 ----------------------------------------
-- line 257 ----------------------------------------
        .           if (len % 4 != 0) {
        .             return 0;
        .           }
        .         
        .           *out_len = (len / 4) * 3;
        .           return 1;
        .         }
        .         
      730 (0.0%)  void EVP_DecodeInit(EVP_ENCODE_CTX *ctx) {
      730 (0.0%)    OPENSSL_memset(ctx, 0, sizeof(EVP_ENCODE_CTX));
      438 (0.0%)  }
        .         
1,248,840 (0.9%)  static uint8_t base64_ascii_to_bin(uint8_t a) {
        .           // Since PEM is sometimes used to carry private keys, we decode base64 data
        .           // itself in constant-time.
1,248,840 (0.9%)    const uint8_t is_upper = constant_time_in_range_8(a, 'A', 'Z');
1,248,840 (0.9%)    const uint8_t is_lower = constant_time_in_range_8(a, 'a', 'z');
1,248,840 (0.9%)    const uint8_t is_digit = constant_time_in_range_8(a, '0', '9');
1,040,700 (0.8%)    const uint8_t is_plus = constant_time_eq_8(a, '+');
1,040,700 (0.8%)    const uint8_t is_slash = constant_time_eq_8(a, '/');
1,040,700 (0.8%)    const uint8_t is_equals = constant_time_eq_8(a, '=');
        .         
  208,140 (0.2%)    uint8_t ret = 0;
1,665,120 (1.2%)    ret |= is_upper & (a - 'A');       // [0,26)
1,665,120 (1.2%)    ret |= is_lower & (a - 'a' + 26);  // [26,52)
1,665,120 (1.2%)    ret |= is_digit & (a - '0' + 52);  // [52,62)
1,248,840 (0.9%)    ret |= is_plus & 62;
1,248,840 (0.9%)    ret |= is_slash & 63;
        .           // Invalid inputs, 'A', and '=' have all been mapped to zero. Map invalid
        .           // inputs to 0xff. Note '=' is padding and handled separately by the caller.
1,456,980 (1.1%)    const uint8_t is_valid =
        .               is_upper | is_lower | is_digit | is_plus | is_slash | is_equals;
1,248,840 (0.9%)    ret |= ~is_valid;
  208,140 (0.2%)    return ret;
  416,280 (0.3%)  }
        .         
        .         // base64_decode_quad decodes a single “quad” (i.e. four characters) of base64
        .         // data and writes up to three bytes to |out|. It sets |*out_num_bytes| to the
        .         // number of bytes written, which will be less than three if the quad ended
        .         // with padding.  It returns one on success or zero on error.
        .         static int base64_decode_quad(uint8_t *out, size_t *out_num_bytes,
  364,245 (0.3%)                                const uint8_t *in) {
  312,210 (0.2%)    const uint8_t a = base64_ascii_to_bin(in[0]);
  364,245 (0.3%)    const uint8_t b = base64_ascii_to_bin(in[1]);
  364,245 (0.3%)    const uint8_t c = base64_ascii_to_bin(in[2]);
  364,245 (0.3%)    const uint8_t d = base64_ascii_to_bin(in[3]);
  416,280 (0.3%)    if (a == 0xff || b == 0xff || c == 0xff || d == 0xff) {
        .             return 0;
        .           }
        .         
  468,315 (0.3%)    const uint32_t v = ((uint32_t)a) << 18 | ((uint32_t)b) << 12 |
  156,105 (0.1%)                       ((uint32_t)c) << 6 | (uint32_t)d;
        .         
  364,245 (0.3%)    const unsigned padding_pattern = (in[0] == '=') << 3 |
  364,245 (0.3%)                                     (in[1] == '=') << 2 |
  364,282 (0.3%)                                     (in[2] == '=') << 1 |
  312,210 (0.2%)                                     (in[3] == '=');
        .         
  312,156 (0.2%)    switch (padding_pattern) {
        .             case 0:
        .               // The common case of no padding.
  103,902 (0.1%)        *out_num_bytes = 3;
  259,755 (0.2%)        out[0] = v >> 16;
  311,706 (0.2%)        out[1] = v >> 8;
  207,804 (0.2%)        out[2] = v;
   51,951 (0.0%)        break;
        .         
        .             case 1:  // xxx=
       94 (0.0%)        *out_num_bytes = 2;
      235 (0.0%)        out[0] = v >> 16;
      282 (0.0%)        out[1] = v >> 8;
       47 (0.0%)        break;
        .         
        .             case 3:  // xx==
       74 (0.0%)        *out_num_bytes = 1;
      185 (0.0%)        out[0] = v >> 16;
       37 (0.0%)        break;
        .         
        .             default:
        .               return 0;
        .           }
        .         
   52,035 (0.0%)    return 1;
  104,070 (0.1%)  }
        .         
        .         int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, uint8_t *out, int *out_len,
    1,752 (0.0%)                       const uint8_t *in, size_t in_len) {
      292 (0.0%)    *out_len = 0;
        .         
      584 (0.0%)    if (ctx->error_encountered) {
        .             return -1;
        .           }
        .         
      146 (0.0%)    size_t bytes_out = 0, i;
  846,562 (0.6%)    for (i = 0; i < in_len; i++) {
1,057,290 (0.8%)      const char c = in[i];
1,087,152 (0.8%)      switch (c) {
        .               case ' ':
        .               case '\t':
        .               case '\r':
        .               case '\n':
    3,318 (0.0%)          continue;
        .             }
        .         
  832,560 (0.6%)      if (ctx->eof_seen) {
        .               ctx->error_encountered = 1;
        .               return -1;
        .             }
        .         
1,873,260 (1.4%)      ctx->data[ctx->data_used++] = c;
  832,560 (0.6%)      if (ctx->data_used == 4) {
        .               size_t num_bytes_resulting;
  468,315 (0.3%)        if (!base64_decode_quad(out, &num_bytes_resulting, ctx->data)) {
        .                 ctx->error_encountered = 1;
        .                 return -1;
        .               }
        .         
  104,070 (0.1%)        ctx->data_used = 0;
  104,070 (0.1%)        bytes_out += num_bytes_resulting;
  104,070 (0.1%)        out += num_bytes_resulting;
        .         
  156,105 (0.1%)        if (num_bytes_resulting < 3) {
      252 (0.0%)          ctx->eof_seen = 1;
        .               }
        .             }
        .           }
        .         
      438 (0.0%)    if (bytes_out > INT_MAX) {
        .             ctx->error_encountered = 1;
        .             *out_len = 0;
        .             return -1;
        .           }
      584 (0.0%)    *out_len = (int)bytes_out;
        .         
      584 (0.0%)    if (ctx->eof_seen) {
      168 (0.0%)      return 0;
        .           }
        .         
       62 (0.0%)    return 1;
      730 (0.0%)  }
        .         
      876 (0.0%)  int EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, uint8_t *out, int *out_len) {
      292 (0.0%)    *out_len = 0;
    1,168 (0.0%)    if (ctx->error_encountered || ctx->data_used != 0) {
        .             return -1;
        .           }
        .         
      146 (0.0%)    return 1;
      292 (0.0%)  }
        .         
        .         int EVP_DecodeBase64(uint8_t *out, size_t *out_len, size_t max_out,
        .                              const uint8_t *in, size_t in_len) {
        .           *out_len = 0;
        .         
        .           if (in_len % 4 != 0) {
        .             return 0;
        .           }
-- line 413 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bio/bio.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 92 ----------------------------------------
     .             }
     .           }
     .           return ret;
     .         }
     .         
     .         static CRYPTO_EX_DATA_CLASS g_ex_data_class =
     .             CRYPTO_EX_DATA_CLASS_INIT_WITH_APP_DATA;
     .         
     5 (0.0%)  BIO *BIO_new(const BIO_METHOD *method) {
     3 (0.0%)    BIO *ret = OPENSSL_zalloc(sizeof(BIO));
     2 (0.0%)    if (ret == NULL) {
     .             return NULL;
     .           }
     .         
     3 (0.0%)    ret->method = method;
     2 (0.0%)    ret->shutdown = 1;
     2 (0.0%)    ret->references = 1;
     2 (0.0%)    ret->callback_ex = NULL;
     4 (0.0%)    CRYPTO_new_ex_data(&ret->ex_data);
     .         
     4 (0.0%)    if (method->create != NULL && !method->create(ret)) {
     .             OPENSSL_free(ret);
     .             return NULL;
     .           }
     .         
     1 (0.0%)    return ret;
     2 (0.0%)  }
     .         
     5 (0.0%)  int BIO_free(BIO *bio) {
     .           BIO *next_bio;
     .         
     7 (0.0%)    for (; bio != NULL; bio = next_bio) {
     6 (0.0%)      if (!CRYPTO_refcount_dec_and_test_zero(&bio->references)) {
     .               return 0;
     .             }
     .         
     4 (0.0%)      next_bio = BIO_pop(bio);
     .         
     9 (0.0%)      if (bio->method != NULL && bio->method->destroy != NULL) {
     6 (0.0%)        bio->method->destroy(bio);
     .             }
     4 (0.0%)      if (HAS_CALLBACK(bio)) {
     .               int ret = (int)bio->callback_ex(bio, BIO_CB_FREE, NULL, 0, 0, 0L, 1L, NULL);
     .               if (ret <= 0) {
     .                 return ret;
     .               }
     .             }
     .         
     7 (0.0%)      CRYPTO_free_ex_data(&g_ex_data_class, bio, &bio->ex_data);
     3 (0.0%)      OPENSSL_free(bio);
     .           }
     1 (0.0%)    return 1;
     2 (0.0%)  }
     .         
     .         int BIO_up_ref(BIO *bio) {
     .           CRYPTO_refcount_inc(&bio->references);
     .           return 1;
     .         }
     .         
     .         void BIO_vfree(BIO *bio) {
     .           BIO_free(bio);
-- line 152 ----------------------------------------
-- line 202 ----------------------------------------
     .             *read_bytes = ret;
     .             return 1;
     .           } else {
     .             *read_bytes = 0;
     .             return 0;
     .           }
     .         }
     .         
25,277 (0.0%)  int BIO_gets(BIO *bio, char *buf, int len) {
39,721 (0.0%)    if (bio == NULL || bio->method == NULL || bio->method->bgets == NULL) {
     .             OPENSSL_PUT_ERROR(BIO, BIO_R_UNSUPPORTED_METHOD);
     .             return -2;
     .           }
14,444 (0.0%)    if (!bio->init) {
     .             OPENSSL_PUT_ERROR(BIO, BIO_R_UNINITIALIZED);
     .             return -2;
     .           }
 7,222 (0.0%)    if (len <= 0) {
     .             return 0;
     .           }
36,110 (0.0%)    int ret = bio->method->bgets(bio, buf, len);
 7,222 (0.0%)    if (ret > 0) {
25,270 (0.0%)      bio->num_read += ret;
     .           }
 3,611 (0.0%)    return ret;
 7,222 (0.0%)  }
     .         
     .         int BIO_write(BIO *bio, const void *in, int inl) {
     .           int ret = 0;
     .           if (bio == NULL || bio->method == NULL || bio->method->bwrite == NULL) {
     .             OPENSSL_PUT_ERROR(BIO, BIO_R_UNSUPPORTED_METHOD);
     .             return -2;
     .           }
     .           if (HAS_CALLBACK(bio)) {
-- line 235 ----------------------------------------
-- line 307 ----------------------------------------
     .           }
     .           return BIO_write(bio, in, (int)len);
     .         }
     .         
     .         int BIO_flush(BIO *bio) {
     .           return (int)BIO_ctrl(bio, BIO_CTRL_FLUSH, 0, NULL);
     .         }
     .         
     8 (0.0%)  long BIO_ctrl(BIO *bio, int cmd, long larg, void *parg) {
     2 (0.0%)    if (bio == NULL) {
     .             return 0;
     .           }
     .         
     9 (0.0%)    if (bio->method == NULL || bio->method->ctrl == NULL) {
     .             OPENSSL_PUT_ERROR(BIO, BIO_R_UNSUPPORTED_METHOD);
     .             return -2;
     .           }
     .         
     9 (0.0%)    return bio->method->ctrl(bio, cmd, larg, parg);
     2 (0.0%)  }
     .         
     .         char *BIO_ptr_ctrl(BIO *b, int cmd, long larg) {
     .           char *p = NULL;
     .         
     .           if (BIO_ctrl(b, cmd, larg, (void *)&p) <= 0) {
     .             return NULL;
     .           }
     .         
-- line 334 ----------------------------------------
-- line 470 ----------------------------------------
     .           while (last_bio->next_bio != NULL) {
     .             last_bio = last_bio->next_bio;
     .           }
     .         
     .           last_bio->next_bio = appended_bio;
     .           return bio;
     .         }
     .         
     4 (0.0%)  BIO *BIO_pop(BIO *bio) {
     .           BIO *ret;
     .         
     2 (0.0%)    if (bio == NULL) {
     .             return NULL;
     .           }
     3 (0.0%)    ret = bio->next_bio;
     2 (0.0%)    bio->next_bio = NULL;
     1 (0.0%)    return ret;
     2 (0.0%)  }
     .         
     .         BIO *BIO_next(BIO *bio) {
     .           if (!bio) {
     .             return NULL;
     .           }
     .           return bio->next_bio;
     .         }
     .         
-- line 495 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/buf/buf.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 59 ----------------------------------------
     .         #include <string.h>
     .         
     .         #include <openssl/mem.h>
     .         #include <openssl/err.h>
     .         
     .         #include "../internal.h"
     .         
     .         
 7,175 (0.0%)  BUF_MEM *BUF_MEM_new(void) { return OPENSSL_zalloc(sizeof(BUF_MEM)); }
     .         
 1,475 (0.0%)  void BUF_MEM_free(BUF_MEM *buf) {
   590 (0.0%)    if (buf == NULL) {
     .             return;
     .           }
     .         
 1,180 (0.0%)    OPENSSL_free(buf->data);
 1,180 (0.0%)    OPENSSL_free(buf);
   590 (0.0%)  }
     .         
25,164 (0.0%)  int BUF_MEM_reserve(BUF_MEM *buf, size_t cap) {
16,776 (0.0%)    if (buf->max >= cap) {
 5,738 (0.0%)      return 1;
     .           }
     .         
 3,975 (0.0%)    size_t n = cap + 3;
 3,975 (0.0%)    if (n < cap) {
     .             OPENSSL_PUT_ERROR(BUF, ERR_R_OVERFLOW);
     .             return 0;
     .           }
 7,950 (0.0%)    n = n / 3;
 3,975 (0.0%)    size_t alloc_size = n * 4;
 5,300 (0.0%)    if (alloc_size / 4 != n) {
     .             OPENSSL_PUT_ERROR(BUF, ERR_R_OVERFLOW);
     .             return 0;
     .           }
     .         
 9,275 (0.0%)    char *new_buf = OPENSSL_realloc(buf->data, alloc_size);
 2,650 (0.0%)    if (new_buf == NULL) {
     .             return 0;
     .           }
     .         
 3,975 (0.0%)    buf->data = new_buf;
 3,975 (0.0%)    buf->max = alloc_size;
 1,325 (0.0%)    return 1;
 8,388 (0.0%)  }
     .         
25,164 (0.0%)  size_t BUF_MEM_grow(BUF_MEM *buf, size_t len) {
29,358 (0.0%)    if (!BUF_MEM_reserve(buf, len)) {
     .             return 0;
     .           }
16,776 (0.0%)    if (buf->length < len) {
48,576 (0.0%)      OPENSSL_memset(&buf->data[buf->length], 0, len - buf->length);
     .           }
12,582 (0.0%)    buf->length = len;
 4,194 (0.0%)    return len;
 8,388 (0.0%)  }
     .         
     .         size_t BUF_MEM_grow_clean(BUF_MEM *buf, size_t len) {
     .           return BUF_MEM_grow(buf, len);
     .         }
     .         
     .         int BUF_MEM_append(BUF_MEM *buf, const void *in, size_t len) {
     .           // Work around a C language bug. See https://crbug.com/1019588.
     .           if (len == 0) {
-- line 122 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbb.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 19 ----------------------------------------
      .         #include <string.h>
      .         
      .         #include <openssl/mem.h>
      .         #include <openssl/err.h>
      .         
      .         #include "../internal.h"
      .         
      .         
  9,120 (0.0%)  void CBB_zero(CBB *cbb) {
  9,120 (0.0%)    OPENSSL_memset(cbb, 0, sizeof(CBB));
  5,472 (0.0%)  }
      .         
  5,460 (0.0%)  static void cbb_init(CBB *cbb, uint8_t *buf, size_t cap, int can_resize) {
  1,560 (0.0%)    cbb->is_child = 0;
  1,560 (0.0%)    cbb->child = NULL;
  2,340 (0.0%)    cbb->u.base.buf = buf;
  1,560 (0.0%)    cbb->u.base.len = 0;
  2,340 (0.0%)    cbb->u.base.cap = cap;
  7,020 (0.0%)    cbb->u.base.can_resize = can_resize;
  3,120 (0.0%)    cbb->u.base.error = 0;
  2,340 (0.0%)  }
      .         
  4,680 (0.0%)  int CBB_init(CBB *cbb, size_t initial_capacity) {
  2,340 (0.0%)    CBB_zero(cbb);
      .         
  3,120 (0.0%)    uint8_t *buf = OPENSSL_malloc(initial_capacity);
  3,120 (0.0%)    if (initial_capacity > 0 && buf == NULL) {
      .             return 0;
      .           }
      .         
  4,680 (0.0%)    cbb_init(cbb, buf, initial_capacity, /*can_resize=*/1);
    780 (0.0%)    return 1;
  1,560 (0.0%)  }
      .         
      .         int CBB_init_fixed(CBB *cbb, uint8_t *buf, size_t len) {
      .           CBB_zero(cbb);
      .           cbb_init(cbb, buf, len, /*can_resize=*/0);
      .           return 1;
      .         }
      .         
  3,900 (0.0%)  void CBB_cleanup(CBB *cbb) {
      .           // Child |CBB|s are non-owning. They are implicitly discarded and should not
      .           // be used with |CBB_cleanup| or |ScopedCBB|.
  3,120 (0.0%)    assert(!cbb->is_child);
  3,120 (0.0%)    if (cbb->is_child) {
      .             return;
      .           }
      .         
  3,900 (0.0%)    if (cbb->u.base.can_resize) {
  3,900 (0.0%)      OPENSSL_free(cbb->u.base.buf);
      .           }
  1,560 (0.0%)  }
      .         
      .         static int cbb_buffer_reserve(struct cbb_buffer_st *base, uint8_t **out,
 84,000 (0.1%)                                size_t len) {
 24,000 (0.0%)    if (base == NULL) {
      .             return 0;
      .           }
      .         
 60,000 (0.0%)    size_t newlen = base->len + len;
 48,000 (0.0%)    if (newlen < base->len) {
      .             // Overflow
      .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
      .             goto err;
      .           }
      .         
 48,000 (0.0%)    if (newlen > base->cap) {
      .             if (!base->can_resize) {
      .               OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
      .               goto err;
      .             }
      .         
      .             size_t newcap = base->cap * 2;
      .             if (newcap < base->cap || newcap < newlen) {
      .               newcap = newlen;
-- line 93 ----------------------------------------
-- line 96 ----------------------------------------
      .             if (newbuf == NULL) {
      .               goto err;
      .             }
      .         
      .             base->buf = newbuf;
      .             base->cap = newcap;
      .           }
      .         
 24,000 (0.0%)    if (out) {
 84,000 (0.1%)      *out = base->buf + base->len;
      .           }
      .         
 24,000 (0.0%)    return 1;
      .         
      .         err:
      .           base->error = 1;
      .           return 0;
 24,000 (0.0%)  }
      .         
      .         static int cbb_buffer_add(struct cbb_buffer_st *base, uint8_t **out,
 84,000 (0.1%)                            size_t len) {
 96,000 (0.1%)    if (!cbb_buffer_reserve(base, out, len)) {
      .             return 0;
      .           }
      .           // This will not overflow or |cbb_buffer_reserve| would have failed.
 72,000 (0.1%)    base->len += len;
 12,000 (0.0%)    return 1;
 24,000 (0.0%)  }
      .         
  5,460 (0.0%)  int CBB_finish(CBB *cbb, uint8_t **out_data, size_t *out_len) {
  3,120 (0.0%)    if (cbb->is_child) {
      .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
      .             return 0;
      .           }
      .         
  3,900 (0.0%)    if (!CBB_flush(cbb)) {
      .             return 0;
      .           }
      .         
  7,020 (0.0%)    if (cbb->u.base.can_resize && (out_data == NULL || out_len == NULL)) {
      .             // |out_data| and |out_len| can only be NULL if the CBB is fixed.
      .             return 0;
      .           }
      .         
  1,560 (0.0%)    if (out_data != NULL) {
  3,120 (0.0%)      *out_data = cbb->u.base.buf;
      .           }
  1,560 (0.0%)    if (out_len != NULL) {
  3,120 (0.0%)      *out_len = cbb->u.base.len;
      .           }
  1,560 (0.0%)    cbb->u.base.buf = NULL;
  2,340 (0.0%)    CBB_cleanup(cbb);
    780 (0.0%)    return 1;
  1,560 (0.0%)  }
      .         
 99,120 (0.1%)  static struct cbb_buffer_st *cbb_get_base(CBB *cbb) {
 99,120 (0.1%)    if (cbb->is_child) {
      .             return cbb->u.child.base;
      .           }
 49,560 (0.0%)    return &cbb->u.base;
 49,560 (0.0%)  }
      .         
      .         static void cbb_on_error(CBB *cbb) {
      .           // Due to C's lack of destructors and |CBB|'s auto-flushing API, a failing
      .           // |CBB|-taking function may leave a dangling pointer to a child |CBB|. As a
      .           // result, the convention is callers may not write to |CBB|s that have failed.
      .           // But, as a safety measure, we lock the |CBB| into an error state. Once the
      .           // error bit is set, |cbb->child| will not be read.
      .           //
-- line 164 ----------------------------------------
-- line 176 ----------------------------------------
      .           // warning does not know |cbb->child| will not be read once |error| is set
      .           // above.
      .           cbb->child = NULL;
      .         }
      .         
      .         // CBB_flush recurses and then writes out any pending length prefix. The
      .         // current length of the underlying base is taken to be the length of the
      .         // length-prefixed data.
 63,900 (0.0%)  int CBB_flush(CBB *cbb) {
      .           // If |base| has hit an error, the buffer is in an undefined state, so
      .           // fail all following calls. In particular, |cbb->child| may point to invalid
      .           // memory.
 51,120 (0.0%)    struct cbb_buffer_st *base = cbb_get_base(cbb);
 89,460 (0.1%)    if (base == NULL || base->error) {
      .             return 0;
      .           }
      .         
 51,120 (0.0%)    if (cbb->child == NULL) {
      .             // Nothing to flush.
 25,560 (0.0%)      return 1;
      .           }
      .         
      .           assert(cbb->child->is_child);
      .           struct cbb_child_st *child = &cbb->child->u.child;
      .           assert(child->base == base);
      .           size_t child_start = child->offset + child->pending_len_len;
      .         
      .           if (!CBB_flush(cbb->child) ||
-- line 203 ----------------------------------------
-- line 264 ----------------------------------------
      .           child->base = NULL;
      .           cbb->child = NULL;
      .         
      .           return 1;
      .         
      .         err:
      .           cbb_on_error(cbb);
      .           return 0;
 25,560 (0.0%)  }
      .         
      .         const uint8_t *CBB_data(const CBB *cbb) {
      .           assert(cbb->child == NULL);
      .           if (cbb->is_child) {
      .             return cbb->u.child.base->buf + cbb->u.child.offset +
      .                    cbb->u.child.pending_len_len;
      .           }
      .           return cbb->u.base.buf;
-- line 280 ----------------------------------------
-- line 397 ----------------------------------------
      .           uint8_t *out;
      .           if (!CBB_add_space(cbb, &out, len)) {
      .             return 0;
      .           }
      .           OPENSSL_memset(out, 0, len);
      .           return 1;
      .         }
      .         
 84,000 (0.1%)  int CBB_add_space(CBB *cbb, uint8_t **out_data, size_t len) {
 84,000 (0.1%)    if (!CBB_flush(cbb) ||
108,000 (0.1%)        !cbb_buffer_add(cbb_get_base(cbb), out_data, len)) {
      .             return 0;
      .           }
 12,000 (0.0%)    return 1;
 24,000 (0.0%)  }
      .         
      .         int CBB_reserve(CBB *cbb, uint8_t **out_data, size_t len) {
      .           if (!CBB_flush(cbb) ||
      .               !cbb_buffer_reserve(cbb_get_base(cbb), out_data, len)) {
      .             return 0;
      .           }
      .           return 1;
      .         }
-- line 419 ----------------------------------------
-- line 425 ----------------------------------------
      .               newlen < base->len ||
      .               newlen > base->cap) {
      .             return 0;
      .           }
      .           base->len = newlen;
      .           return 1;
      .         }
      .         
120,000 (0.1%)  static int cbb_add_u(CBB *cbb, uint64_t v, size_t len_len) {
      .           uint8_t *buf;
 96,000 (0.1%)    if (!CBB_add_space(cbb, &buf, len_len)) {
      .             return 0;
      .           }
      .         
132,000 (0.1%)    for (size_t i = len_len - 1; i < len_len; i--) {
 60,000 (0.0%)      buf[i] = v;
 12,000 (0.0%)      v >>= 8;
      .           }
      .         
      .           // |v| must fit in |len_len| bytes.
 24,000 (0.0%)    if (v != 0) {
      .             cbb_on_error(cbb);
      .             return 0;
      .           }
      .         
 12,000 (0.0%)    return 1;
 60,000 (0.0%)  }
      .         
 84,000 (0.1%)  int CBB_add_u8(CBB *cbb, uint8_t value) {
 72,000 (0.1%)    return cbb_add_u(cbb, value, 1);
 24,000 (0.0%)  }
      .         
      .         int CBB_add_u16(CBB *cbb, uint16_t value) {
      .           return cbb_add_u(cbb, value, 2);
      .         }
      .         
      .         int CBB_add_u16le(CBB *cbb, uint16_t value) {
      .           return CBB_add_u16(cbb, CRYPTO_bswap2(value));
      .         }
-- line 463 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/cbs.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 26 ----------------------------------------
      .         
      .         #include <string.h>
      .         
      .         #include "../asn1/internal.h"
      .         #include "../internal.h"
      .         #include "internal.h"
      .         
      .         
172,938 (0.1%)  void CBS_init(CBS *cbs, const uint8_t *data, size_t len) {
 86,469 (0.1%)    cbs->data = data;
 86,469 (0.1%)    cbs->len = len;
 86,469 (0.1%)  }
      .         
572,256 (0.4%)  static int cbs_get(CBS *cbs, const uint8_t **p, size_t n) {
381,504 (0.3%)    if (cbs->len < n) {
  4,380 (0.0%)      return 0;
      .           }
      .         
372,744 (0.3%)    *p = cbs->data;
559,116 (0.4%)    cbs->data += n;
559,116 (0.4%)    cbs->len -= n;
 93,186 (0.1%)    return 1;
190,752 (0.1%)  }
      .         
114,021 (0.1%)  int CBS_skip(CBS *cbs, size_t len) {
      .           const uint8_t *dummy;
 76,014 (0.1%)    return cbs_get(cbs, &dummy, len);
 63,345 (0.0%)  }
      .         
100,640 (0.1%)  const uint8_t *CBS_data(const CBS *cbs) { return cbs->data; }
      .         
658,296 (0.5%)  size_t CBS_len(const CBS *cbs) { return cbs->len; }
      .         
      .         int CBS_stow(const CBS *cbs, uint8_t **out_ptr, size_t *out_len) {
      .           OPENSSL_free(*out_ptr);
      .           *out_ptr = NULL;
      .           *out_len = 0;
      .         
      .           if (cbs->len == 0) {
      .             return 1;
-- line 65 ----------------------------------------
-- line 79 ----------------------------------------
      .           *out_ptr = OPENSSL_strndup((const char *)cbs->data, cbs->len);
      .           return (*out_ptr != NULL);
      .         }
      .         
      .         int CBS_contains_zero_byte(const CBS *cbs) {
      .           return OPENSSL_memchr(cbs->data, 0, cbs->len) != NULL;
      .         }
      .         
    812 (0.0%)  int CBS_mem_equal(const CBS *cbs, const uint8_t *data, size_t len) {
    464 (0.0%)    if (len != cbs->len) {
     80 (0.0%)      return 0;
      .           }
    760 (0.0%)    return CRYPTO_memcmp(cbs->data, data, len) == 0;
    232 (0.0%)  }
      .         
 12,090 (0.0%)  static int cbs_get_u(CBS *cbs, uint64_t *out, size_t len) {
  1,209 (0.0%)    uint64_t result = 0;
      .           const uint8_t *data;
      .         
  9,672 (0.0%)    if (!cbs_get(cbs, &data, len)) {
      .             return 0;
      .           }
 15,141 (0.0%)    for (size_t i = 0; i < len; i++) {
  2,274 (0.0%)      result <<= 8;
 13,644 (0.0%)      result |= data[i];
      .           }
  3,627 (0.0%)    *out = result;
  1,209 (0.0%)    return 1;
  6,045 (0.0%)  }
      .         
619,668 (0.4%)  int CBS_get_u8(CBS *cbs, uint8_t *out) {
      .           const uint8_t *v;
550,816 (0.4%)    if (!cbs_get(cbs, &v, 1)) {
  4,380 (0.0%)      return 0;
      .           }
266,648 (0.2%)    *out = *v;
 66,662 (0.0%)    return 1;
344,260 (0.2%)  }
      .         
      .         int CBS_get_u16(CBS *cbs, uint16_t *out) {
      .           uint64_t v;
      .           if (!cbs_get_u(cbs, &v, 2)) {
      .             return 0;
      .           }
      .           *out = v;
      .           return 1;
-- line 124 ----------------------------------------
-- line 172 ----------------------------------------
      .           if (cbs->len == 0) {
      .             return 0;
      .           }
      .           *out = cbs->data[cbs->len - 1];
      .           cbs->len--;
      .           return 1;
      .         }
      .         
126,460 (0.1%)  int CBS_get_bytes(CBS *cbs, CBS *out, size_t len) {
      .           const uint8_t *v;
101,168 (0.1%)    if (!cbs_get(cbs, &v, len)) {
      .             return 0;
      .           }
 75,876 (0.1%)    CBS_init(out, v, len);
 12,646 (0.0%)    return 1;
 63,230 (0.0%)  }
      .         
      .         int CBS_copy_bytes(CBS *cbs, uint8_t *out, size_t len) {
      .           const uint8_t *v;
      .           if (!cbs_get(cbs, &v, len)) {
      .             return 0;
      .           }
      .           OPENSSL_memcpy(out, v, len);
      .           return 1;
-- line 195 ----------------------------------------
-- line 272 ----------------------------------------
      .         
      .             // Values end at an octet with the high bit cleared.
      .           } while (b & 0x80);
      .         
      .           *out = v;
      .           return 1;
      .         }
      .         
113,814 (0.1%)  static int parse_asn1_tag(CBS *cbs, CBS_ASN1_TAG *out) {
      .           uint8_t tag_byte;
 88,522 (0.1%)    if (!CBS_get_u8(cbs, &tag_byte)) {
      .             return 0;
      .           }
      .         
      .           // ITU-T X.690 section 8.1.2.3 specifies the format for identifiers with a tag
      .           // number no greater than 30.
      .           //
      .           // If the number portion is 31 (0x1f, the largest value that fits in the
      .           // allotted bits), then the tag is more than one byte long and the
      .           // continuation bytes contain the tag number.
 63,230 (0.0%)    CBS_ASN1_TAG tag = ((CBS_ASN1_TAG)tag_byte & 0xe0) << CBS_ASN1_TAG_SHIFT;
 50,584 (0.0%)    CBS_ASN1_TAG tag_number = tag_byte & 0x1f;
 25,292 (0.0%)    if (tag_number == 0x1f) {
      .             uint64_t v;
      .             if (!parse_base128_integer(cbs, &v) ||
      .                 // Check the tag number is within our supported bounds.
      .                 v > CBS_ASN1_TAG_NUMBER_MASK ||
      .                 // Small tag numbers should have used low tag number form, even in BER.
      .                 v < 0x1f) {
      .               return 0;
      .             }
      .             tag_number = (CBS_ASN1_TAG)v;
      .           }
      .         
 25,292 (0.0%)    tag |= tag_number;
      .         
      .           // Tag [UNIVERSAL 0] is reserved for use by the encoding. Reject it here to
      .           // avoid some ambiguity around ANY values and BER indefinite-length EOCs. See
      .           // https://crbug.com/boringssl/455.
 50,584 (0.0%)    if ((tag & ~CBS_ASN1_CONSTRUCTED) == 0) {
      .             return 0;
      .           }
      .         
 37,938 (0.0%)    *out = tag;
 12,646 (0.0%)    return 1;
 63,230 (0.0%)  }
      .         
      .         static int cbs_get_any_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
      .                                             size_t *out_header_len, int *out_ber_found,
177,044 (0.1%)                                      int *out_indefinite, int ber_ok) {
 63,230 (0.0%)    CBS header = *cbs;
      .           CBS throwaway;
      .         
 25,292 (0.0%)    if (out == NULL) {
      .             out = &throwaway;
      .           }
 25,292 (0.0%)    if (ber_ok) {
 23,196 (0.0%)      *out_ber_found = 0;
 34,794 (0.0%)      *out_indefinite = 0;
      .           } else {
  2,096 (0.0%)      assert(out_ber_found == NULL);
  2,096 (0.0%)      assert(out_indefinite == NULL);
      .           }
      .         
      .           CBS_ASN1_TAG tag;
 88,522 (0.1%)    if (!parse_asn1_tag(&header, &tag)) {
      .             return 0;
      .           }
 25,292 (0.0%)    if (out_tag != NULL) {
 37,938 (0.0%)      *out_tag = tag;
      .           }
      .         
      .           uint8_t length_byte;
 88,522 (0.1%)    if (!CBS_get_u8(&header, &length_byte)) {
      .             return 0;
      .           }
      .         
126,460 (0.1%)    size_t header_len = CBS_len(cbs) - CBS_len(&header);
      .         
      .           size_t len;
      .           // The format for the length encoding is specified in ITU-T X.690 section
      .           // 8.1.3.
 37,938 (0.0%)    if ((length_byte & 0x80) == 0) {
      .             // Short form length.
 57,185 (0.0%)      len = ((size_t)length_byte) + header_len;
 22,874 (0.0%)      if (out_header_len != NULL) {
 45,748 (0.0%)        *out_header_len = header_len;
      .             }
      .           } else {
      .             // The high bit indicate that this is the long form, while the next 7 bits
      .             // encode the number of subsequent octets used to encode the length (ITU-T
      .             // X.690 clause 8.1.3.5.b).
  4,836 (0.0%)      const size_t num_bytes = length_byte & 0x7f;
      .             uint64_t len64;
      .         
  6,664 (0.0%)      if (ber_ok && (tag & CBS_ASN1_CONSTRUCTED) != 0 && num_bytes == 0) {
      .               // indefinite length
      .               if (out_header_len != NULL) {
      .                 *out_header_len = header_len;
      .               }
      .               *out_ber_found = 1;
      .               *out_indefinite = 1;
      .               return CBS_get_bytes(cbs, out, header_len);
      .             }
      .         
      .             // ITU-T X.690 clause 8.1.3.5.c specifies that the value 0xff shall not be
      .             // used as the first byte of the length. If this parser encounters that
      .             // value, num_bytes will be parsed as 127, which will fail this check.
  4,836 (0.0%)      if (num_bytes == 0 || num_bytes > 4) {
      .               return 0;
      .             }
  9,672 (0.0%)      if (!cbs_get_u(&header, &len64, num_bytes)) {
      .               return 0;
      .             }
      .             // ITU-T X.690 section 10.1 (DER length forms) requires encoding the
      .             // length with the minimum number of octets. BER could, technically, have
      .             // 125 superfluous zero bytes. We do not attempt to handle that and still
      .             // require that the length fit in a |uint32_t| for BER.
  3,627 (0.0%)      if (len64 < 128) {
      .               // Length should have used short-form encoding.
      .               if (ber_ok) {
      .                 *out_ber_found = 1;
      .               } else {
      .                 return 0;
      .               }
      .             }
 10,881 (0.0%)      if ((len64 >> ((num_bytes - 1) * 8)) == 0) {
      .               // Length should have been at least one byte shorter.
      .               if (ber_ok) {
      .                 *out_ber_found = 1;
      .               } else {
      .                 return 0;
      .               }
      .             }
  2,418 (0.0%)      len = len64;
  8,463 (0.0%)      if (len + header_len + num_bytes < len) {
      .               // Overflow.
      .               return 0;
      .             }
  4,836 (0.0%)      len += header_len + num_bytes;
  2,418 (0.0%)      if (out_header_len != NULL) {
  6,045 (0.0%)        *out_header_len = header_len + num_bytes;
      .             }
      .           }
      .         
 75,876 (0.1%)    return CBS_get_bytes(cbs, out, len);
 75,876 (0.1%)  }
      .         
      .         int CBS_get_any_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag) {
      .           size_t header_len;
      .           if (!CBS_get_any_asn1_element(cbs, out, out_tag, &header_len)) {
      .             return 0;
      .           }
      .         
      .           if (!CBS_skip(out, header_len)) {
-- line 426 ----------------------------------------
-- line 427 ----------------------------------------
      .             assert(0);
      .             return 0;
      .           }
      .         
      .           return 1;
      .         }
      .         
      .         int CBS_get_any_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
  8,384 (0.0%)                               size_t *out_header_len) {
 11,528 (0.0%)    return cbs_get_any_asn1_element(cbs, out, out_tag, out_header_len, NULL, NULL,
      .                                           /*ber_ok=*/0);
  2,096 (0.0%)  }
      .         
      .         int CBS_get_any_ber_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG *out_tag,
      .                                          size_t *out_header_len, int *out_ber_found,
150,774 (0.1%)                                   int *out_indefinite) {
      .           int ber_found_temp;
173,970 (0.1%)    return cbs_get_any_asn1_element(
      .               cbs, out, out_tag, out_header_len,
      .               out_ber_found ? out_ber_found : &ber_found_temp, out_indefinite,
      .               /*ber_ok=*/1);
 57,990 (0.0%)  }
      .         
      .         static int cbs_get_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value,
 11,528 (0.0%)                          int skip_header) {
      .           size_t header_len;
      .           CBS_ASN1_TAG tag;
      .           CBS throwaway;
      .         
  2,096 (0.0%)    if (out == NULL) {
      .             out = &throwaway;
      .           }
      .         
 10,480 (0.0%)    if (!CBS_get_any_asn1_element(cbs, out, &tag, &header_len) ||
  1,048 (0.0%)        tag != tag_value) {
      .             return 0;
      .           }
      .         
  9,432 (0.0%)    if (skip_header && !CBS_skip(out, header_len)) {
      .             assert(0);
      .             return 0;
      .           }
      .         
  1,048 (0.0%)    return 1;
  5,240 (0.0%)  }
      .         
  7,336 (0.0%)  int CBS_get_asn1(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value) {
  6,288 (0.0%)    return cbs_get_asn1(cbs, out, tag_value, 1 /* skip header */);
  2,096 (0.0%)  }
      .         
      .         int CBS_get_asn1_element(CBS *cbs, CBS *out, CBS_ASN1_TAG tag_value) {
      .           return cbs_get_asn1(cbs, out, tag_value, 0 /* include header */);
      .         }
      .         
      .         int CBS_peek_asn1_tag(const CBS *cbs, CBS_ASN1_TAG tag_value) {
      .           CBS copy = *cbs;
      .           CBS_ASN1_TAG actual_tag;
-- line 483 ----------------------------------------
-- line 670 ----------------------------------------
      .         
      .           // Unused bits are zero, and this function does not distinguish between
      .           // missing and unset bits. Thus it is sufficient to do a byte-level length
      .           // check.
      .           return byte_num < CBS_len(cbs) &&
      .                  (CBS_data(cbs)[byte_num] & (1 << bit_num)) != 0;
      .         }
      .         
  4,536 (0.0%)  int CBS_is_valid_asn1_integer(const CBS *cbs, int *out_is_negative) {
  2,520 (0.0%)    CBS copy = *cbs;
      .           uint8_t first_byte, second_byte;
  3,528 (0.0%)    if (!CBS_get_u8(&copy, &first_byte)) {
      .             return 0;  // INTEGERs may not be empty.
      .           }
  1,008 (0.0%)    if (out_is_negative != NULL) {
  2,520 (0.0%)      *out_is_negative = (first_byte & 0x80) != 0;
      .           }
  3,528 (0.0%)    if (!CBS_get_u8(&copy, &second_byte)) {
    330 (0.0%)      return 1;  // One byte INTEGERs are always minimal.
      .           }
  2,058 (0.0%)    if ((first_byte == 0x00 && (second_byte & 0x80) == 0) ||
    339 (0.0%)        (first_byte == 0xff && (second_byte & 0x80) != 0)) {
      .             return 0;  // The value is minimal iff the first 9 bits are not all equal.
      .           }
    339 (0.0%)    return 1;
  2,520 (0.0%)  }
      .         
      .         int CBS_is_unsigned_asn1_integer(const CBS *cbs) {
      .           int is_negative;
      .           return CBS_is_valid_asn1_integer(cbs, &is_negative) && !is_negative;
      .         }
      .         
      .         static int add_decimal(CBB *out, uint64_t v) {
      .           char buf[DECIMAL_SIZE(uint64_t) + 1];
      .           snprintf(buf, sizeof(buf), "%" PRIu64, v);
      .           return CBB_add_bytes(out, (const uint8_t *)buf, strlen(buf));
      .         }
      .         
 16,200 (0.0%)  int CBS_is_valid_asn1_oid(const CBS *cbs) {
 10,125 (0.0%)    if (CBS_len(cbs) == 0) {
      .             return 0;  // OID encodings cannot be empty.
      .           }
      .         
 10,125 (0.0%)    CBS copy = *cbs;
  2,025 (0.0%)    uint8_t v, prev = 0;
 77,275 (0.1%)    while (CBS_get_u8(&copy, &v)) {
      .             // OID encodings are a sequence of minimally-encoded base-128 integers (see
      .             // |parse_base128_integer|). If |prev|'s MSB was clear, it was the last byte
      .             // of an integer (or |v| is the first byte). |v| is then the first byte of
      .             // the next integer. If first byte of an integer is 0x80, it is not
      .             // minimally-encoded.
 48,570 (0.0%)      if ((prev & 0x80) == 0 && v == 0x80) {
      .               return 0;
      .             }
 17,450 (0.0%)      prev = v;
      .           }
      .         
      .           // The last byte should must end an integer encoding.
  8,100 (0.0%)    return (prev & 0x80) == 0;
 10,125 (0.0%)  }
      .         
      .         char *CBS_asn1_oid_to_text(const CBS *cbs) {
      .           CBB cbb;
      .           if (!CBB_init(&cbb, 32)) {
      .             goto err;
      .           }
      .         
      .           CBS copy = *cbs;
-- line 737 ----------------------------------------
-- line 766 ----------------------------------------
      .         
      .           return (char *)txt;
      .         
      .         err:
      .           CBB_cleanup(&cbb);
      .           return NULL;
      .         }
      .         
 15,786 (0.0%)  static int cbs_get_two_digits(CBS *cbs, int *out) {
      .           uint8_t first_digit, second_digit;
 12,278 (0.0%)    if (!CBS_get_u8(cbs, &first_digit)) {
      .             return 0;
      .           }
 10,524 (0.0%)    if (!OPENSSL_isdigit(first_digit)) {
      .             return 0;
      .           }
 12,278 (0.0%)    if (!CBS_get_u8(cbs, &second_digit)) {
      .             return 0;
      .           }
 10,524 (0.0%)    if (!OPENSSL_isdigit(second_digit)) {
      .             return 0;
      .           }
 24,556 (0.0%)    *out = (first_digit - '0') * 10 + (second_digit - '0');
  1,754 (0.0%)    return 1;
  8,770 (0.0%)  }
      .         
  1,752 (0.0%)  static int is_valid_day(int year, int month, int day) {
    584 (0.0%)    if (day < 1) {
      .             return 0;
      .           }
  5,180 (0.0%)    switch (month) {
      .             case 1:
      .             case 3:
      .             case 5:
      .             case 7:
      .             case 8:
      .             case 10:
      .             case 12:
    728 (0.0%)        return day <= 31;
      .             case 4:
      .             case 6:
      .             case 9:
      .             case 11:
    328 (0.0%)        return day <= 30;
      .             case 2:
    476 (0.0%)        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
     24 (0.0%)          return day <= 29;
      .               } else {
     88 (0.0%)          return day <= 28;
      .               }
      .             default:
      .               return 0;
      .           }
    584 (0.0%)  }
      .         
      .         static int CBS_parse_rfc5280_time_internal(const CBS *cbs, int is_gentime,
      .                                                    int allow_timezone_offset,
  3,212 (0.0%)                                             struct tm *out_tm) {
      .           int year, month, day, hour, min, sec, tmp;
  1,460 (0.0%)    CBS copy = *cbs;
      .           uint8_t tz;
      .         
    584 (0.0%)    if (is_gentime) {
     14 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
      .               return 0;
      .             }
      6 (0.0%)      year = tmp * 100;
     14 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
      .               return 0;
      .             }
      6 (0.0%)      year += tmp;
      .           } else {
    290 (0.0%)      year = 1900;
  2,030 (0.0%)      if (!cbs_get_two_digits(&copy, &tmp)) {
      .               return 0;
      .             }
    580 (0.0%)      year += tmp;
    580 (0.0%)      if (year < 1950) {
    288 (0.0%)        year += 100;
      .             }
    580 (0.0%)      if (year >= 2050) {
      .               return 0;  // A Generalized time must be used.
      .             }
      .           }
  3,504 (0.0%)    if (!cbs_get_two_digits(&copy, &month) || month < 1 ||
    876 (0.0%)        month > 12 ||  // Reject invalid months.
  2,044 (0.0%)        !cbs_get_two_digits(&copy, &day) ||
  2,336 (0.0%)        !is_valid_day(year, month, day) ||  // Reject invalid days.
  2,044 (0.0%)        !cbs_get_two_digits(&copy, &hour) ||
    876 (0.0%)        hour > 23 ||  // Reject invalid hours.
  2,044 (0.0%)        !cbs_get_two_digits(&copy, &min) ||
    876 (0.0%)        min > 59 ||  // Reject invalid minutes.
  4,380 (0.0%)        !cbs_get_two_digits(&copy, &sec) || sec > 59 || !CBS_get_u8(&copy, &tz)) {
      .             return 0;
      .           }
      .         
    292 (0.0%)    int offset_sign = 0;
  1,168 (0.0%)    switch (tz) {
      .             case 'Z':
    292 (0.0%)        break;  // We correctly have 'Z' on the end as per spec.
      .             case '+':
      .               offset_sign = 1;
      .               break;  // Should not be allowed per RFC 5280.
      .             case '-':
      .               offset_sign = -1;
      .               break;  // Should not be allowed per RFC 5280.
      .             default:
      .               return 0;  // Reject anything else after the time.
-- line 873 ----------------------------------------
-- line 880 ----------------------------------------
      .           // are now difficult to change. These certificates were generated with the
      .           // 'openssl' command that permissively allowed the creation of certificates
      .           // with notBefore and notAfter times specified as strings for direct
      .           // certificate inclusion on the command line. For context see cl/237068815.
      .           //
      .           // TODO(bbe): This has been expunged from public web-pki as the ecosystem has
      .           // managed to encourage CA compliance with standards. We should find a way to
      .           // get rid of this or make it off by default.
    292 (0.0%)    int offset_seconds = 0;
    584 (0.0%)    if (offset_sign != 0) {
      .             if (!allow_timezone_offset) {
      .               return 0;
      .             }
      .             int offset_hours, offset_minutes;
      .             if (!cbs_get_two_digits(&copy, &offset_hours) ||
      .                 offset_hours > 23 ||  // Reject invalid hours.
      .                 !cbs_get_two_digits(&copy, &offset_minutes) ||
      .                 offset_minutes > 59) {  // Reject invalid minutes.
      .               return 0;
      .             }
      .             offset_seconds = offset_sign * (offset_hours * 3600 + offset_minutes * 60);
      .           }
      .         
  1,460 (0.0%)    if (CBS_len(&copy) != 0) {
      .             return 0;  // Reject invalid lengths.
      .           }
      .         
    584 (0.0%)    if (out_tm != NULL) {
      .             // Fill in the tm fields corresponding to what we validated.
      .             out_tm->tm_year = year - 1900;
      .             out_tm->tm_mon = month - 1;
      .             out_tm->tm_mday = day;
      .             out_tm->tm_hour = hour;
      .             out_tm->tm_min = min;
      .             out_tm->tm_sec = sec;
      .             if (offset_seconds && !OPENSSL_gmtime_adj(out_tm, 0, offset_seconds)) {
      .               return 0;
      .             }
      .           }
    292 (0.0%)    return 1;
  1,460 (0.0%)  }
      .         
      .         int CBS_parse_generalized_time(const CBS *cbs, struct tm *out_tm,
     14 (0.0%)                                 int allow_timezone_offset) {
     12 (0.0%)    return CBS_parse_rfc5280_time_internal(cbs, 1, allow_timezone_offset, out_tm);
      4 (0.0%)  }
      .         
      .         int CBS_parse_utc_time(const CBS *cbs, struct tm *out_tm,
  2,030 (0.0%)                         int allow_timezone_offset) {
  1,740 (0.0%)    return CBS_parse_rfc5280_time_internal(cbs, 0, allow_timezone_offset, out_tm);
    580 (0.0%)  }
      .         
      .         int CBS_get_optional_asn1_int64(CBS *cbs, int64_t *out, CBS_ASN1_TAG tag,
      .                                         int64_t default_value) {
      .           CBS child;
      .           int present;
      .           if (!CBS_get_optional_asn1(cbs, &child, &present, tag)) {
      .             return 0;
      .           }
-- line 938 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/bytestring/unicode.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 12 ----------------------------------------
      .          * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
      .          * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
      .         
      .         #include <openssl/bytestring.h>
      .         
      .         #include "internal.h"
      .         
      .         
 44,944 (0.0%)  static int is_valid_code_point(uint32_t v) {
      .           // References in the following are to Unicode 9.0.0.
 22,472 (0.0%)    if (// The Unicode space runs from zero to 0x10ffff (3.4 D9).
 22,472 (0.0%)        v > 0x10ffff ||
      .               // Values 0x...fffe, 0x...ffff, and 0xfdd0-0xfdef are permanently reserved
      .               // (3.4 D14)
 44,944 (0.0%)        (v & 0xfffe) == 0xfffe ||
 22,472 (0.0%)        (v >= 0xfdd0 && v <= 0xfdef) ||
      .               // Surrogate code points are invalid (3.2 C1).
      .               (v >= 0xd800 && v <= 0xdfff)) {
      .             return 0;
      .           }
 11,236 (0.0%)    return 1;
 22,472 (0.0%)  }
      .         
      .         // BOTTOM_BITS returns a byte with the bottom |n| bits set.
      .         #define BOTTOM_BITS(n) (uint8_t)((1u << (n)) - 1)
      .         
      .         // TOP_BITS returns a byte with the top |n| bits set.
      .         #define TOP_BITS(n) ((uint8_t)~BOTTOM_BITS(8 - (n)))
      .         
 48,600 (0.0%)  int cbs_get_utf8(CBS *cbs, uint32_t *out) {
      .           uint8_t c;
 37,800 (0.0%)    if (!CBS_get_u8(cbs, &c)) {
      .             return 0;
      .           }
 16,200 (0.0%)    if (c <= 0x7f) {
 21,536 (0.0%)      *out = c;
 10,768 (0.0%)      return 1;
      .           }
      .           uint32_t v, lower_bound;
      .           size_t len;
     80 (0.0%)    if ((c & TOP_BITS(3)) == TOP_BITS(2)) {
     64 (0.0%)      v = c & BOTTOM_BITS(5);
     16 (0.0%)      len = 1;
     32 (0.0%)      lower_bound = 0x80;
      .           } else if ((c & TOP_BITS(4)) == TOP_BITS(3)) {
      .             v = c & BOTTOM_BITS(4);
      .             len = 2;
      .             lower_bound = 0x800;
      .           } else if ((c & TOP_BITS(5)) == TOP_BITS(4)) {
      .             v = c & BOTTOM_BITS(3);
      .             len = 3;
      .             lower_bound = 0x10000;
      .           } else {
      .             return 0;
      .           }
    144 (0.0%)    for (size_t i = 0; i < len; i++) {
    144 (0.0%)      if (!CBS_get_u8(cbs, &c) ||
     48 (0.0%)          (c & TOP_BITS(2)) != TOP_BITS(1)) {
      .               return 0;
      .             }
     16 (0.0%)      v <<= 6;
     64 (0.0%)      v |= c & BOTTOM_BITS(6);
      .           }
    128 (0.0%)    if (!is_valid_code_point(v) ||
      .               v < lower_bound) {
      .             return 0;
      .           }
     48 (0.0%)    *out = v;
     16 (0.0%)    return 1;
 27,000 (0.0%)  }
      .         
201,960 (0.1%)  int cbs_get_latin1(CBS *cbs, uint32_t *out) {
      .           uint8_t c;
157,080 (0.1%)    if (!CBS_get_u8(cbs, &c)) {
      .             return 0;
      .           }
 89,760 (0.1%)    *out = c;
 22,440 (0.0%)    return 1;
112,200 (0.1%)  }
      .         
      .         int cbs_get_ucs2_be(CBS *cbs, uint32_t *out) {
      .           // Note UCS-2 (used by BMPString) does not support surrogates.
      .           uint16_t c;
      .           if (!CBS_get_u16(cbs, &c) ||
      .               !is_valid_code_point(c)) {
      .             return 0;
      .           }
-- line 98 ----------------------------------------
-- line 99 ----------------------------------------
      .           *out = c;
      .           return 1;
      .         }
      .         
      .         int cbs_get_utf32_be(CBS *cbs, uint32_t *out) {
      .           return CBS_get_u32(cbs, out) && is_valid_code_point(*out);
      .         }
      .         
 66,480 (0.0%)  size_t cbb_get_utf8_len(uint32_t u) {
 33,240 (0.0%)    if (u <= 0x7f) {
 33,208 (0.0%)      return 1;
      .           }
     32 (0.0%)    if (u <= 0x7ff) {
     32 (0.0%)      return 2;
      .           }
      .           if (u <= 0xffff) {
      .             return 3;
      .           }
      .           return 4;
 33,240 (0.0%)  }
      .         
 67,320 (0.0%)  int cbb_add_utf8(CBB *cbb, uint32_t u) {
 56,100 (0.0%)    if (!is_valid_code_point(u)) {
      .             return 0;
      .           }
 22,440 (0.0%)    if (u <= 0x7f) {
 78,540 (0.1%)      return CBB_add_u8(cbb, (uint8_t)u);
      .           }
      .           if (u <= 0x7ff) {
      .             return CBB_add_u8(cbb, TOP_BITS(2) | (u >> 6)) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | (u & BOTTOM_BITS(6)));
      .           }
      .           if (u <= 0xffff) {
      .             return CBB_add_u8(cbb, TOP_BITS(3) | (u >> 12)) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | ((u >> 6) & BOTTOM_BITS(6))) &&
-- line 133 ----------------------------------------
-- line 135 ----------------------------------------
      .           }
      .           if (u <= 0x10ffff) {
      .             return CBB_add_u8(cbb, TOP_BITS(4) | (u >> 18)) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | ((u >> 12) & BOTTOM_BITS(6))) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | ((u >> 6) & BOTTOM_BITS(6))) &&
      .                    CBB_add_u8(cbb, TOP_BITS(1) | (u & BOTTOM_BITS(6)));
      .           }
      .           return 0;
 22,440 (0.0%)  }
      .         
      .         int cbb_add_latin1(CBB *cbb, uint32_t u) {
      .           return u <= 0xff && CBB_add_u8(cbb, (uint8_t)u);
      .         }
      .         
      .         int cbb_add_ucs2_be(CBB *cbb, uint32_t u) {
      .           return u <= 0xffff && is_valid_code_point(u) && CBB_add_u16(cbb, (uint16_t)u);
      .         }
-- line 151 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/fipsmodule/../internal.h
--------------------------------------------------------------------------------
Ir____________ 

-- line 293 ----------------------------------------
      .         
      .         // value_barrier_w returns |a|, but prevents GCC and Clang from reasoning about
      .         // the returned value. This is used to mitigate compilers undoing constant-time
      .         // code, until we can express our requirements directly in the language.
      .         //
      .         // Note the compiler is aware that |value_barrier_w| has no side effects and
      .         // always has the same output for a given input. This allows it to eliminate
      .         // dead code, move computations across loops, and vectorize.
  8,352 (0.0%)  static inline crypto_word_t value_barrier_w(crypto_word_t a) {
      .         #if defined(__GNUC__) || defined(__clang__)
  5,568 (0.0%)    __asm__("" : "+r"(a) : /* no inputs */);
      .         #endif
  2,784 (0.0%)    return a;
  5,568 (0.0%)  }
      .         
      .         // value_barrier_u32 behaves like |value_barrier_w| but takes a |uint32_t|.
      .         static inline uint32_t value_barrier_u32(uint32_t a) {
      .         #if defined(__GNUC__) || defined(__clang__)
      .           __asm__("" : "+r"(a) : /* no inputs */);
      .         #endif
      .           return a;
      .         }
-- line 314 ----------------------------------------
-- line 318 ----------------------------------------
      .         #if defined(__GNUC__) || defined(__clang__)
      .           __asm__("" : "+r"(a) : /* no inputs */);
      .         #endif
      .           return a;
      .         }
      .         
      .         // constant_time_msb_w returns the given value with the MSB copied to all the
      .         // other bits.
  2,784 (0.0%)  static inline crypto_word_t constant_time_msb_w(crypto_word_t a) {
  1,856 (0.0%)    return 0u - (a >> (sizeof(a) * 8 - 1));
  1,856 (0.0%)  }
      .         
      .         // constant_time_lt_w returns 0xff..f if a < b and 0 otherwise.
      .         static inline crypto_word_t constant_time_lt_w(crypto_word_t a,
  2,320 (0.0%)                                                 crypto_word_t b) {
      .           // Consider the two cases of the problem:
      .           //   msb(a) == msb(b): a < b iff the MSB of a - b is set.
      .           //   msb(a) != msb(b): a < b iff the MSB of b is set.
      .           //
      .           // If msb(a) == msb(b) then the following evaluates as:
      .           //   msb(a^((a^b)|((a-b)^a))) ==
      .           //   msb(a^((a-b) ^ a))       ==   (because msb(a^b) == 0)
      .           //   msb(a^a^(a-b))           ==   (rearranging)
-- line 340 ----------------------------------------
-- line 355 ----------------------------------------
      .           // )
      .           //
      .           // (declare-fun a () (_ BitVec 32))
      .           // (declare-fun b () (_ BitVec 32))
      .           //
      .           // (assert (not (= (= #x00000001 (bvlshr (lt a b) #x0000001f)) (bvult a b))))
      .           // (check-sat)
      .           // (get-model)
  4,640 (0.0%)    return constant_time_msb_w(a^((a^b)|((a-b)^a)));
    928 (0.0%)  }
      .         
      .         // constant_time_lt_8 acts like |constant_time_lt_w| but returns an 8-bit
      .         // mask.
      .         static inline uint8_t constant_time_lt_8(crypto_word_t a, crypto_word_t b) {
      .           return (uint8_t)(constant_time_lt_w(a, b));
      .         }
      .         
      .         // constant_time_ge_w returns 0xff..f if a >= b and 0 otherwise.
-- line 372 ----------------------------------------
-- line 377 ----------------------------------------
      .         
      .         // constant_time_ge_8 acts like |constant_time_ge_w| but returns an 8-bit
      .         // mask.
      .         static inline uint8_t constant_time_ge_8(crypto_word_t a, crypto_word_t b) {
      .           return (uint8_t)(constant_time_ge_w(a, b));
      .         }
      .         
      .         // constant_time_is_zero returns 0xff..f if a == 0 and 0 otherwise.
  1,856 (0.0%)  static inline crypto_word_t constant_time_is_zero_w(crypto_word_t a) {
      .           // Here is an SMT-LIB verification of this formula:
      .           //
      .           // (define-fun is_zero ((a (_ BitVec 32))) (_ BitVec 32)
      .           //   (bvand (bvnot a) (bvsub a #x00000001))
      .           // )
      .           //
      .           // (declare-fun a () (_ BitVec 32))
      .           //
      .           // (assert (not (= (= #x00000001 (bvlshr (is_zero a) #x0000001f)) (= a #x00000000))))
      .           // (check-sat)
      .           // (get-model)
  3,712 (0.0%)    return constant_time_msb_w(~a & (a - 1));
    928 (0.0%)  }
      .         
      .         // constant_time_is_zero_8 acts like |constant_time_is_zero_w| but returns an
      .         // 8-bit mask.
      .         static inline uint8_t constant_time_is_zero_8(crypto_word_t a) {
      .           return (uint8_t)(constant_time_is_zero_w(a));
      .         }
      .         
      .         // constant_time_eq_w returns 0xff..f if a == b and 0 otherwise.
      .         static inline crypto_word_t constant_time_eq_w(crypto_word_t a,
  2,320 (0.0%)                                                 crypto_word_t b) {
  1,856 (0.0%)    return constant_time_is_zero_w(a ^ b);
    928 (0.0%)  }
      .         
      .         // constant_time_eq_8 acts like |constant_time_eq_w| but returns an 8-bit
      .         // mask.
      .         static inline uint8_t constant_time_eq_8(crypto_word_t a, crypto_word_t b) {
      .           return (uint8_t)(constant_time_eq_w(a, b));
      .         }
      .         
      .         // constant_time_eq_int acts like |constant_time_eq_w| but works on int
-- line 418 ----------------------------------------
-- line 427 ----------------------------------------
      .           return constant_time_eq_8((crypto_word_t)(a), (crypto_word_t)(b));
      .         }
      .         
      .         // constant_time_select_w returns (mask & a) | (~mask & b). When |mask| is all
      .         // 1s or all 0s (as returned by the methods above), the select methods return
      .         // either |a| (if |mask| is nonzero) or |b| (if |mask| is zero).
      .         static inline crypto_word_t constant_time_select_w(crypto_word_t mask,
      .                                                            crypto_word_t a,
  9,744 (0.0%)                                                     crypto_word_t b) {
      .           // Clang recognizes this pattern as a select. While it usually transforms it
      .           // to a cmov, it sometimes further transforms it into a branch, which we do
      .           // not want.
      .           //
      .           // Adding barriers to both |mask| and |~mask| breaks the relationship between
      .           // the two, which makes the compiler stick with bitmasks.
 15,312 (0.0%)    return (value_barrier_w(mask) & a) | (value_barrier_w(~mask) & b);
  4,176 (0.0%)  }
      .         
      .         // constant_time_select_8 acts like |constant_time_select| but operates on
      .         // 8-bit values.
      .         static inline uint8_t constant_time_select_8(uint8_t mask, uint8_t a,
      .                                                      uint8_t b) {
      .           return (uint8_t)(constant_time_select_w(mask, a, b));
      .         }
      .         
      .         // constant_time_select_int acts like |constant_time_select| but operates on
      .         // ints.
  5,568 (0.0%)  static inline int constant_time_select_int(crypto_word_t mask, int a, int b) {
  7,424 (0.0%)    return (int)(constant_time_select_w(mask, (crypto_word_t)(a),
      .                                               (crypto_word_t)(b)));
  1,856 (0.0%)  }
      .         
      .         #if defined(BORINGSSL_CONSTANT_TIME_VALIDATION)
      .         
      .         // CONSTTIME_SECRET takes a pointer and a number of bytes and marks that region
      .         // of memory as secret. Secret data is tracked as it flows to registers and
      .         // other parts of a memory. If secret data is used as a condition for a branch,
      .         // or as a memory index, it will trigger warnings in valgrind.
      .         #define CONSTTIME_SECRET(ptr, len) VALGRIND_MAKE_MEM_UNDEFINED(ptr, len)
-- line 465 ----------------------------------------
-- line 800 ----------------------------------------
      .         static inline uint64_t CRYPTO_bswap8(uint64_t x) {
      .           return _byteswap_uint64(x);
      .         }
      .         #else
      .         static inline uint16_t CRYPTO_bswap2(uint16_t x) {
      .           return (x >> 8) | (x << 8);
      .         }
      .         
 35,232 (0.0%)  static inline uint32_t CRYPTO_bswap4(uint32_t x) {
 11,744 (0.0%)    x = (x >> 16) | (x << 16);
105,696 (0.1%)    x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);
 11,744 (0.0%)    return x;
 23,488 (0.0%)  }
      .         
 29,360 (0.0%)  static inline uint64_t CRYPTO_bswap8(uint64_t x) {
 64,592 (0.0%)    return CRYPTO_bswap4(x >> 32) | (((uint64_t)CRYPTO_bswap4(x)) << 32);
 17,616 (0.0%)  }
      .         #endif
      .         
      .         
      .         // Language bug workarounds.
      .         //
      .         // Most C standard library functions are undefined if passed NULL, even when the
      .         // corresponding length is zero. This gives them (and, in turn, all functions
      .         // which call them) surprising behavior on empty arrays. Some compilers will
-- line 824 ----------------------------------------
-- line 866 ----------------------------------------
      .         static inline int OPENSSL_memcmp(const void *s1, const void *s2, size_t n) {
      .           if (n == 0) {
      .             return 0;
      .           }
      .         
      .           return memcmp(s1, s2, n);
      .         }
      .         
 37,224 (0.0%)  static inline void *OPENSSL_memcpy(void *dst, const void *src, size_t n) {
 12,408 (0.0%)    if (n == 0) {
    424 (0.0%)      return dst;
      .           }
      .         
 35,952 (0.0%)    return memcpy(dst, src, n);
 12,408 (0.0%)  }
      .         
      .         static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
      .           if (n == 0) {
      .             return dst;
      .           }
      .         
      .           return memmove(dst, src, n);
      .         }
      .         
  2,712 (0.0%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
    904 (0.0%)    if (n == 0) {
    424 (0.0%)      return dst;
      .           }
      .         
  1,440 (0.0%)    return memset(dst, c, n);
    904 (0.0%)  }
      .         
      .         
      .         // Loads and stores.
      .         //
      .         // The following functions load and store sized integers with the specified
      .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
      .         // requirements on the input and output pointers.
      .         
-- line 904 ----------------------------------------
-- line 1026 ----------------------------------------
      .         
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           v = CRYPTO_bswap_word(v);
      .         #endif
      .           OPENSSL_memcpy(out, &v, sizeof(v));
      .         
      .         }
      .         
 41,104 (0.0%)  static inline crypto_word_t CRYPTO_load_word_be(const void *in) {
      .           crypto_word_t v;
 35,232 (0.0%)    OPENSSL_memcpy(&v, in, sizeof(v));
      .         #if defined(OPENSSL_BIG_ENDIAN)
      .           return v;
      .         #else
      .         #if defined(OPENSSL_64_BIT)
      .           assert(sizeof(v) == 8);
 17,616 (0.0%)    return CRYPTO_bswap8(v);
      .         #else
      .           assert(sizeof(v) == 4);
      .           return CRYPTO_bswap4(v);
      .         #endif
      .         #endif
 29,360 (0.0%)  }
      .         
      .         // Bit rotation functions.
      .         //
      .         // Note these functions use |(-shift) & 31|, etc., because shifting by the bit
      .         // width is undefined. Both Clang and GCC recognize this pattern as a rotation,
      .         // but MSVC does not. Instead, we call MSVC's built-in functions.
      .         
      .         static inline uint32_t CRYPTO_rotl_u32(uint32_t value, int shift) {
-- line 1056 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/internal.h
--------------------------------------------------------------------------------
Ir____________ 

-- line 866 ----------------------------------------
      .         static inline int OPENSSL_memcmp(const void *s1, const void *s2, size_t n) {
      .           if (n == 0) {
      .             return 0;
      .           }
      .         
      .           return memcmp(s1, s2, n);
      .         }
      .         
 21,042 (0.0%)  static inline void *OPENSSL_memcpy(void *dst, const void *src, size_t n) {
  7,014 (0.0%)    if (n == 0) {
      .             return dst;
      .           }
      .         
 21,042 (0.0%)    return memcpy(dst, src, n);
  7,014 (0.0%)  }
      .         
      .         static inline void *OPENSSL_memmove(void *dst, const void *src, size_t n) {
      .           if (n == 0) {
      .             return dst;
      .           }
      .         
      .           return memmove(dst, src, n);
      .         }
      .         
199,878 (0.1%)  static inline void *OPENSSL_memset(void *dst, int c, size_t n) {
 66,626 (0.0%)    if (n == 0) {
      .             return dst;
      .           }
      .         
199,878 (0.1%)    return memset(dst, c, n);
 66,626 (0.0%)  }
      .         
      .         
      .         // Loads and stores.
      .         //
      .         // The following functions load and store sized integers with the specified
      .         // endianness. They use |memcpy|, and so avoid alignment or strict aliasing
      .         // requirements on the input and output pointers.
      .         
-- line 904 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/mem.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 77 ----------------------------------------
      .         #define OPENSSL_MALLOC_PREFIX 8
      .         OPENSSL_STATIC_ASSERT(OPENSSL_MALLOC_PREFIX >= sizeof(size_t),
      .                               size_t_too_large)
      .         
      .         #if defined(OPENSSL_ASAN)
      .         void __asan_poison_memory_region(const volatile void *addr, size_t size);
      .         void __asan_unpoison_memory_region(const volatile void *addr, size_t size);
      .         #else
239,136 (0.2%)  static void __asan_poison_memory_region(const void *addr, size_t size) {}
119,696 (0.1%)  static void __asan_unpoison_memory_region(const void *addr, size_t size) {}
      .         #endif
      .         
      .         // Windows doesn't really support weak symbols as of May 2019, and Clang on
      .         // Windows will emit strong symbols instead. See
      .         // https://bugs.llvm.org/show_bug.cgi?id=37598
      .         #if defined(__ELF__) && defined(__GNUC__)
      .         #define WEAK_SYMBOL_FUNC(rettype, name, args) \
      .           rettype name args __attribute__((weak));
-- line 94 ----------------------------------------
-- line 157 ----------------------------------------
      .             return 0;
      .           }
      .           malloc_impl = m;
      .           realloc_impl = r;
      .           free_impl = f;
      .           return 1;
      .         }
      .         
144,420 (0.1%)  void *OPENSSL_malloc(size_t size) {
 86,652 (0.1%)    if (malloc_impl != NULL) {
      .             assert(OPENSSL_memory_alloc == NULL);
      .             assert(OPENSSL_memory_realloc == NULL);
      .             assert(OPENSSL_memory_free == NULL);
      .             assert(OPENSSL_memory_get_size == NULL);
      .             assert(realloc_impl != NULL);
      .             assert(free_impl != NULL);
      .             return malloc_impl(size, AWSLC_FILE, AWSLC_LINE);
      .           }
 86,652 (0.1%)    if (OPENSSL_memory_alloc != NULL) {
      .             assert(OPENSSL_memory_free != NULL);
      .             assert(OPENSSL_memory_get_size != NULL);
      .             void *ptr = OPENSSL_memory_alloc(size);
      .             if (ptr == NULL && size != 0) {
      .               goto err;
      .             }
      .             return ptr;
      .           }
      .         
 57,768 (0.0%)    if (size + OPENSSL_MALLOC_PREFIX < size) {
      .             goto err;
      .           }
      .         
144,420 (0.1%)    void *ptr = malloc(size + OPENSSL_MALLOC_PREFIX);
 57,768 (0.0%)    if (ptr == NULL) {
      .             goto err;
      .           }
      .         
 86,652 (0.1%)    *(size_t *)ptr = size;
      .         
115,536 (0.1%)    __asan_poison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
 86,652 (0.1%)    return ((uint8_t *)ptr) + OPENSSL_MALLOC_PREFIX;
      .         
      .          err:
      .           // This only works because ERR does not call OPENSSL_malloc.
      .           OPENSSL_PUT_ERROR(CRYPTO, ERR_R_MALLOC_FAILURE);
      .           return NULL;
 57,768 (0.0%)  }
      .         
 96,795 (0.1%)  void *OPENSSL_zalloc(size_t size) {
 77,436 (0.1%)    void *ret = OPENSSL_malloc(size);
 38,718 (0.0%)    if (ret != NULL) {
 96,795 (0.1%)      OPENSSL_memset(ret, 0, size);
      .           }
 19,359 (0.0%)    return ret;
 38,718 (0.0%)  }
      .         
 21,714 (0.0%)  void *OPENSSL_calloc(size_t num, size_t size) {
 32,571 (0.0%)    if (size != 0 && num > SIZE_MAX / size) {
      .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
      .             return NULL;
      .           }
      .         
 14,476 (0.0%)    return OPENSSL_zalloc(num * size);
  7,238 (0.0%)  }
      .         
 93,480 (0.1%)  void OPENSSL_free(void *orig_ptr) {
 37,392 (0.0%)    if (orig_ptr == NULL) {
  4,742 (0.0%)      return;
      .           }
 41,862 (0.0%)    if (free_impl != NULL) {
      .             assert(OPENSSL_memory_alloc == NULL);
      .             assert(OPENSSL_memory_realloc == NULL);
      .             assert(OPENSSL_memory_free == NULL);
      .             assert(OPENSSL_memory_get_size == NULL);
      .             assert(malloc_impl != NULL);
      .             assert(realloc_impl != NULL);
      .             free_impl(orig_ptr, AWSLC_FILE, AWSLC_LINE);
      .             return;
      .           }
      .         
 41,862 (0.0%)    if (OPENSSL_memory_free != NULL) {
      .             OPENSSL_memory_free(orig_ptr);
      .             return;
      .           }
      .         
 41,862 (0.0%)    void *ptr = ((uint8_t *)orig_ptr) - OPENSSL_MALLOC_PREFIX;
 55,816 (0.0%)    __asan_unpoison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
      .         
 41,862 (0.0%)    size_t size = *(size_t *)ptr;
 83,724 (0.1%)    OPENSSL_cleanse(ptr, size + OPENSSL_MALLOC_PREFIX);
      .         
      .         // ASan knows to intercept malloc and free, but not sdallocx.
      .         #if defined(OPENSSL_ASAN)
      .           (void)sdallocx;
      .           free(ptr);
      .           (void) sdallocx;
      .         #else
 41,862 (0.0%)    if (sdallocx) {
      .             sdallocx(ptr, size + OPENSSL_MALLOC_PREFIX, 0 /* flags */);
      .           } else {
 55,816 (0.0%)      free(ptr);
      .           }
      .         #endif
 37,392 (0.0%)  }
      .         
 10,428 (0.0%)  void *OPENSSL_realloc(void *orig_ptr, size_t new_size) {
  3,476 (0.0%)    if (orig_ptr == NULL) {
  2,920 (0.0%)      return OPENSSL_malloc(new_size);
      .           }
  3,024 (0.0%)    if (realloc_impl != NULL) {
      .             assert(OPENSSL_memory_alloc == NULL);
      .             assert(OPENSSL_memory_realloc == NULL);
      .             assert(OPENSSL_memory_free == NULL);
      .             assert(OPENSSL_memory_get_size == NULL);
      .             assert(malloc_impl != NULL);
      .             assert(free_impl != NULL);
      .             return realloc_impl(orig_ptr, new_size, AWSLC_FILE, AWSLC_LINE);
      .           }
  3,024 (0.0%)    if (OPENSSL_memory_realloc != NULL) {
      .             assert(OPENSSL_memory_alloc != NULL);
      .             assert(OPENSSL_memory_free != NULL);
      .             assert(OPENSSL_memory_get_size != NULL);
      .             return OPENSSL_memory_realloc(orig_ptr, new_size);
      .           }
      .           size_t old_size;
  3,024 (0.0%)    if (OPENSSL_memory_get_size != NULL) {
      .             old_size = OPENSSL_memory_get_size(orig_ptr);
      .           } else {
  3,024 (0.0%)      void *ptr = ((uint8_t *)orig_ptr) - OPENSSL_MALLOC_PREFIX;
  4,032 (0.0%)      __asan_unpoison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
  3,024 (0.0%)      old_size = *(size_t *)ptr;
  4,032 (0.0%)      __asan_poison_memory_region(ptr, OPENSSL_MALLOC_PREFIX);
      .           }
      .         
  4,032 (0.0%)    void *ret = OPENSSL_malloc(new_size);
  2,016 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
  2,016 (0.0%)    size_t to_copy = new_size;
  3,024 (0.0%)    if (old_size < to_copy) {
  2,016 (0.0%)      to_copy = old_size;
      .           }
      .         
  6,048 (0.0%)    memcpy(ret, orig_ptr, to_copy);
  3,024 (0.0%)    OPENSSL_free(orig_ptr);
      .         
  1,008 (0.0%)    return ret;
  3,476 (0.0%)  }
      .         
 83,724 (0.1%)  void OPENSSL_cleanse(void *ptr, size_t len) {
      .         #if defined(OPENSSL_WINDOWS)
      .           SecureZeroMemory(ptr, len);
      .         #else
 69,770 (0.1%)    OPENSSL_memset(ptr, 0, len);
      .         
      .         #if !defined(OPENSSL_NO_ASM)
      .           /* As best as we can tell, this is sufficient to break any optimisations that
      .              might try to eliminate "superfluous" memsets. If there's an easy way to
      .              detect memset_s, it would be better to use that. */
 13,954 (0.0%)    __asm__ __volatile__("" : : "r"(ptr) : "memory");
      .         #endif
      .         #endif  // !OPENSSL_NO_ASM
 41,862 (0.0%)  }
      .         
      .         void OPENSSL_clear_free(void *ptr, size_t unused) { OPENSSL_free(ptr); }
      .         
      .         int CRYPTO_secure_malloc_init(size_t size, size_t min_size) { return 0; }
      .         
      .         int CRYPTO_secure_malloc_initialized(void) { return 0; }
      .         
      .         size_t CRYPTO_secure_used(void) { return 0; }
-- line 328 ----------------------------------------
-- line 330 ----------------------------------------
      .         void *OPENSSL_secure_malloc(size_t size) { return OPENSSL_malloc(size); }
      .         
      .         void *OPENSSL_secure_zalloc(size_t size) { return OPENSSL_zalloc(size); }
      .         
      .         void OPENSSL_secure_clear_free(void *ptr, size_t len) {
      .           OPENSSL_clear_free(ptr, len);
      .         }
      .         
    696 (0.0%)  int CRYPTO_memcmp(const void *in_a, const void *in_b, size_t len) {
    232 (0.0%)    const uint8_t *a = in_a;
    232 (0.0%)    const uint8_t *b = in_b;
    116 (0.0%)    uint8_t x = 0;
      .         
  9,572 (0.0%)    for (size_t i = 0; i < len; i++) {
 22,480 (0.0%)      x |= a[i] ^ b[i];
      .           }
      .         
    116 (0.0%)    return x;
    232 (0.0%)  }
      .         
      .         uint32_t OPENSSL_hash32(const void *ptr, size_t len) {
      .           // These are the FNV-1a parameters for 32 bits.
      .           static const uint32_t kPrime = 16777619u;
      .           static const uint32_t kOffsetBasis = 2166136261u;
      .         
      .           const uint8_t *in = ptr;
      .           uint32_t h = kOffsetBasis;
-- line 356 ----------------------------------------
-- line 387 ----------------------------------------
      .           OPENSSL_memcpy(ret, s, len);
      .           return ret;
      .         }
      .         
      .         int OPENSSL_isalpha(int c) {
      .           return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
      .         }
      .         
 42,096 (0.0%)  int OPENSSL_isdigit(int c) { return c >= '0' && c <= '9'; }
      .         
      .         int OPENSSL_isxdigit(int c) {
      .           return OPENSSL_isdigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
      .         }
      .         
      .         int OPENSSL_fromxdigit(uint8_t *out, int c) {
      .           if (OPENSSL_isdigit(c)) {
      .             *out = c - '0';
-- line 403 ----------------------------------------
-- line 411 ----------------------------------------
      .             *out = c - 'A' + 10;
      .             return 1;
      .           }
      .           return 0;
      .         }
      .         
      .         int OPENSSL_isalnum(int c) { return OPENSSL_isalpha(c) || OPENSSL_isdigit(c); }
      .         
 60,120 (0.0%)  int OPENSSL_tolower(int c) {
 58,076 (0.0%)    if (c >= 'A' && c <= 'Z') {
 12,840 (0.0%)      return c + ('a' - 'A');
      .           }
 10,750 (0.0%)    return c;
 30,060 (0.0%)  }
      .         
 81,320 (0.1%)  int OPENSSL_isspace(int c) {
265,896 (0.2%)    return c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r' ||
      .                  c == ' ';
 40,660 (0.0%)  }
      .         
      .         int OPENSSL_strcasecmp(const char *a, const char *b) {
      .           for (size_t i = 0;; i++) {
      .             const int aa = OPENSSL_tolower(a[i]);
      .             const int bb = OPENSSL_tolower(b[i]);
      .         
      .             if (aa < bb) {
      .               return -1;
-- line 437 ----------------------------------------
-- line 542 ----------------------------------------
      .             return NULL;
      .           }
      .         
      .           OPENSSL_memcpy(ret, str, size);
      .           ret[size] = '\0';
      .           return ret;
      .         }
      .         
      7 (0.0%)  size_t OPENSSL_strlcpy(char *dst, const char *src, size_t dst_size) {
      1 (0.0%)    size_t l = 0;
      .         
    129 (0.0%)    for (; dst_size > 1 && *src; dst_size--) {
    144 (0.0%)      *dst++ = *src++;
     18 (0.0%)      l++;
      .           }
      .         
      2 (0.0%)    if (dst_size) {
      2 (0.0%)      *dst = 0;
      .           }
      .         
      5 (0.0%)    return l + strlen(src);
      2 (0.0%)  }
      .         
      .         size_t OPENSSL_strlcat(char *dst, const char *src, size_t dst_size) {
      .           size_t l = 0;
      .           for (; dst_size > 0 && *dst; dst_size--, dst++) {
      .             l++;
      .           }
      .           return l + OPENSSL_strlcpy(dst, src, dst_size);
      .         }
      .         
 21,042 (0.0%)  void *OPENSSL_memdup(const void *data, size_t size) {
  7,014 (0.0%)    if (size == 0) {
      .             return NULL;
      .           }
      .         
 14,028 (0.0%)    void *ret = OPENSSL_malloc(size);
  7,014 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
 21,042 (0.0%)    OPENSSL_memcpy(ret, data, size);
  3,507 (0.0%)    return ret;
  7,014 (0.0%)  }
      .         
      .         void *CRYPTO_malloc(size_t size, const char *file, int line) {
      .           return OPENSSL_malloc(size);
      .         }
      .         
      .         void *CRYPTO_realloc(void *ptr, size_t new_size, const char *file, int line) {
      .           return OPENSSL_realloc(ptr, new_size);
      .         }
-- line 593 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/obj/obj.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 97 ----------------------------------------
     .         
     .           CRYPTO_STATIC_MUTEX_lock_write(&global_next_nid_lock);
     .           ret = global_next_nid++;
     .           CRYPTO_STATIC_MUTEX_unlock_write(&global_next_nid_lock);
     .         
     .           return ret;
     .         }
     .         
15,345 (0.0%)  ASN1_OBJECT *OBJ_dup(const ASN1_OBJECT *o) {
     .           ASN1_OBJECT *r;
 3,069 (0.0%)    unsigned char *data = NULL;
 6,138 (0.0%)    char *sn = NULL, *ln = NULL;
     .         
 6,138 (0.0%)    if (o == NULL) {
     .             return NULL;
     .           }
     .         
15,345 (0.0%)    if (!(o->flags & ASN1_OBJECT_FLAG_DYNAMIC)) {
     .             // TODO(fork): this is a little dangerous.
     .             return (ASN1_OBJECT *)o;
     .           }
     .         
 6,138 (0.0%)    r = ASN1_OBJECT_new();
 6,138 (0.0%)    if (r == NULL) {
     .             OPENSSL_PUT_ERROR(OBJ, ERR_R_ASN1_LIB);
     .             return NULL;
     .           }
18,414 (0.0%)    r->ln = r->sn = NULL;
     .         
     .           // once data is attached to an object, it remains const
30,690 (0.0%)    r->data = OPENSSL_memdup(o->data, o->length);
24,552 (0.0%)    if (o->length != 0 && r->data == NULL) {
     .             goto err;
     .           }
     .         
12,276 (0.0%)    r->length = o->length;
12,276 (0.0%)    r->nid = o->nid;
     .         
12,276 (0.0%)    if (o->ln != NULL) {
     .             ln = OPENSSL_strdup(o->ln);
     .             if (ln == NULL) {
     .               goto err;
     .             }
     .           }
     .         
12,276 (0.0%)    if (o->sn != NULL) {
     .             sn = OPENSSL_strdup(o->sn);
     .             if (sn == NULL) {
     .               goto err;
     .             }
     .           }
     .         
 9,207 (0.0%)    r->sn = sn;
 9,207 (0.0%)    r->ln = ln;
     .         
 6,138 (0.0%)    r->flags =
12,276 (0.0%)        o->flags | (ASN1_OBJECT_FLAG_DYNAMIC | ASN1_OBJECT_FLAG_DYNAMIC_STRINGS |
     .                           ASN1_OBJECT_FLAG_DYNAMIC_DATA);
 6,138 (0.0%)    return r;
     .         
     .         err:
     .           OPENSSL_free(ln);
     .           OPENSSL_free(sn);
     .           OPENSSL_free(data);
     .           OPENSSL_free(r);
     .           return NULL;
 6,138 (0.0%)  }
     .         
     .         int OBJ_cmp(const ASN1_OBJECT *a, const ASN1_OBJECT *b) {
     .           if (a->length < b->length) {
     .             return -1;
     .           } else if (a->length > b->length) {
     .             return 1;
     .           }
     .           return OPENSSL_memcmp(a->data, b->data, a->length);
-- line 171 ----------------------------------------
-- line 334 ----------------------------------------
     .               !CBB_add_bytes(&oid, obj->data, obj->length) ||
     .               !CBB_flush(out)) {
     .             return 0;
     .           }
     .         
     .           return 1;
     .         }
     .         
 9,087 (0.0%)  const ASN1_OBJECT *OBJ_get_undef(void) {
     .           static const ASN1_OBJECT kUndef = {
     .               /*sn=*/SN_undef,
     .               /*ln=*/LN_undef,
     .               /*nid=*/NID_undef,
     .               /*length=*/0,
     .               /*data=*/NULL,
     .               /*flags=*/0,
     .           };
 3,029 (0.0%)    return &kUndef;
 6,058 (0.0%)  }
     .         
     .         ASN1_OBJECT *OBJ_nid2obj(int nid) {
     .           if (nid == NID_undef) {
     .             return (ASN1_OBJECT *)OBJ_get_undef();
     .           }
     .         
     .           if (nid > 0 && nid < NUM_NID) {
     .             const ASN1_OBJECT *obj = get_builtin_object(nid);
-- line 360 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/pem/pem_lib.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 369 ----------------------------------------
     .           OPENSSL_cleanse(iv, sizeof(iv));
     .           OPENSSL_cleanse((char *)&ctx, sizeof(ctx));
     .           OPENSSL_cleanse(buf, PEM_BUFSIZE);
     .           OPENSSL_free(data);
     .           return ret;
     .         }
     .         
     .         int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,
 2,044 (0.0%)                    pem_password_cb *callback, void *u) {
   146 (0.0%)    int i = 0, j, o, klen;
     .           long len;
     .           EVP_CIPHER_CTX ctx;
     .           unsigned char key[EVP_MAX_KEY_LENGTH];
     .           char buf[PEM_BUFSIZE];
     .         
   438 (0.0%)    len = *plen;
     .         
   584 (0.0%)    if (cipher->cipher == NULL) {
   292 (0.0%)      return 1;
     .           }
     .         
     .           klen = 0;
     .           if (!callback) {
     .             callback = PEM_def_callback;
     .           }
     .           klen = callback(buf, PEM_BUFSIZE, 0, u);
     .           if (klen <= 0) {
-- line 395 ----------------------------------------
-- line 416 ----------------------------------------
     .           OPENSSL_cleanse((char *)key, sizeof(key));
     .           if (!o) {
     .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_DECRYPT);
     .             return 0;
     .           }
     .           j += i;
     .           *plen = j;
     .           return 1;
 1,168 (0.0%)  }
     .         
   876 (0.0%)  int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher) {
   146 (0.0%)    const EVP_CIPHER *enc = NULL;
     .           char *p, c;
   292 (0.0%)    char **header_pp = &header;
     .         
   292 (0.0%)    cipher->cipher = NULL;
   876 (0.0%)    OPENSSL_memset(cipher->iv, 0, sizeof(cipher->iv));
 1,022 (0.0%)    if ((header == NULL) || (*header == '\0') || (*header == '\n')) {
   292 (0.0%)      return 1;
     .           }
     .           if (strncmp(header, "Proc-Type: ", 11) != 0) {
     .             OPENSSL_PUT_ERROR(PEM, PEM_R_NOT_PROC_TYPE);
     .             return 0;
     .           }
     .           header += 11;
     .           if (*header != '4') {
     .             return 0;
-- line 442 ----------------------------------------
-- line 489 ----------------------------------------
     .             OPENSSL_PUT_ERROR(PEM, PEM_R_UNSUPPORTED_ENCRYPTION);
     .             return 0;
     .           }
     .           if (!load_iv(header_pp, &(cipher->iv[0]), EVP_CIPHER_iv_length(enc))) {
     .             return 0;
     .           }
     .         
     .           return 1;
   292 (0.0%)  }
     .         
     .         static int load_iv(char **fromp, unsigned char *to, size_t num) {
     .           uint8_t v;
     .           char *from;
     .         
     .           from = *fromp;
     .           for (size_t i = 0; i < num; i++) {
     .             to[i] = 0;
-- line 505 ----------------------------------------
-- line 599 ----------------------------------------
     .             return 0;
     .           }
     .           int ret = PEM_read_bio(b, name, header, data, len);
     .           BIO_free(b);
     .           return ret;
     .         }
     .         
     .         int PEM_read_bio(BIO *bp, char **name, char **header, unsigned char **data,
 1,764 (0.0%)                   long *len) {
     .           EVP_ENCODE_CTX ctx;
   588 (0.0%)    int end = 0, i, k, bl = 0, hl = 0, nohead = 0;
     .           char buf[256];
     .           BUF_MEM *nameB;
     .           BUF_MEM *headerB;
     .           BUF_MEM *dataB, *tmpB;
     .         
   294 (0.0%)    nameB = BUF_MEM_new();
   294 (0.0%)    headerB = BUF_MEM_new();
   294 (0.0%)    dataB = BUF_MEM_new();
   882 (0.0%)    if ((nameB == NULL) || (headerB == NULL) || (dataB == NULL)) {
     .             BUF_MEM_free(nameB);
     .             BUF_MEM_free(headerB);
     .             BUF_MEM_free(dataB);
     .             return 0;
     .           }
     .         
   147 (0.0%)    buf[254] = '\0';
     .           for (;;) {
 1,029 (0.0%)      i = BIO_gets(bp, buf, 254);
     .         
   294 (0.0%)      if (i <= 0) {
     7 (0.0%)        OPENSSL_PUT_ERROR(PEM, PEM_R_NO_START_LINE);
     1 (0.0%)        goto err;
     .             }
     .         
 3,066 (0.0%)      while ((i >= 0) && (buf[i] <= ' ')) {
   292 (0.0%)        i--;
     .             }
   584 (0.0%)      buf[++i] = '\n';
   584 (0.0%)      buf[++i] = '\0';
     .         
 1,168 (0.0%)      if (strncmp(buf, "-----BEGIN ", 11) == 0) {
   730 (0.0%)        i = strlen(&(buf[11]));
     .         
 1,752 (0.0%)        if (strncmp(&(buf[11 + i - 6]), "-----\n", 6) != 0) {
     .                 continue;
     .               }
 1,314 (0.0%)        if (!BUF_MEM_grow(nameB, i + 9)) {
     .                 goto err;
     .               }
 1,460 (0.0%)        OPENSSL_memcpy(nameB->data, &(buf[11]), i - 6);
 1,022 (0.0%)        nameB->data[i - 6] = '\0';
   146 (0.0%)        break;
     .             }
     .           }
   146 (0.0%)    hl = 0;
   876 (0.0%)    if (!BUF_MEM_grow(headerB, 256)) {
     .             goto err;
     .           }
   438 (0.0%)    headerB->data[0] = '\0';
     .           for (;;) {
27,566 (0.0%)      i = BIO_gets(bp, buf, 254);
 6,928 (0.0%)      if (i <= 0) {
     .               break;
     .             }
     .         
76,208 (0.1%)      while ((i >= 0) && (buf[i] <= ' ')) {
 6,928 (0.0%)        i--;
     .             }
13,856 (0.0%)      buf[++i] = '\n';
13,856 (0.0%)      buf[++i] = '\0';
     .         
10,392 (0.0%)      if (buf[0] == '\n') {
     .               break;
     .             }
38,104 (0.0%)      if (!BUF_MEM_grow(headerB, hl + i + 9)) {
     .               goto err;
     .             }
27,712 (0.0%)      if (strncmp(buf, "-----END ", 9) == 0) {
   146 (0.0%)        nohead = 1;
   146 (0.0%)        break;
     .             }
36,498 (0.0%)      OPENSSL_memcpy(&(headerB->data[hl]), buf, i);
26,544 (0.0%)      headerB->data[hl + i] = '\0';
 6,636 (0.0%)      hl += i;
     .           }
     .         
   146 (0.0%)    bl = 0;
   876 (0.0%)    if (!BUF_MEM_grow(dataB, 1024)) {
     .             goto err;
     .           }
   438 (0.0%)    dataB->data[0] = '\0';
   292 (0.0%)    if (!nohead) {
     .             for (;;) {
     .               i = BIO_gets(bp, buf, 254);
     .               if (i <= 0) {
     .                 break;
     .               }
     .         
     .               while ((i >= 0) && (buf[i] <= ' ')) {
     .                 i--;
-- line 699 ----------------------------------------
-- line 728 ----------------------------------------
     .                 }
     .                 buf[++i] = '\n';
     .                 buf[++i] = '\0';
     .         
     .                 break;
     .               }
     .             }
     .           } else {
   292 (0.0%)      tmpB = headerB;
   292 (0.0%)      headerB = dataB;
   292 (0.0%)      dataB = tmpB;
   438 (0.0%)      bl = hl;
     .           }
   730 (0.0%)    i = strlen(nameB->data);
 1,460 (0.0%)    if ((strncmp(buf, "-----END ", 9) != 0) ||
 1,606 (0.0%)        (strncmp(nameB->data, &(buf[9]), i) != 0) ||
 1,460 (0.0%)        (strncmp(&(buf[9 + i]), "-----\n", 6) != 0)) {
     .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_END_LINE);
     .             goto err;
     .           }
     .         
   438 (0.0%)    EVP_DecodeInit(&ctx);
 1,460 (0.0%)    i = EVP_DecodeUpdate(&ctx, (unsigned char *)dataB->data, &bl,
   292 (0.0%)                         (unsigned char *)dataB->data, bl);
   292 (0.0%)    if (i < 0) {
     .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_BASE64_DECODE);
     .             goto err;
     .           }
 1,606 (0.0%)    i = EVP_DecodeFinal(&ctx, (unsigned char *)&(dataB->data[bl]), &k);
   292 (0.0%)    if (i < 0) {
     .             OPENSSL_PUT_ERROR(PEM, PEM_R_BAD_BASE64_DECODE);
     .             goto err;
     .           }
   584 (0.0%)    bl += k;
     .         
   438 (0.0%)    if (bl == 0) {
     .             goto err;
     .           }
   584 (0.0%)    *name = nameB->data;
   584 (0.0%)    *header = headerB->data;
   584 (0.0%)    *data = (unsigned char *)dataB->data;
   584 (0.0%)    *len = bl;
   438 (0.0%)    OPENSSL_free(nameB);
   438 (0.0%)    OPENSSL_free(headerB);
   438 (0.0%)    OPENSSL_free(dataB);
   292 (0.0%)    return 1;
     .         err:
     3 (0.0%)    BUF_MEM_free(nameB);
     3 (0.0%)    BUF_MEM_free(headerB);
     3 (0.0%)    BUF_MEM_free(dataB);
     1 (0.0%)    return 0;
   735 (0.0%)  }
     .         
     .         int PEM_def_callback(char *buf, int size, int rwflag, void *userdata) {
     .           if (!buf || !userdata || size < 0) {
     .             return 0;
     .           }
     .           size_t len = strlen((char *)userdata);
     .           if (len >= (size_t)size) {
     .             return 0;
-- line 787 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/stack/stack.c
--------------------------------------------------------------------------------
Ir___________ 

-- line 78 ----------------------------------------
     .           // comp is an optional comparison function.
     .           OPENSSL_sk_cmp_func comp;
     .         };
     .         
     .         // kMinSize is the number of pointers that will be initially allocated in a new
     .         // stack.
     .         static const size_t kMinSize = 4;
     .         
17,035 (0.0%)  OPENSSL_STACK *OPENSSL_sk_new(OPENSSL_sk_cmp_func comp) {
10,221 (0.0%)    OPENSSL_STACK *ret = OPENSSL_zalloc(sizeof(OPENSSL_STACK));
 6,814 (0.0%)    if (ret == NULL) {
     .             return NULL;
     .           }
     .         
20,442 (0.0%)    ret->data = OPENSSL_calloc(kMinSize, sizeof(void *));
13,628 (0.0%)    if (ret->data == NULL) {
     .             goto err;
     .           }
     .         
10,221 (0.0%)    ret->comp = comp;
10,221 (0.0%)    ret->num_alloc = kMinSize;
     .         
 6,814 (0.0%)    return ret;
     .         
     .         err:
     .           OPENSSL_free(ret);
     .           return NULL;
 6,814 (0.0%)  }
     .         
23,835 (0.0%)  OPENSSL_STACK *OPENSSL_sk_new_null(void) { return OPENSSL_sk_new(NULL); }
     .         
60,740 (0.0%)  size_t OPENSSL_sk_num(const OPENSSL_STACK *sk) {
30,370 (0.0%)    if (sk == NULL) {
     4 (0.0%)      return 0;
     .           }
30,366 (0.0%)    return sk->num;
30,370 (0.0%)  }
     .         
     .         void OPENSSL_sk_zero(OPENSSL_STACK *sk) {
     .           if (sk == NULL || sk->num == 0) {
     .             return;
     .           }
     .           OPENSSL_memset(sk->data, 0, sizeof(void*) * sk->num);
     .           sk->num = 0;
     .           sk->sorted = 0;
     .         }
     .         
42,495 (0.0%)  void *OPENSSL_sk_value(const OPENSSL_STACK *sk, size_t i) {
50,994 (0.0%)    if (!sk || i >= sk->num) {
     .             return NULL;
     .           }
50,994 (0.0%)    return sk->data[i];
16,998 (0.0%)  }
     .         
 6,264 (0.0%)  void *OPENSSL_sk_set(OPENSSL_STACK *sk, size_t i, void *value) {
 6,264 (0.0%)    if (!sk || i >= sk->num) {
     .             return NULL;
     .           }
 8,352 (0.0%)    return sk->data[i] = value;
 2,088 (0.0%)  }
     .         
14,825 (0.0%)  void OPENSSL_sk_free(OPENSSL_STACK *sk) {
 5,930 (0.0%)    if (sk == NULL) {
     .             return;
     .           }
11,860 (0.0%)    OPENSSL_free(sk->data);
11,860 (0.0%)    OPENSSL_free(sk);
 5,930 (0.0%)  }
     .         
     .         void OPENSSL_sk_pop_free_ex(OPENSSL_STACK *sk,
     .                                     OPENSSL_sk_call_free_func call_free_func,
13,447 (0.0%)                              OPENSSL_sk_free_func free_func) {
 3,842 (0.0%)    if (sk == NULL) {
     .             return;
     .           }
     .         
27,916 (0.0%)    for (size_t i = 0; i < sk->num; i++) {
26,224 (0.0%)      if (sk->data[i] != NULL) {
36,058 (0.0%)        call_free_func(free_func, sk->data[i]);
     .             }
     .           }
 7,684 (0.0%)    OPENSSL_sk_free(sk);
 3,842 (0.0%)  }
     .         
     .         // Historically, |sk_pop_free| called the function as |OPENSSL_sk_free_func|
     .         // directly. This is undefined in C. Some callers called |sk_pop_free| directly,
     .         // so we must maintain a compatibility version for now.
     .         static void call_free_func_legacy(OPENSSL_sk_free_func func, void *ptr) {
     .           func(ptr);
     .         }
     .         
     .         void sk_pop_free(OPENSSL_STACK *sk, OPENSSL_sk_free_func free_func) {
     .           OPENSSL_sk_pop_free_ex(sk, call_free_func_legacy, free_func);
     .         }
     .         
42,126 (0.0%)  size_t OPENSSL_sk_insert(OPENSSL_STACK *sk, void *p, size_t where) {
12,036 (0.0%)    if (sk == NULL) {
     .             return 0;
     .           }
     .         
24,072 (0.0%)    if (sk->num >= INT_MAX) {
     .             OPENSSL_PUT_ERROR(CRYPTO, ERR_R_OVERFLOW);
     .             return 0;
     .           }
     .         
42,126 (0.0%)    if (sk->num_alloc <= sk->num + 1) {
     .             // Attempt to double the size of the array.
 1,652 (0.0%)      size_t new_alloc = sk->num_alloc << 1;
 1,239 (0.0%)      size_t alloc_size = new_alloc * sizeof(void *);
     .             void **data;
     .         
     .             // If the doubling overflowed, try to increment.
 3,304 (0.0%)      if (new_alloc < sk->num_alloc || alloc_size / sizeof(void *) != new_alloc) {
     .               new_alloc = sk->num_alloc + 1;
     .               alloc_size = new_alloc * sizeof(void *);
     .             }
     .         
     .             // If the increment also overflowed, fail.
 3,304 (0.0%)      if (new_alloc < sk->num_alloc || alloc_size / sizeof(void *) != new_alloc) {
     .               return 0;
     .             }
     .         
 2,891 (0.0%)      data = OPENSSL_realloc(sk->data, alloc_size);
   826 (0.0%)      if (data == NULL) {
     .               return 0;
     .             }
     .         
 1,239 (0.0%)      sk->data = data;
 1,239 (0.0%)      sk->num_alloc = new_alloc;
     .           }
     .         
24,072 (0.0%)    if (where >= sk->num) {
54,162 (0.0%)      sk->data[sk->num] = p;
     .           } else {
     .             OPENSSL_memmove(&sk->data[where + 1], &sk->data[where],
     .                             sizeof(void *) * (sk->num - where));
     .             sk->data[where] = p;
     .           }
     .         
30,090 (0.0%)    sk->num++;
12,036 (0.0%)    sk->sorted = 0;
     .         
12,036 (0.0%)    return sk->num;
12,036 (0.0%)  }
     .         
     .         void *OPENSSL_sk_delete(OPENSSL_STACK *sk, size_t where) {
     .           void *ret;
     .         
     .           if (!sk || where >= sk->num) {
     .             return NULL;
     .           }
     .         
-- line 229 ----------------------------------------
-- line 265 ----------------------------------------
     .               sk->data[new_num] = sk->data[i];
     .               new_num++;
     .             }
     .           }
     .           sk->num = new_num;
     .         }
     .         
     .         int OPENSSL_sk_find(const OPENSSL_STACK *sk, size_t *out_index, const void *p,
 1,168 (0.0%)                      OPENSSL_sk_call_cmp_func call_cmp_func) {
   292 (0.0%)    if (sk == NULL) {
     .             return 0;
     .           }
     .         
   584 (0.0%)    if (sk->comp == NULL) {
     .             // Use pointer equality when no comparison function has been set.
     .             for (size_t i = 0; i < sk->num; i++) {
     .               if (sk->data[i] == p) {
     .                 if (out_index) {
     .                   *out_index = i;
     .                 }
     .                 return 1;
     .               }
     .             }
     .             return 0;
     .           }
     .         
   292 (0.0%)    if (p == NULL) {
     .             return 0;
     .           }
     .         
   730 (0.0%)    if (!OPENSSL_sk_is_sorted(sk)) {
     .             for (size_t i = 0; i < sk->num; i++) {
     .               if (call_cmp_func(sk->comp, p, sk->data[i]) == 0) {
     .                 if (out_index) {
     .                   *out_index = i;
     .                 }
     .                 return 1;
     .               }
     .             }
     .             return 0;
     .           }
     .         
     .           // The stack is sorted, so binary search to find the element.
     .           //
     .           // |lo| and |hi| maintain a half-open interval of where the answer may be. All
     .           // indices such that |lo <= idx < hi| are candidates.
   584 (0.0%)    size_t lo = 0, hi = sk->num;
 3,116 (0.0%)    while (lo < hi) {
     .             // Bias |mid| towards |lo|. See the |r == 0| case below.
 6,752 (0.0%)      size_t mid = lo + (hi - lo - 1) / 2;
 5,064 (0.0%)      assert(lo <= mid && mid < hi);
11,816 (0.0%)      int r = call_cmp_func(sk->comp, p, sk->data[mid]);
 1,688 (0.0%)      if (r > 0) {
 1,860 (0.0%)        lo = mid + 1;  // |mid| is too low.
   758 (0.0%)      } else if (r < 0) {
 1,137 (0.0%)        hi = mid;  // |mid| is too high.
     .             } else {
     .               // |mid| matches. However, this function returns the earliest match, so we
     .               // can only return if the range has size one.
     .               if (hi - lo == 1) {
     .                 if (out_index != NULL) {
     .                   *out_index = mid;
     .                 }
     .                 return 1;
-- line 328 ----------------------------------------
-- line 329 ----------------------------------------
     .               }
     .               // The sample is biased towards |lo|. |mid| can only be |hi - 1| if
     .               // |hi - lo| was one, so this makes forward progress.
     .               assert(mid + 1 < hi);
     .               hi = mid + 1;
     .             }
     .           }
     .         
   438 (0.0%)    assert(lo == hi);
   146 (0.0%)    return 0;  // Not found.
   292 (0.0%)  }
     .         
     .         int OPENSSL_sk_unshift(OPENSSL_STACK *sk, void *data) {
     .             return (int)OPENSSL_sk_insert(sk, data, 0);
     .         }
     .         
     .         void *OPENSSL_sk_shift(OPENSSL_STACK *sk) {
     .           if (sk == NULL) {
     .             return NULL;
     .           }
     .           if (sk->num == 0) {
     .             return NULL;
     .           }
     .           return OPENSSL_sk_delete(sk, 0);
     .         }
     .         
36,108 (0.0%)  size_t OPENSSL_sk_push(OPENSSL_STACK *sk, void *p) {
42,126 (0.0%)    return OPENSSL_sk_insert(sk, p, sk->num);
12,036 (0.0%)  }
     .         
     .         void *OPENSSL_sk_pop(OPENSSL_STACK *sk) {
     .           if (sk == NULL) {
     .             return NULL;
     .           }
     .           if (sk->num == 0) {
     .             return NULL;
     .           }
-- line 365 ----------------------------------------
-- line 403 ----------------------------------------
     .           // |a| and |b| point to |void*| pointers which contain the actual values.
     .           const void *const *a_ptr = a;
     .           const void *const *b_ptr = b;
     .           return ctx->call_cmp_func(ctx->cmp_func, *a_ptr, *b_ptr);
     .         }
     .         #endif
     .         
     .         void OPENSSL_sk_sort(OPENSSL_STACK *sk,
   876 (0.0%)                       OPENSSL_sk_call_cmp_func call_cmp_func) {
 1,460 (0.0%)    if (sk == NULL || sk->comp == NULL || sk->sorted) {
     .             return;
     .           }
     .         
   584 (0.0%)    if (sk->num >= 2) {
     .         #if defined(_MSC_VER)
     .             // MSVC's |qsort_s| is different from the C11 one.
     .             // https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/qsort-s?view=msvc-170
     .             struct sort_compare_ctx ctx = {call_cmp_func, sk->comp};
     .             qsort_s(sk->data, sk->num, sizeof(void *), sort_compare, &ctx);
     .         #else
     .             // sk->comp is a function that takes pointers to pointers to elements, but
     .             // qsort take a comparison function that just takes pointers to elements.
     .             // However, since we're passing an array of pointers to qsort, we can just
     .             // cast the comparison function and everything works.
     .             //
     .             // TODO(davidben): This is undefined behavior, but the call is in libc so,
     .             // e.g., CFI does not notice. |qsort| is missing a void* parameter in its
     .             // callback, while no one defines |qsort_r| or |qsort_s| consistently. See
     .             // https://stackoverflow.com/a/39561369
   432 (0.0%)      int (*comp_func)(const void *, const void *) =
     .                 (int (*)(const void *, const void *))(sk->comp);
 1,296 (0.0%)      qsort(sk->data, sk->num, sizeof(void *), comp_func);
     .         #endif
     .           }
   438 (0.0%)    sk->sorted = 1;
   292 (0.0%)  }
     .         
   584 (0.0%)  int OPENSSL_sk_is_sorted(const OPENSSL_STACK *sk) {
   292 (0.0%)    if (!sk) {
     .             return 1;
     .           }
     .           // Zero- and one-element lists are always sorted.
   876 (0.0%)    return sk->sorted || (sk->comp != NULL && sk->num < 2);
   292 (0.0%)  }
     .         
     .         OPENSSL_sk_cmp_func OPENSSL_sk_set_cmp_func(OPENSSL_STACK *sk,
     .                                                     OPENSSL_sk_cmp_func comp) {
     .           OPENSSL_sk_cmp_func old = sk->comp;
     .         
     .           if (sk->comp != comp) {
     .             sk->sorted = 0;
     .           }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_cmp.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 69 ----------------------------------------
      .         #include "../internal.h"
      .         #include "internal.h"
      .         
      .         
      .         int X509_issuer_name_cmp(const X509 *a, const X509 *b) {
      .           return (X509_NAME_cmp(a->cert_info->issuer, b->cert_info->issuer));
      .         }
      .         
205,620 (0.1%)  int X509_subject_name_cmp(const X509 *a, const X509 *b) {
308,430 (0.2%)    return (X509_NAME_cmp(a->cert_info->subject, b->cert_info->subject));
 68,540 (0.0%)  }
      .         
      .         int X509_CRL_cmp(const X509_CRL *a, const X509_CRL *b) {
      .           return (X509_NAME_cmp(a->crl->issuer, b->crl->issuer));
      .         }
      .         
      .         int X509_CRL_match(const X509_CRL *a, const X509_CRL *b) {
      .           return OPENSSL_memcmp(a->crl_hash, b->crl_hash, SHA256_DIGEST_LENGTH);
      .         }
-- line 87 ----------------------------------------
-- line 134 ----------------------------------------
      .           // retain the old OpenSSL behavior, which was to ignore the error. See
      .           // https://crbug.com/boringssl/355.
      .           x509v3_cache_extensions((X509 *)a);
      .           x509v3_cache_extensions((X509 *)b);
      .         
      .           return OPENSSL_memcmp(a->cert_hash, b->cert_hash, SHA256_DIGEST_LENGTH);
      .         }
      .         
205,620 (0.1%)  int X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b) {
      .           int ret;
      .         
      .           // Ensure canonical encoding is present and up to date
      .         
274,160 (0.2%)    if (!a->canon_enc || a->modified) {
      .             ret = i2d_X509_NAME((X509_NAME *)a, NULL);
      .             if (ret < 0) {
      .               return -2;
      .             }
      .           }
      .         
274,160 (0.2%)    if (!b->canon_enc || b->modified) {
      .             ret = i2d_X509_NAME((X509_NAME *)b, NULL);
      .             if (ret < 0) {
      .               return -2;
      .             }
      .           }
      .         
205,620 (0.1%)    ret = a->canon_enclen - b->canon_enclen;
      .         
 68,540 (0.0%)    if (ret) {
 55,316 (0.0%)      return ret;
      .           }
      .         
 66,120 (0.0%)    return OPENSSL_memcmp(a->canon_enc, b->canon_enc, a->canon_enclen);
 68,540 (0.0%)  }
      .         
      .         uint32_t X509_NAME_hash(X509_NAME *x) {
      .           // Make sure the X509_NAME structure contains a valid cached encoding.
      .           if (i2d_X509_NAME(x, NULL) < 0) {
      .             return 0;
      .           }
      .         
      .           uint8_t md[SHA_DIGEST_LENGTH];
-- line 176 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x509_lu.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 74 ----------------------------------------
      .         static int X509_OBJECT_up_ref_count(X509_OBJECT *a);
      .         
      .         static X509_LOOKUP *X509_LOOKUP_new(const X509_LOOKUP_METHOD *method,
      .                                             X509_STORE *store);
      .         static int X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,
      .                                           X509_OBJECT *ret);
      .         
      .         static X509_LOOKUP *X509_LOOKUP_new(const X509_LOOKUP_METHOD *method,
     12 (0.0%)                                      X509_STORE *store) {
      6 (0.0%)    X509_LOOKUP *ret = OPENSSL_zalloc(sizeof(X509_LOOKUP));
      4 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
      6 (0.0%)    ret->method = method;
      6 (0.0%)    ret->store_ctx = store;
     15 (0.0%)    if ((method->new_item != NULL) && !method->new_item(ret)) {
      .             OPENSSL_free(ret);
      .             return NULL;
      .           }
      2 (0.0%)    return ret;
      4 (0.0%)  }
      .         
      .         void X509_LOOKUP_free(X509_LOOKUP *ctx) {
      .           if (ctx == NULL) {
      .             return;
      .           }
      .           if (ctx->method != NULL && ctx->method->free != NULL) {
      .             (*ctx->method->free)(ctx);
      .           }
      .           OPENSSL_free(ctx);
      .         }
      .         
      .         int X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc, long argl,
     18 (0.0%)                       char **ret) {
      8 (0.0%)    if (ctx->method == NULL) {
      .             return -1;
      .           }
     10 (0.0%)    if (ctx->method->ctrl != NULL) {
     24 (0.0%)      return ctx->method->ctrl(ctx, cmd, argc, argl, ret);
      .           } else {
      .             return 1;
      .           }
      4 (0.0%)  }
      .         
      .         static int X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,
      .                                           X509_OBJECT *ret) {
      .           if (ctx->method == NULL || ctx->method->get_by_subject == NULL) {
      .             return 0;
      .           }
      .           // Note |get_by_subject| leaves |ret| in an inconsistent state. It has
      .           // pointers to an |X509| or |X509_CRL|, but has not bumped the refcount yet.
      .           // For now, the caller is expected to fix this, but ideally we'd fix the
      .           // |X509_LOOKUP| convention itself.
      .           return ctx->method->get_by_subject(ctx, type, name, ret) > 0;
      .         }
      .         
205,620 (0.1%)  static int x509_object_cmp(const X509_OBJECT *a, const X509_OBJECT *b) {
205,620 (0.1%)    int ret = a->type - b->type;
 68,540 (0.0%)    if (ret) {
      .             return ret;
      .           }
137,080 (0.1%)    switch (a->type) {
      .             case X509_LU_X509:
274,160 (0.2%)        return X509_subject_name_cmp(a->data.x509, b->data.x509);
      .             case X509_LU_CRL:
      .               return X509_CRL_cmp(a->data.crl, b->data.crl);
      .             default:
      .               // abort();
      .               return 0;
      .           }
 68,540 (0.0%)  }
      .         
      .         static int x509_object_cmp_sk(const X509_OBJECT *const *a,
205,620 (0.1%)                                const X509_OBJECT *const *b) {
239,890 (0.2%)    return x509_object_cmp(*a, *b);
 68,540 (0.0%)  }
      .         
      .         static CRYPTO_EX_DATA_CLASS g_ex_data_class =
      .             CRYPTO_EX_DATA_CLASS_INIT_WITH_APP_DATA;
      .         
      4 (0.0%)  X509_STORE *X509_STORE_new(void) {
      3 (0.0%)    X509_STORE *ret = OPENSSL_zalloc(sizeof(X509_STORE));
      2 (0.0%)    if (ret == NULL) {
      .             return NULL;
      .           }
      .         
      2 (0.0%)    ret->references = 1;
      4 (0.0%)    CRYPTO_MUTEX_init(&ret->objs_lock);
      4 (0.0%)    CRYPTO_new_ex_data(&ret->ex_data);
      5 (0.0%)    ret->objs = sk_X509_OBJECT_new(x509_object_cmp_sk);
      3 (0.0%)    ret->get_cert_methods = sk_X509_LOOKUP_new_null();
      3 (0.0%)    ret->param = X509_VERIFY_PARAM_new();
      6 (0.0%)    if (ret->objs == NULL ||
      4 (0.0%)        ret->get_cert_methods == NULL ||
      2 (0.0%)        ret->param == NULL) {
      .             X509_STORE_free(ret);
      .             return NULL;
      .           }
      .         
      1 (0.0%)    return ret;
      2 (0.0%)  }
      .         
      .         int X509_STORE_lock(X509_STORE *v) {
      .             if (v == NULL) {
      .               return 0;
      .             }
      .             CRYPTO_MUTEX_lock_write(&v->objs_lock);
      .             return 1;
      .         }
-- line 183 ----------------------------------------
-- line 207 ----------------------------------------
      .           CRYPTO_MUTEX_cleanup(&vfy->objs_lock);
      .           CRYPTO_free_ex_data(&g_ex_data_class, vfy, &vfy->ex_data);
      .           sk_X509_LOOKUP_pop_free(vfy->get_cert_methods, X509_LOOKUP_free);
      .           sk_X509_OBJECT_pop_free(vfy->objs, X509_OBJECT_free);
      .           X509_VERIFY_PARAM_free(vfy->param);
      .           OPENSSL_free(vfy);
      .         }
      .         
     12 (0.0%)  X509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, const X509_LOOKUP_METHOD *m) {
      6 (0.0%)    STACK_OF(X509_LOOKUP) *sk = v->get_cert_methods;
     20 (0.0%)    for (size_t i = 0; i < sk_X509_LOOKUP_num(sk); i++) {
      6 (0.0%)      X509_LOOKUP *lu = sk_X509_LOOKUP_value(sk, i);
      4 (0.0%)      if (m == lu->method) {
      .               return lu;
      .             }
      .           }
      .         
     12 (0.0%)    X509_LOOKUP *lu = X509_LOOKUP_new(m, v);
     20 (0.0%)    if (lu == NULL || !sk_X509_LOOKUP_push(v->get_cert_methods, lu)) {
      .             X509_LOOKUP_free(lu);
      .             return NULL;
      .           }
      .         
      2 (0.0%)    return lu;
      4 (0.0%)  }
      .         
      .         int X509_STORE_CTX_get_by_subject(X509_STORE_CTX *vs, int type, X509_NAME *name,
      .                                           X509_OBJECT *ret) {
      .           X509_STORE *ctx = vs->ctx;
      .           X509_OBJECT stmp;
      .           CRYPTO_MUTEX_lock_write(&ctx->objs_lock);
      .           X509_OBJECT *tmp = X509_OBJECT_retrieve_by_subject(ctx->objs, type, name);
      .           CRYPTO_MUTEX_unlock_write(&ctx->objs_lock);
-- line 239 ----------------------------------------
-- line 256 ----------------------------------------
      .           ret->type = tmp->type;
      .           ret->data.ptr = tmp->data.ptr;
      .         
      .           X509_OBJECT_up_ref_count(ret);
      .         
      .           return 1;
      .         }
      .         
  1,022 (0.0%)  static int x509_store_add(X509_STORE *ctx, void *x, int is_crl) {
    292 (0.0%)    if (x == NULL) {
      .             return 0;
      .           }
      .         
    292 (0.0%)    X509_OBJECT *const obj = X509_OBJECT_new();
    292 (0.0%)    if (obj == NULL) {
      .             return 0;
      .           }
      .         
    292 (0.0%)    if (is_crl) {
      .             obj->type = X509_LU_CRL;
      .             obj->data.crl = (X509_CRL *)x;
      .           } else {
    292 (0.0%)      obj->type = X509_LU_X509;
    438 (0.0%)      obj->data.x509 = (X509 *)x;
      .           }
    438 (0.0%)    X509_OBJECT_up_ref_count(obj);
      .         
    584 (0.0%)    CRYPTO_MUTEX_lock_write(&ctx->objs_lock);
      .         
    146 (0.0%)    int ret = 1;
    146 (0.0%)    int added = 0;
      .           // Duplicates are silently ignored
  1,168 (0.0%)    if (!X509_OBJECT_retrieve_match(ctx->objs, obj)) {
  1,752 (0.0%)      ret = added = (sk_X509_OBJECT_push(ctx->objs, obj) != 0);
      .           }
      .         
    584 (0.0%)    CRYPTO_MUTEX_unlock_write(&ctx->objs_lock);
      .         
    292 (0.0%)    if (!added) {
      .             X509_OBJECT_free(obj);
      .           }
      .         
    146 (0.0%)    return ret;
    292 (0.0%)  }
      .         
    876 (0.0%)  int X509_STORE_add_cert(X509_STORE *ctx, X509 *x) {
    876 (0.0%)    return x509_store_add(ctx, x, /*is_crl=*/0);
    292 (0.0%)  }
      .         
      .         int X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x) {
      .           return x509_store_add(ctx, x, /*is_crl=*/1);
      .         }
      .         
    438 (0.0%)  X509_OBJECT *X509_OBJECT_new(void) {
    292 (0.0%)    return OPENSSL_zalloc(sizeof(X509_OBJECT));
    292 (0.0%)  }
      .         
      .         void X509_OBJECT_free(X509_OBJECT *obj) {
      .           if (obj == NULL) {
      .             return;
      .           }
      .           X509_OBJECT_free_contents(obj);
      .           OPENSSL_free(obj);
      .         }
      .         
    730 (0.0%)  static int X509_OBJECT_up_ref_count(X509_OBJECT *a) {
    584 (0.0%)    switch (a->type) {
      .             case X509_LU_X509:
    584 (0.0%)        X509_up_ref(a->data.x509);
    146 (0.0%)        break;
      .             case X509_LU_CRL:
      .               X509_CRL_up_ref(a->data.crl);
      .               break;
      .           }
    146 (0.0%)    return 1;
    292 (0.0%)  }
      .         
      .         void X509_OBJECT_free_contents(X509_OBJECT *a) {
      .           switch (a->type) {
      .             case X509_LU_X509:
      .               X509_free(a->data.x509);
      .               break;
      .             case X509_LU_CRL:
      .               X509_CRL_free(a->data.crl);
-- line 339 ----------------------------------------
-- line 519 ----------------------------------------
      .               return NULL;
      .             }
      .           }
      .           CRYPTO_MUTEX_unlock_write(&ctx->ctx->objs_lock);
      .           return sk;
      .         }
      .         
      .         static X509_OBJECT *X509_OBJECT_retrieve_match(STACK_OF(X509_OBJECT) *h,
  1,314 (0.0%)                                                 X509_OBJECT *x) {
    438 (0.0%)    sk_X509_OBJECT_sort(h);
      .           size_t idx;
  1,168 (0.0%)    if (!sk_X509_OBJECT_find_awslc(h, &idx, x)) {
    292 (0.0%)      return NULL;
      .           }
      .           if ((x->type != X509_LU_X509) && (x->type != X509_LU_CRL)) {
      .             return sk_X509_OBJECT_value(h, idx);
      .           }
      .           for (size_t i = idx; i < sk_X509_OBJECT_num(h); i++) {
      .             X509_OBJECT *obj = sk_X509_OBJECT_value(h, i);
      .             if (x509_object_cmp(obj, x)) {
      .               return NULL;
-- line 539 ----------------------------------------
-- line 546 ----------------------------------------
      .               if (!X509_CRL_match(obj->data.crl, x->data.crl)) {
      .                 return obj;
      .               }
      .             } else {
      .               return obj;
      .             }
      .           }
      .           return NULL;
    730 (0.0%)  }
      .         
      .         // Try to get issuer certificate from store. Due to limitations of the API
      .         // this can only retrieve a single certificate matching a given subject name.
      .         // However it will fill the cache with all matching certificates, so we can
      .         // examine the cache for all matches. Return values are: 1 lookup
      .         // successful.  0 certificate not found. -1 some other error.
      .         int X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x) {
      .           X509_NAME *xn;
-- line 562 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/ubuntu/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aws-lc-sys-0.19.0/aws-lc/crypto/x509/x_name.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 67 ----------------------------------------
      .         #include <openssl/x509.h>
      .         
      .         #include "../asn1/internal.h"
      .         #include "../internal.h"
      .         #include "internal.h"
      .         
      .         
      .         typedef STACK_OF(X509_NAME_ENTRY) STACK_OF_X509_NAME_ENTRY;
 71,188 (0.1%)  DEFINE_STACK_OF(STACK_OF_X509_NAME_ENTRY)
      .         
      .         // Maximum length of X509_NAME: much larger than anything we should
      .         // ever see in practice.
      .         
      .         #define X509_NAME_MAX (1024 * 1024)
      .         
      .         static int x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                     long len, const ASN1_ITEM *it, int tag, int aclass,
-- line 83 ----------------------------------------
-- line 94 ----------------------------------------
      .         static int i2d_name_canon(STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname,
      .                                   unsigned char **in);
      .         
      .         ASN1_SEQUENCE(X509_NAME_ENTRY) = {
      .             ASN1_SIMPLE(X509_NAME_ENTRY, object, ASN1_OBJECT),
      .             ASN1_SIMPLE(X509_NAME_ENTRY, value, ASN1_PRINTABLE),
      .         } ASN1_SEQUENCE_END(X509_NAME_ENTRY)
      .         
 20,880 (0.0%)  IMPLEMENT_ASN1_FUNCTIONS_const(X509_NAME_ENTRY)
      .         IMPLEMENT_ASN1_DUP_FUNCTION_const(X509_NAME_ENTRY)
      .         
      .         // For the "Name" type we need a SEQUENCE OF { SET OF X509_NAME_ENTRY } so
      .         // declare two template wrappers for this
      .         
      .         ASN1_ITEM_TEMPLATE(X509_NAME_ENTRIES) = ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SET_OF,
      .                                                                       0, RDNS,
      .                                                                       X509_NAME_ENTRY)
-- line 110 ----------------------------------------
-- line 129 ----------------------------------------
      .         };
      .         
      .         IMPLEMENT_EXTERN_ASN1(X509_NAME, V_ASN1_SEQUENCE, x509_name_ff)
      .         
      .         IMPLEMENT_ASN1_FUNCTIONS(X509_NAME)
      .         
      .         IMPLEMENT_ASN1_DUP_FUNCTION(X509_NAME)
      .         
  3,504 (0.0%)  static int x509_name_ex_new(ASN1_VALUE **val, const ASN1_ITEM *it) {
    584 (0.0%)    X509_NAME *ret = NULL;
  1,752 (0.0%)    ret = OPENSSL_malloc(sizeof(X509_NAME));
  1,168 (0.0%)    if (!ret) {
      .             goto memerr;
      .           }
  4,088 (0.0%)    if ((ret->entries = sk_X509_NAME_ENTRY_new_null()) == NULL) {
      .             goto memerr;
      .           }
  4,088 (0.0%)    if ((ret->bytes = BUF_MEM_new()) == NULL) {
      .             goto memerr;
      .           }
  1,168 (0.0%)    ret->canon_enc = NULL;
  1,168 (0.0%)    ret->canon_enclen = 0;
  1,168 (0.0%)    ret->modified = 1;
  1,752 (0.0%)    *val = (ASN1_VALUE *)ret;
  1,168 (0.0%)    return 1;
      .         
      .         memerr:
      .           if (ret) {
      .             if (ret->entries) {
      .               sk_X509_NAME_ENTRY_free(ret->entries);
      .             }
      .             OPENSSL_free(ret);
      .           }
      .           return 0;
  1,168 (0.0%)  }
      .         
  1,752 (0.0%)  static void x509_name_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it) {
      .           X509_NAME *a;
  1,752 (0.0%)    if (!pval || !*pval) {
      .             return;
      .           }
    876 (0.0%)    a = (X509_NAME *)*pval;
      .         
  1,168 (0.0%)    BUF_MEM_free(a->bytes);
  1,752 (0.0%)    sk_X509_NAME_ENTRY_pop_free(a->entries, X509_NAME_ENTRY_free);
  1,168 (0.0%)    if (a->canon_enc) {
      .             OPENSSL_free(a->canon_enc);
      .           }
    876 (0.0%)    OPENSSL_free(a);
    876 (0.0%)    *pval = NULL;
    584 (0.0%)  }
      .         
  5,220 (0.0%)  static void local_sk_X509_NAME_ENTRY_free(STACK_OF(X509_NAME_ENTRY) *ne) {
  3,132 (0.0%)    sk_X509_NAME_ENTRY_free(ne);
  3,132 (0.0%)  }
      .         
  5,220 (0.0%)  static void local_sk_X509_NAME_ENTRY_pop_free(STACK_OF(X509_NAME_ENTRY) *ne) {
  5,220 (0.0%)    sk_X509_NAME_ENTRY_pop_free(ne, X509_NAME_ENTRY_free);
  3,132 (0.0%)  }
      .         
      .         static int x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
      .                                     long len, const ASN1_ITEM *it, int tag, int aclass,
  4,964 (0.0%)                              char opt, ASN1_TLC *ctx) {
    876 (0.0%)    const unsigned char *p = *in, *q;
    292 (0.0%)    STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname = NULL;
    292 (0.0%)    X509_NAME *nm = NULL;
      .           size_t i, j;
      .           int ret;
      .           STACK_OF(X509_NAME_ENTRY) *entries;
      .           X509_NAME_ENTRY *entry;
      .           // Bound the size of an X509_NAME we are willing to parse.
    584 (0.0%)    if (len > X509_NAME_MAX) {
      .             len = X509_NAME_MAX;
      .           }
    584 (0.0%)    q = p;
      .         
      .           // Get internal representation of Name
    292 (0.0%)    ASN1_VALUE *intname_val = NULL;
  4,380 (0.0%)    ret = ASN1_item_ex_d2i(&intname_val, &p, len,
      .                                  ASN1_ITEM_rptr(X509_NAME_INTERNAL), tag, aclass, opt,
      .                                  ctx);
    584 (0.0%)    if (ret <= 0) {
      .             return ret;
      .           }
    584 (0.0%)    intname = (STACK_OF(STACK_OF_X509_NAME_ENTRY) *)intname_val;
      .         
  1,168 (0.0%)    if (*val) {
  1,168 (0.0%)      x509_name_ex_free(val, NULL);
      .           }
    292 (0.0%)    ASN1_VALUE *nm_val = NULL;
  1,752 (0.0%)    if (!x509_name_ex_new(&nm_val, NULL)) {
      .             goto err;
      .           }
    584 (0.0%)    nm = (X509_NAME *)nm_val;
      .           // We've decoded it: now cache encoding
  2,920 (0.0%)    if (!BUF_MEM_grow(nm->bytes, p - q)) {
      .             goto err;
      .           }
  2,920 (0.0%)    OPENSSL_memcpy(nm->bytes->data, q, p - q);
      .         
      .           // Convert internal representation to X509_NAME structure
  8,308 (0.0%)    for (i = 0; i < sk_STACK_OF_X509_NAME_ENTRY_num(intname); i++) {
  6,264 (0.0%)      entries = sk_STACK_OF_X509_NAME_ENTRY_value(intname, i);
 13,572 (0.0%)      for (j = 0; j < sk_X509_NAME_ENTRY_num(entries); j++) {
  6,264 (0.0%)        entry = sk_X509_NAME_ENTRY_value(entries, j);
  4,176 (0.0%)        entry->set = (int)i;
  8,352 (0.0%)        if (!sk_X509_NAME_ENTRY_push(nm->entries, entry)) {
      .                 goto err;
      .               }
  6,264 (0.0%)        (void)sk_X509_NAME_ENTRY_set(entries, j, NULL);
      .             }
      .           }
  1,168 (0.0%)    ret = x509_name_canon(nm);
    584 (0.0%)    if (!ret) {
      .             goto err;
      .           }
  1,460 (0.0%)    sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname, local_sk_X509_NAME_ENTRY_free);
    584 (0.0%)    nm->modified = 0;
    876 (0.0%)    *val = (ASN1_VALUE *)nm;
    876 (0.0%)    *in = p;
    584 (0.0%)    return ret;
      .         err:
      .           X509_NAME_free(nm);
      .           sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname,
      .                                                local_sk_X509_NAME_ENTRY_pop_free);
      .           OPENSSL_PUT_ERROR(X509, ERR_R_ASN1_LIB);
      .           return 0;
  1,460 (0.0%)  }
      .         
      .         static int x509_name_ex_i2d(ASN1_VALUE **val, unsigned char **out,
      .                                     const ASN1_ITEM *it, int tag, int aclass) {
      .           X509_NAME *a = (X509_NAME *)*val;
      .           if (a->modified && (!x509_name_encode(a) || !x509_name_canon(a))) {
      .             return -1;
      .           }
      .           int ret = a->bytes->length;
-- line 264 ----------------------------------------
-- line 324 ----------------------------------------
      .         // it all strings are converted to UTF8, leading, trailing and multiple
      .         // spaces collapsed, converted to lower case and the leading SEQUENCE header
      .         // removed. In future we could also normalize the UTF8 too. By doing this
      .         // comparison of Name structures can be rapidly perfomed by just using
      .         // OPENSSL_memcmp() of the canonical encoding. By omitting the leading SEQUENCE
      .         // name constraints of type dirName can also be checked with a simple
      .         // OPENSSL_memcmp().
      .         
  2,336 (0.0%)  static int x509_name_canon(X509_NAME *a) {
      .           unsigned char *p;
    292 (0.0%)    STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname = NULL;
    292 (0.0%)    STACK_OF(X509_NAME_ENTRY) *entries = NULL;
    292 (0.0%)    X509_NAME_ENTRY *entry, *tmpentry = NULL;
    584 (0.0%)    int set = -1, ret = 0, len;
      .           size_t i;
      .         
  1,168 (0.0%)    if (a->canon_enc) {
      .             OPENSSL_free(a->canon_enc);
      .             a->canon_enc = NULL;
      .           }
      .           // Special case: empty X509_NAME => null encoding
  1,752 (0.0%)    if (sk_X509_NAME_ENTRY_num(a->entries) == 0) {
      .             a->canon_enclen = 0;
      .             return 1;
      .           }
    584 (0.0%)    intname = sk_STACK_OF_X509_NAME_ENTRY_new_null();
    584 (0.0%)    if (!intname) {
      .             goto err;
      .           }
  9,644 (0.0%)    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {
  7,308 (0.0%)      entry = sk_X509_NAME_ENTRY_value(a->entries, i);
  4,176 (0.0%)      if (entry->set != set) {
  2,088 (0.0%)        entries = sk_X509_NAME_ENTRY_new_null();
  2,088 (0.0%)        if (!entries) {
      .                 goto err;
      .               }
  7,308 (0.0%)        if (!sk_STACK_OF_X509_NAME_ENTRY_push(intname, entries)) {
      .                 sk_X509_NAME_ENTRY_free(entries);
      .                 goto err;
      .               }
  3,132 (0.0%)        set = entry->set;
      .             }
  2,088 (0.0%)      tmpentry = X509_NAME_ENTRY_new();
  2,088 (0.0%)      if (tmpentry == NULL) {
      .               goto err;
      .             }
  6,264 (0.0%)      tmpentry->object = OBJ_dup(entry->object);
  9,396 (0.0%)      if (!asn1_string_canon(tmpentry->value, entry->value)) {
      .               goto err;
      .             }
  7,308 (0.0%)      if (!sk_X509_NAME_ENTRY_push(entries, tmpentry)) {
      .               goto err;
      .             }
  1,044 (0.0%)      tmpentry = NULL;
      .           }
      .         
      .           // Finally generate encoding
      .         
  1,460 (0.0%)    len = i2d_name_canon(intname, NULL);
    584 (0.0%)    if (len < 0) {
      .             goto err;
      .           }
    876 (0.0%)    a->canon_enclen = len;
      .         
  1,752 (0.0%)    p = OPENSSL_malloc(a->canon_enclen);
      .         
    876 (0.0%)    if (!p) {
      .             goto err;
      .           }
      .         
    876 (0.0%)    a->canon_enc = p;
      .         
  1,460 (0.0%)    i2d_name_canon(intname, &p);
      .         
    584 (0.0%)    ret = 1;
      .         
      .         err:
      .         
    584 (0.0%)    if (tmpentry) {
      .             X509_NAME_ENTRY_free(tmpentry);
      .           }
    584 (0.0%)    if (intname) {
  1,460 (0.0%)      sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname,
      .                                                  local_sk_X509_NAME_ENTRY_pop_free);
      .           }
    292 (0.0%)    return ret;
  1,460 (0.0%)  }
      .         
      .         // Bitmap of all the types of string that will be canonicalized.
      .         
      .         #define ASN1_MASK_CANON                                            \
      .           (B_ASN1_UTF8STRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING | \
      .            B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING |  \
      .            B_ASN1_VISIBLESTRING)
      .         
  6,264 (0.0%)  static int asn1_string_canon(ASN1_STRING *out, ASN1_STRING *in) {
      .           unsigned char *to, *from;
      .           int len, i;
      .         
      .           // If type not in bitmask just copy string across
  7,308 (0.0%)    if (!(ASN1_tag2bit(in->type) & ASN1_MASK_CANON)) {
      .             if (!ASN1_STRING_copy(out, in)) {
      .               return 0;
      .             }
      .             return 1;
      .           }
      .         
  2,088 (0.0%)    out->type = V_ASN1_UTF8STRING;
  8,352 (0.0%)    out->length = ASN1_STRING_to_UTF8(&out->data, in);
  4,176 (0.0%)    if (out->length == -1) {
      .             return 0;
      .           }
      .         
  3,132 (0.0%)    to = out->data;
  2,088 (0.0%)    from = to;
      .         
  3,132 (0.0%)    len = out->length;
      .         
      .           // Convert string in place to canonical form.
      .         
      .           // Ignore leading spaces
 10,440 (0.0%)    while ((len > 0) && OPENSSL_isspace(*from)) {
      .             from++;
      .             len--;
      .           }
      .         
  5,220 (0.0%)    to = from + len;
      .         
      .           // Ignore trailing spaces
 11,484 (0.0%)    while ((len > 0) && OPENSSL_isspace(to[-1])) {
      .             to--;
      .             len--;
      .           }
      .         
  3,132 (0.0%)    to = out->data;
      .         
  1,044 (0.0%)    i = 0;
 54,084 (0.0%)    while (i < len) {
      .             // Collapse multiple spaces
116,452 (0.1%)      if (OPENSSL_isspace(*from)) {
      .               // Copy one space across
  6,424 (0.0%)        *to++ = ' ';
      .               // Ignore subsequent spaces. Note: don't need to check len here
      .               // because we know the last character is a non-space so we can't
      .               // overflow.
      .               do {
  1,606 (0.0%)          from++;
  1,606 (0.0%)          i++;
 12,848 (0.0%)        } while (OPENSSL_isspace(*from));
      .             } else {
165,330 (0.1%)        *to++ = OPENSSL_tolower(*from);
 15,030 (0.0%)        from++;
 15,030 (0.0%)        i++;
      .             }
      .           }
      .         
  6,264 (0.0%)    out->length = to - out->data;
      .         
  1,044 (0.0%)    return 1;
  2,088 (0.0%)  }
      .         
      .         static int i2d_name_canon(STACK_OF(STACK_OF_X509_NAME_ENTRY) *_intname,
  5,256 (0.0%)                            unsigned char **in) {
      .           int len, ltmp;
      .           size_t i;
      .           ASN1_VALUE *v;
  1,168 (0.0%)    STACK_OF(ASN1_VALUE) *intname = (STACK_OF(ASN1_VALUE) *)_intname;
      .         
    584 (0.0%)    len = 0;
 16,616 (0.0%)    for (i = 0; i < sk_ASN1_VALUE_num(intname); i++) {
 12,528 (0.0%)      v = sk_ASN1_VALUE_value(intname, i);
 16,704 (0.0%)      ltmp = ASN1_item_ex_i2d(&v, in, ASN1_ITEM_rptr(X509_NAME_ENTRIES),
      .                                     /*tag=*/-1, /*aclass=*/0);
  4,176 (0.0%)      if (ltmp < 0) {
      .               return ltmp;
      .             }
  4,176 (0.0%)      len += ltmp;
      .           }
    584 (0.0%)    return len;
  2,920 (0.0%)  }
      .         
      .         int X509_NAME_set(X509_NAME **xn, X509_NAME *name) {
      .           if ((name = X509_NAME_dup(name)) == NULL) {
      .             return 0;
      .           }
      .           X509_NAME_free(*xn);
      .           *xn = name;
      .           return 1;
-- line 511 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir_________________ 

126,845,054 (91.7%)    annotated: files known & above threshold & readable, line numbers known
          0            annotated: files known & above threshold & readable, line numbers unknown
          0          unannotated: files known & above threshold & two or more non-identical
  8,250,953  (6.0%)  unannotated: files known & above threshold & unreadable 
  3,128,118  (2.3%)  unannotated: files known & below threshold
    163,935  (0.1%)  unannotated: files unknown

